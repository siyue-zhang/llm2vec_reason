{"0": {"gold": {"leetcode/leetcode_11.txt": 1, "leetcode/leetcode_238.txt": 1, "leetcode/leetcode_407.txt": 1}, "retrieved": {"leetcode/leetcode_363.txt": {"score": 0.7929477095603943, "content": {"text": "from sortedcontainers import SortedList\n    \"\"\"Given an `m x n` matrix `matrix` and an integer `k`, return _the max sum of a rectangle in the matrix such that its sum is no larger than_ `k`.\n\nIt is **guaranteed** that there will be a rectangle with a sum no larger than `k`.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,0,1\\],\\[0,-2,3\\]\\], k = 2\n**Output:** 2\n**Explanation:** Because the sum of the blue rectangle \\[\\[0, 1\\], \\[-2, 3\\]\\] is 2, and 2 is the max number no larger than k (k = 2).\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[2,2,-1\\]\\], k = 3\n**Output:** 3\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 100`\n*   `-100 <= matrix[i][j] <= 100`\n*   `-105 <= k <= 105`\n\n**Follow up:** What if the number of rows is much larger than the number of columns?\"\"\"\n\n\ndef maxSumSubmatrix(matrix, k):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for l in range(cols):\n        sums = [0] * rows\n        for r in range(l, cols):\n            for i in range(rows):\n                sums[i] += matrix[i][r]\n\n            sorted_sums = SortedList()\n            sorted_sums.add(0)\n            curr_sum = 0\n            for sum in sums:\n                curr_sum += sum\n                it = sorted_sums.bisect_left(curr_sum - k)\n                if it != len(sorted_sums):\n                    max_sum = max(max_sum, curr_sum - sorted_sums[it])\n                sorted_sums.add(curr_sum)\n\n    return max_sum"}}, "leetcode/leetcode_1105.txt": {"score": 0.7988352179527283, "content": {"text": "def max_uncrossed_lines(nums1, nums2):\n    \"\"\"You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`.\n\nWe want to place these books in order onto bookcase shelves that have a total width `shelfWidth`.\n\nWe choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n\nNote that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n*   For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\nReturn _the minimum possible height that the total bookshelf can be after placing shelves in this manner_.\n\n**Example 1:**\n\n**Input:** books = \\[\\[1,1\\],\\[2,3\\],\\[2,3\\],\\[1,1\\],\\[1,1\\],\\[1,1\\],\\[1,2\\]\\], shelfWidth = 4\n**Output:** 6\n**Explanation:**\nThe sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n**Example 2:**\n\n**Input:** books = \\[\\[1,3\\],\\[2,4\\],\\[3,2\\]\\], shelfWidth = 6\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= books.length <= 1000`\n*   `1 <= thicknessi <= shelfWidth <= 1000`\n*   `1 <= heighti <= 1000`\"\"\"\n\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]"}}, "leetcode/leetcode_799.txt": {"score": 0.7941796779632568, "content": {"text": "class TreeNode:\n    \"\"\"We stack glasses in a pyramid, where the **first** row has `1` glass, the **second** row has `2` glasses, and so on until the 100th row. Each glass holds one cup of champagne.\n\nThen, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has its excess champagne fall on the floor.)\n\nFor example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\nNow after pouring some non-negative integer cups of champagne, return how full the `jth` glass in the `ith` row is (both `i` and `j` are 0-indexed.)\n\n**Example 1:**\n\n**Input:** poured = 1, query\\_row = 1, query\\_glass = 1\n**Output:** 0.00000\n**Explanation:** We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n\n**Example 2:**\n\n**Input:** poured = 2, query\\_row = 1, query\\_glass = 1\n**Output:** 0.50000\n**Explanation:** We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\n\n**Example 3:**\n\n**Input:** poured = 100000009, query\\_row = 33, query\\_glass = 17\n**Output:** 1.00000\n\n**Constraints:**\n\n*   `0 <= poured <= 109`\n*   `0 <= query_glass <= query_row < 100`\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.min_diff = float(\"inf\")\n        self.prev = None\n\n    def minDiffInBST(self, root: TreeNode) -> int:\n        self.in_order_traversal(root)\n        return self.min_diff\n\n    def in_order_traversal(self, node: TreeNode) -> None:\n        if not node: return\n        self.in_order_traversal(node.left)\n        if self.prev:\n            self.min_diff = min(self.min_diff, node.val - self.prev.val)\n        self.prev = node\n        self.in_order_traversal(node.right)"}}, "leetcode/csn_python_train_321006.txt": {"score": 0.8230000138282776, "content": {"text": "def rectangles_from_histogram(H):\n    \"\"\"Largest Rectangular Area in a Histogram\n\n    :param H: histogram table\n    :returns: area, left, height, right, rect. is [0, height] * [left, right)\n    :complexity: linear\n    \"\"\"\n    best = (float('-inf'), 0, 0, 0)\n    S = []\n    H2 = H + [float('-inf')]  # extra element to empty the queue\n    for right in range(len(H2)):\n        x = H2[right]\n        left = right\n        while len(S) > 0 and S[-1][1] >= x:\n            left, height = S.pop()\n            # first element is area of candidate\n            rect = (height * (right - left), left, height, right)\n            if rect > best:\n                best = rect\n        S.append((left, x))\n    return best"}}, "leetcode/leetcode_407.txt": {"score": 0.9283682703971863, "content": {"text": "import heapq\n    \"\"\"Given an `m x n` integer matrix `heightMap` representing the height of each unit cell in a 2D elevation map, return _the volume of water it can trap after raining_.\n\n**Example 1:**\n\n**Input:** heightMap = \\[\\[1,4,3,1,3,2\\],\\[3,2,1,3,2,4\\],\\[2,3,3,2,3,1\\]\\]\n**Output:** 4\n**Explanation:** After the rain, water is trapped between the blocks.\nWe have two small ponds 1 and 3 units trapped.\nThe total volume of water trapped is 4.\n\n**Example 2:**\n\n**Input:** heightMap = \\[\\[3,3,3,3,3\\],\\[3,2,2,2,3\\],\\[3,2,1,2,3\\],\\[3,2,2,2,3\\],\\[3,3,3,3,3\\]\\]\n**Output:** 10\n\n**Constraints:**\n\n*   `m == heightMap.length`\n*   `n == heightMap[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= heightMap[i][j] <= 2 * 104`\"\"\"\n\n\ndef trapRainWater(heightMap):\n    m, n = len(heightMap), len(heightMap[0])\n    pq = []\n    visited = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n        heapq.heappush(pq, (heightMap[i][0], i, 0))\n        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))\n        visited[i][0] = visited[i][n - 1] = True\n\n    for i in range(1, n - 1):\n        heapq.heappush(pq, (heightMap[0][i], 0, i))\n        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))\n        visited[0][i] = visited[m - 1][i] = True\n\n    water, maxHeight = 0, 0\n    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while pq:\n        h, r, c = heapq.heappop(pq)\n        maxHeight = max(maxHeight, h)\n        for dx, dy in dirs:\n            x, y = r + dx, c + dy\n            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y]:\n                continue\n            if heightMap[x][y] < maxHeight:\n                water += maxHeight - heightMap[x][y]\n            heapq.heappush(pq, (heightMap[x][y], x, y))\n            visited[x][y] = True\n\n    return water"}}, "leetcode/leetcode_845.txt": {"score": 0.7995561957359314, "content": {"text": "def longestMountain(arr):\n    \"\"\"You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.\n\n**Example 1:**\n\n**Input:** arr = \\[2,1,4,7,3,2,5\\]\n**Output:** 5\n**Explanation:** The largest mountain is \\[1,4,7,3,2\\] which has length 5.\n\n**Example 2:**\n\n**Input:** arr = \\[2,2,2\\]\n**Output:** 0\n**Explanation:** There is no mountain.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`\n\n**Follow up:**\n\n*   Can you solve it using only one pass?\n*   Can you solve it in `O(1)` space?\"\"\"\n\n    n = len(arr)\n    res = up = down = 0\n\n    for i in range(1, n):\n        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:\n            up = down = 0\n\n        up += arr[i - 1] < arr[i]\n        down += arr[i - 1] > arr[i]\n\n        if up and down:\n            res = max(res, up + down + 1)\n\n    return res"}}, "leetcode/leetcode_85.txt": {"score": 0.822493314743042, "content": {"text": "def maximalRectangle(matrix):\n    \"\"\"Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.\"\"\"\n\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area"}}, "leetcode/leetcode_84.txt": {"score": 0.8643121123313904, "content": {"text": "def largestRectangleArea(heights):\n    \"\"\"Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.\n\n**Example 1:**\n\n**Input:** heights = \\[2,1,5,6,2,3\\]\n**Output:** 10\n**Explanation:** The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n**Example 2:**\n\n**Input:** heights = \\[2,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `0 <= heights[i] <= 104`\"\"\"\n\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area"}}, "leetcode/leetcode_11.txt": {"score": 0.9147361516952515, "content": {"text": "def max_area(height):\n    \"\"\"You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.\n\n**Example 1:**\n\n**Input:** height = \\[1,8,6,2,5,4,8,3,7\\]\n**Output:** 49\n**Explanation:** The above vertical lines are represented by array \\[1,8,6,2,5,4,8,3,7\\]. In this case, the max area of water (blue section) the container can contain is 49.\n\n**Example 2:**\n\n**Input:** height = \\[1,1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == height.length`\n*   `2 <= n <= 105`\n*   `0 <= height[i] <= 104`\"\"\"\n\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area"}}, "leetcode/leetcode_42.txt": {"score": 0.9927926063537598, "content": {"text": "def trap(height):\n    \"\"\"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\"\"\"\n\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water"}}}}, "1": {"gold": {"leetcode/leetcode_52.txt": 1, "leetcode/leetcode_1001.txt": 1}, "retrieved": {"leetcode/csn_python_train_274058.txt": {"score": 0.8341089487075806, "content": {"text": "def count_blank_positions(self):\n        \"\"\"\n        return a count of blank cells\n        \"\"\"\n        blanks = 0\n        for row_ndx in range(self.grid_height - 0):\n            for col_ndx in range(self.grid_width - 0):\n                if self.get_tile(row_ndx, col_ndx) == EMPTY:\n                    blanks += 1\n        return blanks"}}, "leetcode/csn_python_train_405203.txt": {"score": 0.8422859311103821, "content": {"text": "def clear(self):\n        '''Clear a chessboard'''\n        self.pos = [[0 for _ in range(self.board_size)] for _ in range(self.board_size)]\n        self.graph = copy.deepcopy(self.pos)\n        self._game_round = 1"}}, "leetcode/csn_python_train_311997.txt": {"score": 0.8382981419563293, "content": {"text": "def getEmptyCells(self):\n        \"\"\"return a (x, y) pair for each empty cell\"\"\"\n        return [(x, y)\n                for x in self.__size_range\n                for y in self.__size_range if self.getCell(x, y) == 0]"}}, "leetcode/leetcode_2056.txt": {"score": 0.8472674489021301, "content": {"text": "def count_valid_combos(pieces, positions, index=0):\n    \"\"\"There is an `8 x 8` chessboard containing `n` pieces (rooks, queens, or bishops). You are given a string array `pieces` of length `n`, where `pieces[i]` describes the type (rook, queen, or bishop) of the `ith` piece. In addition, you are given a 2D integer array `positions` also of length `n`, where `positions[i] = [ri, ci]` indicates that the `ith` piece is currently at the **1-based** coordinate `(ri, ci)` on the chessboard.\n\nWhen making a **move** for a piece, you choose a **destination** square that the piece will travel toward and stop on.\n\n*   A rook can only travel **horizontally or vertically** from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, or `(r, c-1)`.\n*   A queen can only travel **horizontally, vertically, or diagonally** from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, `(r, c-1)`, `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`.\n*   A bishop can only travel **diagonally** from `(r, c)` to the direction of `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`.\n\nYou must make a **move** for every piece on the board simultaneously. A **move combination** consists of all the **moves** performed on all the given pieces. Every second, each piece will instantaneously travel **one square** towards their destination if they are not already at it. All pieces start traveling at the `0th` second. A move combination is **invalid** if, at a given time, **two or more** pieces occupy the same square.\n\nReturn _the number of **valid** move combinations_\u200b\u200b\u200b\u200b\u200b.\n\n**Notes:**\n\n*   **No two pieces** will start in the **same** square.\n*   You may choose the square a piece is already on as its **destination**.\n*   If two pieces are **directly adjacent** to each other, it is valid for them to **move past each other** and swap positions in one second.\n\n**Example 1:**\n\n**Input:** pieces = \\[ \"rook \"\\], positions = \\[\\[1,1\\]\\]\n**Output:** 15\n**Explanation:** The image above shows the possible squares the piece can move to.\n\n**Example 2:**\n\n**Input:** pieces = \\[ \"queen \"\\], positions = \\[\\[1,1\\]\\]\n**Output:** 22\n**Explanation:** The image above shows the possible squares the piece can move to.\n\n**Example 3:**\n\n**Input:** pieces = \\[ \"bishop \"\\], positions = \\[\\[4,3\\]\\]\n**Output:** 12\n**Explanation:** The image above shows the possible squares the piece can move to.\n\n**Constraints:**\n\n*   `n == pieces.length`\n*   `n == positions.length`\n*   `1 <= n <= 4`\n*   `pieces` only contains the strings `\"rook \"`, `\"queen \"`, and `\"bishop \"`.\n*   There will be at most one queen on the chessboard.\n*   `1 <= xi, yi <= 8`\n*   Each `positions[i]` is distinct.\"\"\"\n\n    if index == len(pieces):\n        return 1\n\n    r, c = positions[index]\n    dr = [0, 1, 0, -1, 1, 1, -1, -1]\n    dc = [1, 0, -1, 0, 1, -1, 1, -1]\n    valids = 0\n\n    for x in range(8):\n        if pieces[index] == \"bishop\" and x < 4:\n            continue\n        if pieces[index] == \"rook\" and x >= 4:\n            break\n\n        for dist in range(1, 9):\n            nr, nc = r + dr[x] * dist, c + dc[x] * dist\n            if nr < 1 or nr > 8 or nc < 1 or nc > 8:\n                break\n            if nr == r and nc == c:\n                continue\n\n            valid = True\n            for other in range(len(positions)):\n                if other == index:\n                    continue\n                orr, occ = positions[other]\n                if orr == nr and occ == nc:\n                    valid = False\n                    break\n                if orr + occ == nr + nc or orr - occ == nr - nc:\n                    valid = False\n                    break\n                if orr == nr or occ == nc:\n                    valid = False\n                    break\n\n            if valid:\n                positions[index] = [nr, nc]\n                valids += count_valid_combos(pieces, positions, index + 1)\n                positions[index] = [r, c]\n\n    return valids"}}, "leetcode/csn_python_train_299237.txt": {"score": 0.8493528366088867, "content": {"text": "def under_attack(col, queens):\n        \"\"\"Checks if queen is under attack\n\n        :param col: Column number\n        :param queens: list of queens\n        :return: True iff queen is under attack\n        \"\"\"\n        left = right = col\n        for _, column in reversed(queens):\n            left, right = left - 1, right + 1\n            if column in (left, col, right):\n                return True\n        return False"}}, "leetcode/leetcode_2596.txt": {"score": 0.8446862697601318, "content": {"text": "def isValidMove(i, j, k, n):\n    \"\"\"There is a knight on an `n x n` chessboard. In a valid configuration, the knight starts **at the top-left cell** of the board and visits every cell on the board **exactly once**.\n\nYou are given an `n x n` integer matrix `grid` consisting of distinct integers from the range `[0, n * n - 1]` where `grid[row][col]` indicates that the cell `(row, col)` is the `grid[row][col]th` cell that the knight visited. The moves are **0-indexed**.\n\nReturn `true` _if_ `grid` _represents a valid configuration of the knight's movements or_ `false` _otherwise_.\n\n**Note** that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,11,16,5,20\\],\\[17,4,19,10,15\\],\\[12,1,8,21,6\\],\\[3,18,23,14,9\\],\\[24,13,2,7,22\\]\\]\n**Output:** true\n**Explanation:** The above diagram represents the grid. It can be shown that it is a valid configuration.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,3,6\\],\\[5,8,1\\],\\[2,7,4\\]\\]\n**Output:** false\n**Explanation:** The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `3 <= n <= 7`\n*   `0 <= grid[row][col] < n * n`\n*   All integers in `grid` are **unique**.\"\"\"\n\n    return (i + 1 < n and j + 2 < n and k == n * (i + 1) + (j + 2)) or \\\n           (i + 1 < n and j - 2 >= 0 and k == n * (i + 1) + (j - 2)) or \\\n           (i + 2 < n and j + 1 < n and k == n * (i + 2) + (j + 1)) or \\\n           (i + 2 < n and j - 1 >= 0 and k == n * (i + 2) + (j - 1))\n\ndef validPath(grid):\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            k = grid[i][j]\n            if k != n * n - 1 and not isValidMove(i, j, k + 1, n):\n                return False\n    return True"}}, "leetcode/csn_python_train_119698.txt": {"score": 0.9563856720924377, "content": {"text": "def n_queens(queen_count):\n    \"\"\"N-Queens solver.\n\n    Args:\n        queen_count: the number of queens to solve for. This is also the\n            board size.\n\n    Yields:\n        Solutions to the problem. Each yielded value is looks like\n        (3, 8, 2, 1, 4, ..., 6) where each number is the column position for the\n        queen, and the index into the tuple indicates the row.\n    \"\"\"\n    out =list()\n    cols = range(queen_count)\n    #for vec in permutations(cols):\n    for vec in permutations(cols,None):\n        if (queen_count == len(set(vec[i]+i for i in cols))\n                        == len(set(vec[i]-i for i in cols))):\n            #yield vec\n            out.append(vec)\n    return out"}}, "leetcode/csn_python_train_299238.txt": {"score": 0.9530601501464844, "content": {"text": "def solve(self, table_size):\n        \"\"\"Solves problem\n\n        :param table_size: Size of table\n        :return: List of possible solutions\n        \"\"\"\n        if table_size == 0:\n            return [[]]\n\n        smaller_solutions = self.solve(table_size - 1)\n        solutions = []\n        for solution in smaller_solutions:\n            for column in range(1, self.board_size + 1):\n                # try adding a new queen to row = n, column = column\n                if not self.under_attack(column, solution):\n                    solutions.append(solution + [(table_size, column)])\n        return solutions"}}, "leetcode/leetcode_52.txt": {"score": 0.9783068299293518, "content": {"text": "def is_safe(cols, row):\n    \"\"\"The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 9`\"\"\"\n\n    col = len(cols)\n    for i, r in enumerate(cols):\n        if r == row or abs(i - col) == abs(r - row):\n            return False\n    return True\n\n\ndef backtrack(n, cols):\n    if len(cols) == n:\n        return 1\n\n    count = 0\n    for i in range(n):\n        if is_safe(cols, i):\n            cols.append(i)\n            count += backtrack(n, cols)\n            cols.pop()\n\n    return count\n\n\ndef total_n_queens(n):\n    cols = []\n    return backtrack(n, cols)"}}, "leetcode/leetcode_51.txt": {"score": 0.9907205104827881, "content": {"text": "def solveNQueens(n):\n    \"\"\"The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** \\[\\[ \".Q.. \", \"...Q \", \"Q... \", \"..Q. \"\\],\\[ \"..Q. \", \"Q... \", \"...Q \", \".Q.. \"\\]\\]\n**Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[ \"Q \"\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 9`\"\"\"\n\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result"}}}}, "2": {"gold": {"leetcode/leetcode_51.txt": 1}, "retrieved": {"leetcode/leetcode_790.txt": {"score": 0.8202829957008362, "content": {"text": "def is_ideal_permutation(nums):\n    \"\"\"You have two types of tiles: a `2 x 1` domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return _the number of ways to tile an_ `2 x n` _board_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 5\n**Explanation:** The five different ways are show above.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\"\"\"\n\n    for i, num in enumerate(nums):\n        if abs(num - i) > 1:\n            return False\n    return True"}}, "leetcode/leetcode_2392.txt": {"score": 0.8263996243476868, "content": {"text": "def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:\n    \"\"\"You are given a **positive** integer `k`. You are also given:\n\n*   a 2D integer array `rowConditions` of size `n` where `rowConditions[i] = [abovei, belowi]`, and\n*   a 2D integer array `colConditions` of size `m` where `colConditions[i] = [lefti, righti]`.\n\nThe two arrays contain integers from `1` to `k`.\n\nYou have to build a `k x k` matrix that contains each of the numbers from `1` to `k` **exactly once**. The remaining cells should have the value `0`.\n\nThe matrix should also satisfy the following conditions:\n\n*   The number `abovei` should appear in a **row** that is strictly **above** the row at which the number `belowi` appears for all `i` from `0` to `n - 1`.\n*   The number `lefti` should appear in a **column** that is strictly **left** of the column at which the number `righti` appears for all `i` from `0` to `m - 1`.\n\nReturn _**any** matrix that satisfies the conditions_. If no answer exists, return an empty matrix.\n\n**Example 1:**\n\n**Input:** k = 3, rowConditions = \\[\\[1,2\\],\\[3,2\\]\\], colConditions = \\[\\[2,1\\],\\[3,2\\]\\]\n**Output:** \\[\\[3,0,0\\],\\[0,0,1\\],\\[0,2,0\\]\\]\n**Explanation:** The diagram above shows a valid example of a matrix that satisfies all the conditions.\nThe row conditions are the following:\n- Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix.\n- Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix.\nThe column conditions are the following:\n- Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix.\n- Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix.\nNote that there may be multiple correct answers.\n\n**Example 2:**\n\n**Input:** k = 3, rowConditions = \\[\\[1,2\\],\\[2,3\\],\\[3,1\\],\\[2,3\\]\\], colConditions = \\[\\[2,1\\]\\]\n**Output:** \\[\\]\n**Explanation:** From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.\nNo matrix can satisfy all the conditions, so we return the empty matrix.\n\n**Constraints:**\n\n*   `2 <= k <= 400`\n*   `1 <= rowConditions.length, colConditions.length <= 104`\n*   `rowConditions[i].length == colConditions[i].length == 2`\n*   `1 <= abovei, belowi, lefti, righti <= k`\n*   `abovei != belowi`\n*   `lefti != righti`\"\"\"\n\n    row, col = [0] * (k + 1), [0] * (k + 1)\n    for condition in row_conditions:\n        if row[condition[0]] >= row[condition[1]]:\n            return []\n        row[condition[1]] = row[condition[0]] + 1\n    for condition in col_conditions:\n        if col[condition[0]] >= col[condition[1]]:\n            return []\n        col[condition[1]] = col[condition[0]] + 1\n    matrix = [[0] * k for _ in range(k)]\n    for i in range(1, k + 1):\n        matrix[row[i]][col[i]] = i\n    return matrix"}}, "leetcode/leetcode_2596.txt": {"score": 0.8389953374862671, "content": {"text": "def isValidMove(i, j, k, n):\n    \"\"\"There is a knight on an `n x n` chessboard. In a valid configuration, the knight starts **at the top-left cell** of the board and visits every cell on the board **exactly once**.\n\nYou are given an `n x n` integer matrix `grid` consisting of distinct integers from the range `[0, n * n - 1]` where `grid[row][col]` indicates that the cell `(row, col)` is the `grid[row][col]th` cell that the knight visited. The moves are **0-indexed**.\n\nReturn `true` _if_ `grid` _represents a valid configuration of the knight's movements or_ `false` _otherwise_.\n\n**Note** that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,11,16,5,20\\],\\[17,4,19,10,15\\],\\[12,1,8,21,6\\],\\[3,18,23,14,9\\],\\[24,13,2,7,22\\]\\]\n**Output:** true\n**Explanation:** The above diagram represents the grid. It can be shown that it is a valid configuration.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,3,6\\],\\[5,8,1\\],\\[2,7,4\\]\\]\n**Output:** false\n**Explanation:** The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `3 <= n <= 7`\n*   `0 <= grid[row][col] < n * n`\n*   All integers in `grid` are **unique**.\"\"\"\n\n    return (i + 1 < n and j + 2 < n and k == n * (i + 1) + (j + 2)) or \\\n           (i + 1 < n and j - 2 >= 0 and k == n * (i + 1) + (j - 2)) or \\\n           (i + 2 < n and j + 1 < n and k == n * (i + 2) + (j + 1)) or \\\n           (i + 2 < n and j - 1 >= 0 and k == n * (i + 2) + (j - 1))\n\ndef validPath(grid):\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            k = grid[i][j]\n            if k != n * n - 1 and not isValidMove(i, j, k + 1, n):\n                return False\n    return True"}}, "leetcode/leetcode_935.txt": {"score": 0.8309056162834167, "content": {"text": "def lex_smallest_string(s, k):\n    \"\"\"The chess knight has a **unique movement**, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an **L**). The possible movements of chess knight are shown in this diagaram:\n\nA chess knight can move as indicated in the chess diagram below:\n\nWe have a chess knight and a phone pad as shown below, the knight **can only stand on a numeric cell** (i.e. blue cell).\n\nGiven an integer `n`, return how many distinct phone numbers of length `n` we can dial.\n\nYou are allowed to place the knight **on any numeric cell** initially and then you should perform `n - 1` jumps to dial a number of length `n`. All jumps should be **valid** knight jumps.\n\nAs the answer may be very large, **return the answer modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 10\n**Explanation:** We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 20\n**Explanation:** All the valid number we can dial are \\[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94\\]\n\n**Example 3:**\n\n**Input:** n = 3131\n**Output:** 136006598\n**Explanation:** Please take care of the mod.\n\n**Constraints:**\n\n*   `1 <= n <= 5000`\"\"\"\n\n    res = s\n    for i in range(k):\n        tmp = s[i:] + s[:i]\n        if tmp < res:\n            res = tmp\n    return res"}}, "leetcode/csn_python_train_299238.txt": {"score": 0.9437278509140015, "content": {"text": "def solve(self, table_size):\n        \"\"\"Solves problem\n\n        :param table_size: Size of table\n        :return: List of possible solutions\n        \"\"\"\n        if table_size == 0:\n            return [[]]\n\n        smaller_solutions = self.solve(table_size - 1)\n        solutions = []\n        for solution in smaller_solutions:\n            for column in range(1, self.board_size + 1):\n                # try adding a new queen to row = n, column = column\n                if not self.under_attack(column, solution):\n                    solutions.append(solution + [(table_size, column)])\n        return solutions"}}, "leetcode/csn_python_train_299237.txt": {"score": 0.8428764939308167, "content": {"text": "def under_attack(col, queens):\n        \"\"\"Checks if queen is under attack\n\n        :param col: Column number\n        :param queens: list of queens\n        :return: True iff queen is under attack\n        \"\"\"\n        left = right = col\n        for _, column in reversed(queens):\n            left, right = left - 1, right + 1\n            if column in (left, col, right):\n                return True\n        return False"}}, "leetcode/leetcode_52.txt": {"score": 0.9881619811058044, "content": {"text": "def is_safe(cols, row):\n    \"\"\"The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 9`\"\"\"\n\n    col = len(cols)\n    for i, r in enumerate(cols):\n        if r == row or abs(i - col) == abs(r - row):\n            return False\n    return True\n\n\ndef backtrack(n, cols):\n    if len(cols) == n:\n        return 1\n\n    count = 0\n    for i in range(n):\n        if is_safe(cols, i):\n            cols.append(i)\n            count += backtrack(n, cols)\n            cols.pop()\n\n    return count\n\n\ndef total_n_queens(n):\n    cols = []\n    return backtrack(n, cols)"}}, "leetcode/leetcode_2056.txt": {"score": 0.8482118844985962, "content": {"text": "def count_valid_combos(pieces, positions, index=0):\n    \"\"\"There is an `8 x 8` chessboard containing `n` pieces (rooks, queens, or bishops). You are given a string array `pieces` of length `n`, where `pieces[i]` describes the type (rook, queen, or bishop) of the `ith` piece. In addition, you are given a 2D integer array `positions` also of length `n`, where `positions[i] = [ri, ci]` indicates that the `ith` piece is currently at the **1-based** coordinate `(ri, ci)` on the chessboard.\n\nWhen making a **move** for a piece, you choose a **destination** square that the piece will travel toward and stop on.\n\n*   A rook can only travel **horizontally or vertically** from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, or `(r, c-1)`.\n*   A queen can only travel **horizontally, vertically, or diagonally** from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, `(r, c-1)`, `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`.\n*   A bishop can only travel **diagonally** from `(r, c)` to the direction of `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`.\n\nYou must make a **move** for every piece on the board simultaneously. A **move combination** consists of all the **moves** performed on all the given pieces. Every second, each piece will instantaneously travel **one square** towards their destination if they are not already at it. All pieces start traveling at the `0th` second. A move combination is **invalid** if, at a given time, **two or more** pieces occupy the same square.\n\nReturn _the number of **valid** move combinations_\u200b\u200b\u200b\u200b\u200b.\n\n**Notes:**\n\n*   **No two pieces** will start in the **same** square.\n*   You may choose the square a piece is already on as its **destination**.\n*   If two pieces are **directly adjacent** to each other, it is valid for them to **move past each other** and swap positions in one second.\n\n**Example 1:**\n\n**Input:** pieces = \\[ \"rook \"\\], positions = \\[\\[1,1\\]\\]\n**Output:** 15\n**Explanation:** The image above shows the possible squares the piece can move to.\n\n**Example 2:**\n\n**Input:** pieces = \\[ \"queen \"\\], positions = \\[\\[1,1\\]\\]\n**Output:** 22\n**Explanation:** The image above shows the possible squares the piece can move to.\n\n**Example 3:**\n\n**Input:** pieces = \\[ \"bishop \"\\], positions = \\[\\[4,3\\]\\]\n**Output:** 12\n**Explanation:** The image above shows the possible squares the piece can move to.\n\n**Constraints:**\n\n*   `n == pieces.length`\n*   `n == positions.length`\n*   `1 <= n <= 4`\n*   `pieces` only contains the strings `\"rook \"`, `\"queen \"`, and `\"bishop \"`.\n*   There will be at most one queen on the chessboard.\n*   `1 <= xi, yi <= 8`\n*   Each `positions[i]` is distinct.\"\"\"\n\n    if index == len(pieces):\n        return 1\n\n    r, c = positions[index]\n    dr = [0, 1, 0, -1, 1, 1, -1, -1]\n    dc = [1, 0, -1, 0, 1, -1, 1, -1]\n    valids = 0\n\n    for x in range(8):\n        if pieces[index] == \"bishop\" and x < 4:\n            continue\n        if pieces[index] == \"rook\" and x >= 4:\n            break\n\n        for dist in range(1, 9):\n            nr, nc = r + dr[x] * dist, c + dc[x] * dist\n            if nr < 1 or nr > 8 or nc < 1 or nc > 8:\n                break\n            if nr == r and nc == c:\n                continue\n\n            valid = True\n            for other in range(len(positions)):\n                if other == index:\n                    continue\n                orr, occ = positions[other]\n                if orr == nr and occ == nc:\n                    valid = False\n                    break\n                if orr + occ == nr + nc or orr - occ == nr - nc:\n                    valid = False\n                    break\n                if orr == nr or occ == nc:\n                    valid = False\n                    break\n\n            if valid:\n                positions[index] = [nr, nc]\n                valids += count_valid_combos(pieces, positions, index + 1)\n                positions[index] = [r, c]\n\n    return valids"}}, "leetcode/csn_python_train_119698.txt": {"score": 0.9515902400016785, "content": {"text": "def n_queens(queen_count):\n    \"\"\"N-Queens solver.\n\n    Args:\n        queen_count: the number of queens to solve for. This is also the\n            board size.\n\n    Yields:\n        Solutions to the problem. Each yielded value is looks like\n        (3, 8, 2, 1, 4, ..., 6) where each number is the column position for the\n        queen, and the index into the tuple indicates the row.\n    \"\"\"\n    out =list()\n    cols = range(queen_count)\n    #for vec in permutations(cols):\n    for vec in permutations(cols,None):\n        if (queen_count == len(set(vec[i]+i for i in cols))\n                        == len(set(vec[i]-i for i in cols))):\n            #yield vec\n            out.append(vec)\n    return out"}}, "leetcode/leetcode_51.txt": {"score": 0.9677614569664001, "content": {"text": "def solveNQueens(n):\n    \"\"\"The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** \\[\\[ \".Q.. \", \"...Q \", \"Q... \", \"..Q. \"\\],\\[ \"..Q. \", \"Q... \", \"...Q \", \".Q.. \"\\]\\]\n**Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[ \"Q \"\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 9`\"\"\"\n\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result"}}}}, "3": {"gold": {"leetcode/leetcode_85.txt": 1, "leetcode/leetcode_1793.txt": 1}, "retrieved": {"leetcode/leetcode_1043.txt": {"score": 0.8174267411231995, "content": {"text": "def grid_illumination(n, lamps, queries):\n    \"\"\"Given an integer array `arr`, partition the array into (contiguous) subarrays of length **at most** `k`. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\n\nReturn _the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a **32-bit** integer._\n\n**Example 1:**\n\n**Input:** arr = \\[1,15,7,9,2,5,10\\], k = 3\n**Output:** 84\n**Explanation:** arr becomes \\[15,15,15,9,10,10,10\\]\n\n**Example 2:**\n\n**Input:** arr = \\[1,4,1,5,7,3,6,1,9,9,3\\], k = 4\n**Output:** 83\n\n**Example 3:**\n\n**Input:** arr = \\[1\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= arr.length <= 500`\n*   `0 <= arr[i] <= 109`\n*   `1 <= k <= arr.length`\"\"\"\n\n    lamp_rows = set()\n    lamp_cols = set()\n    lamp_left_diag = set()\n    lamp_right_diag = set()\n\n    for lamp in lamps:\n        row, col = lamp\n        lamp_rows.add(row)\n        lamp_cols.add(col)\n        lamp_left_diag.add(row - col)\n        lamp_right_diag.add(row + col)\n\n    ans = []\n\n    for query in queries:\n        row, col = query\n        if row in lamp_rows or col in lamp_cols or (row - col) in lamp_left_diag or (row + col) in lamp_right_diag:\n            ans.append(1)\n        else:\n            ans.append(0)\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                newRow, newCol = row + i, col + j\n                lamp_rows.discard(newRow)\n                lamp_cols.discard(newCol)\n                lamp_left_diag.discard(newRow - newCol)\n                lamp_right_diag.discard(newRow + newCol)\n\n    return ans"}}, "leetcode/leetcode_1105.txt": {"score": 0.8177480697631836, "content": {"text": "def max_uncrossed_lines(nums1, nums2):\n    \"\"\"You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`.\n\nWe want to place these books in order onto bookcase shelves that have a total width `shelfWidth`.\n\nWe choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n\nNote that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n*   For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\nReturn _the minimum possible height that the total bookshelf can be after placing shelves in this manner_.\n\n**Example 1:**\n\n**Input:** books = \\[\\[1,1\\],\\[2,3\\],\\[2,3\\],\\[1,1\\],\\[1,1\\],\\[1,1\\],\\[1,2\\]\\], shelfWidth = 4\n**Output:** 6\n**Explanation:**\nThe sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n**Example 2:**\n\n**Input:** books = \\[\\[1,3\\],\\[2,4\\],\\[3,2\\]\\], shelfWidth = 6\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= books.length <= 1000`\n*   `1 <= thicknessi <= shelfWidth <= 1000`\n*   `1 <= heighti <= 1000`\"\"\"\n\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]"}}, "leetcode/leetcode_845.txt": {"score": 0.8320434093475342, "content": {"text": "def longestMountain(arr):\n    \"\"\"You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.\n\n**Example 1:**\n\n**Input:** arr = \\[2,1,4,7,3,2,5\\]\n**Output:** 5\n**Explanation:** The largest mountain is \\[1,4,7,3,2\\] which has length 5.\n\n**Example 2:**\n\n**Input:** arr = \\[2,2,2\\]\n**Output:** 0\n**Explanation:** There is no mountain.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`\n\n**Follow up:**\n\n*   Can you solve it using only one pass?\n*   Can you solve it in `O(1)` space?\"\"\"\n\n    n = len(arr)\n    res = up = down = 0\n\n    for i in range(1, n):\n        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:\n            up = down = 0\n\n        up += arr[i - 1] < arr[i]\n        down += arr[i - 1] > arr[i]\n\n        if up and down:\n            res = max(res, up + down + 1)\n\n    return res"}}, "leetcode/leetcode_2271.txt": {"score": 0.8220210671424866, "content": {"text": "def rearrange_array(nums):\n    \"\"\"You are given a 2D integer array `tiles` where `tiles[i] = [li, ri]` represents that every tile `j` in the range `li <= j <= ri` is colored white.\n\nYou are also given an integer `carpetLen`, the length of a single carpet that can be placed **anywhere**.\n\nReturn _the **maximum** number of white tiles that can be covered by the carpet_.\n\n**Example 1:**\n\n**Input:** tiles = \\[\\[1,5\\],\\[10,11\\],\\[12,18\\],\\[20,25\\],\\[30,32\\]\\], carpetLen = 10\n**Output:** 9\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles.\n\n**Example 2:**\n\n**Input:** tiles = \\[\\[10,11\\],\\[1,1\\]\\], carpetLen = 2\n**Output:** 2\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2.\n\n**Constraints:**\n\n*   `1 <= tiles.length <= 5 * 104`\n*   `tiles[i].length == 2`\n*   `1 <= li <= ri <= 109`\n*   `1 <= carpetLen <= 109`\n*   The `tiles` are **non-overlapping**.\"\"\"\n\n    nums.sort()\n    half = len(nums) // 2\n    result = [0] * len(nums)\n    j = 0\n    for i in range(half):\n        result[j] = nums[i]\n        result[j + 1] = nums[half + i]\n        j += 2\n    return result"}}, "leetcode/leetcode_363.txt": {"score": 0.8351150751113892, "content": {"text": "from sortedcontainers import SortedList\n    \"\"\"Given an `m x n` matrix `matrix` and an integer `k`, return _the max sum of a rectangle in the matrix such that its sum is no larger than_ `k`.\n\nIt is **guaranteed** that there will be a rectangle with a sum no larger than `k`.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,0,1\\],\\[0,-2,3\\]\\], k = 2\n**Output:** 2\n**Explanation:** Because the sum of the blue rectangle \\[\\[0, 1\\], \\[-2, 3\\]\\] is 2, and 2 is the max number no larger than k (k = 2).\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[2,2,-1\\]\\], k = 3\n**Output:** 3\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 100`\n*   `-100 <= matrix[i][j] <= 100`\n*   `-105 <= k <= 105`\n\n**Follow up:** What if the number of rows is much larger than the number of columns?\"\"\"\n\n\ndef maxSumSubmatrix(matrix, k):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for l in range(cols):\n        sums = [0] * rows\n        for r in range(l, cols):\n            for i in range(rows):\n                sums[i] += matrix[i][r]\n\n            sorted_sums = SortedList()\n            sorted_sums.add(0)\n            curr_sum = 0\n            for sum in sums:\n                curr_sum += sum\n                it = sorted_sums.bisect_left(curr_sum - k)\n                if it != len(sorted_sums):\n                    max_sum = max(max_sum, curr_sum - sorted_sums[it])\n                sorted_sums.add(curr_sum)\n\n    return max_sum"}}, "leetcode/leetcode_84.txt": {"score": 0.9858388304710388, "content": {"text": "def largestRectangleArea(heights):\n    \"\"\"Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.\n\n**Example 1:**\n\n**Input:** heights = \\[2,1,5,6,2,3\\]\n**Output:** 10\n**Explanation:** The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n**Example 2:**\n\n**Input:** heights = \\[2,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `0 <= heights[i] <= 104`\"\"\"\n\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area"}}, "leetcode/leetcode_42.txt": {"score": 0.8735475540161133, "content": {"text": "def trap(height):\n    \"\"\"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`\"\"\"\n\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water"}}, "leetcode/leetcode_11.txt": {"score": 0.897240161895752, "content": {"text": "def max_area(height):\n    \"\"\"You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.\n\n**Example 1:**\n\n**Input:** height = \\[1,8,6,2,5,4,8,3,7\\]\n**Output:** 49\n**Explanation:** The above vertical lines are represented by array \\[1,8,6,2,5,4,8,3,7\\]. In this case, the max area of water (blue section) the container can contain is 49.\n\n**Example 2:**\n\n**Input:** height = \\[1,1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == height.length`\n*   `2 <= n <= 105`\n*   `0 <= height[i] <= 104`\"\"\"\n\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area"}}, "leetcode/csn_python_train_321006.txt": {"score": 0.9292144179344177, "content": {"text": "def rectangles_from_histogram(H):\n    \"\"\"Largest Rectangular Area in a Histogram\n\n    :param H: histogram table\n    :returns: area, left, height, right, rect. is [0, height] * [left, right)\n    :complexity: linear\n    \"\"\"\n    best = (float('-inf'), 0, 0, 0)\n    S = []\n    H2 = H + [float('-inf')]  # extra element to empty the queue\n    for right in range(len(H2)):\n        x = H2[right]\n        left = right\n        while len(S) > 0 and S[-1][1] >= x:\n            left, height = S.pop()\n            # first element is area of candidate\n            rect = (height * (right - left), left, height, right)\n            if rect > best:\n                best = rect\n        S.append((left, x))\n    return best"}}, "leetcode/leetcode_85.txt": {"score": 0.9046319723129272, "content": {"text": "def maximalRectangle(matrix):\n    \"\"\"Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.\"\"\"\n\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area"}}}}, "4": {"gold": {"leetcode/leetcode_2280.txt": 1}, "retrieved": {"leetcode/leetcode_452.txt": {"score": 0.8551380038261414, "content": {"text": "def findMinArrowShots(points):\n    \"\"\"There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` if `xstart <= x <= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array `points`, return _the **minimum** number of arrows that must be shot to burst all balloons_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[10,16\\],\\[2,8\\],\\[1,6\\],\\[7,12\\]\\]\n**Output:** 2\n**Explanation:** The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons \\[2,8\\] and \\[1,6\\].\n- Shoot an arrow at x = 11, bursting the balloons \\[10,16\\] and \\[7,12\\].\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,2\\],\\[3,4\\],\\[5,6\\],\\[7,8\\]\\]\n**Output:** 4\n**Explanation:** One arrow needs to be shot for each balloon for a total of 4 arrows.\n\n**Example 3:**\n\n**Input:** points = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons \\[1,2\\] and \\[2,3\\].\n- Shoot an arrow at x = 4, bursting the balloons \\[3,4\\] and \\[4,5\\].\n\n**Constraints:**\n\n*   `1 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `-231 <= xstart < xend <= 231 - 1`\"\"\"\n\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows"}}, "leetcode/leetcode_963.txt": {"score": 0.8584080934524536, "content": {"text": "def find_same_binary_value_parts(arr):\n    \"\"\"You are given an array of points in the **X-Y** plane `points` where `points[i] = [xi, yi]`.\n\nReturn _the minimum area of any rectangle formed from these points, with sides **not necessarily parallel** to the X and Y axes_. If there is not any such rectangle, return `0`.\n\nAnswers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,2\\],\\[2,1\\],\\[1,0\\],\\[0,1\\]\\]\n**Output:** 2.00000\n**Explanation:** The minimum area rectangle occurs at \\[1,2\\],\\[2,1\\],\\[1,0\\],\\[0,1\\], with an area of 2.\n\n**Example 2:**\n\n**Input:** points = \\[\\[0,1\\],\\[2,1\\],\\[1,1\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:** 1.00000\n**Explanation:** The minimum area rectangle occurs at \\[1,0\\],\\[1,1\\],\\[2,1\\],\\[2,0\\], with an area of 1.\n\n**Example 3:**\n\n**Input:** points = \\[\\[0,3\\],\\[1,2\\],\\[3,1\\],\\[1,3\\],\\[2,1\\]\\]\n**Output:** 0\n**Explanation:** There is no possible rectangle to form from these points.\n\n**Constraints:**\n\n*   `1 <= points.length <= 50`\n*   `points[i].length == 2`\n*   `0 <= xi, yi <= 4 * 104`\n*   All the given points are **unique**.\"\"\"\n\n    ones = sum(arr)\n\n    if ones % 3 != 0:\n        return [-1, -1]\n\n    target = ones // 3\n    if target == 0:\n        return [0, len(arr) - 2]\n\n    count = 0\n    i = j = -1\n    ones = 0\n    for idx, n in enumerate(arr):\n        if n == 1:\n            ones += 1\n            if ones == target + 1:\n                count += 1\n            if count == 1 and i == -1:\n                i = idx\n            if count == 2 and j == -1:\n                j = idx\n            if count == 3:\n                break\n\n    return [i, j]"}}, "leetcode/leetcode_447.txt": {"score": 0.8596693873405457, "content": {"text": "def numberOfBoomerangs(points):\n    \"\"\"You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**.\n\nReturn _the number of boomerangs_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:** 2\n**Explanation:** The two boomerangs are \\[\\[1,0\\],\\[0,0\\],\\[2,0\\]\\] and \\[\\[1,0\\],\\[2,0\\],\\[0,0\\]\\].\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** points = \\[\\[1,1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == points.length`\n*   `1 <= n <= 500`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the points are **unique**.\"\"\"\n\n    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count"}}, "leetcode/leetcode_1035.txt": {"score": 0.8767135143280029, "content": {"text": "class TreeNode:\n    \"\"\"You are given two integer arrays `nums1` and `nums2`. We write the integers of `nums1` and `nums2` (in the order they are given) on two separate horizontal lines.\n\nWe may draw connecting lines: a straight line connecting two numbers `nums1[i]` and `nums2[j]` such that:\n\n*   `nums1[i] == nums2[j]`, and\n*   the line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n\nReturn _the maximum number of connecting lines we can draw in this way_.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,4,2\\], nums2 = \\[1,2,4\\]\n**Output:** 2\n**Explanation:** We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from nums1\\[1\\] = 4 to nums2\\[2\\] = 4 will intersect the line from nums1\\[2\\]=2 to nums2\\[1\\]=2.\n\n**Example 2:**\n\n**Input:** nums1 = \\[2,5,1,2,5\\], nums2 = \\[10,5,2,1,5,2\\]\n**Output:** 3\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,3,7,1,7,5\\], nums2 = \\[1,9,2,5,1\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 500`\n*   `1 <= nums1[i], nums2[j] <= 2000`\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isCousins(self, root, x, y):\n        def findDepth(node, search_val, depth):\n            if not node:\n                return -1\n            if node.val == search_val:\n                return depth\n            left_depth = findDepth(node.left, search_val, depth + 1)\n            if left_depth != -1:\n                return left_depth\n            return findDepth(node.right, search_val, depth + 1)\n\n        def findParent(node, search_val):\n            if not node or not (node.left or node.right):\n                return None\n            if (node.left and node.left.val == search_val) or (node.right and node.right.val == search_val):\n                return node\n            left_parent = findParent(node.left, search_val)\n            if left_parent:\n                return left_parent\n            return findParent(node.right, search_val)\n\n        x_depth = findDepth(root, x, 0)\n        y_depth = findDepth(root, y, 0)\n        x_parent = findParent(root, x)\n        y_parent = findParent(root, y)\n        return (x_depth == y_depth) and (x_parent != y_parent)"}}, "leetcode/leetcode_1232.txt": {"score": 0.9317944645881653, "content": {"text": "def findBestValue(arr, target):\n    \"\"\"You are given an array `coordinates`, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the XY plane.\n\n**Example 1:**\n\n**Input:** coordinates = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[6,7\\]\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** coordinates = \\[\\[1,1\\],\\[2,2\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[7,7\\]\\]\n**Output:** false\n\n**Constraints:**\n\n*   `2 <= coordinates.length <= 1000`\n*   `coordinates[i].length == 2`\n*   `-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4`\n*   `coordinates` contains no duplicate point.\"\"\"\n\n    left = 0\n    right = max(arr)\n    result = -1\n    min_diff = float('inf')\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        total_sum = sum(min(x, mid) for x in arr)\n        if total_sum == target:\n            return mid\n        elif total_sum > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n        if abs(target - total_sum) < min_diff or (\n                abs(target - total_sum) == min_diff and mid < result):\n            min_diff = abs(target - total_sum)\n            result = mid\n\n    return result"}}, "leetcode/leetcode_1637.txt": {"score": 0.8681368231773376, "content": {"text": "def min_length_encoded(s: str, k: int) -> int:\n    \"\"\"Given `n` `points` on a 2D plane where `points[i] = [xi, yi]`, Return _the **widest vertical area** between two points such that no points are inside the area._\n\nA **vertical area** is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The **widest vertical area** is the one with the maximum width.\n\nNote that points **on the edge** of a vertical area **are not** considered included in the area.\n\n**Example 1:**\n\n\u200b\n\n**Input:** points = \\[\\[8,7\\],\\[9,9\\],\\[7,4\\],\\[9,7\\]\\]\n**Output:** 1\n**Explanation:** Both the red and the blue area are optimal.\n\n**Example 2:**\n\n**Input:** points = \\[\\[3,1\\],\\[9,0\\],\\[1,0\\],\\[1,4\\],\\[5,3\\],\\[8,8\\]\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `n == points.length`\n*   `2 <= n <= 105`\n*   `points[i].length == 2`\n*   `0 <= xi, yi <= 109`\"\"\"\n\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            cnt = 1\n            dp[i][j] = i - j\n            l = i - 2\n            while l >= 0 and i - 2 - l <= j:\n                if s[l] == s[i - 1]:\n                    cnt += 1\n                else:\n                    cnt = 1\n                used = i - 2 - l\n                new_aposition = i - 1 - cnt - used + 1\n                if cnt >= 100:\n                    new_aposition += 4\n                elif cnt >= 10:\n                    new_aposition += 3\n                elif cnt >= 2:\n                    new_aposition += 2\n                else:\n                    new_aposition += 1\n                dp[i][j] = min(dp[i][j], new_aposition + dp[l][j - used])\n                l -= 1\n\n    return dp[n][k]"}}, "leetcode/leetcode_2280.txt": {"score": 0.878140389919281, "content": {"text": "def count_good_triplets(nums1: list, nums2: list) -> int:\n    \"\"\"You are given a 2D integer array `stockPrices` where `stockPrices[i] = [dayi, pricei]` indicates the price of the stock on day `dayi` is `pricei`. A **line chart** is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:\n\nReturn _the **minimum number of lines** needed to represent the line chart_.\n\n**Example 1:**\n\n**Input:** stockPrices = \\[\\[1,7\\],\\[2,6\\],\\[3,5\\],\\[4,4\\],\\[5,4\\],\\[6,3\\],\\[7,2\\],\\[8,1\\]\\]\n**Output:** 3\n**Explanation:**\nThe diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.\nThe following 3 lines can be drawn to represent the line chart:\n- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).\n- Line 2 (in blue) from (4,4) to (5,4).\n- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).\nIt can be shown that it is not possible to represent the line chart using less than 3 lines.\n\n**Example 2:**\n\n**Input:** stockPrices = \\[\\[3,4\\],\\[1,2\\],\\[7,8\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:**\nAs shown in the diagram above, the line chart can be represented with a single line.\n\n**Constraints:**\n\n*   `1 <= stockPrices.length <= 105`\n*   `stockPrices[i].length == 2`\n*   `1 <= dayi, pricei <= 109`\n*   All `dayi` are **distinct**.\"\"\"\n\n    n = len(nums1)\n    pos1 = [0] * n\n    pos2 = [0] * n\n    for i in range(n):\n        pos1[nums1[i]] = i\n        pos2[nums2[i]] = i\n    count = 0\n    for x in range(n):\n        for y in range(x + 1, n):\n            for z in range(y + 1, n):\n                if pos1[x] < pos1[y] < pos1[z] and pos2[x] < pos2[y] < pos2[z]:\n                    count += 1\n    return count"}}, "leetcode/leetcode_1499.txt": {"score": 0.8831019401550293, "content": {"text": "import heapq\n    \"\"\"You are given an array `points` containing the coordinates of points on a 2D plane, sorted by the x-values, where `points[i] = [xi, yi]` such that `xi < xj` for all `1 <= i < j <= points.length`. You are also given an integer `k`.\n\nReturn _the maximum value of the equation_ `yi + yj + |xi - xj|` where `|xi - xj| <= k` and `1 <= i < j <= points.length`.\n\nIt is guaranteed that there exists at least one pair of points that satisfy the constraint `|xi - xj| <= k`.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,3\\],\\[2,0\\],\\[5,10\\],\\[6,-10\\]\\], k = 1\n**Output:** 4\n**Explanation:** The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\nNo other pairs satisfy the condition, so we return the max of 4 and 1.\n\n**Example 2:**\n\n**Input:** points = \\[\\[0,0\\],\\[3,0\\],\\[9,2\\]\\], k = 3\n**Output:** 3\n**Explanation:** Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.\n\n**Constraints:**\n\n*   `2 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `-108 <= xi, yi <= 108`\n*   `0 <= k <= 2 * 108`\n*   `xi < xj` for all `1 <= i < j <= points.length`\n*   `xi` form a strictly increasing sequence.\"\"\"\n\n\ndef max_performance(n, k, speed, efficiency):\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n\n    result = 0\n    sum_speed = 0\n    min_heap = []\n    for e, s in engineers:\n        if len(min_heap) >= k:\n            sum_speed -= heapq.heappop(min_heap)\n\n        heapq.heappush(min_heap, s)\n        sum_speed += s\n        result = max(result, e * sum_speed)\n\n    return result % (10**9 + 7)"}}, "leetcode/leetcode_1453.txt": {"score": 0.8857564330101013, "content": {"text": "def numPoints(darts, r):\n    \"\"\"Alice is throwing `n` darts on a very large wall. You are given an array `darts` where `darts[i] = [xi, yi]` is the position of the `ith` dart that Alice threw on the wall.\n\nBob knows the positions of the `n` darts on the wall. He wants to place a dartboard of radius `r` on the wall so that the maximum number of darts that Alice throws lies on the dartboard.\n\nGiven the integer `r`, return _the maximum number of darts that can lie on the dartboard_.\n\n**Example 1:**\n\n**Input:** darts = \\[\\[-2,0\\],\\[2,0\\],\\[0,2\\],\\[0,-2\\]\\], r = 2\n**Output:** 4\n**Explanation:** Circle dartboard with center in (0,0) and radius = 2 contain all points.\n\n**Example 2:**\n\n**Input:** darts = \\[\\[-3,0\\],\\[3,0\\],\\[2,6\\],\\[5,4\\],\\[0,9\\],\\[7,8\\]\\], r = 5\n**Output:** 5\n**Explanation:** Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n\n**Constraints:**\n\n*   `1 <= darts.length <= 100`\n*   `darts[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `darts` are unique\n*   `1 <= r <= 5000`\"\"\"\n\n    n = len(darts)\n    result = 1\n    \n    for i in range(n):\n        for j in range(n):\n            cnt = 0\n            for k in range(n):\n                dx = darts[i][0] - darts[k][0]\n                dy = darts[i][1] - darts[k][1]\n                if (dx * dx + dy * dy) ** 0.5 <= r:\n                    cnt += 1\n                    \n            if cnt > result:\n                result = cnt\n                \n    return result"}}, "leetcode/leetcode_149.txt": {"score": 0.9782813787460327, "content": {"text": "from math import gcd\n    \"\"\"Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane, return _the maximum number of points that lie on the same straight line_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,2\\],\\[5,3\\],\\[4,1\\],\\[2,3\\],\\[1,4\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= points.length <= 300`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `points` are **unique**.\"\"\"\n\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    n = len(points)\n    if n <= 2:\n        return n\n\n    max_count = 0\n\n    for i in range(n):\n        slope_map = defaultdict(int)\n        duplicates = 0\n        local_max = 0\n\n        for j in range(i+1, n):\n            deltaX = points[j][0] - points[i][0]\n            deltaY = points[j][1] - points[i][1]\n\n            if deltaX == 0 and deltaY == 0:\n                duplicates += 1\n                continue\n\n            g = gcd(deltaX, deltaY)\n            deltaX = deltaX // g\n            deltaY = deltaY // g\n\n            key = f\"{deltaX}_{deltaY}\"\n            slope_map[key] += 1\n            local_max = max(local_max, slope_map[key])\n\n        max_count = max(max_count, local_max + duplicates + 1)\n\n    return max_count"}}}}, "5": {"gold": {"leetcode/leetcode_210.txt": 1, "leetcode/leetcode_310.txt": 1, "leetcode/leetcode_630.txt": 1, "leetcode/leetcode_2392.txt": 1}, "retrieved": {"leetcode/csn_python_train_179363.txt": {"score": 0.9106244444847107, "content": {"text": "def is_cyclic(graph):\n    \"\"\"\n    Return True if the directed graph g has a cycle. The directed graph\n    should be represented as a dictionary mapping of edges for each node.\n    \"\"\"\n    path = set()\n\n    def visit(vertex):\n        path.add(vertex)\n        for neighbour in graph.get(vertex, ()):\n            if neighbour in path or visit(neighbour):\n                return True\n        path.remove(vertex)\n        return False\n\n    return any(visit(v) for v in graph)"}}, "leetcode/leetcode_1559.txt": {"score": 0.9180174469947815, "content": {"text": "def cherry_pickup(grid):\n    \"\"\"Given a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the **same value** in `grid`.\n\nA cycle is a path of **length 4 or more** in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the **same value** of the current cell.\n\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.\n\nReturn `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[ \"a \", \"a \", \"a \", \"a \"\\],\\[ \"a \", \"b \", \"b \", \"a \"\\],\\[ \"a \", \"b \", \"b \", \"a \"\\],\\[ \"a \", \"a \", \"a \", \"a \"\\]\\]\n**Output:** true\n**Explanation:** There are two valid cycles shown in different colors in the image below:\n \n\n**Example 2:**\n\n**Input:** grid = \\[\\[ \"c \", \"c \", \"c \", \"a \"\\],\\[ \"c \", \"d \", \"c \", \"c \"\\],\\[ \"c \", \"c \", \"e \", \"c \"\\],\\[ \"f \", \"c \", \"c \", \"c \"\\]\\]\n**Output:** true\n**Explanation:** There is only one valid cycle highlighted in the image below:\n \n\n**Example 3:**\n\n**Input:** grid = \\[\\[ \"a \", \"b \", \"b \"\\],\\[ \"b \", \"z \", \"b \"\\],\\[ \"b \", \"b \", \"a \"\\]\\]\n**Output:** false\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid` consists only of lowercase English letters.\"\"\"\n\n    rows, cols = len(grid), len(grid[0])\n    dp = [[[0] * cols for _ in range(cols)] for _ in range(rows)]\n\n    for row in reversed(range(rows)):\n        for col1 in range(cols):\n            for col2 in range(cols):\n                current_cell = dp[row + 1][col1][col2] if row < rows - 1 else 0\n                current_cell += grid[row][col1] + (grid[row][col2] if col1 != col2 else 0)\n\n                max_val = 0\n                for move1 in range(-1, 2):\n                    for move2 in range(-1, 2):\n                        new_col1, new_col2 = col1 + move1, col2 + move2\n                        if 0 <= new_col1 < cols and 0 <= new_col2 < cols:\n                            max_val = max(max_val, dp[row][new_col1][new_col2])\n\n                dp[row][col1][col2] = current_cell + max_val\n\n    return dp[0][0][cols - 1]"}}, "leetcode/csn_python_train_393230.txt": {"score": 0.9156135320663452, "content": {"text": "def verify_valid_dependencies(self):\n        \"\"\" Checks if the assigned dependencies are valid\n            valid dependency graphs are:\n\n            - noncyclic (i.e. no `A -> B -> ... -> A`)\n            - Contain no undefined dependencies\n              (dependencies referencing undefined tasks)\n        \"\"\"\n\n        unobserved_dependencies = set(self.tasks.keys())\n        target_queue = []\n\n        while len(unobserved_dependencies) > 0:\n            target_queue = [unobserved_dependencies.pop()]\n\n            while target_queue is not []:\n                target_queue += unobserved_dependencies"}}, "leetcode/leetcode_802.txt": {"score": 0.9326174855232239, "content": {"text": "import heapq\n    \"\"\"There is a directed graph of `n` nodes with each node labeled from `0` to `n - 1`. The graph is represented by a **0-indexed** 2D integer array `graph` where `graph[i]` is an integer array of nodes adjacent to node `i`, meaning there is an edge from node `i` to each node in `graph[i]`.\n\nA node is a **terminal node** if there are no outgoing edges. A node is a **safe node** if every possible path starting from that node leads to a **terminal node** (or another safe node).\n\nReturn _an array containing all the **safe nodes** of the graph_. The answer should be sorted in **ascending** order.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[1,2\\],\\[2,3\\],\\[5\\],\\[0\\],\\[5\\],\\[\\],\\[\\]\\]\n**Output:** \\[2,4,5,6\\]\n**Explanation:** The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,2,3,4\\],\\[1,2\\],\\[3,4\\],\\[0,4\\],\\[\\]\\]\n**Output:** \\[4\\]\n**Explanation:**\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n\n**Constraints:**\n\n*   `n == graph.length`\n*   `1 <= n <= 104`\n*   `0 <= graph[i].length <= n`\n*   `0 <= graph[i][j] <= n - 1`\n*   `graph[i]` is sorted in a strictly increasing order.\n*   The graph may contain self-loops.\n*   The number of edges in the graph will be in the range `[1, 4 * 104]`.\"\"\"\n\n\ndef kthSmallestPrimeFraction(arr, k):\n    pq = [(-arr[i] / arr[-1], i, len(arr) - 1) for i in range(len(arr) - 1)]\n\n    heapq.heapify(pq)\n\n    for _ in range(k - 1):\n        frac, i, j = heapq.heappop(pq)\n        j -= 1\n        if i < j:\n            heapq.heappush(pq, (-arr[i] / arr[j], i, j))\n\n    frac, i, j = heapq.heappop(pq)\n    return [arr[i], arr[j]]"}}, "leetcode/csn_python_train_184822.txt": {"score": 0.9206302762031555, "content": {"text": "def have_cycle(graph:dict) -> frozenset:\n    \"\"\"Perform a topologic sort to detect any cycle.\n\n    Return the set of unsortable nodes. If at least one item,\n    then there is cycle in given graph.\n\n    \"\"\"\n    # topological sort\n    walked = set()  # walked nodes\n    nodes = frozenset(it.chain(it.chain.from_iterable(graph.values()), graph.keys()))  # all nodes of the graph\n    preds = reversed_graph(graph)  # succ: preds\n    last_walked_len = -1\n    while last_walked_len != len(walked):\n        last_walked_len = len(walked)\n        for node in nodes - walked:\n            if len(preds.get(node, set()) - walked) == 0:\n                walked.add(node)\n    return frozenset(nodes - walked)"}}, "leetcode/leetcode_1436.txt": {"score": 0.9297524690628052, "content": {"text": "from collections import deque\n    \"\"\"You are given the array `paths`, where `paths[i] = [cityAi, cityBi]` means there exists a direct path going from `cityAi` to `cityBi`. _Return the destination city, that is, the city without any path outgoing to another city._\n\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n\n**Example 1:**\n\n**Input:** paths = \\[\\[ \"London \", \"New York \"\\],\\[ \"New York \", \"Lima \"\\],\\[ \"Lima \", \"Sao Paulo \"\\]\\]\n**Output:**  \"Sao Paulo \" \n**Explanation:** Starting at  \"London \" city you will reach  \"Sao Paulo \" city which is the destination city. Your trip consist of:  \"London \" ->  \"New York \" ->  \"Lima \" ->  \"Sao Paulo \".\n\n**Example 2:**\n\n**Input:** paths = \\[\\[ \"B \", \"C \"\\],\\[ \"D \", \"B \"\\],\\[ \"C \", \"A \"\\]\\]\n**Output:**  \"A \"\n**Explanation:** All possible trips are: \n \"D \" ->  \"B \" ->  \"C \" ->  \"A \". \n \"B \" ->  \"C \" ->  \"A \". \n \"C \" ->  \"A \". \n \"A \". \nClearly the destination city is  \"A \".\n\n**Example 3:**\n\n**Input:** paths = \\[\\[ \"A \", \"Z \"\\]\\]\n**Output:**  \"Z \"\n\n**Constraints:**\n\n*   `1 <= paths.length <= 100`\n*   `paths[i].length == 2`\n*   `1 <= cityAi.length, cityBi.length <= 10`\n*   `cityAi != cityBi`\n*   All strings consist of lowercase and uppercase English letters and the space character.\"\"\"\n\nfrom collections import defaultdict\n\ndef watched_videos_by_friends(watched_videos, friends, id, level):\n    visited = set()\n    q = deque([(id, 0)])\n    video_freq = defaultdict(int)\n\n    while q:\n        current_id, current_level = q.popleft()\n\n        if current_level == level:\n            for video in watched_videos[current_id]:\n                video_freq[video] += 1\n        elif current_level < level:\n            for friend_id in friends[current_id]:\n                if friend_id not in visited:\n                    visited.add(friend_id)\n                    q.append((friend_id, current_level + 1))\n\n    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))\n\n    return result"}}, "leetcode/csn_python_train_105731.txt": {"score": 0.9164420962333679, "content": {"text": "def sequence(arcs):\n    \"\"\"sequence: make a list of cities to visit, from set of arcs\"\"\"\n    succ = {}\n    for (i,j) in arcs:\n        succ[i] = j\n    curr = 1    # first node being visited\n    sol = [curr]\n    for i in range(len(arcs)-2):\n        curr = succ[curr]\n        sol.append(curr)\n    return sol"}}, "leetcode/leetcode_210.txt": {"score": 0.9346276521682739, "content": {"text": "from collections import deque\n    \"\"\"There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn _the ordering of courses you should take to finish all courses_. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** \\[0,1\\]\n**Explanation:** There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is \\[0,1\\].\n\n**Example 2:**\n\n**Input:** numCourses = 4, prerequisites = \\[\\[1,0\\],\\[2,0\\],\\[3,1\\],\\[3,2\\]\\]\n**Output:** \\[0,2,1,3\\]\n**Explanation:** There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is \\[0,1,2,3\\]. Another correct ordering is \\[0,2,1,3\\].\n\n**Example 3:**\n\n**Input:** numCourses = 1, prerequisites = \\[\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= numCourses * (numCourses - 1)`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   `ai != bi`\n*   All the pairs `[ai, bi]` are **distinct**.\"\"\"\n\n\ndef findOrder(numCourses, prerequisites):\n    in_degree = [0] * numCourses\n    adj_list = [[] for _ in range(numCourses)]\n    \n    for p in prerequisites:\n        adj_list[p[1]].append(p[0])\n        in_degree[p[0]] += 1\n    \n    q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    order = []\n    \n    while q:\n        curr = q.popleft()\n        order.append(curr)\n        for next in adj_list[curr]:\n            in_degree[next] -= 1\n            if in_degree[next] == 0:\n                q.append(next)\n    \n    return order if len(order) == numCourses else []"}}, "leetcode/leetcode_797.txt": {"score": 0.9380418658256531, "content": {"text": "from collections import defaultdict\n    \"\"\"Given a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in **any order**.\n\nThe graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).\n\n**Example 1:**\n\n**Input:** graph = \\[\\[1,2\\],\\[3\\],\\[3\\],\\[\\]\\]\n**Output:** \\[\\[0,1,3\\],\\[0,2,3\\]\\]\n**Explanation:** There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n\n**Example 2:**\n\n**Input:** graph = \\[\\[4,3,1\\],\\[3,2,4\\],\\[3\\],\\[4\\],\\[\\]\\]\n**Output:** \\[\\[0,4\\],\\[0,3,4\\],\\[0,1,3,4\\],\\[0,1,2,3,4\\],\\[0,1,4\\]\\]\n\n**Constraints:**\n\n*   `n == graph.length`\n*   `2 <= n <= 15`\n*   `0 <= graph[i][j] < n`\n*   `graph[i][j] != i` (i.e., there will be no self-loops).\n*   All the elements of `graph[i]` are **unique**.\n*   The input graph is **guaranteed** to be a **DAG**.\"\"\"\n\ndef numRabbits(answers):\n    count = defaultdict(int)\n    res = 0\n    for a in answers:\n        count[a] += 1\n        if count[a] == 1:\n            res += (a + 1)\n        elif count[a] > a + 1:\n            count[a] = 1\n            res += (a + 1)\n    return res"}}, "leetcode/leetcode_207.txt": {"score": 0.9884188175201416, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n**Example 2:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= 5000`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   All the pairs prerequisites\\[i\\] are **unique**.\"\"\"\n\n\ndef canFinish(numCourses, prerequisites):\n    adj = defaultdict(list)\n    inDegree = [0] * numCourses\n    \n    for a, b in prerequisites:\n        adj[b].append(a)\n        inDegree[a] += 1\n    \n    q = deque([i for i in range(numCourses) if inDegree[i]==0])\n    \n    while q:\n        currCourse = q.popleft()\n        numCourses -= 1\n        \n        for nextCourse in adj[currCourse]:\n            inDegree[nextCourse] -= 1\n            if inDegree[nextCourse] == 0:\n                q.append(nextCourse)\n    \n    return numCourses == 0"}}}}, "6": {"gold": {"leetcode/leetcode_207.txt": 1, "leetcode/leetcode_310.txt": 1, "leetcode/leetcode_630.txt": 1, "leetcode/leetcode_2115.txt": 1, "leetcode/leetcode_2392.txt": 1}, "retrieved": {"leetcode/csn_python_train_321007.txt": {"score": 0.915838897228241, "content": {"text": "def topological_order_dfs(graph):\n    \"\"\"Topological sorting by depth first search\n\n    :param graph: directed graph in listlist format, cannot be listdict\n    :returns: list of vertices in order\n    :complexity: `O(|V|+|E|)`\n    \"\"\"\n    n = len(graph)\n    order = []\n    times_seen = [-1] * n\n    for start in range(n):\n        if times_seen[start] == -1:\n            times_seen[start] = 0\n            to_visit = [start]\n            while to_visit:\n                node = to_visit[-1]\n                children = graph[node]\n                if times_seen[node] == len(children):\n                    to_visit.pop()\n                    order.append(node)\n                else:\n                    child = children[times_seen[node]]\n                    times_seen[node] += 1\n                    if times_seen[child] == -1:\n                        times_seen[child] = 0\n                        to_visit.append(child)\n    return order[::-1]"}}, "leetcode/csn_python_train_180743.txt": {"score": 0.9158565402030945, "content": {"text": "def __calculate_order(self, node_dict):\n        \"\"\"\n        Determine a valid ordering of the nodes in which a node is not called before all of it's dependencies.\n\n        Raise an error if there is a cycle, or nodes are missing.\n        \"\"\"\n        if len(node_dict.keys()) != len(set(node_dict.keys())):\n            raise DependencyTreeException(\"Duplicate Keys Exist in node dictionary!\")\n        valid_order = [node for node, dependencies in node_dict.items() if len(dependencies) == 0]\n        remaining_nodes = [node for node in node_dict.keys() if node not in valid_order]\n        while len(remaining_nodes) > 0:\n            node_added = False\n            for node in remaining_nodes:\n                dependencies = [d for d in node_dict[node] if d not in valid_order]\n                if len(dependencies) == 0:\n                    valid_order.append(node)\n                    remaining_nodes.remove(node)\n                    node_added = True\n            if not node_added:\n                # the tree must be invalid, as it was not possible to remove a node.\n                # it's hard to find all the errors, so just spit out the first one you can find.\n                invalid_node = remaining_nodes[0]\n                invalid_dependency = ', '.join(node_dict[invalid_node])\n                if invalid_dependency not in remaining_nodes:\n                    raise DependencyTreeException(\n                        \"Missing dependency! One or more of ({dependency}) are missing for {dependant}.\".format(\n                            dependant=invalid_node, dependency=invalid_dependency))\n                else:\n                    raise DependencyTreeException(\"The dependency %s is cyclic or dependent on a cyclic dependency\" % invalid_dependency)\n        return valid_order"}}, "leetcode/csn_python_train_167209.txt": {"score": 0.9231702089309692, "content": {"text": "def GetArtifactsInProperOrder(self):\n    \"\"\"Bring the artifacts in a linear order that resolves dependencies.\n\n    This method obtains a linear ordering of the nodes and then returns the list\n    of artifact names.\n\n    Returns:\n      A list of `ArtifactName` instances such that if they are collected in the\n      given order their dependencies are resolved.\n    \"\"\"\n    artifact_list = []\n    while self.reachable_nodes:\n      node_name = self.reachable_nodes.pop()\n      node = self.graph[node_name]\n      if node.is_artifact:\n        artifact_list.append(node_name)\n      for next_node_name in node.outgoing:\n        if next_node_name not in self.graph:\n          continue\n        next_node = self.graph[next_node_name]\n        if next_node.is_provided:\n          continue\n        next_node.incoming.remove(node_name)\n        if not (next_node.is_artifact and next_node.incoming):\n          next_node.is_provided = True\n          self.reachable_nodes.add(next_node_name)\n    return artifact_list"}}, "leetcode/csn_python_train_162770.txt": {"score": 0.9189304709434509, "content": {"text": "def sort_topologically(dag):\n    \"\"\"Sort the dag breath first topologically.\n\n    Only the nodes inside the dag are returned, i.e. the nodes that are also keys.\n\n    Returns:\n         a topological ordering of the DAG.\n    Raises:\n         an error if this is not possible (graph is not valid).\n    \"\"\"\n    dag = copy.deepcopy(dag)\n    sorted_nodes = []\n    independent_nodes = deque(get_independent_nodes(dag))\n    while independent_nodes:\n        node = independent_nodes.popleft()\n        sorted_nodes.append(node)\n        # this alters the dag so that we are sure we are visiting the nodes only once\n        downstream_nodes = dag[node]\n        while downstream_nodes:\n            downstream_node = downstream_nodes.pop(0)\n            if downstream_node not in dag:\n                continue\n            if not has_dependencies(downstream_node, dag):\n                independent_nodes.append(downstream_node)\n\n    if len(sorted_nodes) != len(dag.keys()):\n        raise ValueError('graph is not acyclic')\n    return sorted_nodes"}}, "leetcode/csn_python_train_93294.txt": {"score": 0.9256011247634888, "content": {"text": "def dependencies_order_of_build(target_contract, dependencies_map):\n    \"\"\" Return an ordered list of contracts that is sufficient to successfully\n    deploy the target contract.\n\n    Note:\n        This function assumes that the `dependencies_map` is an acyclic graph.\n    \"\"\"\n    if not dependencies_map:\n        return [target_contract]\n\n    if target_contract not in dependencies_map:\n        raise ValueError('no dependencies defined for {}'.format(target_contract))\n\n    order = [target_contract]\n    todo = list(dependencies_map[target_contract])\n\n    while todo:\n        target_contract = todo.pop(0)\n        target_pos = len(order)\n\n        for dependency in dependencies_map[target_contract]:\n            # we need to add the current contract before all its depedencies\n            if dependency in order:\n                target_pos = order.index(dependency)\n            else:\n                todo.append(dependency)\n\n        order.insert(target_pos, target_contract)\n\n    order.reverse()\n    return order"}}, "leetcode/csn_python_train_12894.txt": {"score": 0.9302156567573547, "content": {"text": "def topological_order(self):\n        \"\"\"Return the topological order of the node IDs from the input node to the output node.\"\"\"\n        q = Queue()\n        in_degree = {}\n        for i in range(self.n_nodes):\n            in_degree[i] = 0\n        for u in range(self.n_nodes):\n            for v, _ in self.adj_list[u]:\n                in_degree[v] += 1\n        for i in range(self.n_nodes):\n            if in_degree[i] == 0:\n                q.put(i)\n\n        order_list = []\n        while not q.empty():\n            u = q.get()\n            order_list.append(u)\n            for v, _ in self.adj_list[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    q.put(v)\n        return order_list"}}, "leetcode/csn_python_train_376580.txt": {"score": 0.9251435995101929, "content": {"text": "def getTopologicalOrderingOfJobs(self):\n        \"\"\"\n        :returns: a list of jobs such that for all pairs of indices i, j for which i < j, \\\n        the job at index i can be run before the job at index j.\n        :rtype: list\n        \"\"\"\n        ordering = []\n        visited = set()\n        def getRunOrder(job):\n            #Do not add the job to the ordering until all its predecessors have been\n            #added to the ordering\n            for p in job._directPredecessors:\n                if p not in visited:\n                    return\n            if job not in visited:\n                visited.add(job)\n                ordering.append(job)\n                list(map(getRunOrder, job._children + job._followOns))\n        getRunOrder(self)\n        return ordering"}}, "leetcode/leetcode_210.txt": {"score": 0.9983389973640442, "content": {"text": "from collections import deque\n    \"\"\"There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn _the ordering of courses you should take to finish all courses_. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** \\[0,1\\]\n**Explanation:** There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is \\[0,1\\].\n\n**Example 2:**\n\n**Input:** numCourses = 4, prerequisites = \\[\\[1,0\\],\\[2,0\\],\\[3,1\\],\\[3,2\\]\\]\n**Output:** \\[0,2,1,3\\]\n**Explanation:** There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is \\[0,1,2,3\\]. Another correct ordering is \\[0,2,1,3\\].\n\n**Example 3:**\n\n**Input:** numCourses = 1, prerequisites = \\[\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= numCourses * (numCourses - 1)`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   `ai != bi`\n*   All the pairs `[ai, bi]` are **distinct**.\"\"\"\n\n\ndef findOrder(numCourses, prerequisites):\n    in_degree = [0] * numCourses\n    adj_list = [[] for _ in range(numCourses)]\n    \n    for p in prerequisites:\n        adj_list[p[1]].append(p[0])\n        in_degree[p[0]] += 1\n    \n    q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    order = []\n    \n    while q:\n        curr = q.popleft()\n        order.append(curr)\n        for next in adj_list[curr]:\n            in_degree[next] -= 1\n            if in_degree[next] == 0:\n                q.append(next)\n    \n    return order if len(order) == numCourses else []"}}, "leetcode/csn_python_train_179362.txt": {"score": 0.9316732287406921, "content": {"text": "def sort_topologically(graph):\n    \"\"\"\n    Stackless topological sorting.\n\n    graph = {\n        3: [1],\n        5: [3],\n        4: [2],\n        6: [4],\n    }\n\n    sort_topologically(graph)\n    [[1, 2], [3, 4], [5, 6]]\n    \"\"\"\n    levels_by_name = {}\n    names_by_level = defaultdict(list)\n\n    def add_level_to_name(name, level):\n        levels_by_name[name] = level\n        names_by_level[level].append(name)\n\n\n    def walk_depth_first(name):\n        stack = [name]\n        while(stack):\n            name = stack.pop()\n            if name in levels_by_name:\n                continue\n\n            if name not in graph or not graph[name]:\n                level = 0\n                add_level_to_name(name, level)\n                continue\n\n            children = graph[name]\n\n            children_not_calculated = [child for child in children if child not in levels_by_name]\n            if children_not_calculated:\n                stack.append(name)\n                stack.extend(children_not_calculated)\n                continue\n\n            level = 1 + max(levels_by_name[lname] for lname in children)\n            add_level_to_name(name, level)\n\n    for name in graph:\n        walk_depth_first(name)\n\n    return list(itertools.takewhile(lambda x: x is not None,\n                                    (names_by_level.get(i, None)\n                                     for i in itertools.count())))"}}, "leetcode/leetcode_207.txt": {"score": 0.9511834979057312, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n**Example 2:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= 5000`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   All the pairs prerequisites\\[i\\] are **unique**.\"\"\"\n\n\ndef canFinish(numCourses, prerequisites):\n    adj = defaultdict(list)\n    inDegree = [0] * numCourses\n    \n    for a, b in prerequisites:\n        adj[b].append(a)\n        inDegree[a] += 1\n    \n    q = deque([i for i in range(numCourses) if inDegree[i]==0])\n    \n    while q:\n        currCourse = q.popleft()\n        numCourses -= 1\n        \n        for nextCourse in adj[currCourse]:\n            inDegree[nextCourse] -= 1\n            if inDegree[nextCourse] == 0:\n                q.append(nextCourse)\n    \n    return numCourses == 0"}}}}, "7": {"gold": {"leetcode/leetcode_699.txt": 1, "leetcode/leetcode_2381.txt": 1}, "retrieved": {"leetcode/csn_python_train_246198.txt": {"score": 0.8847752213478088, "content": {"text": "def merge_intervals(elems, overlap_thres=2.0):\n    \"\"\"\n    Project in x axis\n    Sort by start\n    Go through segments and keep max x1\n\n    Return a list of non-overlapping intervals\n    \"\"\"\n    overlap_thres = max(0.0, overlap_thres)\n    ordered = sorted(elems, key=lambda e: e.x0)\n\n    intervals = []\n    cur = [-overlap_thres, -overlap_thres]\n    for e in ordered:\n        if e.x0 - cur[1] > overlap_thres:\n            # Check interval validity\n            if cur[1] > 0.0:\n                intervals.append(cur)\n            cur = [e.x0, e.x1]\n            continue\n        cur[1] = max(cur[1], e.x1)\n    intervals.append(cur)\n    # Freeze the interval to tuples\n    return map(tuple, intervals)"}}, "leetcode/leetcode_587.txt": {"score": 0.885773777961731, "content": {"text": "def cross_product(p, q, r):\n    \"\"\"You are given an array `trees` where `trees[i] = [xi, yi]` represents the location of a tree in the garden.\n\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if **all the trees are enclosed**.\n\nReturn _the coordinates of trees that are exactly located on the fence perimeter_. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** trees = \\[\\[1,1\\],\\[2,2\\],\\[2,0\\],\\[2,4\\],\\[3,3\\],\\[4,2\\]\\]\n**Output:** \\[\\[1,1\\],\\[2,0\\],\\[4,2\\],\\[3,3\\],\\[2,4\\]\\]\n**Explanation:** All the trees will be on the perimeter of the fence except the tree at \\[2, 2\\], which will be inside the fence.\n\n**Example 2:**\n\n**Input:** trees = \\[\\[1,2\\],\\[2,2\\],\\[4,2\\]\\]\n**Output:** \\[\\[4,2\\],\\[2,2\\],\\[1,2\\]\\]\n**Explanation:** The fence forms a line that passes through all the trees.\n\n**Constraints:**\n\n*   `1 <= trees.length <= 3000`\n*   `trees[i].length == 2`\n*   `0 <= xi, yi <= 100`\n*   All the given positions are **unique**.\"\"\"\n\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef fence(trees):\n    trees.sort(key=lambda p: (p[0], p[1]))\n    hull = []\n    for p in trees:\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n\n    for p in reversed(trees):\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n    \n    return hull"}}, "leetcode/csn_python_train_320943.txt": {"score": 0.8854832053184509, "content": {"text": "def intervals_union(S):\n    \"\"\"Union of intervals\n\n    :param S: list of pairs (low, high) defining intervals [low, high)\n    :returns: ordered list of disjoint intervals with the same union as S\n    :complexity: O(n log n)\n    \"\"\"\n    E = [(low, -1) for (low, high) in S]\n    E += [(high, +1) for (low, high) in S]\n    nb_open = 0\n    last = None\n    retval = []\n    for x, _dir in sorted(E):\n        if _dir == -1:\n            if nb_open == 0:\n                last = x\n            nb_open += 1\n        else:\n            nb_open -= 1\n            if nb_open == 0:\n                retval.append((last, x))\n    return retval"}}, "leetcode/leetcode_807.txt": {"score": 0.8897527456283569, "content": {"text": "def custom_sort_string(order, s):\n    \"\"\"There is a city composed of `n x n` blocks, where each block contains a single building shaped like a vertical square prism. You are given a **0-indexed** `n x n` integer matrix `grid` where `grid[r][c]` represents the **height** of the building located in the block at row `r` and column `c`.\n\nA city's **skyline** is the outer contour formed by all the building when viewing the side of the city from a distance. The **skyline** from each cardinal direction north, east, south, and west may be different.\n\nWe are allowed to increase the height of **any number of buildings by any amount** (the amount can be different per building). The height of a `0`\\-height building can also be increased. However, increasing the height of a building should **not** affect the city's **skyline** from any cardinal direction.\n\nReturn _the **maximum total sum** that the height of the buildings can be increased by **without** changing the city's **skyline** from any cardinal direction_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[3,0,8,4\\],\\[2,4,5,7\\],\\[9,2,6,3\\],\\[0,3,1,0\\]\\]\n**Output:** 35\n**Explanation:** The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = \\[ \\[8, 4, 8, 7\\],\n            \\[7, 4, 7, 7\\],\n            \\[9, 4, 8, 7\\],\n            \\[3, 3, 3, 3\\] \\]\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Output:** 0\n**Explanation:** Increasing the height of any building will result in the skyline changing.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[r].length`\n*   `2 <= n <= 50`\n*   `0 <= grid[r][c] <= 100`\"\"\"\n\n    return ''.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))"}}, "leetcode/csn_python_train_52687.txt": {"score": 0.9097462892532349, "content": {"text": "def _add_skyline(self, rect):\n        \"\"\"\n        Arguments:\n            seg (Rectangle):\n        \"\"\"\n        skylineq = collections.deque([]) # Skyline after adding new one\n        \n        for sky in self._skyline:\n            if sky.right <= rect.left or sky.left >= rect.right:\n                self._merge_skyline(skylineq, sky)\n                continue\n\n            if sky.left < rect.left and sky.right > rect.left:\n                # Skyline section partially under segment left\n                self._merge_skyline(skylineq, \n                        HSegment(sky.start, rect.left-sky.left))\n                sky = HSegment(P(rect.left, sky.top), sky.right-rect.left)\n            \n            if sky.left < rect.right:\n                if sky.left == rect.left:\n                    self._merge_skyline(skylineq, \n                        HSegment(P(rect.left, rect.top), rect.width))\n                # Skyline section partially under segment right\n                if sky.right > rect.right:\n                    self._merge_skyline(skylineq, \n                        HSegment(P(rect.right, sky.top), sky.right-rect.right))\n                    sky = HSegment(sky.start, rect.right-sky.left)\n            \n            if sky.left >= rect.left and sky.right <= rect.right:\n                # Skyline section fully under segment, account for wasted space\n                if self._waste_management and sky.top < rect.bottom:\n                    self._waste.add_waste(sky.left, sky.top, \n                        sky.length, rect.bottom - sky.top)\n            else:\n                # Segment\n                self._merge_skyline(skylineq, sky)\n\n        # Aaaaand ..... Done\n        self._skyline = list(skylineq)"}}, "leetcode/csn_python_train_320978.txt": {"score": 0.8876741528511047, "content": {"text": "def union_rectangles(R):\n    \"\"\"Area of union of rectangles\n\n    :param R: list of rectangles defined by (x1, y1, x2, y2)\n       where (x1, y1) is top left corner and (x2, y2) bottom right corner\n    :returns: area\n    :complexity: :math:`O(n^2)`\n    \"\"\"\n    if R == []:\n        return 0\n    X = []\n    Y = []\n    for j in range(len(R)):\n        (x1, y1, x2, y2) = R[j]\n        assert x1 <= x2 and y1 <= y2\n        X.append(x1)\n        X.append(x2)\n        Y.append((y1, +1, j))    # generate events\n        Y.append((y2, -1, j))\n    X.sort()\n    Y.sort()\n    X2i = {X[i]: i for i in range(len(X))}\n    L = [X[i + 1] - X[i] for i in range(len(X) - 1)]\n    C = Cover_query(L)\n    area = 0\n    last = 0\n    for (y, delta, j) in Y:\n        area += (y - last) * C.cover()\n        last = y\n        (x1, y1, x2, y2) = R[j]\n        i = X2i[x1]\n        k = X2i[x2]\n        C.change(i, k, delta)\n    return area"}}, "leetcode/csn_python_train_52686.txt": {"score": 0.9032237529754639, "content": {"text": "def _merge_skyline(self, skylineq, segment):\n        \"\"\"\n        Arguments:\n            skylineq (collections.deque):\n            segment (HSegment):\n        \"\"\"\n        if len(skylineq) == 0:\n            skylineq.append(segment)\n            return\n\n        if skylineq[-1].top == segment.top:\n            s = skylineq[-1]\n            skylineq[-1] = HSegment(s.start, s.length+segment.length)\n        else:\n            skylineq.append(segment)"}}, "leetcode/leetcode_218.txt": {"score": 0.9968402981758118, "content": {"text": "from sortedcontainers import SortedList\n    \"\"\"A city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return _the **skyline** formed by these buildings collectively_.\n\nThe geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:\n\n*   `lefti` is the x coordinate of the left edge of the `ith` building.\n*   `righti` is the x coordinate of the right edge of the `ith` building.\n*   `heighti` is the height of the `ith` building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.\n\nThe **skyline** should be represented as a list of \"key points \" **sorted by their x-coordinate** in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\n**Note:** There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`\n\n**Example 1:**\n\n**Input:** buildings = \\[\\[2,9,10\\],\\[3,7,15\\],\\[5,12,12\\],\\[15,20,10\\],\\[19,24,8\\]\\]\n**Output:** \\[\\[2,10\\],\\[3,15\\],\\[7,12\\],\\[12,0\\],\\[15,10\\],\\[20,8\\],\\[24,0\\]\\]\n**Explanation:**\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n\n**Example 2:**\n\n**Input:** buildings = \\[\\[0,2,3\\],\\[2,5,3\\]\\]\n**Output:** \\[\\[0,3\\],\\[5,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= buildings.length <= 104`\n*   `0 <= lefti < righti <= 231 - 1`\n*   `1 <= heighti <= 231 - 1`\n*   `buildings` is sorted by `lefti` in non-decreasing order.\"\"\"\n\n\ndef getSkyline(buildings):\n    points = []\n    for l, r, h in buildings:\n        points.append((l, -h))\n        points.append((r, h))\n    points.sort()\n    heights = SortedList([0])\n    prev = 0\n    skyline = []\n    for x, h in points:\n        if h < 0:\n            heights.add(-h)\n        else:\n            heights.remove(h)\n        cur = heights[-1]\n        if cur != prev:\n            skyline.append([x, cur])\n            prev = cur\n    return skyline"}}, "leetcode/csn_python_train_177686.txt": {"score": 0.8936999440193176, "content": {"text": "def upper(self) -> Set[Point2]:\n        \"\"\" Returns the upper points of a ramp. \"\"\"\n        max_height = max([self.height_at(p) for p in self._points])\n        return {p for p in self._points if self.height_at(p) == max_height}"}}, "leetcode/csn_python_train_3898.txt": {"score": 0.9265598058700562, "content": {"text": "def get_skyline(lrh):\n    \"\"\"\n    Wortst Time Complexity: O(NlogN)\n    :type buildings: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    skyline, live = [], []\n    i, n = 0, len(lrh)\n    while i < n or live:\n        if not live or i < n and lrh[i][0] <= -live[0][1]:\n            x = lrh[i][0]\n            while i < n and lrh[i][0] == x:\n                heapq.heappush(live, (-lrh[i][2], -lrh[i][1]))\n                i += 1\n        else:\n            x = -live[0][1]\n            while live and -live[0][1] <= x:\n                heapq.heappop(live)\n        height = len(live) and -live[0][0]\n        if not skyline or height != skyline[-1][1]:\n            skyline += [x, height],\n    return skyline"}}}}, "8": {"gold": {"leetcode/leetcode_12.txt": 1}, "retrieved": {"leetcode/csn_python_train_321191.txt": {"score": 0.8701095581054688, "content": {"text": "def _convertUnitAsWords(self, unitText):\n        \"\"\"\n        Converts text units into their number value.\n\n        @type  unitText: string\n        @param unitText: number text to convert\n\n        @rtype:  integer\n        @return: numerical value of unitText\n        \"\"\"\n        word_list, a, b = re.split(r\"[,\\s-]+\", unitText), 0, 0\n        for word in word_list:\n            x = self.ptc.small.get(word)\n            if x is not None:\n                a += x\n            elif word == \"hundred\":\n                a *= 100\n            else:\n                x = self.ptc.magnitude.get(word)\n                if x is not None:\n                    b += a * x\n                    a = 0\n                elif word in self.ptc.ignore:\n                    pass\n                else:\n                    raise Exception(\"Unknown number: \" + word)\n        return a + b"}}, "leetcode/csn_python_train_86465.txt": {"score": 0.884293258190155, "content": {"text": "def number(digit):\n\t\"\"\"\n\tGets a spoken-word representation for a number.\n\n\tArguments:\n\t\tdigit (int): An integer to convert into spoken-word.\n\n\tReturns:\n\t\tA spoken-word representation for a digit,\n\t\tincluding an article ('a' or 'an') and a suffix,\n\t\te.g. 1 -> 'a 1st', 11 -> \"an 11th\". Adittionally\n\t\tdelimits characters in pairs of three for values > 999.\n\t\"\"\"\n\n\tspoken = str(digit)\n\n\tif spoken.startswith(\"8\") or spoken[:len(spoken) % 3] == \"11\":\n\t\tarticle = \"an \"\n\telse:\n\t\tarticle = \"a \"\n\n\tif spoken.endswith(\"1\") and spoken != \"11\":\n\t\tsuffix = \"st\"\n\telif spoken.endswith(\"2\") and spoken != \"12\":\n\t\tsuffix = \"nd\"\n\telif spoken.endswith(\"3\") and spoken != \"13\":\n\t\tsuffix = \"rd\"\n\telse:\n\t\tsuffix = \"th\"\n\n\tif digit > 999:\n\t\tprefix = len(spoken) % 3\n\t\tseparated = spoken[:prefix]\n\t\tfor n in range(prefix, len(spoken), 3):\n\t\t\tseparated += \",\" + spoken[n : n + 3]\n\t\tspoken = separated\n\n\treturn article + spoken + suffix"}}, "leetcode/csn_python_train_83217.txt": {"score": 0.8773720860481262, "content": {"text": "def __to_text(self, number, indice = 0, sing=False):\n        \"\"\"Convierte un numero a texto, recursivamente\"\"\"\n\n        number = int(number)\n        exp = self.exponentes[indice]\n        indice += 1\n        divisor = 10 ** exp\n\n        if exp == 3:\n            func = self.__numero_tres_cifras\n        else:\n            func = self.__to_text\n        \n        if divisor < number:\n            division = number // divisor\n            resto = number % divisor\n        \n            if resto:\n                der = func(resto, indice, sing)\n            else:\n                der = False\n\n            if exp == 3 and division == 1: #1000\n                return \"%s %s\" % (exponentes_plural[exp], der)\n            else:\n                izq = func(division, indice, True)\n                if der:\n                    if division == 1:\n                        return \"%s %s\" % (exponentes_singular[exp], der)\n                    else:\n                        return \"%s %s %s\" % (izq, exponentes_plural[exp], der)\n                else:\n                    if division == 1:\n                        return exponentes_singular[exp]\n                    else:\n                        return \"%s %s\" % (izq, exponentes_plural[exp])\n                        \n        elif divisor == int(number):\n            if exp == 3:\n                return exponentes_plural[exp]\n            else:\n                return exponentes_singular[exp]\n        else:\n            return func(number, indice, sing)"}}, "leetcode/csn_python_train_33847.txt": {"score": 0.892703652381897, "content": {"text": "def _sum_string_fn(into, tmp_val, gender, items=None):\n    \"\"\"\n    Make in-words representation of single order\n\n    @param into: in-words representation of lower orders\n    @type into: C{unicode}\n\n    @param tmp_val: temporary value without lower orders\n    @type tmp_val: C{integer types}\n\n    @param gender: gender (MALE, FEMALE or NEUTER)\n    @type gender: C{int}\n\n    @param items: variants of objects\n    @type items: 3-element C{sequence} of C{unicode}\n\n    @return: new into and tmp_val\n    @rtype: C{tuple}\n\n    @raise ValueError: tmp_val is negative\n    \"\"\"\n    if items is None:\n        items = (u\"\", u\"\", u\"\")\n    one_item, two_items, five_items = items\n    \n    check_positive(tmp_val)\n\n    if tmp_val == 0:\n        return into, tmp_val\n\n    words = []\n\n    rest = tmp_val % 1000\n    tmp_val = tmp_val // 1000\n    if rest == 0:\n        # \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0435 \u0442\u0440\u0438 \u0437\u043d\u0430\u043a\u0430 \u043d\u0443\u043b\u0435\u0432\u044b\u0435\n        if into == u\"\":\n            into = u\"%s \" % five_items\n        return into, tmp_val\n\n    # \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u043f\u043e\u0434\u0441\u0447\u0435\u0442 \u0441 rest\n    end_word = five_items\n\n    # \u0441\u043e\u0442\u043d\u0438\n    words.append(HUNDREDS[rest // 100])\n\n    # \u0434\u0435\u0441\u044f\u0442\u043a\u0438\n    rest = rest % 100\n    rest1 = rest // 10\n    # \u043e\u0441\u043e\u0431\u044b\u0439 \u0441\u043b\u0443\u0447\u0430\u0439 -- tens=1\n    tens = rest1 == 1 and TENS[rest] or TENS[rest1]\n    words.append(tens)\n\n    # \u0435\u0434\u0438\u043d\u0438\u0446\u044b\n    if rest1 < 1 or rest1 > 1:\n        amount = rest % 10\n        end_word = choose_plural(amount, items)\n        words.append(ONES[amount][gender-1])\n    words.append(end_word)\n\n    # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u043e, \u0447\u0442\u043e \u0443\u0436\u0435 \u0431\u044b\u043b\u043e\n    words.append(into)\n\n    # \u0443\u0431\u0438\u0440\u0430\u0435\u043c \u043f\u0443\u0441\u0442\u044b\u0435 \u043f\u043e\u0434\u0441\u0442\u0440\u043e\u043a\u0438\n    words = filter(lambda x: len(x) > 0, words)\n\n    # \u0441\u043a\u043b\u0435\u0438\u0432\u0430\u0435\u043c \u0438 \u043e\u0442\u0434\u0430\u0435\u043c\n    return u\" \".join(words).strip(), tmp_val"}}, "leetcode/csn_python_train_108923.txt": {"score": 0.9154427647590637, "content": {"text": "def num2eng(num):\n    '''English representation of a number up to a trillion.\n    '''\n    num = str(int(num))  # Convert to string, throw if bad number\n    if (len(num) / 3 >= len(_PRONOUNCE)):  # Sanity check\n        return num\n    elif num == '0':  # Zero is a special case\n        return 'zero'\n    pron = []  # Result accumulator\n    first = True\n    for pr, bits in zip(_PRONOUNCE, grouper(3, reversed(num), '')):\n        num = ''.join(reversed(bits))\n        n = int(num)\n        bits = []\n        if n > 99:  # Got hundred\n            bits.append('%s hundred' % _SMALL[num[0]])\n            num = num[1:]\n            n = int(num)\n            num = str(n)\n        if (n > 20) and (n != (n // 10 * 10)):\n            bits.append('%s %s' % (_SMALL[num[0] + '0'], _SMALL[num[1]]))\n        elif n:\n            bits.append(_SMALL[num])\n        if len(bits) == 2 and first:\n            first = False\n            p = ' and '.join(bits)\n        else:\n            p = ' '.join(bits)\n        if p and pr:\n            p = '%s %s' % (p, pr)\n        pron.append(p)\n    return ', '.join(reversed(pron))"}}, "leetcode/csn_python_train_254530.txt": {"score": 0.8888447880744934, "content": {"text": "def number_to_words(\n        self,\n        num,\n        wantlist=False,\n        group=0,\n        comma=\",\",\n        andword=\"and\",\n        zero=\"zero\",\n        one=\"one\",\n        decimal=\"point\",\n        threshold=None,\n    ):\n        \"\"\"\n        Return a number in words.\n\n        group = 1, 2 or 3 to group numbers before turning into words\n        comma: define comma\n        andword: word for 'and'. Can be set to ''.\n            e.g. \"one hundred and one\" vs \"one hundred one\"\n        zero: word for '0'\n        one: word for '1'\n        decimal: word for decimal point\n        threshold: numbers above threshold not turned into words\n\n        parameters not remembered from last call. Departure from Perl version.\n        \"\"\"\n        self.number_args = dict(andword=andword, zero=zero, one=one)\n        num = \"%s\" % num\n\n        # Handle \"stylistic\" conversions (up to a given threshold)...\n        if threshold is not None and float(num) > threshold:\n            spnum = num.split(\".\", 1)\n            while comma:\n                (spnum[0], n) = re.subn(r\"(\\d)(\\d{3}(?:,|\\Z))\", r\"\\1,\\2\", spnum[0])\n                if n == 0:\n                    break\n            try:\n                return \"{}.{}\".format(spnum[0], spnum[1])\n            except IndexError:\n                return \"%s\" % spnum[0]\n\n        if group < 0 or group > 3:\n            raise BadChunkingOptionError\n        nowhite = num.lstrip()\n        if nowhite[0] == \"+\":\n            sign = \"plus\"\n        elif nowhite[0] == \"-\":\n            sign = \"minus\"\n        else:\n            sign = \"\"\n\n        myord = num[-2:] in (\"st\", \"nd\", \"rd\", \"th\")\n        if myord:\n            num = num[:-2]\n        finalpoint = False\n        if decimal:\n            if group != 0:\n                chunks = num.split(\".\")\n            else:\n                chunks = num.split(\".\", 1)\n            if chunks[-1] == \"\":  # remove blank string if nothing after decimal\n                chunks = chunks[:-1]\n                finalpoint = True  # add 'point' to end of output\n        else:\n            chunks = [num]\n\n        first = 1\n        loopstart = 0\n\n        if chunks[0] == \"\":\n            first = 0\n            if len(chunks) > 1:\n                loopstart = 1\n\n        for i in range(loopstart, len(chunks)):\n            chunk = chunks[i]\n            # remove all non numeric \\D\n            chunk = re.sub(r\"\\D\", self.blankfn, chunk)\n            if chunk == \"\":\n                chunk = \"0\"\n\n            if group == 0 and (first == 0 or first == \"\"):\n                chunk = self.enword(chunk, 1)\n            else:\n                chunk = self.enword(chunk, group)\n\n            if chunk[-2:] == \", \":\n                chunk = chunk[:-2]\n            chunk = re.sub(r\"\\s+,\", self.commafn, chunk)\n\n            if group == 0 and first:\n                chunk = re.sub(r\", (\\S+)\\s+\\Z\", \" %s \\\\1\" % andword, chunk)\n            chunk = re.sub(r\"\\s+\", self.spacefn, chunk)\n            # chunk = re.sub(r\"(\\A\\s|\\s\\Z)\", self.blankfn, chunk)\n            chunk = chunk.strip()\n            if first:\n                first = \"\"\n            chunks[i] = chunk\n\n        numchunks = []\n        if first != 0:\n            numchunks = chunks[0].split(\"%s \" % comma)\n\n        if myord and numchunks:\n            # TODO: can this be just one re as it is in perl?\n            mo = re.search(r\"(%s)\\Z\" % ordinal_suff, numchunks[-1])\n            if mo:\n                numchunks[-1] = re.sub(\n                    r\"(%s)\\Z\" % ordinal_suff, ordinal[mo.group(1)], numchunks[-1]\n                )\n            else:\n                numchunks[-1] += \"th\"\n\n        for chunk in chunks[1:]:\n            numchunks.append(decimal)\n            numchunks.extend(chunk.split(\"%s \" % comma))\n\n        if finalpoint:\n            numchunks.append(decimal)\n\n        # wantlist: Perl list context. can explictly specify in Python\n        if wantlist:\n            if sign:\n                numchunks = [sign] + numchunks\n            return numchunks\n        elif group:\n            signout = \"%s \" % sign if sign else \"\"\n            return \"{}{}\".format(signout, \", \".join(numchunks))\n        else:\n            signout = \"%s \" % sign if sign else \"\"\n            num = \"{}{}\".format(signout, numchunks.pop(0))\n            if decimal is None:\n                first = True\n            else:\n                first = not num.endswith(decimal)\n            for nc in numchunks:\n                if nc == decimal:\n                    num += \" %s\" % nc\n                    first = 0\n                elif first:\n                    num += \"{} {}\".format(comma, nc)\n                else:\n                    num += \" %s\" % nc\n            return num"}}, "leetcode/csn_python_train_273612.txt": {"score": 0.8780907392501831, "content": {"text": "def parseInt(self, words):\n        \"\"\"Parses words to the integer they describe.\n\n        Args:\n            words (str): Description of the integer.\n\n        Returns:\n            An integer representation of the words.\n        \"\"\"\n        # Remove 'and', case-sensitivity\n        words = words.replace(\" and \", \" \").lower()\n        # 'a' -> 'one'\n        words = re.sub(r'(\\b)a(\\b)', '\\g<1>one\\g<2>', words)\n\n        def textToNumber(s):\n            \"\"\"\n            Converts raw number string to an integer.\n            Based on text2num.py by Greg Hewill.\n            \"\"\"\n            a = re.split(r\"[\\s-]+\", s)\n            n = 0\n            g = 0\n            for w in a:\n                x = NumberService.__small__.get(w, None)\n                if x is not None:\n                    g += x\n                elif w == \"hundred\":\n                    g *= 100\n                else:\n                    x = NumberService.__magnitude__.get(w, None)\n                    if x is not None:\n                        n += g * x\n                        g = 0\n                    else:\n                        raise NumberService.NumberException(\n                            \"Unknown number: \" + w)\n            return n + g\n\n        return textToNumber(words)"}}, "leetcode/csn_python_train_342755.txt": {"score": 0.9165870547294617, "content": {"text": "def int_to_words(number, european=False):\n    \"\"\"\n    Converts an integer or float to words.\n\n    .. code: python\n\n        reusables.int_to_number(445)\n        # 'four hundred forty-five'\n\n        reusables.int_to_number(1.45)\n        # 'one and forty-five hundredths'\n\n    :param number: String, integer, or float to convert to words. The decimal\n        can only be up to three places long, and max number allowed is 999\n        decillion.\n    :param european: If the string uses the european style formatting, i.e.\n        decimal points instead of commas and commas instead of decimal points,\n        set this parameter to True\n    :return: The translated string\n    \"\"\"\n    def ones(n):\n        return \"\" if n == 0 else _numbers[n]\n\n    def tens(n):\n        teen = int(\"{0}{1}\".format(n[0], n[1]))\n\n        if n[0] == 0:\n            return ones(n[1])\n        if teen in _numbers:\n            return _numbers[teen]\n        else:\n            ten = _numbers[int(\"{0}0\".format(n[0]))]\n            one = _numbers[n[1]]\n            return \"{0}-{1}\".format(ten, one)\n\n    def hundreds(n):\n        if n[0] == 0:\n            return tens(n[1:])\n        else:\n            t = tens(n[1:])\n            return \"{0} hundred {1}\".format(_numbers[n[0]], \"\" if not t else t)\n\n    def comma_separated(list_of_strings):\n        if len(list_of_strings) > 1:\n            return \"{0} \".format(\"\" if len(list_of_strings) == 2\n                                 else \",\").join(list_of_strings)\n        else:\n            return list_of_strings[0]\n\n    def while_loop(list_of_numbers, final_list):\n        index = 0\n        group_set = int(len(list_of_numbers) / 3)\n        while group_set != 0:\n            value = hundreds(list_of_numbers[index:index + 3])\n            if value:\n                final_list.append(\"{0} {1}\".format(value, _places[group_set])\n                                  if _places[group_set] else value)\n            group_set -= 1\n            index += 3\n\n    number_list = []\n    decimal_list = []\n\n    decimal = ''\n    number = str(number)\n    group_delimiter, point_delimiter = (\",\", \".\") \\\n        if not european else (\".\", \",\")\n\n    if point_delimiter in number:\n        decimal = number.split(point_delimiter)[1]\n        number = number.split(point_delimiter)[0].replace(\n            group_delimiter, \"\")\n    elif group_delimiter in number:\n        number = number.replace(group_delimiter, \"\")\n\n    if not number.isdigit():\n        raise ValueError(\"Number is not numeric\")\n\n    if decimal and not decimal.isdigit():\n        raise ValueError(\"Decimal is not numeric\")\n\n    if int(number) == 0:\n        number_list.append(\"zero\")\n\n    r = len(number) % 3\n    d_r = len(decimal) % 3\n    number = number.zfill(len(number) + 3 - r if r else 0)\n    f_decimal = decimal.zfill(len(decimal) + 3 - d_r if d_r else 0)\n\n    d = [int(x) for x in f_decimal]\n    n = [int(x) for x in number]\n\n    while_loop(n, number_list)\n\n    if decimal and int(decimal) != 0:\n        while_loop(d, decimal_list)\n\n        if decimal_list:\n            name = ''\n            if len(decimal) % 3 == 1:\n                name = 'ten'\n            elif len(decimal) % 3 == 2:\n                name = 'hundred'\n\n            place = int((str(len(decimal) / 3).split(\".\")[0]))\n            number_list.append(\"and {0} {1}{2}{3}ths\".format(\n                comma_separated(decimal_list), name,\n                \"-\" if name and _places[place+1] else \"\", _places[place+1]))\n\n    return comma_separated(number_list)"}}, "leetcode/csn_python_train_281413.txt": {"score": 0.9240709543228149, "content": {"text": "def NumbersToWords(number):\n    \"\"\"\n    little function that converts numbers to words. This could be more efficient,\n    and won't work if the number is bigger than 999 but it's for stave names,\n    and I doubt any part would have more than 10 staves let alone 999.\n    \"\"\"\n\n    units = [\n        'one',\n        'two',\n        'three',\n        'four',\n        'five',\n        'six',\n        'seven',\n        'eight',\n        'nine']\n    tens = [\n        'ten',\n        'twenty',\n        'thirty',\n        'forty',\n        'fifty',\n        'sixty',\n        'seventy',\n        'eighty',\n        'ninety']\n    output = \"\"\n    if number != 0:\n        str_val = str(number)\n        if 4 > len(str_val) > 2:\n            output += units[int(str_val[0]) - 1]\n            output += \"hundred\"\n            if str_val[1] != 0:\n                output += \"and\" + tens[int(str_val[1]) - 1]\n                if str_val[2] != 0:\n                    output += units[int(str_val[2]) - 1]\n        if 3 > len(str_val) > 1:\n            output += tens[int(str_val[0]) - 1]\n            if str_val[1] != 0:\n                output += units[int(str_val[1]) - 1]\n        if 2 > len(str_val) == 1:\n            output += units[int(str_val[0]) - 1]\n    else:\n        output = \"zero\"\n    return output"}}, "leetcode/leetcode_273.txt": {"score": 0.9766450524330139, "content": {"text": "class Solution:\n    \"\"\"Convert a non-negative integer `num` to its English words representation.\n\n**Example 1:**\n\n**Input:** num = 123\n**Output:**  \"One Hundred Twenty Three \"\n\n**Example 2:**\n\n**Input:** num = 12345\n**Output:**  \"Twelve Thousand Three Hundred Forty Five \"\n\n**Example 3:**\n\n**Input:** num = 1234567\n**Output:**  \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven \"\n\n**Constraints:**\n\n*   `0 <= num <= 231 - 1`\"\"\"\n\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return LESS_THAN_20[num] + \" \"\n            elif num < 100:\n                return TENS[num // 10] + \" \" + helper(num % 10)\n            else:\n                return LESS_THAN_20[num // 100] + \" Hundred \" + helper(num % 100)\n\n        result = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result\n            num //= 1000\n            i += 1\n        return result.strip()"}}}}, "9": {"gold": {"leetcode/leetcode_275.txt": 1}, "retrieved": {"leetcode/leetcode_2529.txt": {"score": 0.876070499420166, "content": {"text": "def max_positive_negative_count(nums):\n    \"\"\"Given an array `nums` sorted in **non-decreasing** order, return _the maximum between the number of positive integers and the number of negative integers._\n\n*   In other words, if the number of positive integers in `nums` is `pos` and the number of negative integers is `neg`, then return the maximum of `pos` and `neg`.\n\n**Note** that `0` is neither positive nor negative.\n\n**Example 1:**\n\n**Input:** nums = \\[-2,-1,-1,1,2,3\\]\n**Output:** 3\n**Explanation:** There are 3 positive integers and 3 negative integers. The maximum count among them is 3.\n\n**Example 2:**\n\n**Input:** nums = \\[-3,-2,-1,0,0,1,2\\]\n**Output:** 3\n**Explanation:** There are 2 positive integers and 3 negative integers. The maximum count among them is 3.\n\n**Example 3:**\n\n**Input:** nums = \\[5,20,66,1314\\]\n**Output:** 4\n**Explanation:** There are 4 positive integers and 0 negative integers. The maximum count among them is 4.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `-2000 <= nums[i] <= 2000`\n*   `nums` is sorted in a **non-decreasing order**.\n\n**Follow up:** Can you solve the problem in `O(log(n))` time complexity?\"\"\"\n\n    pos = next((i for i, x in enumerate(nums) if x >= 0), len(nums))\n    neg = len(nums) - pos\n    return max(pos, neg)"}}, "leetcode/leetcode_2432.txt": {"score": 0.879840075969696, "content": {"text": "def worker_with_longest_task(n, logs):\n    \"\"\"There are `n` employees, each with a unique id from `0` to `n - 1`.\n\nYou are given a 2D integer array `logs` where `logs[i] = [idi, leaveTimei]` where:\n\n*   `idi` is the id of the employee that worked on the `ith` task, and\n*   `leaveTimei` is the time at which the employee finished the `ith` task. All the values `leaveTimei` are **unique**.\n\nNote that the `ith` task starts the moment right after the `(i - 1)th` task ends, and the `0th` task starts at time `0`.\n\nReturn _the id of the employee that worked the task with the longest time._ If there is a tie between two or more employees, return _the **smallest** id among them_.\n\n**Example 1:**\n\n**Input:** n = 10, logs = \\[\\[0,3\\],\\[2,5\\],\\[0,9\\],\\[1,15\\]\\]\n**Output:** 1\n**Explanation:** \nTask 0 started at 0 and ended at 3 with 3 units of times.\nTask 1 started at 3 and ended at 5 with 2 units of times.\nTask 2 started at 5 and ended at 9 with 4 units of times.\nTask 3 started at 9 and ended at 15 with 6 units of times.\nThe task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n\n**Example 2:**\n\n**Input:** n = 26, logs = \\[\\[1,1\\],\\[3,7\\],\\[2,12\\],\\[7,17\\]\\]\n**Output:** 3\n**Explanation:** \nTask 0 started at 0 and ended at 1 with 1 unit of times.\nTask 1 started at 1 and ended at 7 with 6 units of times.\nTask 2 started at 7 and ended at 12 with 5 units of times.\nTask 3 started at 12 and ended at 17 with 5 units of times.\nThe tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3.\n\n**Example 3:**\n\n**Input:** n = 2, logs = \\[\\[0,10\\],\\[1,20\\]\\]\n**Output:** 0\n**Explanation:** \nTask 0 started at 0 and ended at 10 with 10 units of times.\nTask 1 started at 10 and ended at 20 with 10 units of times.\nThe tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.\n\n**Constraints:**\n\n*   `2 <= n <= 500`\n*   `1 <= logs.length <= 500`\n*   `logs[i].length == 2`\n*   `0 <= idi <= n - 1`\n*   `1 <= leaveTimei <= 500`\n*   `idi != idi+1`\n*   `leaveTimei` are sorted in a strictly increasing order.\"\"\"\n\n    result = 0\n    max_time = logs[0][1] - 0\n\n    for i in range(1, len(logs)):\n        time = logs[i][1] - logs[i-1][1]\n        if time > max_time:\n            max_time = time\n            result = logs[i][0]\n\n    return result"}}, "leetcode/leetcode_1471.txt": {"score": 0.8765931725502014, "content": {"text": "def maxStudents(seats):\n    \"\"\"Given an array of integers `arr` and an integer `k`.\n\nA value `arr[i]` is said to be stronger than a value `arr[j]` if `|arr[i] - m| > |arr[j] - m|` where `m` is the **median** of the array.  \nIf `|arr[i] - m| == |arr[j] - m|`, then `arr[i]` is said to be stronger than `arr[j]` if `arr[i] > arr[j]`.\n\nReturn _a list of the strongest `k`_ values in the array. return the answer **in any arbitrary order**.\n\n**Median** is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position `((n - 1) / 2)` in the sorted list **(0-indexed)**.\n\n*   For `arr = [6, -3, 7, 2, 11]`, `n = 5` and the median is obtained by sorting the array `arr = [-3, 2, 6, 7, 11]` and the median is `arr[m]` where `m = ((5 - 1) / 2) = 2`. The median is `6`.\n*   For `arr = [-7, 22, 17,\u20093]`, `n = 4` and the median is obtained by sorting the array `arr = [-7, 3, 17, 22]` and the median is `arr[m]` where `m = ((4 - 1) / 2) = 1`. The median is `3`.\n\n**Example 1:**\n\n**Input:** arr = \\[1,2,3,4,5\\], k = 2\n**Output:** \\[5,1\\]\n**Explanation:** Median is 3, the elements of the array sorted by the strongest are \\[5,1,4,2,3\\]. The strongest 2 elements are \\[5, 1\\]. \\[1, 5\\] is also **accepted** answer.\nPlease note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.\n\n**Example 2:**\n\n**Input:** arr = \\[1,1,3,5,5\\], k = 2\n**Output:** \\[5,5\\]\n**Explanation:** Median is 3, the elements of the array sorted by the strongest are \\[5,5,1,1,3\\]. The strongest 2 elements are \\[5, 5\\].\n\n**Example 3:**\n\n**Input:** arr = \\[6,7,11,7,6,8\\], k = 5\n**Output:** \\[11,8,6,6,7\\]\n**Explanation:** Median is 7, the elements of the array sorted by the strongest are \\[11,8,6,6,7,7\\].\nAny permutation of \\[11,8,6,6,7\\] is **accepted**.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `-105 <= arr[i] <= 105`\n*   `1 <= k <= arr.length`\"\"\"\n\n    m, n = len(seats), len(seats[0])\n    valid_rows = [0] * m\n    max_valid = (1 << n) - 1\n    for i in range(m):\n        state = 0\n        for j in range(n):\n            state |= (seats[i][j] == '.') << j\n        valid_rows[i] = state\n\n    memo = [[-1] * (1 << n) for _ in range(m)]\n    return dfs(0, 0, valid_rows, m, n, max_valid, memo)\n\ndef dfs(row_index, prev_state, valid_rows, m, n, max_valid, memo):\n    if row_index == m:\n        return 0\n\n    if memo[row_index][prev_state] != -1:\n        return memo[row_index][prev_state]\n\n    max_students = 0\n    for cur_state in range(max_valid + 1):\n        if (cur_state & valid_rows[row_index]) != cur_state:\n            continue\n        if cur_state & (cur_state << 1):\n            continue\n        if cur_state & (prev_state << 1) or prev_state & (cur_state << 1):\n            continue\n\n        max_students = max(max_students, dfs(row_index + 1, cur_state, valid_rows, m, n, max_valid, memo) + bin(cur_state).count('1'))\n\n    memo[row_index][prev_state] = max_students\n    return max_students"}}, "leetcode/leetcode_747.txt": {"score": 0.8800462484359741, "content": {"text": "def minCostClimbingStairs(cost):\n    \"\"\"You are given an integer array `nums` where the largest integer is **unique**.\n\nDetermine whether the largest element in the array is **at least twice** as much as every other number in the array. If it is, return _the **index** of the largest element, or return_ `-1` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,1,0\\]\n**Output:** 1\n**Explanation:** 6 is the largest integer.\nFor every other number in the array x, 6 is at least twice as big as x.\nThe index of value 6 is 1, so we return 1.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** -1\n**Explanation:** 4 is less than twice the value of 3, so we return -1.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 50`\n*   `0 <= nums[i] <= 100`\n*   The largest element in `nums` is unique.\"\"\"\n\n    for i in range(2, len(cost)):\n        cost[i] += min(cost[i-1], cost[i-2])\n    return min(cost[-1], cost[-2])"}}, "leetcode/leetcode_275.txt": {"score": 0.9536523818969727, "content": {"text": "def hIndex(citations: List[int]) -> int:\n    \"\"\"Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper and `citations` is sorted in **ascending order**, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\nYou must write an algorithm that runs in logarithmic time.\n\n**Example 1:**\n\n**Input:** citations = \\[0,1,3,5,6\\]\n**Output:** 3\n**Explanation:** \\[0,1,3,5,6\\] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n**Example 2:**\n\n**Input:** citations = \\[1,2,100\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 105`\n*   `0 <= citations[i] <= 1000`\n*   `citations` is sorted in **ascending order**.\"\"\"\n\n    n = len(citations)\n    left, right = 0, n - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if citations[mid] == n - mid:\n            return n - mid\n        elif citations[mid] < n - mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return n - left"}}, "leetcode/leetcode_2012.txt": {"score": 0.878203809261322, "content": {"text": "from queue import PriorityQueue\n    \"\"\"You are given a **0-indexed** integer array `nums`. For each index `i` (`1 <= i <= nums.length - 2`) the **beauty** of `nums[i]` equals:\n\n*   `2`, if `nums[j] < nums[i] < nums[k]`, for **all** `0 <= j < i` and for **all** `i < k <= nums.length - 1`.\n*   `1`, if `nums[i - 1] < nums[i] < nums[i + 1]`, and the previous condition is not satisfied.\n*   `0`, if none of the previous conditions holds.\n\nReturn _the **sum of beauty** of all_ `nums[i]` _where_ `1 <= i <= nums.length - 2`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** For each index i in the range 1 <= i <= 1:\n- The beauty of nums\\[1\\] equals 2.\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,6,4\\]\n**Output:** 1\n**Explanation:** For each index i in the range 1 <= i <= 2:\n- The beauty of nums\\[1\\] equals 1.\n- The beauty of nums\\[2\\] equals 0.\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 0\n**Explanation:** For each index i in the range 1 <= i <= 1:\n- The beauty of nums\\[1\\] equals 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\"\"\"\n\n\ndef assignTasks(servers, tasks):\n    n, m = len(servers), len(tasks)\n    ans = [0] * m\n    freeServers = PriorityQueue()\n\n    for i in range(n):\n        freeServers.put((servers[i], i))\n\n    busyServers = PriorityQueue()\n    currentTask = 0\n\n    while currentTask < m:\n        while not busyServers.empty() and busyServers.queue[0][0] <= currentTask:\n            _, idx = busyServers.get()\n            freeServers.put((servers[idx], idx))\n\n        while not freeServers.empty() and currentTask < m:\n            _, idx = freeServers.get()\n            ans[currentTask] = idx\n            busyServers.put((currentTask + tasks[currentTask], idx))\n            currentTask += 1\n            \n        if freeServers.empty():\n            currentTask = busyServers.queue[0][0]\n    \n    return ans"}}, "leetcode/leetcode_2454.txt": {"score": 0.8824647665023804, "content": {"text": "def find_second_greater(nums):\n    \"\"\"You are given a **0-indexed** array of non-negative integers `nums`. For each integer in `nums`, you must find its respective **second greater** integer.\n\nThe **second greater** integer of `nums[i]` is `nums[j]` such that:\n\n*   `j > i`\n*   `nums[j] > nums[i]`\n*   There exists **exactly one** index `k` such that `nums[k] > nums[i]` and `i < k < j`.\n\nIf there is no such `nums[j]`, the second greater integer is considered to be `-1`.\n\n*   For example, in the array `[1, 2, 4, 3]`, the second greater integer of `1` is `4`, `2` is `3`, and that of `3` and `4` is `-1`.\n\nReturn _an integer array_ `answer`_, where_ `answer[i]` _is the second greater integer of_ `nums[i]`_._\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,0,9,6\\]\n**Output:** \\[9,6,6,-1,-1\\]\n**Explanation:**\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return \\[9,6,6,-1,-1\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,3\\]\n**Output:** \\[-1,-1\\]\n**Explanation:**\nWe return \\[-1,-1\\] since neither integer has any integer greater than it.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`\"\"\"\n\n    n = len(nums)\n    answer = [-1] * n\n    for i in range(n):\n        k = -1\n        for j in range(i + 1, n):\n            if nums[j] > nums[i]:\n                if k == -1:\n                    k = j\n                else:\n                    answer[i] = nums[j]\n                    break\n    return answer"}}, "leetcode/leetcode_1985.txt": {"score": 0.886506199836731, "content": {"text": "def maxMinProduct(nums):\n    \"\"\"You are given an array of strings `nums` and an integer `k`. Each string in `nums` represents an integer without leading zeros.\n\nReturn _the string that represents the_ `kth` _**largest integer** in_ `nums`.\n\n**Note**: Duplicate numbers should be counted distinctly. For example, if `nums` is `[ \"1 \", \"2 \", \"2 \"]`, `\"2 \"` is the first largest integer, `\"2 \"` is the second-largest integer, and `\"1 \"` is the third-largest integer.\n\n**Example 1:**\n\n**Input:** nums = \\[ \"3 \", \"6 \", \"7 \", \"10 \"\\], k = 4\n**Output:**  \"3 \"\n**Explanation:**\nThe numbers in nums sorted in non-decreasing order are \\[ \"3 \", \"6 \", \"7 \", \"10 \"\\].\nThe 4th largest integer in nums is  \"3 \".\n\n**Example 2:**\n\n**Input:** nums = \\[ \"2 \", \"21 \", \"12 \", \"1 \"\\], k = 3\n**Output:**  \"2 \"\n**Explanation:**\nThe numbers in nums sorted in non-decreasing order are \\[ \"1 \", \"2 \", \"12 \", \"21 \"\\].\nThe 3rd largest integer in nums is  \"2 \".\n\n**Example 3:**\n\n**Input:** nums = \\[ \"0 \", \"0 \"\\], k = 2\n**Output:**  \"0 \"\n**Explanation:**\nThe numbers in nums sorted in non-decreasing order are \\[ \"0 \", \"0 \"\\].\nThe 2nd largest integer in nums is  \"0 \".\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 104`\n*   `1 <= nums[i].length <= 100`\n*   `nums[i]` consists of only digits.\n*   `nums[i]` will not have any leading zeros.\"\"\"\n\n    res, mod = 0, 10**9 + 7\n    n = len(nums)\n    prefix = [0] * (n + 1)\n    stack = []\n\n    for i in range(n):\n        prefix[i + 1] = (prefix[i] + nums[i]) % mod\n\n    for i in range(n + 1):\n        while stack and (i == n or nums[stack[-1]] > nums[i]):\n            j = stack.pop()\n            res = max(res, nums[j] * (prefix[i] - prefix[stack[-1] + 1 if stack else 0]) % mod)\n        stack.append(i)\n\n    return res"}}, "leetcode/leetcode_1608.txt": {"score": 0.907603919506073, "content": {"text": "def specialArray(nums):\n    \"\"\"You are given an array `nums` of non-negative integers. `nums` is considered **special** if there exists a number `x` such that there are **exactly** `x` numbers in `nums` that are **greater than or equal to** `x`.\n\nNotice that `x` **does not** have to be an element in `nums`.\n\nReturn `x` _if the array is **special**, otherwise, return_ `-1`. It can be proven that if `nums` is special, the value for `x` is **unique**.\n\n**Example 1:**\n\n**Input:** nums = \\[3,5\\]\n**Output:** 2\n**Explanation:** There are 2 values (3 and 5) that are greater than or equal to 2.\n\n**Example 2:**\n\n**Input:** nums = \\[0,0\\]\n**Output:** -1\n**Explanation:** No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers >= x, but there are 2.\nIf x = 1, there should be 1 number >= x, but there are 0.\nIf x = 2, there should be 2 numbers >= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums.\n\n**Example 3:**\n\n**Input:** nums = \\[0,4,3,0,4\\]\n**Output:** 3\n**Explanation:** There are 3 values that are greater than or equal to 3.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`\"\"\"\n\n    max_val = max(nums)\n    for x in range(1, max_val + 1):\n        count = sum([1 for num in nums if num >= x])\n        if count == x:\n            return x\n    return -1"}}, "leetcode/leetcode_274.txt": {"score": 0.9952008128166199, "content": {"text": "def hIndex(citations: List[int]) -> int:\n    \"\"\"Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\n**Example 1:**\n\n**Input:** citations = \\[3,0,6,1,5\\]\n**Output:** 3\n**Explanation:** \\[3,0,6,1,5\\] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n**Example 2:**\n\n**Input:** citations = \\[1,3,1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 5000`\n*   `0 <= citations[i] <= 1000`\"\"\"\n\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h"}}}}, "10": {"gold": {"leetcode/leetcode_34.txt": 1, "leetcode/leetcode_35.txt": 1, "leetcode/leetcode_374.txt": 1}, "retrieved": {"leetcode/csn_python_train_281649.txt": {"score": 0.8652488589286804, "content": {"text": "def find_last_true(sorted_list, true_criterion):\n    \"\"\"\n    Suppose we have a list of item [item1, item2, ..., itemN].\n\n    :type array: list\n    :param array: an iterable object that support inex\n\n    :param x: a comparable value\n\n    If we do a mapping::\n\n        >>> def true_criterion(item):\n        ...     return item <= 6\n        >>> [true_criterion(item) for item in sorted_list]\n        [True, True, ... True(last true), False, False, ... False]\n\n    this function returns the index of last true item.\n\n    we do can do the map for all item, and run a binary search to find the \n    index. But sometime the mapping function is expensive. This method avoid\n    run mapping function for all items.\n\n    Example::\n\n        array     = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        index     = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        criterion = def true_criterion(x): return x <= 6\n        boolean   = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0]\n\n    Solution::\n\n        # first, we check index = int((0 + 9)/2.0) = 4, it's True. \n        # Then check array[4 + 1], it's still True. \n        # Then we jump to int((4 + 9)/2.0) = 6, it's True. \n        # Then check array[6 + 1], ite's False. So array[6] is the one we need.\n\n        >>> find_last_true([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], true_criterion)\n        6\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u529f\u80fd: \u5047\u8bbe\u6709\u4e00\u7ec4\u6392\u5e8f\u53f7\u4e86\u7684\u5143\u7d20, \u4ece\u524d\u5f80\u540e\u5047\u8bbe\u524d\u9762\u7684\u5143\u7d20\u90fd\u6ee1\u8db3\u67d0\u4e00\u6761\u4ef6, \u800c\u5230\u4e86\n    \u4e2d\u95f4\u67d0\u5904\u8d77\u5c31\u4e0d\u518d\u6ee1\u8db3\u4e86\u3002\u672c\u51fd\u6570\u8fd4\u56de\u6ee1\u8db3\u8fd9\u4e00\u6761\u4ef6\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u3002\u8fd9\u5728\u5f53\u68c0\u9a8c\u662f\u5426\n    \u6ee1\u8db3\u6761\u4ef6\u672c\u8eab\u5f00\u9500\u8f83\u5927\u65f6, \u80fd\u8282\u7ea6\u5927\u91cf\u7684\u8ba1\u7b97\u65f6\u95f4\u3002\u4f8b\u5982\u4f60\u8981\u5224\u5b9a\u4e00\u7cfb\u5217\u7f51\u9875\u4e2d, \u4ece\n    page1 \u5230 page999, \u4ece\u7b2c\u51e0\u9875\u5f00\u59cb\u51fa\u73b0404\u9519\u8bef\u3002\u5047\u8bbe\u662f\u7b2c400\u4e2a, \u90a3\u4e48\u5982\u679c\u4e00\u4e2a\u4e2a\u5730\n    \u53bb\u8bd5, \u9700\u8981400\u6b21, \u90a3\u5982\u679c\u4ece0 - 999\u4e4b\u95f4\u53bb\u8bd5, \u53ea\u9700\u8981\u8bd5\u9a8c9\u6b21\u5373\u53ef (2 ** 9 = 512)\n\n    \u7b97\u6cd5: \n\n    \u6211\u4eec\u68c0\u9a8c\u6700\u4e2d\u95f4\u7684\u5143\u7d20, \u5982\u679c\u4e3aFalse, \u90a3\u4e48\u5219\u68c0\u9a8c\u5de6\u8fb9\u6240\u6709\u672a\u68c0\u9a8c\u8fc7\u7684\u5143\u7d20\u7684\u6700\u4e2d\u95f4\n    \u7684\u90a3\u4e2a\u3002\u5982\u679c\u4e3aTrue, \u90a3\u4e48\u68c0\u9a8c\u53f3\u8fb9\u6240\u6709\u672a\u68c0\u9a8c\u8fc7\u7684\u5143\u7d20\u7684\u6700\u4e2d\u95f4\u90a3\u4e2a\u3002\u91cd\u590d\u8fd9\u4e00\u8fc7\u7a0b\n    \u76f4\u5230\u88ab\u68c0\u9a8c\u7684\u5143\u7d20\u4e3aTrue, \u800c\u4e0b\u4e00\u4e2a\u5143\u7d20\u4e3aFalse, \u8bf4\u660e\u627e\u5230\u4e86\u3002\n\n    \u4f8b\u9898::\n\n        \u6709\u5e8f\u6570\u7ec4    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        \u5e8f\u53f7        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        \u6761\u4ef6        \u5c0f\u4e8e\u7b49\u4e8e6\n        \u771f\u503c\u8868      [1, 1, 1, 1, 1, 1, 1, 0, 0, 0]\n\n    \u89e3::\n\n        \u7b2c\u4e00\u6b21\u68c0\u67e5``index = int((0+9)/2.0) = 4``, \u4e3aTrue,\n        \u68c0\u67e5array[4+1], \u4e5f\u662fTrue\u3002\u90a3\u4e48\u8df3\u8dc3\u81f3``int((4+9)/2.0)=6``, \u4e3aTrue,\u3002\n        \u518d\u68c0\u67e5array[6+1], \u4e3aFalse, \u5f88\u663e\u7136, \u6211\u4eec\u627e\u5230\u4e86\u3002\n    \"\"\"\n\n    # exam first item, if not true, then impossible to find result\n    if not true_criterion(sorted_list[0]):\n        raise ValueError\n\n    # exam last item, if true, it is the one.\n    if true_criterion(sorted_list[-1]):\n        return sorted_list[-1]\n\n    lower, upper = 0, len(sorted_list) - 1\n\n    index = int((lower + upper) / 2.0)\n    while 1:\n        if true_criterion(sorted_list[index]):\n            if true_criterion(sorted_list[index + 1]):\n                lower = index\n                index = int((index + upper) / 2.0)\n            else:\n                return index\n        else:\n            upper = index\n            index = int((lower + index) / 2.0)"}}, "leetcode/leetcode_34.txt": {"score": 0.8662111759185791, "content": {"text": "def searchRange(nums, target):\n    \"\"\"Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.\n\nIf `target` is not found in the array, return `[-1, -1]`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n\n**Input:** nums = \\[5,7,7,8,8,10\\], target = 8\n**Output:** \\[3,4\\]\n\n**Example 2:**\n\n**Input:** nums = \\[5,7,7,8,8,10\\], target = 6\n**Output:** \\[-1,-1\\]\n\n**Example 3:**\n\n**Input:** nums = \\[\\], target = 0\n**Output:** \\[-1,-1\\]\n\n**Constraints:**\n\n*   `0 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `nums` is a non-decreasing array.\n*   `-109 <= target <= 109`\"\"\"\n\n    start, end = -1, -1\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            if nums[mid] == target:\n                start = mid\n\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] > target:right = mid - 1\n        else:\n            left = mid + 1\n            if nums[mid] == target:\n                end = mid\n    \n    return [start, end]"}}, "leetcode/csn_python_train_321049.txt": {"score": 0.8754515051841736, "content": {"text": "def discrete_binary_search(tab, lo, hi):\n    \"\"\"Binary search in a table\n\n    :param tab: boolean monotone table with tab[hi] = True\n    :param int lo:\n    :param int hi: with hi >= lo\n    :returns: first index i in [lo,hi] such that tab[i]\n    :complexity: `O(log(hi-lo))`\n    \"\"\"\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if tab[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo"}}, "leetcode/leetcode_1884.txt": {"score": 0.8693699836730957, "content": {"text": "def min_operations_to_alternate(s: str) -> int:\n    \"\"\"You are given **two identical** eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nIn each move, you may take an **unbroken** egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** We can drop the first egg from floor 1 and the second egg from floor 2.\nIf the first egg breaks, we know that f = 0.\nIf the second egg breaks but the first egg didn't, we know that f = 1.\nOtherwise, if both eggs survive, we know that f = 2.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 14\n**Explanation:** One optimal strategy is:\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\nRegardless of the outcome, it takes at most 14 drops to determine f.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\"\"\"\n\n    count_a, count_b = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        else:\n            if c == '0':\n                count_b += 1\n            else:\n                count_a += 1\n    return min(count_a, count_b)"}}, "leetcode/leetcode_1095.txt": {"score": 0.8906149864196777, "content": {"text": "def twoCitySchedCost(costs):\n    \"\"\"_(This problem is an **interactive problem**.)_\n\nYou may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some `i` with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven a mountain array `mountainArr`, return the **minimum** `index` such that `mountainArr.get(index) == target`. If such an `index` does not exist, return `-1`.\n\n**You cannot access the mountain array directly.** You may only access the array using a `MountainArray` interface:\n\n*   `MountainArray.get(k)` returns the element of the array at index `k` (0-indexed).\n*   `MountainArray.length()` returns the length of the array.\n\nSubmissions making more than `100` calls to `MountainArray.get` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification.\n\n**Example 1:**\n\n**Input:** array = \\[1,2,3,4,5,3,1\\], target = 3\n**Output:** 2\n**Explanation:** 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.\n\n**Example 2:**\n\n**Input:** array = \\[0,1,2,4,2,1\\], target = 3\n**Output:** -1\n**Explanation:** 3 does not exist in `the array,` so we return -1.\n\n**Constraints:**\n\n*   `3 <= mountain_arr.length() <= 104`\n*   `0 <= target <= 109`\n*   `0 <= mountain_arr.get(index) <= 109`\"\"\"\n\n    costs.sort(key=lambda x: x[0] - x[1])\n\n    totalCost = 0\n    n = len(costs) // 2\n\n    for i in range(n):\n        totalCost += costs[i][0] + costs[i + n][1]\n\n    return totalCost"}}, "leetcode/leetcode_540.txt": {"score": 0.8774333000183105, "content": {"text": "def singleNonDuplicate(nums):\n    \"\"\"You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n\nReturn _the single element that appears only once_.\n\nYour solution must run in `O(log n)` time and `O(1)` space.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,2,3,3,4,4,8,8\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** nums = \\[3,3,7,7,10,11,11\\]\n**Output:** 10\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`\"\"\"\n\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return nums[low]"}}, "leetcode/leetcode_704.txt": {"score": 0.8766685128211975, "content": {"text": "def search(nums: List[int], target: int) -> int:\n    \"\"\"Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 9\n**Output:** 4\n**Explanation:** 9 exists in nums and its index is 4\n\n**Example 2:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 2\n**Output:** -1\n**Explanation:** 2 does not exist in nums so return -1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 < nums[i], target < 104`\n*   All the integers in `nums` are **unique**.\n*   `nums` is sorted in ascending order.\"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1"}}, "leetcode/leetcode_374.txt": {"score": 0.9040389657020569, "content": {"text": "def guessNumber(n):\n    \"\"\"We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.\n\n**Example 1:**\n\n**Input:** n = 10, pick = 6\n**Output:** 6\n\n**Example 2:**\n\n**Input:** n = 1, pick = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** n = 2, pick = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`\n*   `1 <= pick <= n`\"\"\"\n\n    low, high = 1, n\n    while low <= high:\n        mid = low + (high - low) // 2\n        result = guess(mid)\n        if result == 0:\n            return mid\n        elif result < 0:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1"}}, "leetcode/leetcode_887.txt": {"score": 0.8757999539375305, "content": {"text": "import heapq\n    \"\"\"You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nEach move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n**Example 1:**\n\n**Input:** k = 1, n = 2\n**Output:** 2\n**Explanation:** \nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n\n**Example 2:**\n\n**Input:** k = 2, n = 6\n**Output:** 3\n\n**Example 3:**\n\n**Input:** k = 3, n = 14\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= n <= 104`\"\"\"\n\n\ndef mincost_to_hire_workers(quality, wage, k):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float(\"inf\")\n\n    for ratio, q in workers:\n        heapq.heappush(max_heap, -q)\n        total_quality += q\n\n        if len(max_heap) > k:\n            total_quality += heapq.heappop(max_heap)\n\n        if len(max_heap) == k:\n            result = min(result, total_quality * ratio)\n\n    return result"}}, "leetcode/leetcode_278.txt": {"score": 0.9960698485374451, "content": {"text": "def first_bad_version(n):\n    \"\"\"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n\n**Example 1:**\n\n**Input:** n = 5, bad = 4\n**Output:** 4\n**Explanation:**\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n\n**Example 2:**\n\n**Input:** n = 1, bad = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= bad <= n <= 231 - 1`\"\"\"\n\n    left, right = 1, n\n    while left < right:\n        mid = left + (right - left) // 2\n        if is_bad_version(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left"}}}}, "11": {"gold": {"leetcode/leetcode_73.txt": 1}, "retrieved": {"leetcode/csn_python_train_132121.txt": {"score": 0.9378824234008789, "content": {"text": "def turn(self):\n        \"\"\"Turn\"\"\"\n        r = (4, 5, 5, 5)\n        nt = copy.deepcopy(self.table)\n        for z in range(self.depth):\n            for y in range(self.height):\n                for x in range(self.width):\n                    neighbours = self.liveNeighbours(z, y, x)\n                    if self.table[z][y][x] == 0 and (neighbours > r[0] and neighbours <= r[1]):\n                        nt[z][y][x] = 1\n                    elif self.table[z][y][x] == 1 and (neighbours > r[2] and neighbours < r[3]):\n                        nt[z][y][x] = 0\n\n        self._oldStates.append(self.table)\n        if len(self._oldStates) > 3:\n            self._oldStates.popleft()\n\n        self.table = nt"}}, "leetcode/csn_python_train_132132.txt": {"score": 0.9384979009628296, "content": {"text": "def liveNeighbours(self, y, x):\n        \"\"\"Returns the number of live neighbours.\"\"\"\n        count = 0\n        if y > 0:\n            if self.table[y - 1][x]:\n                count = count + 1\n            if x > 0:\n                if self.table[y - 1][x - 1]:\n                    count = count + 1\n            if self.width > (x + 1):\n                if self.table[y - 1][x + 1]:\n                    count = count + 1\n\n        if x > 0:\n            if self.table[y][x - 1]:\n                count = count + 1\n        if self.width > (x + 1):\n            if self.table[y][x + 1]:\n                count = count + 1\n\n        if self.height > (y + 1):\n            if self.table[y + 1][x]:\n                count = count + 1\n            if x > 0:\n                if self.table[y + 1][x - 1]:\n                    count = count + 1\n            if self.width > (x + 1):\n                if self.table[y + 1][x + 1]:\n                    count = count + 1\n\n        if self.toroidal:\n            if y == 0:\n                if self.table[self.height - 1][x]:\n                    count = count + 1\n            if y == self.height - 1:\n                if self.table[0][x]:\n                    count = count + 1\n            if x == 0:\n                if self.table[y][self.width - 1]:\n                    count = count + 1\n            if x == self.width - 1:\n                if self.table[y][0]:\n                    count = count + 1\n\n        return count"}}, "leetcode/csn_python_train_73448.txt": {"score": 0.9490496516227722, "content": {"text": "def next_board(board, wrap):\n    \"\"\"Given a board, return the board one interation later.\n\n    Adapted from Jack Diedrich's implementation from his 2012 PyCon talk \"Stop\n    Writing Classes\"\n\n    :arg wrap: A callable which takes a point and transforms it, for example\n        to wrap to the other edge of the screen. Return None to remove a point.\n\n    \"\"\"\n    new_board = {}\n\n    # We need consider only the points that are alive and their neighbors:\n    points_to_recalc = set(board.iterkeys()) | set(chain(*map(neighbors, board)))\n\n    for point in points_to_recalc:\n        count = sum((neigh in board) for neigh in\n                    (wrap(n) for n in neighbors(point) if n))\n        if count == 3:\n            state = 0 if point in board else 1\n        elif count == 2 and point in board:\n            state = 2\n        else:\n            state = None\n\n        if state is not None:\n            wrapped = wrap(point)\n            if wrapped:\n                new_board[wrapped] = state\n\n    return new_board"}}, "leetcode/csn_python_train_17938.txt": {"score": 0.9483467936515808, "content": {"text": "def live_neighbours(self, i, j):\n        \"\"\" Count the number of live neighbours around point (i, j). \"\"\"\n        s = 0  # The total number of live neighbours.\n        # Loop over all the neighbours.\n        for x in [i - 1, i, i + 1]:\n            for y in [j - 1, j, j + 1]:\n                if (x == i and y == j):\n                    continue  # Skip the current point itself - we only want to count the neighbours!\n                if (x != self.N and y != self.N):\n                    s += self.old_grid[x][y]\n                # The remaining branches handle the case where the neighbour is off the end of the grid.\n                # In this case, we loop back round such that the grid becomes a \"toroidal array\".\n                elif (x == self.N and y != self.N):\n                    s += self.old_grid[0][y]\n                elif (x != self.N and y == self.N):\n                    s += self.old_grid[x][0]\n                else:\n                    s += self.old_grid[0][0]\n        return s"}}, "leetcode/csn_python_train_278071.txt": {"score": 0.9595193266868591, "content": {"text": "def nextGen(self):\n        \"\"\"\n        Decide the fate of the cells\n        \"\"\"\n        self.current_gen += 1\n        self.change_gen[self.current_gen % 3] = copy.copy(self.grid)\n        grid_cp = copy.copy(self.grid)\n\n        for cell in self.grid:\n            y, x = cell\n            y1 = (y - 1) % self.y_grid\n            y2 = (y + 1) % self.y_grid\n            x1 = (x - 1) % self.x_grid\n            x2 = (x + 1) % self.x_grid\n            n = self.countNeighbours(cell)\n\n            if n < 2 or n > 3:\n                del grid_cp[cell]\n                self.addchar(y + self.y_pad, x + self.x_pad, ' ')\n            else:\n                grid_cp[cell] = min(self.grid[cell] + 1, self.color_max)\n\n            for neighbour in product([y1, y, y2], [x1, x, x2]):\n                if not self.grid.get(neighbour):\n                    if self.countNeighbours(neighbour) == 3:\n                        y, x = neighbour\n                        y = y % self.y_grid\n                        x = x % self.x_grid\n                        neighbour = y, x\n                        grid_cp[neighbour] = 1\n\n        self.grid = grid_cp"}}, "leetcode/csn_python_train_274016.txt": {"score": 0.9639114141464233, "content": {"text": "def update_gol(self):\n        \"\"\"\n        Function that performs one step of the Game of Life\n        \"\"\"\n        \n        updated_grid = [[self.update_cell(row, col) \\\n                            for col in range(self.get_grid_width())] \\\n                            for row in range(self.get_grid_height())]\n        \n        self.replace_grid(updated_grid)"}}, "leetcode/csn_python_train_274017.txt": {"score": 0.9598466753959656, "content": {"text": "def update_cell(self, row, col):\n        \"\"\"\n        Function that computes the update for one cell in the Game of Life\n        \"\"\"\n        # compute number of living neighbors\n        neighbors = self.eight_neighbors(row, col)\n        living_neighbors = 0\n        for neighbor in neighbors:\n            if not self.is_empty(neighbor[0], neighbor[1]):\n                living_neighbors += 1\n            \n        # logic for Game of life        \n        if (living_neighbors == 3) or (living_neighbors == 2 and not self.is_empty(row, col)):\n            return mod_grid.FULL\n        else:\n            return mod_grid.EMPTY"}}, "leetcode/leetcode_289.txt": {"score": 0.998273491859436, "content": {"text": "def gameOfLife(board):\n    \"\"\"According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): \"The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. \"\n\nThe board is made up of an `m x n` grid of cells, where each cell has an initial state: **live** (represented by a `1`) or **dead** (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2.  Any live cell with two or three live neighbors lives on to the next generation.\n3.  Any live cell with more than three live neighbors dies, as if by over-population.\n4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_.\n\n**Example 1:**\n\n**Input:** board = \\[\\[0,1,0\\],\\[0,0,1\\],\\[1,1,1\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[1,0,1\\],\\[0,1,1\\],\\[0,1,0\\]\\]\n\n**Example 2:**\n\n**Input:** board = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** \\[\\[1,1\\],\\[1,1\\]\\]\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 25`\n*   `board[i][j]` is `0` or `1`.\n\n**Follow up:**\n\n*   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\n*   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?\"\"\"\n\n    m, n = len(board), len(board[0])\n    result = [[0] * n for _ in range(m)]\n    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n    for i in range(m):\n        for j in range(n):\n            liveNeighbors = 0\n            \n            for dir in dirs:\n                newRow = i + dir[0]\n                newCol = j + dir[1]\n                \n                if newRow >= 0 and newRow < m and newCol >= 0 and newCol < n and board[newRow][newCol] == 1:\n                    liveNeighbors += 1\n            \n            if board[i][j] == 1 and (liveNeighbors == 2 or liveNeighbors == 3):\n                result[i][j] = 1\n            elif board[i][j] == 0 and liveNeighbors == 3:\n                result[i][j] = 1\n                \n    return result"}}, "leetcode/csn_python_train_17939.txt": {"score": 0.9676666259765625, "content": {"text": "def play(self):\n        \"\"\" Play Conway's Game of Life. \"\"\"\n\n        # Write the initial configuration to file.\n\n        self.t = 1  # Current time level\n        while self.t <= self.T:  # Evolve!\n            # print( \"At time level %d\" % t)\n\n            # Loop over each cell of the grid and apply Conway's rules.\n            for i in range(self.N):\n                for j in range(self.N):\n                    live = self.live_neighbours(i, j)\n                    if (self.old_grid[i][j] == 1 and live < 2):\n                        self.new_grid[i][j] = 0  # Dead from starvation.\n                    elif (self.old_grid[i][j] == 1 and (live == 2 or live == 3)):\n                        self.new_grid[i][j] = 1  # Continue living.\n                    elif (self.old_grid[i][j] == 1 and live > 3):\n                        self.new_grid[i][j] = 0  # Dead from overcrowding.\n                    elif (self.old_grid[i][j] == 0 and live == 3):\n                        self.new_grid[i][j] = 1  # Alive from reproduction.\n\n            # Output the new configuration.\n\n            # The new configuration becomes the old configuration for the next generation.\n            self.old_grid = self.new_grid.copy()\n            self.draw_board()\n            # Move on to the next time level\n            self.t += 1"}}, "leetcode/csn_python_train_72821.txt": {"score": 0.9704005718231201, "content": {"text": "def update_state(world):\n    \"\"\"\n    Increment the world state, determining which cells live, die, or appear.\n\n    Args:\n        world (list[list]): A square matrix of cells\n\n    Returns: None\n    \"\"\"\n\n    world_size = len(world)\n\n    def wrap(index):\n        \"\"\"Wrap an index around the other end of the array\"\"\"\n        return index % world_size\n\n    for x in range(world_size):\n        for y in range(world_size):\n            # Decide if this node cares about the rules right now\n            if not world[x][y].allow_change.get():\n                continue\n            live_neighbor_count = sum([\n                world[wrap(x)][wrap(y + 1)].value,\n                world[wrap(x + 1)][wrap(y + 1)].value,\n                world[wrap(x + 1)][wrap(y)].value,\n                world[wrap(x + 1)][wrap(y - 1)].value,\n                world[wrap(x)][wrap(y-1)].value,\n                world[wrap(x - 1)][wrap(y - 1)].value,\n                world[wrap(x - 1)][wrap(y)].value,\n                world[wrap(x - 1)][wrap(y + 1)].value\n            ])\n            if world[x][y].value:\n                # Any live cell with fewer than two live neighbours dies\n                # Any live cell with more than three live neighbours dies\n                # Any live cell with two or three live neighbours lives\n                if not (live_neighbor_count == 2 or live_neighbor_count == 3):\n                    world[x][y].value = False\n            else:\n                # Any dead cell with exactly three live neighbours comes alive\n                if live_neighbor_count == 3:\n                    world[x][y].value = True"}}}}, "12": {"gold": {"leetcode/leetcode_2531.txt": 1}, "retrieved": {"leetcode/leetcode_2315.txt": {"score": 0.8388428092002869, "content": {"text": "def count_stars_except_between_pair(s: str) -> int:\n    \"\"\"You are given a string `s`, where every **two** consecutive vertical bars `'|'` are grouped into a **pair**. In other words, the 1st and 2nd `'|'` make a pair, the 3rd and 4th `'|'` make a pair, and so forth.\n\nReturn _the number of_ `'*'` _in_ `s`_, **excluding** the_ `'*'` _between each pair of_ `'|'`.\n\n**Note** that each `'|'` will belong to **exactly** one pair.\n\n**Example 1:**\n\n**Input:** s =  \"l|\\*e\\*et|c\\*\\*o|\\*de| \"\n**Output:** 2\n**Explanation:** The considered characters are underlined:  \"l|\\*e\\*et|c\\*\\*o|\\*de| \".\nThe characters between the first and second '|' are excluded from the answer.\nAlso, the characters between the third and fourth '|' are excluded from the answer.\nThere are 2 asterisks considered. Therefore, we return 2.\n\n**Example 2:**\n\n**Input:** s =  \"iamprogrammer \"\n**Output:** 0\n**Explanation:** In this example, there are no asterisks in s. Therefore, we return 0.\n\n**Example 3:**\n\n**Input:** s =  \"yo|uar|e\\*\\*|b|e\\*\\*\\*au|tifu|l \"\n**Output:** 5\n**Explanation:** The considered characters are underlined:  \"yo|uar|e\\*\\*|b|e\\*\\*\\*au|tifu|l \". There are 5 asterisks considered. Therefore, we return 5.\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase English letters, vertical bars `'|'`, and asterisks `'*'`.\n*   `s` contains an **even** number of vertical bars `'|'`.\"\"\"\n\n    count = 0\n    pipe_count = 0\n\n    for c in s:\n        if c == '|':\n            pipe_count += 1\n        elif c == '*' and pipe_count % 2 == 0:\n            count += 1\n\n    return count"}}, "leetcode/leetcode_890.txt": {"score": 0.8391673564910889, "content": {"text": "def lemonadeChange(bills):\n    \"\"\"Given a list of strings `words` and a string `pattern`, return _a list of_ `words[i]` _that match_ `pattern`. You may return the answer in **any order**.\n\nA word matches the pattern if there exists a permutation of letters `p` so that after replacing every letter `x` in the pattern with `p(x)`, we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.\n\n**Example 1:**\n\n**Input:** words = \\[ \"abc \", \"deq \", \"mee \", \"aqq \", \"dkd \", \"ccc \"\\], pattern =  \"abb \"\n**Output:** \\[ \"mee \", \"aqq \"\\]\n**Explanation:**  \"mee \" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n \"ccc \" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.\n\n**Example 2:**\n\n**Input:** words = \\[ \"a \", \"b \", \"c \"\\], pattern =  \"a \"\n**Output:** \\[ \"a \", \"b \", \"c \"\\]\n\n**Constraints:**\n\n*   `1 <= pattern.length <= 20`\n*   `1 <= words.length <= 50`\n*   `words[i].length == pattern.length`\n*   `pattern` and `words[i]` are lowercase English letters.\"\"\"\n\n    five, ten = 0, 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if not five:\n                return False\n            five -= 1\n            ten += 1\n        else:\n            if ten and five:\n                ten -= 1\n                five -= 1\n            elif five >= 3:\n                five -= 3\n            else:\n                return False\n    return True"}}, "leetcode/leetcode_1662.txt": {"score": 0.8394283652305603, "content": {"text": "def min_num_operations(nums):\n    \"\"\"Given two string arrays `word1` and `word2`, return `true` _if the two arrays **represent** the same string, and_ `false` _otherwise._\n\nA string is **represented** by an array if the array elements concatenated **in order** forms the string.\n\n**Example 1:**\n\n**Input:** word1 = \\[ \"ab \",  \"c \"\\], word2 = \\[ \"a \",  \"bc \"\\]\n**Output:** true\n**Explanation:**\nword1 represents string  \"ab \" +  \"c \" ->  \"abc \"\nword2 represents string  \"a \" +  \"bc \" ->  \"abc \"\nThe strings are the same, so return true.\n\n**Example 2:**\n\n**Input:** word1 = \\[ \"a \",  \"cb \"\\], word2 = \\[ \"ab \",  \"c \"\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** word1  = \\[ \"abc \",  \"d \",  \"defg \"\\], word2 = \\[ \"abcddefg \"\\]\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 103`\n*   `1 <= word1[i].length, word2[i].length <= 103`\n*   `1 <= sum(word1[i].length), sum(word2[i].length) <= 103`\n*   `word1[i]` and `word2[i]` consist of lowercase letters.\"\"\"\n\n    result = 0\n    highest_bit = [0] * 32\n    for num in nums:\n        for j in range(32):\n            if num & (1 << j):\n                highest_bit[j] += 1\n    for count in highest_bit:\n        result = max(result, count)\n    return result + 31"}}, "leetcode/csn_python_train_385420.txt": {"score": 0.8522507548332214, "content": {"text": "def differences(scansion: str, candidate: str) -> List[int]:\n    \"\"\"\n    Given two strings, return a list of index positions where the contents differ.\n\n    :param scansion:\n    :param candidate:\n    :return:\n\n    >>> differences(\"abc\", \"abz\")\n    [2]\n    \"\"\"\n    before = scansion.replace(\" \", \"\")\n    after = candidate.replace(\" \", \"\")\n    diffs = []\n    for idx, tmp in enumerate(before):\n        if before[idx] != after[idx]:\n            diffs.append(idx)\n    return diffs"}}, "leetcode/leetcode_2278.txt": {"score": 0.843953013420105, "content": {"text": "def three_consecutive_integers(num):\n    \"\"\"Given a string `s` and a character `letter`, return _the **percentage** of characters in_ `s` _that equal_ `letter` _**rounded down** to the nearest whole percent._\n\n**Example 1:**\n\n**Input:** s =  \"foobar \", letter =  \"o \"\n**Output:** 33\n**Explanation:**\nThe percentage of characters in s that equal the letter 'o' is 2 / 6 \\* 100% = 33% when rounded down, so we return 33.\n\n**Example 2:**\n\n**Input:** s =  \"jjjj \", letter =  \"k \"\n**Output:** 0\n**Explanation:**\nThe percentage of characters in s that equal the letter 'k' is 0%, so we return 0.\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters.\n*   `letter` is a lowercase English letter.\"\"\"\n\n    if num % 3 == 0:\n        return [num // 3 - 1, num // 3, num // 3 + 1]\n    elif num % 3 == 1:\n        return [(num - 2) // 3, (num + 1) // 3, (num + 4) // 3]\n    else:\n        return []"}}, "leetcode/leetcode_1178.txt": {"score": 0.8420683145523071, "content": {"text": "def find_num_of_valid_words(words, puzzles):\n    \"\"\"With respect to a given `puzzle` string, a `word` is _valid_ if both the following conditions are satisfied:\n\n*   `word` contains the first letter of `puzzle`.\n*   For each letter in `word`, that letter is in `puzzle`.\n    *   For example, if the puzzle is `\"abcdefg \"`, then valid words are `\"faced \"`, `\"cabbage \"`, and `\"baggage \"`, while\n    *   invalid words are `\"beefed \"` (does not include `'a'`) and `\"based \"` (includes `'s'` which is not in the puzzle).\n\nReturn _an array_ `answer`_, where_ `answer[i]` _is the number of words in the given word list_ `words` _that is valid with respect to the puzzle_ `puzzles[i]`.\n\n**Example 1:**\n\n**Input:** words = \\[ \"aaaa \", \"asas \", \"able \", \"ability \", \"actt \", \"actor \", \"access \"\\], puzzles = \\[ \"aboveyz \", \"abrodyz \", \"abslute \", \"absoryz \", \"actresz \", \"gaswxyz \"\\]\n**Output:** \\[1,1,3,2,4,0\\]\n**Explanation:** \n1 valid word for  \"aboveyz \" :  \"aaaa \" \n1 valid word for  \"abrodyz \" :  \"aaaa \"\n3 valid words for  \"abslute \" :  \"aaaa \",  \"asas \",  \"able \"\n2 valid words for  \"absoryz \" :  \"aaaa \",  \"asas \"\n4 valid words for  \"actresz \" :  \"aaaa \",  \"asas \",  \"actt \",  \"access \"\nThere are no valid words for  \"gaswxyz \" cause none of the words in the list contains letter 'g'.\n\n**Example 2:**\n\n**Input:** words = \\[ \"apple \", \"pleas \", \"please \"\\], puzzles = \\[ \"aelwxyz \", \"aelpxyz \", \"aelpsxy \", \"saelpxy \", \"xaelpsy \"\\]\n**Output:** \\[0,1,3,2,0\\]\n\n**Constraints:**\n\n*   `1 <= words.length <= 105`\n*   `4 <= words[i].length <= 50`\n*   `1 <= puzzles.length <= 104`\n*   `puzzles[i].length == 7`\n*   `words[i]` and `puzzles[i]` consist of lowercase English letters.\n*   Each `puzzles[i]` does not contain repeated characters.\"\"\"\n\n    result = []\n    for puzzle in puzzles:\n        count = 0\n        puzzle_set = set(puzzle)\n        for word in words:\n            if puzzle[0] in word:\n                if all(c in puzzle_set for c in word):\n                    count += 1\n        result.append(count)\n    return result"}}, "leetcode/leetcode_961.txt": {"score": 0.8416317105293274, "content": {"text": "def isLongPressedName(name: str, typed: str) -> bool:\n    \"\"\"You are given an integer array `nums` with the following properties:\n\n*   `nums.length == 2 * n`.\n*   `nums` contains `n + 1` **unique** elements.\n*   Exactly one element of `nums` is repeated `n` times.\n\nReturn _the element that is repeated_ `n` _times_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,3\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** nums = \\[2,1,2,5,3,2\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** nums = \\[5,1,5,2,5,3,5,4\\]\n**Output:** 5\n\n**Constraints:**\n\n*   `2 <= n <= 5000`\n*   `nums.length == 2 * n`\n*   `0 <= nums[i] <= 104`\n*   `nums` contains `n + 1` **unique** elements and one of them is repeated exactly `n` times.\"\"\"\n\n    i, j = 0, 0\n    while j < len(typed):\n        if i < len(name) and name[i] == typed[j]:\n            i += 1\n        elif j == 0 or typed[j] != typed[j - 1]:\n            return False\n        j += 1\n    return i == len(name)"}}, "leetcode/leetcode_299.txt": {"score": 0.9900079965591431, "content": {"text": "def get_hint(secret: str, guess: str) -> str:\n    \"\"\"You are playing the **[Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.\n\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\n*   The number of \"bulls \", which are digits in the guess that are in the correct position.\n*   The number of \"cows \", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\n\nGiven the secret number `secret` and your friend's guess `guess`, return _the hint for your friend's guess_.\n\nThe hint should be formatted as `\"xAyB \"`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits.\n\n**Example 1:**\n\n**Input:** secret =  \"1807 \", guess =  \"7810 \"\n**Output:**  \"1A3B \"\n**Explanation:** Bulls are connected with a '|' and cows are underlined:\n \"1807 \"\n  |\n \"7810 \"\n\n**Example 2:**\n\n**Input:** secret =  \"1123 \", guess =  \"0111 \"\n**Output:**  \"1A1B \"\n**Explanation:** Bulls are connected with a '|' and cows are underlined:\n \"1123 \"         \"1123 \"\n  |      or     |\n \"0111 \"         \"0111 \"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n\n**Constraints:**\n\n*   `1 <= secret.length, guess.length <= 1000`\n*   `secret.length == guess.length`\n*   `secret` and `guess` consist of digits only.\"\"\"\n\n    bulls = cows = 0\n    secret_count = [0] * 10\n    guess_count = [0] * 10\n\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            bulls += 1\n        else:\n            secret_count[int(secret[i])] += 1\n            guess_count[int(guess[i])] += 1\n   \n    for i in range(10):\n        cows += min(secret_count[i], guess_count[i])\n    \n    return f\"{bulls}A{cows}B\""}}, "leetcode/csn_python_train_70564.txt": {"score": 0.8746386170387268, "content": {"text": "def compare(self, other):\n        \"\"\"Compare the DigitWord with another DigitWord (other) and provided iterated analysis of the\n        matches (none or loose) and the occurrence (one or more) of each DigitEntry in both\n        DigitWords. The method returns a list of Comparison objects.\"\"\"\n\n        self._validate_compare_parameters(other=other)\n\n        return_list = []\n        for idx, digit in enumerate(other):\n            dwa = DigitWordAnalysis(\n                index=idx,\n                digit=digit,\n                match=(digit == self._word[idx]),\n                in_word=(self._word.count(digit) > 0),\n                multiple=(self._word.count(digit) > 1)\n            )\n            return_list.append(dwa)\n\n        return return_list"}}, "leetcode/leetcode_1704.txt": {"score": 0.8516647815704346, "content": {"text": "def numSpecial(mat):\n    \"\"\"You are given a string `s` of even length. Split this string into two halves of equal lengths, and let `a` be the first half and `b` be the second half.\n\nTwo strings are **alike** if they have the same number of vowels (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`, `'A'`, `'E'`, `'I'`, `'O'`, `'U'`). Notice that `s` contains uppercase and lowercase letters.\n\nReturn `true` _if_ `a` _and_ `b` _are **alike**_. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** s =  \"book \"\n**Output:** true\n**Explanation:** a =  \"bo \" and b =  \"ok \". a has 1 vowel and b has 1 vowel. Therefore, they are alike.\n\n**Example 2:**\n\n**Input:** s =  \"textbook \"\n**Output:** false\n**Explanation:** a =  \"text \" and b =  \"book \". a has 1 vowel whereas b has 2. Therefore, they are not alike.\nNotice that the vowel o is counted twice.\n\n**Constraints:**\n\n*   `2 <= s.length <= 1000`\n*   `s.length` is even.\n*   `s` consists of **uppercase and lowercase** letters.\"\"\"\n\n    m, n = len(mat), len(mat[0])\n    row, col = [0] * m, [0] * n\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                row[i] += 1\n                col[j] += 1\n\n    special_positions = 0\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1 and row[i] == 1 and col[j] == 1:\n                special_positions += 1\n\n    return special_positions"}}}}, "13": {"gold": {"leetcode/leetcode_207.txt": 1, "leetcode/leetcode_210.txt": 1, "leetcode/leetcode_2603.txt": 1}, "retrieved": {"leetcode/leetcode_2440.txt": {"score": 0.9098984003067017, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an undirected tree with `n` nodes labeled from `0` to `n - 1`.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nYou are allowed to **delete** some edges, splitting the tree into multiple connected components. Let the **value** of a component be the sum of **all** `nums[i]` for which node `i` is in the component.\n\nReturn _the **maximum** number of edges you can delete, such that every connected component in the tree has the same value._\n\n**Example 1:**\n\n**Input:** nums = \\[6,2,2,2,6\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\] \n**Output:** 2 \n**Explanation:** The above figure shows how we can delete the edges \\[0,1\\] and \\[3,4\\]. The created components are nodes \\[0\\], \\[1,2,3\\] and \\[4\\]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n\n**Example 2:**\n\n**Input:** nums = \\[2\\], edges = \\[\\]\n**Output:** 0\n**Explanation:** There are no edges to be deleted.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `nums.length == n`\n*   `1 <= nums[i] <= 50`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= edges[i][0], edges[i][1] <= n - 1`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef dfs(node, parent, nums, graph, total, result):\n    total_sum = nums[node]\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            total_sum += dfs(neighbor, node, nums, graph, total, result)\n    if total_sum == total // 2:\n        result.append(1)\n        return 0\n    return total_sum\n\ndef delete_edges_to_balance_tree(nums, edges):\n    n = len(nums)\n    graph = defaultdict(list)\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n\n    total = sum(nums)\n    if total % 2 != 0:\n        return 0  # It is impossible to split the tree fairly.\n\n    result = []\n    dfs(0, -1, nums, graph, total, result)\n    return len(result) - 1"}}, "leetcode/leetcode_1617.txt": {"score": 0.9099135398864746, "content": {"text": "def winnerSquareGame(n: int) -> bool:\n    \"\"\"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.\"\"\"\n\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]"}}, "leetcode/leetcode_2603.txt": {"score": 0.9203423857688904, "content": {"text": "from collections import defaultdict\n    \"\"\"There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef min_edges_to_collect_coins(coins, edges):\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(adj, coins, 0, -1)[1] // 2\n\ndef dfs(adj, coins, node, parent):\n    sum_coins = coins[node]\n    distance = 0\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            result = dfs(adj, coins, neighbor, node)\n            sum_coins += result[0]\n            distance += 2 * result[0] + result[1]\n    return (sum_coins, distance)"}}, "leetcode/leetcode_2538.txt": {"score": 0.9169729948043823, "content": {"text": "from typing import List\n    \"\"\"There exists an undirected and initially unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given the integer `n` and a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nEach node has an associated price. You are given an integer array `price`, where `price[i]` is the price of the `ith` node.\n\nThe **price sum** of a given path is the sum of the prices of all nodes lying on that path.\n\nThe tree can be rooted at any node `root` of your choice. The incurred **cost** after choosing `root` is the difference between the maximum and minimum **price sum** amongst all paths starting at `root`.\n\nReturn _the **maximum** possible **cost**_ _amongst all possible root choices_.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\],\\[3,5\\]\\], price = \\[9,8,7,6,10,5\\]\n**Output:** 24\n**Explanation:** The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes \\[2,1,3,4\\]: the prices are \\[7,8,6,10\\], and the sum of the prices is 31.\n- The second path contains the node \\[2\\] with the price \\[7\\].\nThe difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\]\\], price = \\[1,1,1\\]\n**Output:** 2\n**Explanation:** The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes \\[0,1,2\\]: the prices are \\[1,1,1\\], and the sum of the prices is 3.\n- The second path contains node \\[0\\] with a price \\[1\\].\nThe difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi <= n - 1`\n*   `edges` represents a valid tree.\n*   `price.length == n`\n*   `1 <= price[i] <= 105`\"\"\"\n\n\ndef dfs(u, p, adj, price, dp):\n    dp[u] = [[price[u], 0], [price[u], 0]]\n\n    for v in adj[u]:\n        if v == p:\n            continue\n        dfs(v, u, adj, price, dp)\n        tmpF = sorted([dp[v][0][0] + price[u] - dp[v][1][0], dp[v][0][1]])\n        tmpS = sorted([dp[v][1][0] + price[u] - dp[v][0][0], dp[v][1][1]])\n\n        dp[u][0] = tmpF\n        dp[u][1] = tmpS\n\ndef getMaxCost(n: int, edges: List[List[int]], price: List[int]) -> int:\n    adj = [[] for _ in range(n)]\n    dp = [None] * n\n\n    for e in edges:\n        adj[e[0]].append(e[1])\n        adj[e[1]].append(e[0])\n\n    dfs(0, -1, adj, price, dp)\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, dp[i][0][1] - dp[i][1][1])\n\n    return ans"}}, "leetcode/leetcode_834.txt": {"score": 0.9300624132156372, "content": {"text": "def ambiguousCoordinates(s):\n    \"\"\"There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[8,12,6,10,10,10\\]\n**Explanation:** The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on.\n\n**Example 2:**\n\n**Input:** n = 1, edges = \\[\\]\n**Output:** \\[0\\]\n\n**Example 3:**\n\n**Input:** n = 2, edges = \\[\\[1,0\\]\\]\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 3 * 104`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   The given input represents a valid tree.\"\"\"\n\n    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n    \n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n        \n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n    \n    return res"}}, "leetcode/leetcode_2477.txt": {"score": 0.9390043616294861, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of `n` cities numbered from `0` to `n - 1` and exactly `n - 1` roads. The capital city is city `0`. You are given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a **bidirectional road** connecting cities `ai` and `bi`.\n\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\n\nThere is a car in each city. You are given an integer `seats` that indicates the number of seats in each car.\n\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\n\nReturn _the minimum number of liters of fuel to reach the capital city_.\n\n**Example 1:**\n\n**Input:** roads = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\]\\], seats = 5\n**Output:** 3\n**Explanation:** \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\n**Example 2:**\n\n**Input:** roads = \\[\\[3,1\\],\\[3,2\\],\\[1,0\\],\\[0,4\\],\\[0,5\\],\\[4,6\\]\\], seats = 2\n**Output:** 7\n**Explanation:** \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\n**Example 3:**\n\n**Input:** roads = \\[\\], seats = 1\n**Output:** 0\n**Explanation:** No representatives need to travel to the capital city.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `roads.length == n - 1`\n*   `roads[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `roads` represents a valid tree.\n*   `1 <= seats <= 105`\"\"\"\n\n\n\ndef min_fuel(roads, seats):\n    n = len(roads) + 1\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n\n    distance = [-1] * n\n    q = deque([0])\n    distance[0] = 0\n\n    while q:\n        city = q.popleft()\n        for neighbor in graph[city]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[city] + 1\n                q.append(neighbor)\n\n    total_fuel = 0\n    for city in range(1, n):\n        total_fuel += (distance[city] - 1) // (seats - 1) + 1\n    return total_fuel"}}, "leetcode/leetcode_1466.txt": {"score": 0.9226191639900208, "content": {"text": "def maxJumps(arr, d):\n    \"\"\"There are `n` cities numbered from `0` to `n - 1` and `n - 1` roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n\nRoads are represented by `connections` where `connections[i] = [ai, bi]` represents a road from city `ai` to city `bi`.\n\nThis year, there will be a big event in the capital (city `0`), and many people want to travel to this city.\n\nYour task consists of reorienting some roads such that each city can visit the city `0`. Return the **minimum** number of edges changed.\n\nIt's **guaranteed** that each city can reach city `0` after reorder.\n\n**Example 1:**\n\n**Input:** n = 6, connections = \\[\\[0,1\\],\\[1,3\\],\\[2,3\\],\\[4,0\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\n**Example 2:**\n\n**Input:** n = 5, connections = \\[\\[1,0\\],\\[1,2\\],\\[3,2\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\n**Example 3:**\n\n**Input:** n = 3, connections = \\[\\[1,0\\],\\[2,0\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `2 <= n <= 5 * 104`\n*   `connections.length == n - 1`\n*   `connections[i].length == 2`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\"\"\"\n\n    n = len(arr)\n    dp = [1] * n\n\n    def helper(idx):\n        if dp[idx] > 1:\n            return dp[idx]\n        maximum = 1\n        for i in range(1, d + 1):\n            if idx + i < n and arr[idx] <= arr[idx + i]:\n                break\n            if idx + i < n:\n                maximum = max(maximum, 1 + helper(idx + i))\n\n            if idx - i >= 0 and arr[idx] <= arr[idx - i]:\n                break\n            if idx - i >= 0:\n                maximum = max(maximum, 1 + helper(idx - i))\n        \n        dp[idx] = maximum\n        return maximum\n\n    for i in range(n):\n        helper(i)\n\n    return max(dp)"}}, "leetcode/leetcode_310.txt": {"score": 0.9992324113845825, "content": {"text": "from collections import deque\n    \"\"\"A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\n\nReturn _a list of all **MHTs'** root labels_. You can return the answer in **any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[1\\]\n**Explanation:** As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n**Example 2:**\n\n**Input:** n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]\n**Output:** \\[3,4\\]\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs `(ai, bi)` are distinct.\n*   The given input is **guaranteed** to be a tree and there will be **no repeated** edges.\"\"\"\n\nfrom typing import List\n\ndef find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1:\n        return [0]\n\n    adj_list = [set() for _ in range(n)]\n    for a, b in edges:\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)\n\n    while n > 2:\n        leaves_size = len(leaves)\n        n -= leaves_size\n        for _ in range(leaves_size):\n            leaf = leaves.popleft()\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)"}}, "leetcode/leetcode_1519.txt": {"score": 0.9305296540260315, "content": {"text": "def min_subsequence(nums):\n    \"\"\"You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` `edges`. The **root** of the tree is the node `0`, and each node of the tree has **a label** which is a lower-case character given in the string `labels` (i.e. The node with the number `i` has the label `labels[i]`).\n\nThe `edges` array is given on the form `edges[i] = [ai, bi]`, which means there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn _an array of size `n`_ where `ans[i]` is the number of nodes in the subtree of the `ith` node which have the same label as node `i`.\n\nA subtree of a tree `T` is the tree consisting of a node in `T` and all of its descendant nodes.\n\n**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,4\\],\\[1,5\\],\\[2,3\\],\\[2,6\\]\\], labels =  \"abaedcd \"\n**Output:** \\[2,1,1,1,1,1,1\\]\n**Explanation:** Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.\nNode 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).\n\n**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,3\\]\\], labels =  \"bbbb \"\n**Output:** \\[4,2,1,1\\]\n**Explanation:** The sub-tree of node 2 contains only node 2, so the answer is 1.\nThe sub-tree of node 3 contains only node 3, so the answer is 1.\nThe sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.\nThe sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.\n\n**Example 3:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[0,4\\]\\], labels =  \"aabab \"\n**Output:** \\[3,2,1,1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `labels.length == n`\n*   `labels` is consisting of only of lowercase English letters.\"\"\"\n\n    nums.sort(reverse=True)\n    total_sum, current_sum = sum(nums), 0\n    result = []\n    for num in nums:\n        current_sum += num\n        result.append(num)\n        if current_sum > total_sum - current_sum:\n            break\n    return result"}}, "leetcode/leetcode_2322.txt": {"score": 0.9310278296470642, "content": {"text": "def dfs(node, parent, xor_values, tree):\n    \"\"\"There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nRemove two **distinct** edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n\n1.  Get the XOR of all the values of the nodes for **each** of the three components respectively.\n2.  The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair.\n\n*   For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = **6**`, `1 ^ 9 = **8**`, and `3 ^ 3 ^ 3 = **3**`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn _the **minimum** score of any possible pair of edge removals on the given tree_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,5,4,11\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\]\n**Output:** 9\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[1,3,4\\] with values \\[5,4,11\\]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2nd component has node \\[0\\] with value \\[1\\]. Its XOR value is 1 = 1.\n- The 3rd component has node \\[2\\] with value \\[5\\]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9.\n\n**Example 2:**\n\n**Input:** nums = \\[5,5,2,4,4,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[5,2\\],\\[4,3\\],\\[1,3\\]\\]\n**Output:** 0\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[3,4\\] with values \\[4,4\\]. Its XOR value is 4 ^ 4 = 0.\n- The 2nd component has nodes \\[1,0\\] with values \\[5,5\\]. Its XOR value is 5 ^ 5 = 0.\n- The 3rd component has nodes \\[2,5\\] with values \\[2,2\\]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `3 <= n <= 1000`\n*   `1 <= nums[i] <= 108`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n    xor_value = xor_values[node]\n    for child in tree[node]:\n        if child != parent:\n            xor_value ^= dfs(child, node, xor_values, tree)\n    return xor_value\n\n\ndef minimumScore(nums, edges):\n    n = len(nums)\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]\n    \n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor1 = xor_values[i]\n            xor2 = xor_values[j] ^ nums[i]\n            xor3 = nums[i] ^ nums[j]\n            max_xor = max(xor1, xor2, xor3)\n            min_xor = min(xor1, xor2, xor3)\n            ans = min(ans, max_xor - min_xor)\n    \n    return ans"}}}}, "14": {"gold": {"leetcode/leetcode_672.txt": 1, "leetcode/leetcode_995.txt": 1, "leetcode/leetcode_1375.txt": 1, "leetcode/leetcode_2485.txt": 1}, "retrieved": {"leetcode/leetcode_1359.txt": {"score": 0.8855394124984741, "content": {"text": "def circular_permutation(n, start):\n    \"\"\"Given `n` orders, each order consist in pickup and delivery services.\n\nCount all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i).\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 6\n**Explanation:** All possible orders: \n(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\nThis is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n\n**Example 3:**\n\n**Input:** n = 3\n**Output:** 90\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n\nGiven 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that : p\\[0\\] = start, p\\[i\\] and p\\[i+1\\] differ by only one bit for all 0 <= i < 2^n - 1.\"\"\"\n\n    result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)]\n    return result"}}, "leetcode/leetcode_390.txt": {"score": 0.8865556716918945, "content": {"text": "def last_remaining(n: int) -> int:\n    \"\"\"You have a list `arr` of all integers in the range `[1, n]` sorted in a strictly increasing order. Apply the following algorithm on `arr`:\n\n*   Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n*   Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.\n*   Keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n\nGiven the integer `n`, return _the last number that remains in_ `arr`.\n\n**Example 1:**\n\n**Input:** n = 9\n**Output:** 6\n**Explanation:**\narr = \\[1, 2, 3, 4, 5, 6, 7, 8, 9\\]\narr = \\[2, 4, 6, 8\\]\narr = \\[2, 6\\]\narr = \\[6\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 109`\"\"\"\n\n    direction = True\n    head = 1\n    remaining = n\n    step = 1\n\n    while remaining > 1:\n        if direction or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        direction = not direction\n\n    return head"}}, "leetcode/leetcode_2549.txt": {"score": 0.885832667350769, "content": {"text": "def distinct_numbers(n):\n    \"\"\"You are given a positive integer `n`, that is initially placed on a board. Every day, for `109` days, you perform the following procedure:\n\n*   For each number `x` present on the board, find all numbers `1 <= i <= n` such that `x % i == 1`.\n*   Then, place those numbers on the board.\n\nReturn _the number of **distinct** integers present on the board after_ `109` _days have elapsed_.\n\n**Note:**\n\n*   Once a number is placed on the board, it will remain on it until the end.\n*   `%` stands for the modulo operation. For example, `14 % 3` is `2`.\n\n**Example 1:**\n\n**Input:** n = 5\n**Output:** 4\n**Explanation:** Initially, 5 is present on the board. \nThe next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. \nAfter that day, 3 will be added to the board because 4 % 3 == 1. \nAt the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. \n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** \nSince 3 % 2 == 1, 2 will be added to the board. \nAfter a billion days, the only two distinct numbers on the board are 2 and 3. \n\n**Constraints:**\n\n*   `1 <= n <= 100`\"\"\"\n\n    return n - 1"}}, "leetcode/leetcode_1646.txt": {"score": 0.8910530209541321, "content": {"text": "def findKthPositive(arr, k):\n    \"\"\"You are given an integer `n`. A **0-indexed** integer array `nums` of length `n + 1` is generated in the following way:\n\n*   `nums[0] = 0`\n*   `nums[1] = 1`\n*   `nums[2 * i] = nums[i]` when `2 <= 2 * i <= n`\n*   `nums[2 * i + 1] = nums[i] + nums[i + 1]` when `2 <= 2 * i + 1 <= n`\n\nReturn _the **maximum** integer in the array_ `nums`\u200b\u200b\u200b.\n\n**Example 1:**\n\n**Input:** n = 7\n**Output:** 3\n**Explanation:** According to the given rules:\n  nums\\[0\\] = 0\n  nums\\[1\\] = 1\n  nums\\[(1 \\* 2) = 2\\] = nums\\[1\\] = 1\n  nums\\[(1 \\* 2) + 1 = 3\\] = nums\\[1\\] + nums\\[2\\] = 1 + 1 = 2\n  nums\\[(2 \\* 2) = 4\\] = nums\\[2\\] = 1\n  nums\\[(2 \\* 2) + 1 = 5\\] = nums\\[2\\] + nums\\[3\\] = 1 + 2 = 3\n  nums\\[(3 \\* 2) = 6\\] = nums\\[3\\] = 2\n  nums\\[(3 \\* 2) + 1 = 7\\] = nums\\[3\\] + nums\\[4\\] = 2 + 1 = 3\nHence, nums = \\[0,1,1,2,1,3,2,3\\], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** According to the given rules, nums = \\[0,1,1\\]. The maximum is max(0,1,1) = 1.\n\n**Example 3:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** According to the given rules, nums = \\[0,1,1,2\\]. The maximum is max(0,1,1,2) = 2.\n\n**Constraints:**\n\n*   `0 <= n <= 100`\"\"\"\n\n    i, num = 0, 1\n    while k > 0:\n        if i < len(arr) and arr[i] == num:\n            i += 1\n        else:\n            k -= 1\n        num += 1\n    return num - 1"}}, "leetcode/leetcode_672.txt": {"score": 0.9120649099349976, "content": {"text": "def num_light_configuration(n, presses):\n    \"\"\"There is a room with `n` bulbs labeled from `1` to `n` that all are turned on initially, and **four buttons** on the wall. Each of the four buttons has a different functionality where:\n\n*   **Button 1:** Flips the status of all the bulbs.\n*   **Button 2:** Flips the status of all the bulbs with even labels (i.e., `2, 4, ...`).\n*   **Button 3:** Flips the status of all the bulbs with odd labels (i.e., `1, 3, ...`).\n*   **Button 4:** Flips the status of all the bulbs with a label `j = 3k + 1` where `k = 0, 1, 2, ...` (i.e., `1, 4, 7, 10, ...`).\n\nYou must make **exactly** `presses` button presses in total. For each press, you may pick **any** of the four buttons to press.\n\nGiven the two integers `n` and `presses`, return _the number of **different possible statuses** after performing all_ `presses` _button presses_.\n\n**Example 1:**\n\n**Input:** n = 1, presses = 1\n**Output:** 2\n**Explanation:** Status can be:\n- \\[off\\] by pressing button 1\n- \\[on\\] by pressing button 2\n\n**Example 2:**\n\n**Input:** n = 2, presses = 1\n**Output:** 3\n**Explanation:** Status can be:\n- \\[off, off\\] by pressing button 1\n- \\[on, off\\] by pressing button 2\n- \\[off, on\\] by pressing button 3\n\n**Example 3:**\n\n**Input:** n = 3, presses = 1\n**Output:** 4\n**Explanation:** Status can be:\n- \\[off, off, off\\] by pressing button 1\n- \\[off, on, off\\] by pressing button 2\n- \\[on, off, on\\] by pressing button 3\n- \\[off, on, on\\] by pressing button 4\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= presses <= 1000`\"\"\"\n\n    dp = [[0] * (presses + 1) for _ in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(n + 1):\n        for j in range(1, presses + 1):\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (dp[i - 1][j - 1] if i > 0 else 0)\n\n    return dp[n][presses]"}}, "leetcode/leetcode_1997.txt": {"score": 0.911264181137085, "content": {"text": "def firstDayBeenInAllRooms(nextVisit):\n    \"\"\"There are `n` rooms you need to visit, labeled from `0` to `n - 1`. Each day is labeled, starting from `0`. You will go in and visit one room a day.\n\nInitially on day `0`, you visit room `0`. The **order** you visit the rooms for the coming days is determined by the following **rules** and a given **0-indexed** array `nextVisit` of length `n`:\n\n*   Assuming that on a day, you visit room `i`,\n*   if you have been in room `i` an **odd** number of times (**including** the current visit), on the **next** day you will visit a room with a **lower or equal room number** specified by `nextVisit[i]` where `0 <= nextVisit[i] <= i`;\n*   if you have been in room `i` an **even** number of times (**including** the current visit), on the **next** day you will visit room `(i + 1) mod n`.\n\nReturn _the label of the **first** day where you have been in **all** the rooms_. It can be shown that such a day exists. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** nextVisit = \\[0,0\\]\n**Output:** 2\n**Explanation:**\n- On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n  On the next day you will visit room nextVisit\\[0\\] = 0\n- On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n  On the next day you will visit room (0 + 1) mod 2 = 1\n- On day 2, you visit room 1. This is the first day where you have been in all the rooms.\n\n**Example 2:**\n\n**Input:** nextVisit = \\[0,0,2\\]\n**Output:** 6\n**Explanation:**\nYour room visiting order for each day is: \\[0,0,1,0,0,1,2,...\\].\nDay 6 is the first day where you have been in all the rooms.\n\n**Example 3:**\n\n**Input:** nextVisit = \\[0,1,2,0\\]\n**Output:** 6\n**Explanation:**\nYour room visiting order for each day is: \\[0,0,1,1,2,2,3,...\\].\nDay 6 is the first day where you have been in all the rooms.\n\n**Constraints:**\n\n*   `n == nextVisit.length`\n*   `2 <= n <= 105`\n*   `0 <= nextVisit[i] <= i`\"\"\"\n\n    n = len(nextVisit)\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[n - 1]"}}, "leetcode/leetcode_1411.txt": {"score": 0.8864861726760864, "content": {"text": "class ListNode:\n    \"\"\"You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow,** or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\n\nGiven `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 12\n**Explanation:** There are 12 possible way to paint the grid as shown.\n\n**Example 2:**\n\n**Input:** n = 5000\n**Output:** 30228214\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `1 <= n <= 5000`\"\"\"\n\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head: ListNode) -> int:\n    num = 0\n    while head:\n        num = (num << 1) | head.val\n        head = head.next\n    return num"}}, "leetcode/leetcode_2327.txt": {"score": 0.9137083292007446, "content": {"text": "def largest_swap_permutations(num):\n    \"\"\"On day `1`, one person discovers a secret.\n\nYou are given an integer `delay`, which means that each person will **share** the secret with a new person **every day**, starting from `delay` days after discovering the secret. You are also given an integer `forget`, which means that each person will **forget** the secret `forget` days after discovering it. A person **cannot** share the secret on the same day they forgot it, or on any day afterwards.\n\nGiven an integer `n`, return _the number of people who know the secret at the end of day_ `n`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 6, delay = 2, forget = 4\n**Output:** 5\n**Explanation:**\nDay 1: Suppose the first person is named A. (1 person)\nDay 2: A is the only person who knows the secret. (1 person)\nDay 3: A shares the secret with a new person, B. (2 people)\nDay 4: A shares the secret with a new person, C. (3 people)\nDay 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\nDay 6: B shares the secret with E, and C shares the secret with F. (5 people)\n\n**Example 2:**\n\n**Input:** n = 4, delay = 1, forget = 3\n**Output:** 6\n**Explanation:**\nDay 1: The first person is named A. (1 person)\nDay 2: A shares the secret with B. (2 people)\nDay 3: A and B share the secret with 2 new people, C and D. (4 people)\nDay 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)\n\n**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= delay < forget <= n`\"\"\"\n\n    num_str = str(num)\n    even_digits = sorted([c for c in num_str if int(c) % 2 == 0], reverse=True)\n    odd_digits = sorted([c for c in num_str if int(c) % 2 == 1], reverse=True)\n\n    result = []\n    for c in num_str:\n        if int(c) % 2 == 0:\n            result.append(even_digits.pop(0))\n        else:\n            result.append(odd_digits.pop(0))\n\n    return int(''.join(result))"}}, "leetcode/leetcode_957.txt": {"score": 0.9075441956520081, "content": {"text": "def minAddToMakeValid(s: str) -> int:\n    \"\"\"There are `8` prison cells in a row and each cell is either occupied or vacant.\n\nEach day, whether the cell is occupied or vacant changes according to the following rules:\n\n*   If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.\n*   Otherwise, it becomes vacant.\n\n**Note** that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.\n\nYou are given an integer array `cells` where `cells[i] == 1` if the `ith` cell is occupied and `cells[i] == 0` if the `ith` cell is vacant, and you are given an integer `n`.\n\nReturn the state of the prison after `n` days (i.e., `n` such changes described above).\n\n**Example 1:**\n\n**Input:** cells = \\[0,1,0,1,1,0,0,1\\], n = 7\n**Output:** \\[0,0,1,1,0,0,0,0\\]\n**Explanation:** The following table summarizes the state of the prison on each day:\nDay 0: \\[0, 1, 0, 1, 1, 0, 0, 1\\]\nDay 1: \\[0, 1, 1, 0, 0, 0, 0, 0\\]\nDay 2: \\[0, 0, 0, 0, 1, 1, 1, 0\\]\nDay 3: \\[0, 1, 1, 0, 0, 1, 0, 0\\]\nDay 4: \\[0, 0, 0, 0, 0, 1, 0, 0\\]\nDay 5: \\[0, 1, 1, 1, 0, 1, 0, 0\\]\nDay 6: \\[0, 0, 1, 0, 1, 1, 0, 0\\]\nDay 7: \\[0, 0, 1, 1, 0, 0, 0, 0\\]\n\n**Example 2:**\n\n**Input:** cells = \\[1,0,0,1,0,0,1,0\\], n = 1000000000\n**Output:** \\[0,0,1,1,1,1,1,0\\]\n\n**Constraints:**\n\n*   `cells.length == 8`\n*   `cells[i]` is either `0` or `1`.\n*   `1 <= n <= 109`\"\"\"\n\n    result = balance = 0\n    for c in s:\n        balance += 1 if c == '(' else -1\n        if balance == -1:\n            result += 1\n            balance += 1\n    return result + balance"}}, "leetcode/leetcode_319.txt": {"score": 0.994385302066803, "content": {"text": "def bulbSwitch(n):\n    \"\"\"There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after `n` rounds_.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 1\n**Explanation:** At first, the three bulbs are \\[off, off, off\\].\nAfter the first round, the three bulbs are \\[on, on, on\\].\nAfter the second round, the three bulbs are \\[on, off, on\\].\nAfter the third round, the three bulbs are \\[on, off, off\\]. \nSo you should return 1 because there is only one bulb is on.\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Example 3:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= n <= 109`\"\"\"\n\n    return int(n**0.5)"}}}}, "15": {"gold": {"leetcode/leetcode_2328.txt": 1}, "retrieved": {"leetcode/leetcode_1301.txt": {"score": 0.8733611106872559, "content": {"text": "from typing import List\n    \"\"\"You are given a square `board` of characters. You can move on the board starting at the bottom right square marked with the character `'S'`.\n\nYou need to reach the top left square marked with the character `'E'`. The rest of the squares are labeled either with a numeric character `1, 2, ..., 9` or with an obstacle `'X'`. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.\n\nReturn a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, **taken modulo `10^9 + 7`**.\n\nIn case there is no path, return `[0, 0]`.\n\n**Example 1:**\n\n**Input:** board = \\[\"E23\",\"2X2\",\"12S\"\\]\n**Output:** \\[7,1\\]\n\n**Example 2:**\n\n**Input:** board = \\[\"E12\",\"1X1\",\"21S\"\\]\n**Output:** \\[4,2\\]\n\n**Example 3:**\n\n**Input:** board = \\[\"E11\",\"XXX\",\"11S\"\\]\n**Output:** \\[0,0\\]\n\n**Constraints:**\n\n*   `2 <= board.length == board[i].length <= 100`\"\"\"\n\n\nMOD = 10**9 + 7\n\ndef pathsWithMaxScore(board: List[str]) -> List[int]:\n    n = len(board)\n    dp = [[0] * n for _ in range(n)]\n    cnt = [[0] * n for _ in range(n)]\n\n    board[0] = list(board[0])\n    board[0][0] = '0'\n    board[n-1] = list(board[n-1])\n    board[n-1][n-1] = '0'\n    cnt[n-1][n-1] = 1\n\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if board[i][j] != 'X':\n                neighbors = [(i-1, j), (i, j-1), (i-1, j-1)]\n                for x, y in neighbors:\n                    if x >= 0 and y >= 0:\n                        if dp[i][j] < dp[x][y] + int(board[i][j]):\n                            dp[i][j] = dp[x][y] + int(board[i][j])\n                            cnt[i][j] = cnt[x][y]\n                        elif dp[i][j] == dp[x][y] + int(board[i][j]):\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD\n\n    return [dp[0][0], cnt[0][0]]"}}, "leetcode/leetcode_1901.txt": {"score": 0.8764110803604126, "content": {"text": "def min_operations(nums1, nums2):\n    \"\"\"A **peak** element in a 2D grid is an element that is **strictly greater** than all of its **adjacent** neighbors to the left, right, top, and bottom.\n\nGiven a **0-indexed** `m x n` matrix `mat` where **no two adjacent cells are equal**, find **any** peak element `mat[i][j]` and return _the length 2 array_ `[i,j]`.\n\nYou may assume that the entire matrix is surrounded by an **outer perimeter** with the value `-1` in each cell.\n\nYou must write an algorithm that runs in `O(m log(n))` or `O(n log(m))` time.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[1,4\\],\\[3,2\\]\\]\n**Output:** \\[0,1\\]\n**Explanation:** Both 3 and 4 are peak elements so \\[1,0\\] and \\[0,1\\] are both acceptable answers.\n\n**Example 2:**\n\n**Input:** mat = \\[\\[10,20,15\\],\\[21,30,14\\],\\[7,16,32\\]\\]\n**Output:** \\[1,1\\]\n**Explanation:** Both 30 and 32 are peak elements so \\[1,1\\] and \\[2,2\\] are both acceptable answers.\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 500`\n*   `1 <= mat[i][j] <= 105`\n*   No two adjacent cells are equal.\"\"\"\n\n    sum1, sum2 = sum(nums1), sum(nums2)\n    if sum1 == sum2: return 0\n    if sum1 < sum2: nums1, nums2 = nums2, nums1\n    nums1.sort(reverse=True)\n    nums2.sort()\n    diff, operations, i, j = abs(sum1 - sum2), 0, 0, 0\n    while diff > 0 and (i < len(nums1) or j < len(nums2)):\n        option1 = nums1[i] - 1 if i < len(nums1) else 0\n        option2 = 6 - nums2[j] if j < len(nums2) else 0\n        if option1 > option2:\n            diff -= option1\n            i += 1\n        else:\n            diff -= option2\n            j += 1\n        operations += 1\n    return operations if diff == 0 else -1"}}, "leetcode/leetcode_1340.txt": {"score": 0.8738757371902466, "content": {"text": "import threading\n    \"\"\"Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:\n\n*   `i + x` where: `i + x < arr.length` and `0 < x <= d`.\n*   `i - x` where: `i - x >= 0` and `0 < x <= d`.\n\nIn addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).\n\nYou can choose any index of the array and start jumping. Return _the maximum number of indices_ you can visit.\n\nNotice that you can not jump outside of the array at any time.\n\n**Example 1:**\n\n**Input:** arr = \\[6,4,14,6,8,13,9,7,10,6,12\\], d = 2\n**Output:** 4\n**Explanation:** You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\nNote that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\nSimilarly You cannot jump from index 3 to index 2 or index 1.\n\n**Example 2:**\n\n**Input:** arr = \\[3,3,3,3,3\\], d = 3\n**Output:** 1\n**Explanation:** You can start at any index. You always cannot jump to any index.\n\n**Example 3:**\n\n**Input:** arr = \\[7,6,5,4,3,2,1\\], d = 1\n**Output:** 7\n**Explanation:** Start at index 0. You can visit all the indicies. \n\n**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 105`\n*   `1 <= d <= arr.length`\"\"\"\n\n\nclass DiningPhilosophers:\n    def __init__(self):\n        self.forks = [threading.Lock() for _ in range(5)]\n        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]\n\n    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:\n        left_fork = philosopher\n        right_fork = (philosopher + 1) % 5\n\n        with self.forks[left_fork]:\n            with self.not_busy[left_fork]:\n                while not self.forks[right_fork].acquire(blocking=False):\n                    self.not_busy[left_fork].wait()\n            pickLeftFork()\n\n            with self.forks[right_fork]:\n                pickRightFork()\n                eat()\n                putRightFork()\n                self.forks[right_fork].release()\n                with self.not_busy[right_fork]:\n                    self.not_busy[right_fork].notify_all()\n\n            putLeftFork()\n            self.not_busy[left_fork].notify_all()"}}, "leetcode/leetcode_1696.txt": {"score": 0.8771453499794006, "content": {"text": "def isPrintable(targetGrid):\n    \"\"\"You are given a **0-indexed** integer array `nums` and an integer `k`.\n\nYou are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n - 1, i + k)]` **inclusive**.\n\nYou want to reach the last index of the array (index `n - 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array.\n\nReturn _the **maximum score** you can get_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,\\-1,-2,4,-7,3\\], k = 2\n**Output:** 7\n**Explanation:** You can choose your jumps forming the subsequence \\[1,-1,4,3\\] (underlined above). The sum is 7.\n\n**Example 2:**\n\n**Input:** nums = \\[10,-5,-2,4,0,3\\], k = 3\n**Output:** 17\n**Explanation:** You can choose your jumps forming the subsequence \\[10,4,3\\] (underlined above). The sum is 17.\n\n**Example 3:**\n\n**Input:** nums = \\[1,-5,-20,4,-1,3,-6,-3\\], k = 2\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length, k <= 105`\n*   `-104 <= nums[i] <= 104`\"\"\"\n\n    m, n = len(targetGrid), len(targetGrid[0])\n    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61\n    vis = [[False]*n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            c = targetGrid[i][j]\n            top[c] = min(top[c], i)\n            bottom[c] = max(bottom[c], i)\n            left[c] = min(left[c], j)\n            right[c] = max(right[c], j)\n\n    def dfs(x):\n        i, j = x // n, x % n\n        if vis[i][j]: return True\n        c = targetGrid[i][j]\n        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False\n        vis[i][j] = True\n        for k in range(1, 61):\n            if k == c: continue\n            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False\n            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False\n        return True\n\n    for color in range(1, 61):\n        for i in range(top[color], bottom[color] + 1):\n            for j in range(left[color], right[color] + 1):\n                if not vis[i][j] and not dfs(i * n + j): return False\n\n    return True"}}, "leetcode/leetcode_741.txt": {"score": 0.8824069499969482, "content": {"text": "def cherryPickup(self, grid: List[List[int]]) -> int:\n    \"\"\"You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.\n\n*   `0` means the cell is empty, so you can pass through,\n*   `1` means the cell contains a cherry that you can pick up and pass through, or\n*   `-1` means the cell contains a thorn that blocks your way.\n\nReturn _the maximum number of cherries you can collect by following the rules below_:\n\n*   Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).\n*   After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.\n*   When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.\n*   If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,-1\\],\\[1,0,-1\\],\\[1,1,1\\]\\]\n**Output:** 5\n**Explanation:** The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes \\[\\[0,1,-1\\],\\[0,0,-1\\],\\[0,0,0\\]\\].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,-1\\],\\[1,-1,1\\],\\[-1,1,1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `grid[i][j]` is `-1`, `0`, or `1`.\n*   `grid[0][0] != -1`\n*   `grid[n - 1][n - 1] != -1`\"\"\"\n\n    def dp(r1, c1, c2):\n        r2 = r1 + c1 - c2\n        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or\n            grid[r1][c1] == -1 or grid[r2][c2] == -1):\n            return float('-inf')\n        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:\n            return grid[r1][c1]\n        elif memo[r1][c1][c2] != float('-inf'):\n            return memo[r1][c1][c2]\n        else:\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]\n            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),\n                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))\n            memo[r1][c1][c2] += max_cherries\n        \n        return memo[r1][c1][c2]\n    \n    N = len(grid)\n    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]\n    return max(0, dp(0, 0, 0))"}}, "leetcode/leetcode_1765.txt": {"score": 0.8850118517875671, "content": {"text": "class ListNode:\n    \"\"\"You are given an integer matrix `isWater` of size `m x n` that represents a map of **land** and **water** cells.\n\n*   If `isWater[i][j] == 0`, cell `(i, j)` is a **land** cell.\n*   If `isWater[i][j] == 1`, cell `(i, j)` is a **water** cell.\n\nYou must assign each cell a height in a way that follows these rules:\n\n*   The height of each cell must be non-negative.\n*   If the cell is a **water** cell, its height must be `0`.\n*   Any two adjacent cells must have an absolute height difference of **at most** `1`. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\nFind an assignment of heights such that the maximum height in the matrix is **maximized**.\n\nReturn _an integer matrix_ `height` _of size_ `m x n` _where_ `height[i][j]` _is cell_ `(i, j)`_'s height. If there are multiple solutions, return **any** of them_.\n\n**Example 1:**\n\n**Input:** isWater = \\[\\[0,1\\],\\[0,0\\]\\]\n**Output:** \\[\\[1,0\\],\\[2,1\\]\\]\n**Explanation:** The image shows the assigned heights of each cell.\nThe blue cell is the water cell, and the green cells are the land cells.\n\n**Example 2:**\n\n**Input:** isWater = \\[\\[0,0,1\\],\\[1,0,0\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[1,1,0\\],\\[0,1,1\\],\\[1,2,2\\]\\]\n**Explanation:** A height of 2 is the maximum possible height of any assignment.\nAny height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.\n\n**Constraints:**\n\n*   `m == isWater.length`\n*   `n == isWater[i].length`\n*   `1 <= m, n <= 1000`\n*   `isWater[i][j]` is `0` or `1`.\n*   There is at least **one** water cell.\"\"\"\n\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeInBetween(list1, a, b, list2):\n    prev, curr = None, list1\n    index = 0\n    \n    while curr:\n        if index == a:\n            last = list2\n            while last.next:\n                last = last.next\n            prev.next = list2\n            last.next = curr.next\n            break\n            \n        if index > a and index < b:\n            curr = curr.next\n        else:\n            prev = curr\n            curr = curr.next\n\n        index += 1\n\n    return list1"}}, "leetcode/leetcode_2328.txt": {"score": 0.9115620255470276, "content": {"text": "def add_parentheses(expression: str) -> str:\n    \"\"\"You are given an `m x n` integer matrix `grid`, where you can move from a cell to any adjacent cell in all `4` directions.\n\nReturn _the number of **strictly** **increasing** paths in the grid such that you can start from **any** cell and end at **any** cell._ Since the answer may be very large, return it **modulo** `109 + 7`.\n\nTwo paths are considered different if they do not have exactly the same sequence of visited cells.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1\\],\\[3,4\\]\\]\n**Output:** 8\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[1\\], \\[3\\], \\[4\\].\n- Paths with length 2: \\[1 -> 3\\], \\[1 -> 4\\], \\[3 -> 4\\].\n- Paths with length 3: \\[1 -> 3 -> 4\\].\nThe total number of paths is 4 + 3 + 1 = 8.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1\\],\\[2\\]\\]\n**Output:** 3\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[2\\].\n- Paths with length 2: \\[1 -> 2\\].\nThe total number of paths is 2 + 1 = 3.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 105`\"\"\"\n\n    return f\"({expression})\""}}, "leetcode/leetcode_2503.txt": {"score": 0.8971787095069885, "content": {"text": "from typing import List\n    \"\"\"You are given an `m x n` integer matrix `grid` and an array `queries` of size `k`.\n\nFind an array `answer` of size `k` such that for each integer `queries[i]` you start in the **top left** cell of the matrix and repeat the following process:\n\n*   If `queries[i]` is **strictly** greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any **adjacent** cell in all `4` directions: up, down, left, and right.\n*   Otherwise, you do not get any points, and you end this process.\n\nAfter the process, `answer[i]` is the **maximum** number of points you can get. **Note** that for each query you are allowed to visit the same cell **multiple** times.\n\nReturn _the resulting array_ `answer`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[2,5,7\\],\\[3,5,1\\]\\], queries = \\[5,6,2\\]\n**Output:** \\[5,8,1\\]\n**Explanation:** The diagrams above show which cells we visit to get points for each query.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[5,2,1\\],\\[1,1,2\\]\\], queries = \\[3\\]\n**Output:** \\[0\\]\n**Explanation:** We can not get any points because the value of the top left cell is already greater than or equal to 3.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 1000`\n*   `4 <= m * n <= 105`\n*   `k == queries.length`\n*   `1 <= k <= 104`\n*   `1 <= grid[i][j], queries[i] <= 106`\"\"\"\n\n\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    m, n = len(grid), len(grid[0])\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    def dfs(x: int, y: int, q: int, visited: set) -> int:\n        if 0 <= x < m and 0 <= y < n and grid[x][y] < q and (x, y) not in visited:\n            visited.add((x, y))\n            points = 1\n            for i in range(4):\n                nx, ny = x + dx[i], y + dy[i]\n                points += dfs(nx, ny, q, visited)\n            return points\n        return 0\n\n    return [dfs(0, 0, query, set()) for query in queries]"}}, "leetcode/leetcode_1219.txt": {"score": 0.8902212977409363, "content": {"text": "def longest_wpi(hours):\n    \"\"\"In a gold mine `grid` of size `m x n`, each cell in this mine has an integer representing the amount of gold in that cell, `0` if it is empty.\n\nReturn the maximum amount of gold you can collect under the conditions:\n\n*   Every time you are located in a cell you will collect all the gold in that cell.\n*   From your position, you can walk one step to the left, right, up, or down.\n*   You can't visit the same cell more than once.\n*   Never visit a cell with `0` gold.\n*   You can start and stop collecting gold from **any** position in the grid that has some gold.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,6,0\\],\\[5,8,7\\],\\[0,9,0\\]\\]\n**Output:** 24\n**Explanation:**\n\\[\\[0,6,0\\],\n \\[5,8,7\\],\n \\[0,9,0\\]\\]\nPath to get the maximum gold, 9 -> 8 -> 7.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,7\\],\\[2,0,6\\],\\[3,4,5\\],\\[0,3,0\\],\\[9,0,20\\]\\]\n**Output:** 28\n**Explanation:**\n\\[\\[1,0,7\\],\n \\[2,0,6\\],\n \\[3,4,5\\],\n \\[0,3,0\\],\n \\[9,0,20\\]\\]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 15`\n*   `0 <= grid[i][j] <= 100`\n*   There are at most **25** cells containing gold.\"\"\"\n\n    score = 0\n    max_length = 0\n    first_occurrence = {}\n\n    for i, h in enumerate(hours):\n        score += 1 if h > 8 else -1\n        if score > 0:\n            max_length = i + 1\n        else:\n            if score not in first_occurrence:\n                first_occurrence[score] = i\n            if score - 1 in first_occurrence:\n                max_length = max(max_length, i - first_occurrence[score - 1])\n    return max_length"}}, "leetcode/leetcode_329.txt": {"score": 0.9927892088890076, "content": {"text": "dx = (0, 0, 1, -1)\n    \"\"\"Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[9,9,4\\],\\[6,6,8\\],\\[2,1,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[1, 2, 6, 9]`.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[3,4,5\\],\\[3,2,6\\],\\[2,2,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= matrix[i][j] <= 231 - 1`\"\"\"\n\ndy = (1, -1, 0, 0)\n\ndef dfs(matrix, memo, i, j):\n    if memo[i][j] != 0:\n        return memo[i][j]\n    \n    max_len = 0\n    for k in range(4):\n        ni, nj = i + dx[k], j + dy[k]\n        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):\n            max_len = max(max_len, dfs(matrix, memo, ni, nj))\n    \n    memo[i][j] = max_len + 1\n    return memo[i][j]\n\ndef longest_increasing_path(matrix):\n    m, n = len(matrix), len(matrix[0])\n    \n    memo = [[0] * n for _ in range(m)]\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans = max(ans, dfs(matrix, memo, i, j))\n    \n    return ans"}}}}, "16": {"gold": {"leetcode/leetcode_2097.txt": 1}, "retrieved": {"leetcode/csn_python_train_274229.txt": {"score": 0.8662971258163452, "content": {"text": "def solve(m,c):\n    \"\"\"\n    run the algorithm to find the path list\n    \"\"\"\n    G={ (m,c,1):[] }\n    frontier=[ (m,c,1) ]  # 1 as boat starts on left bank \n    while len(frontier) > 0:\n        hold=list(frontier)\n        for node in hold:\n            newnode=[]\n            frontier.remove(node)\n            newnode.extend(pick_next_boat_trip(node, m,c, frontier))\n            for neighbor in newnode:\n                if neighbor not in G:\n                    G[node].append(neighbor)\n                    G[neighbor]=[node]\n                    frontier.append(neighbor)\n    return mod_plan.find_path_BFS(G,(m,c,1),(0,0,0))"}}, "leetcode/leetcode_797.txt": {"score": 0.8710368871688843, "content": {"text": "from collections import defaultdict\n    \"\"\"Given a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in **any order**.\n\nThe graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).\n\n**Example 1:**\n\n**Input:** graph = \\[\\[1,2\\],\\[3\\],\\[3\\],\\[\\]\\]\n**Output:** \\[\\[0,1,3\\],\\[0,2,3\\]\\]\n**Explanation:** There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n\n**Example 2:**\n\n**Input:** graph = \\[\\[4,3,1\\],\\[3,2,4\\],\\[3\\],\\[4\\],\\[\\]\\]\n**Output:** \\[\\[0,4\\],\\[0,3,4\\],\\[0,1,3,4\\],\\[0,1,2,3,4\\],\\[0,1,4\\]\\]\n\n**Constraints:**\n\n*   `n == graph.length`\n*   `2 <= n <= 15`\n*   `0 <= graph[i][j] < n`\n*   `graph[i][j] != i` (i.e., there will be no self-loops).\n*   All the elements of `graph[i]` are **unique**.\n*   The input graph is **guaranteed** to be a **DAG**.\"\"\"\n\ndef numRabbits(answers):\n    count = defaultdict(int)\n    res = 0\n    for a in answers:\n        count[a] += 1\n        if count[a] == 1:\n            res += (a + 1)\n        elif count[a] > a + 1:\n            count[a] = 1\n            res += (a + 1)\n    return res"}}, "leetcode/csn_python_train_165454.txt": {"score": 0.8721160888671875, "content": {"text": "def _find_path_between(self, p: GridQubit, q: GridQubit,\n                           used: Set[GridQubit]) -> Optional[List[GridQubit]]:\n        \"\"\"Searches for continuous sequence between two qubits.\n\n        This method runs two BFS algorithms in parallel (alternating variable s\n        in each iteration); the first one starting from qubit p, and the second\n        one starting from qubit q. If at some point a qubit reachable from p is\n        found to be on the set of qubits already reached from q (or vice versa),\n        the search is stopped and new path returned.\n\n        Args:\n            p: The first qubit, start of the sequence.\n            q: The second qubit, end of the sequence.\n            used: Set of forbidden qubits which cannot appear on the sequence.\n\n        Returns:\n            Continues sequence of qubits with new path between p and q, or None\n            if no path was found.\n        \"\"\"\n\n        def assemble_path(n: GridQubit, parent: Dict[GridQubit, GridQubit]):\n            path = [n]\n            while n in parent:\n                n = parent[n]\n                path.append(n)\n            return path\n\n        other = {p: q, q: p}\n        parents = {p: dict(), q: dict()} \\\n            # type: Dict[GridQubit, Dict[GridQubit, GridQubit]]\n        visited = {p: set(), q: set()}  # type: Dict[GridQubit, Set[GridQubit]]\n\n        queue = collections.deque([(p, p), (q, q)])\n\n        # Run two BFSs simultaneously.\n        while queue:\n            n, s = queue.popleft()\n            for n_adj in self._c_adj[n]:\n                if n_adj in visited[other[s]]:\n                    # Connection has been found, construct the path and return.\n                    path_s = assemble_path(n, parents[s])[-2::-1]\n                    path_other = assemble_path(n_adj, parents[other[s]])[:-1]\n                    path = path_s + path_other\n                    if s == q:\n                        path.reverse()\n                    return path\n                elif n_adj not in used and n_adj not in visited[s]:\n                    # Append n_adj to the end of queue of qubit s.\n                    queue.append((n_adj, s))\n                    visited[s].add(n_adj)\n                    parents[s][n_adj] = n\n\n        return None"}}, "leetcode/csn_python_train_177704.txt": {"score": 0.8736311793327332, "content": {"text": "def build_path(graph, node1, node2, path=None):\n    \"\"\"\n    Build the path from node1 to node2.\n    The path is composed of all the nodes between node1 and node2,\n    node1 excluded. Although if there is a loop starting from node1, it will be\n    included in the path.\n    \"\"\"\n    if path is None:\n        path = []\n    if node1 is node2:\n        return path\n    path.append(node2)\n    for pred in graph.all_preds(node2):\n        if pred in path:\n            continue\n        build_path(graph, node1, pred, path)\n    return path"}}, "leetcode/csn_python_train_78515.txt": {"score": 0.877622663974762, "content": {"text": "def only_path(self):\n        \"\"\"Finds the only path from the start node. If there is more than one,\n        raises ValueError.\"\"\"\n        start = [v for v in self.nodes if self.nodes[v].get('start', False)]\n        if len(start) != 1: \n            raise ValueError(\"graph does not have exactly one start node\")\n\n        path = []\n        [v] = start\n        while True:\n            path.append(v)\n            u = v\n            vs = self.edges.get(u, ())\n            if len(vs) == 0:\n                break\n            elif len(vs) > 1:\n                raise ValueError(\"graph does not have exactly one path\")\n            [v] = vs\n\n        return path"}}, "leetcode/csn_python_train_307531.txt": {"score": 0.8724592924118042, "content": {"text": "def edges_to_path(edges):\n    \"\"\"\n    Connect edges and return a path.\n    \"\"\"\n    if not edges:\n        return None\n\n    G = edges_to_graph(edges)\n    path = nx.topological_sort(G)\n    return path"}}, "leetcode/csn_python_train_105731.txt": {"score": 0.8753647804260254, "content": {"text": "def sequence(arcs):\n    \"\"\"sequence: make a list of cities to visit, from set of arcs\"\"\"\n    succ = {}\n    for (i,j) in arcs:\n        succ[i] = j\n    curr = 1    # first node being visited\n    sol = [curr]\n    for i in range(len(arcs)-2):\n        curr = succ[curr]\n        sol.append(curr)\n    return sol"}}, "leetcode/leetcode_1436.txt": {"score": 0.8945096731185913, "content": {"text": "from collections import deque\n    \"\"\"You are given the array `paths`, where `paths[i] = [cityAi, cityBi]` means there exists a direct path going from `cityAi` to `cityBi`. _Return the destination city, that is, the city without any path outgoing to another city._\n\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n\n**Example 1:**\n\n**Input:** paths = \\[\\[ \"London \", \"New York \"\\],\\[ \"New York \", \"Lima \"\\],\\[ \"Lima \", \"Sao Paulo \"\\]\\]\n**Output:**  \"Sao Paulo \" \n**Explanation:** Starting at  \"London \" city you will reach  \"Sao Paulo \" city which is the destination city. Your trip consist of:  \"London \" ->  \"New York \" ->  \"Lima \" ->  \"Sao Paulo \".\n\n**Example 2:**\n\n**Input:** paths = \\[\\[ \"B \", \"C \"\\],\\[ \"D \", \"B \"\\],\\[ \"C \", \"A \"\\]\\]\n**Output:**  \"A \"\n**Explanation:** All possible trips are: \n \"D \" ->  \"B \" ->  \"C \" ->  \"A \". \n \"B \" ->  \"C \" ->  \"A \". \n \"C \" ->  \"A \". \n \"A \". \nClearly the destination city is  \"A \".\n\n**Example 3:**\n\n**Input:** paths = \\[\\[ \"A \", \"Z \"\\]\\]\n**Output:**  \"Z \"\n\n**Constraints:**\n\n*   `1 <= paths.length <= 100`\n*   `paths[i].length == 2`\n*   `1 <= cityAi.length, cityBi.length <= 10`\n*   `cityAi != cityBi`\n*   All strings consist of lowercase and uppercase English letters and the space character.\"\"\"\n\nfrom collections import defaultdict\n\ndef watched_videos_by_friends(watched_videos, friends, id, level):\n    visited = set()\n    q = deque([(id, 0)])\n    video_freq = defaultdict(int)\n\n    while q:\n        current_id, current_level = q.popleft()\n\n        if current_level == level:\n            for video in watched_videos[current_id]:\n                video_freq[video] += 1\n        elif current_level < level:\n            for friend_id in friends[current_id]:\n                if friend_id not in visited:\n                    visited.add(friend_id)\n                    q.append((friend_id, current_level + 1))\n\n    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))\n\n    return result"}}, "leetcode/csn_python_train_339920.txt": {"score": 0.8779382109642029, "content": {"text": "def get_route_from_solution(solution, graph):\n    \"\"\"Converts a solution (a list of node indices) into a list\n    of paths suitable for rendering.\"\"\"\n\n    # As a guard against comparing invalid \"solutions\",\n    # ensure that this solution is valid.\n    assert check_valid_solution(solution, graph)\n\n    return [graph.get_path(i) for i in solution]"}}, "leetcode/leetcode_332.txt": {"score": 0.9965193271636963, "content": {"text": "from collections import defaultdict\n    \"\"\"You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\nAll of the tickets belong to a man who departs from `\"JFK \"`, thus, the itinerary must begin with `\"JFK \"`. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n*   For example, the itinerary `[ \"JFK \", \"LGA \"]` has a smaller lexical order than `[ \"JFK \", \"LGB \"]`.\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n**Example 1:**\n\n**Input:** tickets = \\[\\[ \"MUC \", \"LHR \"\\],\\[ \"JFK \", \"MUC \"\\],\\[ \"SFO \", \"SJC \"\\],\\[ \"LHR \", \"SFO \"\\]\\]\n**Output:** \\[ \"JFK \", \"MUC \", \"LHR \", \"SFO \", \"SJC \"\\]\n\n**Example 2:**\n\n**Input:** tickets = \\[\\[ \"JFK \", \"SFO \"\\],\\[ \"JFK \", \"ATL \"\\],\\[ \"SFO \", \"ATL \"\\],\\[ \"ATL \", \"JFK \"\\],\\[ \"ATL \", \"SFO \"\\]\\]\n**Output:** \\[ \"JFK \", \"ATL \", \"JFK \", \"SFO \", \"ATL \", \"SFO \"\\]\n**Explanation:** Another possible reconstruction is \\[ \"JFK \", \"SFO \", \"ATL \", \"JFK \", \"ATL \", \"SFO \"\\] but it is larger in lexical order.\n\n**Constraints:**\n\n*   `1 <= tickets.length <= 300`\n*   `tickets[i].length == 2`\n*   `fromi.length == 3`\n*   `toi.length == 3`\n*   `fromi` and `toi` consist of uppercase English letters.\n*   `fromi != toi`\"\"\"\n\n\ndef findItinerary(tickets):\n    flights = defaultdict(list)\n    itinerary = []\n\n    for ticket in tickets:\n        flights[ticket[0]].append(ticket[1])\n        flights[ticket[0]].sort(reverse=True)\n\n    def dfs(airport):\n        while flights[airport]:\n            dfs(flights[airport].pop())\n        itinerary.append(airport)\n\n    dfs(\"JFK\")\n    \n    return itinerary[::-1]"}}}}, "17": {"gold": {"leetcode/leetcode_278.txt": 1, "leetcode/leetcode_375.txt": 1, "leetcode/leetcode_658.txt": 1}, "retrieved": {"leetcode/leetcode_540.txt": {"score": 0.8498400449752808, "content": {"text": "def singleNonDuplicate(nums):\n    \"\"\"You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\n\nReturn _the single element that appears only once_.\n\nYour solution must run in `O(log n)` time and `O(1)` space.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,2,3,3,4,4,8,8\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** nums = \\[3,3,7,7,10,11,11\\]\n**Output:** 10\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`\"\"\"\n\n    low, high = 0, len(nums) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            low = mid + 2\n        else:\n            high = mid\n    return nums[low]"}}, "leetcode/csn_python_train_321049.txt": {"score": 0.8510634303092957, "content": {"text": "def discrete_binary_search(tab, lo, hi):\n    \"\"\"Binary search in a table\n\n    :param tab: boolean monotone table with tab[hi] = True\n    :param int lo:\n    :param int hi: with hi >= lo\n    :returns: first index i in [lo,hi] such that tab[i]\n    :complexity: `O(log(hi-lo))`\n    \"\"\"\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if tab[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo"}}, "leetcode/leetcode_1884.txt": {"score": 0.8689299821853638, "content": {"text": "def min_operations_to_alternate(s: str) -> int:\n    \"\"\"You are given **two identical** eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nIn each move, you may take an **unbroken** egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** We can drop the first egg from floor 1 and the second egg from floor 2.\nIf the first egg breaks, we know that f = 0.\nIf the second egg breaks but the first egg didn't, we know that f = 1.\nOtherwise, if both eggs survive, we know that f = 2.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 14\n**Explanation:** One optimal strategy is:\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\nRegardless of the outcome, it takes at most 14 drops to determine f.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\"\"\"\n\n    count_a, count_b = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        else:\n            if c == '0':\n                count_b += 1\n            else:\n                count_a += 1\n    return min(count_a, count_b)"}}, "leetcode/leetcode_35.txt": {"score": 0.859314501285553, "content": {"text": "def searchInsert(nums, target):\n    \"\"\"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 5\n**Output:** 2\n\n**Example 2:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 2\n**Output:** 1\n\n**Example 3:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 7\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` contains **distinct** values sorted in **ascending** order.\n*   `-104 <= target <= 104`\"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left"}}, "leetcode/leetcode_1095.txt": {"score": 0.8720800280570984, "content": {"text": "def twoCitySchedCost(costs):\n    \"\"\"_(This problem is an **interactive problem**.)_\n\nYou may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some `i` with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven a mountain array `mountainArr`, return the **minimum** `index` such that `mountainArr.get(index) == target`. If such an `index` does not exist, return `-1`.\n\n**You cannot access the mountain array directly.** You may only access the array using a `MountainArray` interface:\n\n*   `MountainArray.get(k)` returns the element of the array at index `k` (0-indexed).\n*   `MountainArray.length()` returns the length of the array.\n\nSubmissions making more than `100` calls to `MountainArray.get` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification.\n\n**Example 1:**\n\n**Input:** array = \\[1,2,3,4,5,3,1\\], target = 3\n**Output:** 2\n**Explanation:** 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.\n\n**Example 2:**\n\n**Input:** array = \\[0,1,2,4,2,1\\], target = 3\n**Output:** -1\n**Explanation:** 3 does not exist in `the array,` so we return -1.\n\n**Constraints:**\n\n*   `3 <= mountain_arr.length() <= 104`\n*   `0 <= target <= 109`\n*   `0 <= mountain_arr.get(index) <= 109`\"\"\"\n\n    costs.sort(key=lambda x: x[0] - x[1])\n\n    totalCost = 0\n    n = len(costs) // 2\n\n    for i in range(n):\n        totalCost += costs[i][0] + costs[i + n][1]\n\n    return totalCost"}}, "leetcode/leetcode_704.txt": {"score": 0.8748255372047424, "content": {"text": "def search(nums: List[int], target: int) -> int:\n    \"\"\"Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 9\n**Output:** 4\n**Explanation:** 9 exists in nums and its index is 4\n\n**Example 2:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 2\n**Output:** -1\n**Explanation:** 2 does not exist in nums so return -1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 < nums[i], target < 104`\n*   All the integers in `nums` are **unique**.\n*   `nums` is sorted in ascending order.\"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1"}}, "leetcode/leetcode_278.txt": {"score": 0.9033488631248474, "content": {"text": "def first_bad_version(n):\n    \"\"\"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n\n**Example 1:**\n\n**Input:** n = 5, bad = 4\n**Output:** 4\n**Explanation:**\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n\n**Example 2:**\n\n**Input:** n = 1, bad = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= bad <= n <= 231 - 1`\"\"\"\n\n    left, right = 1, n\n    while left < right:\n        mid = left + (right - left) // 2\n        if is_bad_version(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left"}}, "leetcode/leetcode_375.txt": {"score": 0.8813685774803162, "content": {"text": "def getMoneyAmount(n: int) -> int:\n    \"\"\"We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 16\n**Explanation:** The winning strategy is as follows:\n- The range is \\[1,10\\]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is \\[8,10\\]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is \\[1,6\\]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is \\[4,6\\]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is \\[1,2\\]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n**Explanation:** There is only one possible number, so you can guess 1 and not have to pay anything.\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\"\"\"\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]"}}, "leetcode/leetcode_887.txt": {"score": 0.86216801404953, "content": {"text": "import heapq\n    \"\"\"You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nEach move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n**Example 1:**\n\n**Input:** k = 1, n = 2\n**Output:** 2\n**Explanation:** \nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n\n**Example 2:**\n\n**Input:** k = 2, n = 6\n**Output:** 3\n\n**Example 3:**\n\n**Input:** k = 3, n = 14\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= n <= 104`\"\"\"\n\n\ndef mincost_to_hire_workers(quality, wage, k):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float(\"inf\")\n\n    for ratio, q in workers:\n        heapq.heappush(max_heap, -q)\n        total_quality += q\n\n        if len(max_heap) > k:\n            total_quality += heapq.heappop(max_heap)\n\n        if len(max_heap) == k:\n            result = min(result, total_quality * ratio)\n\n    return result"}}, "leetcode/leetcode_374.txt": {"score": 0.9938754439353943, "content": {"text": "def guessNumber(n):\n    \"\"\"We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.\n\n**Example 1:**\n\n**Input:** n = 10, pick = 6\n**Output:** 6\n\n**Example 2:**\n\n**Input:** n = 1, pick = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** n = 2, pick = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`\n*   `1 <= pick <= n`\"\"\"\n\n    low, high = 1, n\n    while low <= high:\n        mid = low + (high - low) // 2\n        result = guess(mid)\n        if result == 0:\n            return mid\n        elif result < 0:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1"}}}}, "18": {"gold": {"leetcode/leetcode_374.txt": 1, "leetcode/leetcode_464.txt": 1, "leetcode/leetcode_658.txt": 1}, "retrieved": {"leetcode/leetcode_975.txt": {"score": 0.8589645028114319, "content": {"text": "def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\n    \"\"\"You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called **odd-numbered jumps**, and the (2nd, 4th, 6th, ...) jumps in the series are called **even-numbered jumps**. Note that the **jumps** are numbered, not the indices.\n\nYou may jump forward from index `i` to index `j` (with `i < j`) in the following way:\n\n*   During **odd-numbered jumps** (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   During **even-numbered jumps** (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   It may be the case that for some index `i`, there are no legal jumps.\n\nA starting index is **good** if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).\n\nReturn _the number of **good** starting indices_.\n\n**Example 1:**\n\n**Input:** arr = \\[10,13,12,14,15\\]\n**Output:** 2\n**Explanation:** \nFrom starting index i = 0, we can make our 1st jump to i = 2 (since arr\\[2\\] is the smallest among arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\] that is greater or equal to arr\\[0\\]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\njumps.\n\n**Example 2:**\n\n**Input:** arr = \\[2,3,1,1,4\\]\n**Output:** 3\n**Explanation:** \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr\\[1\\] is the smallest value in \\[arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[0\\].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr\\[2\\] is the largest value in \\[arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is less than or equal to arr\\[1\\]. arr\\[3\\] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr\\[3\\] is the smallest value in \\[arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[2\\].\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\nnumber of jumps.\n\n**Example 3:**\n\n**Input:** arr = \\[5,1,3,4,2\\]\n**Output:** 3\n**Explanation:** We can reach the end from starting indices 1, 2, and 4.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 2 * 104`\n*   `0 <= arr[i] < 105`\"\"\"\n\n    if not root:\n        return 0\n    if root.val < low:\n        return self.rangeSumBST(root.right, low, high)\n    if root.val > high:\n        return self.rangeSumBST(root.left, low, high)\n    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)"}}, "leetcode/leetcode_2154.txt": {"score": 0.858985960483551, "content": {"text": "def min_moves_to_convert(s):\n    \"\"\"You are given an array of integers `nums`. You are also given an integer `original` which is the first number that needs to be searched for in `nums`.\n\nYou then do the following steps:\n\n1.  If `original` is found in `nums`, **multiply** it by two (i.e., set `original = 2 * original`).\n2.  Otherwise, **stop** the process.\n3.  **Repeat** this process with the new number as long as you keep finding the number.\n\nReturn _the **final** value of_ `original`.\n\n**Example 1:**\n\n**Input:** nums = \\[5,3,6,1,12\\], original = 3\n**Output:** 24\n**Explanation:** \n- 3 is found in nums. 3 is multiplied by 2 to obtain 6.\n- 6 is found in nums. 6 is multiplied by 2 to obtain 12.\n- 12 is found in nums. 12 is multiplied by 2 to obtain 24.\n- 24 is not found in nums. Thus, 24 is returned.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9\\], original = 4\n**Output:** 4\n**Explanation:**\n- 4 is not found in nums. Thus, 4 is returned.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i], original <= 1000`\"\"\"\n\n    count = 0\n    i = 0\n    while i < len(s) - 2:\n        if s[i] == \"X\" and s[i + 1] == \"X\" and s[i + 2] == \"X\":\n            count += 1\n            i += 3\n        else:\n            i += 1\n    return count"}}, "leetcode/leetcode_2208.txt": {"score": 0.8598302006721497, "content": {"text": "import heapq\n    \"\"\"You are given an array `nums` of positive integers. In one operation, you can choose **any** number from `nums` and reduce it to **exactly** half the number. (Note that you may choose this reduced number in future operations.)\n\nReturn _the **minimum** number of operations to reduce the sum of_ `nums` _by **at least** half._\n\n**Example 1:**\n\n**Input:** nums = \\[5,19,8,1\\]\n**Output:** 3\n**Explanation:** The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 19 and reduce it to 9.5.\nPick the number 9.5 and reduce it to 4.75.\nPick the number 8 and reduce it to 4.\nThe final array is \\[5, 4.75, 4, 1\\] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \nThe sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n\n**Example 2:**\n\n**Input:** nums = \\[3,8,20\\]\n**Output:** 3\n**Explanation:** The initial sum of nums is equal to 3 + 8 + 20 = 31.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 20 and reduce it to 10.\nPick the number 10 and reduce it to 5.\nPick the number 3 and reduce it to 1.5.\nThe final array is \\[1.5, 8, 5\\] with a total sum of 1.5 + 8 + 5 = 14.5. \nThe sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 107`\"\"\"\n\n\ndef min_operations(nums):\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n    initial_sum = sum(nums)\n    target_sum = initial_sum // 2\n    sum_so_far = 0\n    operations = 0\n\n    while sum_so_far <= target_sum:\n        largest = -heapq.heappop(max_heap)\n        sum_so_far += largest // 2\n        operations += 1\n\n    return operations"}}, "leetcode/leetcode_2139.txt": {"score": 0.8663774132728577, "content": {"text": "class DetectSquares:\n    \"\"\"You are playing a game with integers. You start with the integer `1` and you want to reach the integer `target`.\n\nIn one move, you can either:\n\n*   **Increment** the current integer by one (i.e., `x = x + 1`).\n*   **Double** the current integer (i.e., `x = 2 * x`).\n\nYou can use the **increment** operation **any** number of times, however, you can only use the **double** operation **at most** `maxDoubles` times.\n\nGiven the two integers `target` and `maxDoubles`, return _the minimum number of moves needed to reach_ `target` _starting with_ `1`.\n\n**Example 1:**\n\n**Input:** target = 5, maxDoubles = 0\n**Output:** 4\n**Explanation:** Keep incrementing by 1 until you reach target.\n\n**Example 2:**\n\n**Input:** target = 19, maxDoubles = 2\n**Output:** 7\n**Explanation:** Initially, x = 1\nIncrement 3 times so x = 4\nDouble once so x = 8\nIncrement once so x = 9\nDouble again so x = 18\nIncrement once so x = 19\n\n**Example 3:**\n\n**Input:** target = 10, maxDoubles = 4\n**Output:** 4\n**Explanation:** Initially, x = 1\nIncrement once so x = 2\nDouble once so x = 4\nIncrement once so x = 5\nDouble again so x = 10\n\n**Constraints:**\n\n*   `1 <= target <= 109`\n*   `0 <= maxDoubles <= 100`\"\"\"\n\n\n    def __init__(self):\n        self.points = collections.defaultdict(lambda: collections.defaultdict(int))\n\n    def add(self, point):\n        self.points[point[0]][point[1]] += 1\n\n    def count(self, point):\n        ans = 0\n        for x2 in self.points[point[0]]:\n            if x2 == point[1]:\n                continue\n            for y2 in self.points[x2]:\n                if y2 == point[1] or abs(x2 - point[1]) != abs(y2 - point[0]):\n                    continue\n                ans += self.points[point[0]][x2] * self.points[x2][y2] * self.points[point[0]][y2]\n        return ans"}}, "leetcode/leetcode_458.txt": {"score": 0.8866411447525024, "content": {"text": "def poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    \"\"\"There are `buckets` buckets of liquid, where **exactly one** of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n1.  Choose some live pigs to feed.\n2.  For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3.  Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n4.  After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5.  Repeat this process until you run out of time.\n\nGiven `buckets`, `minutesToDie`, and `minutesToTest`, return _the **minimum** number of pigs needed to figure out which bucket is poisonous within the allotted time_.\n\n**Example 1:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 15\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.\n\n**Example 2:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 30\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n\n**Constraints:**\n\n*   `1 <= buckets <= 1000`\n*   `1 <= minutesToDie <= minutesToTest <= 100`\"\"\"\n\n    pigs = 0\n    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:\n        pigs += 1\n    return pigs"}}, "leetcode/leetcode_1884.txt": {"score": 0.9257044792175293, "content": {"text": "def min_operations_to_alternate(s: str) -> int:\n    \"\"\"You are given **two identical** eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nIn each move, you may take an **unbroken** egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** We can drop the first egg from floor 1 and the second egg from floor 2.\nIf the first egg breaks, we know that f = 0.\nIf the second egg breaks but the first egg didn't, we know that f = 1.\nOtherwise, if both eggs survive, we know that f = 2.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 14\n**Explanation:** One optimal strategy is:\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\nRegardless of the outcome, it takes at most 14 drops to determine f.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\"\"\"\n\n    count_a, count_b = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        else:\n            if c == '0':\n                count_b += 1\n            else:\n                count_a += 1\n    return min(count_a, count_b)"}}, "leetcode/leetcode_374.txt": {"score": 0.889553427696228, "content": {"text": "def guessNumber(n):\n    \"\"\"We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.\n\n**Example 1:**\n\n**Input:** n = 10, pick = 6\n**Output:** 6\n\n**Example 2:**\n\n**Input:** n = 1, pick = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** n = 2, pick = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`\n*   `1 <= pick <= n`\"\"\"\n\n    low, high = 1, n\n    while low <= high:\n        mid = low + (high - low) // 2\n        result = guess(mid)\n        if result == 0:\n            return mid\n        elif result < 0:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1"}}, "leetcode/leetcode_375.txt": {"score": 0.9947556853294373, "content": {"text": "def getMoneyAmount(n: int) -> int:\n    \"\"\"We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 16\n**Explanation:** The winning strategy is as follows:\n- The range is \\[1,10\\]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is \\[8,10\\]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is \\[1,6\\]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is \\[4,6\\]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is \\[1,2\\]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n**Explanation:** There is only one possible number, so you can guess 1 and not have to pay anything.\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\"\"\"\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]"}}, "leetcode/leetcode_464.txt": {"score": 0.8853713274002075, "content": {"text": "def canIWin(maxChoosableInteger, desiredTotal):\n    \"\"\"In the \"100 game \" two players take turns adding, to a running total, any integer from `1` to `10`. The player who first causes the running total to **reach or exceed** 100 wins.\n\nWhat if we change the game so that players **cannot** re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers `maxChoosableInteger` and `desiredTotal`, return `true` if the first player to move can force a win, otherwise, return `false`. Assume both players play **optimally**.\n\n**Example 1:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 11\n**Output:** false\n**Explanation:**\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n\n**Example 2:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 0\n**Output:** true\n\n**Example 3:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= maxChoosableInteger <= 20`\n*   `0 <= desiredTotal <= 300`\"\"\"\n\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)"}}, "leetcode/leetcode_887.txt": {"score": 0.920417308807373, "content": {"text": "import heapq\n    \"\"\"You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nEach move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n**Example 1:**\n\n**Input:** k = 1, n = 2\n**Output:** 2\n**Explanation:** \nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n\n**Example 2:**\n\n**Input:** k = 2, n = 6\n**Output:** 3\n\n**Example 3:**\n\n**Input:** k = 3, n = 14\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= n <= 104`\"\"\"\n\n\ndef mincost_to_hire_workers(quality, wage, k):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float(\"inf\")\n\n    for ratio, q in workers:\n        heapq.heappush(max_heap, -q)\n        total_quality += q\n\n        if len(max_heap) > k:\n            total_quality += heapq.heappop(max_heap)\n\n        if len(max_heap) == k:\n            result = min(result, total_quality * ratio)\n\n    return result"}}}}, "19": {"gold": {"leetcode/leetcode_17.txt": 1}, "retrieved": {"leetcode/csn_python_train_391444.txt": {"score": 0.901662290096283, "content": {"text": "def phenotype_to_res_set(phenotype, resources):\n    \"\"\"\n    Converts a binary string to a set containing the resources indicated by\n    the bits in the string.\n\n    Inputs: phenotype - a binary string\n            resources - a list of string indicating which resources correspond\n                        to which indices of the phenotype\n\n    returns: A set of strings indicating resources\n    \"\"\"\n    assert(phenotype[0:2] == \"0b\")\n    phenotype = phenotype[2:]\n    # Fill in leading zeroes\n    while len(phenotype) < len(resources):\n        phenotype = \"0\" + phenotype\n\n    res_set = set()\n\n    for i in range(len(phenotype)):\n        if phenotype[i] == \"1\":\n            res_set.add(resources[i])\n\n    assert(phenotype.count(\"1\") == len(res_set))\n    return res_set"}}, "leetcode/csn_python_train_307461.txt": {"score": 0.9048864841461182, "content": {"text": "def bitlist_to_int(bitlist):\n    \"\"\"Convert a binary bitstring into the corresponding unsigned integer.\n\n    :param list bitlist: A list of ones of zeros.\n    :return: The corresponding integer.\n    :rtype: int\n    \"\"\"\n\n    ret = 0\n    for b in bitlist:\n        ret = (ret << 1) | (int(b) & 1)\n    return ret"}}, "leetcode/csn_python_train_236956.txt": {"score": 0.902531087398529, "content": {"text": "def as_int(self, val: Tuple[str]) -> int:\n        \"\"\"Transform a \"bits\" value to an integer.\"\"\"\n        res = 0\n        try:\n            for b in val:\n                res += 1 << self.bit[b]\n        except KeyError:\n            return None\n        return res"}}, "leetcode/leetcode_2595.txt": {"score": 0.9054336547851562, "content": {"text": "def even_odd_indices(n: int) -> List[int]:\n    \"\"\"You are given a **positive** integer `n`.\n\nLet `even` denote the number of even indices in the binary representation of `n` (**0-indexed**) with value `1`.\n\nLet `odd` denote the number of odd indices in the binary representation of `n` (**0-indexed**) with value `1`.\n\nReturn _an integer array_ `answer` _where_ `answer = [even, odd]`.\n\n**Example 1:**\n\n**Input:** n = 17\n**Output:** \\[2,0\\]\n**Explanation:** The binary representation of 17 is 10001. \nIt contains 1 on the 0th and 4th indices. \nThere are 2 even and 0 odd indices.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** \\[0,1\\]\n**Explanation:** The binary representation of 2 is 10.\nIt contains 1 on the 1st index. \nThere are 0 even and 1 odd indices.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\"\"\"\n\n    answer = [0, 0]\n    index = 0\n    while n > 0:\n        if n % 2:\n            answer[index % 2] += 1\n        n //= 2\n        index += 1\n    return answer"}}, "leetcode/leetcode_1017.txt": {"score": 0.9106813669204712, "content": {"text": "def odd_even_jumps(arr):\n    \"\"\"Given an integer `n`, return _a binary string representing its representation in base_ `-2`.\n\n**Note** that the returned string should not have leading zeros unless the string is `\"0 \"`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:**  \"110 \"\n**Explantion:** (-2)2 + (-2)1 = 2\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:**  \"111 \"\n**Explantion:** (-2)2 + (-2)1 + (-2)0 = 3\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:**  \"100 \"\n**Explantion:** (-2)2 = 4\n\n**Constraints:**\n\n*   `0 <= n <= 109`\"\"\"\n\n    n = len(arr)\n    can_reach_odd = [False] * n\n    can_reach_even = [False] * n\n    can_reach_odd[-1] = can_reach_even[-1] = True\n\n    index_map = {}\n    index_map[arr[-1]] = n - 1\n\n    good_indices = 1\n    for i in range(n - 2, -1, -1):\n        odd_jump = next(iter([value for value in index_map if value >= arr[i]]), None)\n        even_jump = next(iter([value for value in index_map if value <= arr[i]]), None)\n\n        if odd_jump is not None:\n            can_reach_odd[i] = can_reach_even[index_map[odd_jump]]\n        if even_jump is not None:\n            can_reach_even[i] = can_reach_odd[index_map[even_jump]]\n\n        if can_reach_odd[i]:\n            good_indices += 1\n\n        index_map[arr[i]] = i\n\n    return good_indices"}}, "leetcode/csn_python_train_188885.txt": {"score": 0.9295366406440735, "content": {"text": "def get_possible_splits(n):\n    \"\"\"\n    Parameters\n    ----------\n    n : int\n        n strokes were make\n    \"\"\"\n    get_bin = lambda x, n: x >= 0 and str(bin(x))[2:].zfill(n) or \"-\" + str(bin(x))[3:].zfill(n)\n    possible_splits = []\n    for i in range(2**(n - 1)):\n        possible_splits.append(get_bin(i, n - 1))\n    return possible_splits"}}, "leetcode/csn_python_train_402254.txt": {"score": 0.907215416431427, "content": {"text": "def to_binary(decimal, length):\n        \"\"\"\n        Given a decimal, generate the binary equivalent string of\n        given length.\n        e.g. binary(2, 5) = 00010\n        \"\"\"\n        b = bitstring.Bits(int=decimal, length=length)\n        return b.bin"}}, "leetcode/csn_python_train_391447.txt": {"score": 0.9222561120986938, "content": {"text": "def n_tasks(dec_num):\n    \"\"\"\n    Takes a decimal number as input and returns the number of ones in the\n    binary representation.\n    This translates to the number of tasks being done by an organism with a\n    phenotype represented as a decimal number.\n    \"\"\"\n    bitstring = \"\"\n    try:\n        bitstring = dec_num[2:]\n    except:\n        bitstring = bin(int(dec_num))[2:]  # cut off 0b\n    # print bin(int(dec_num)), bitstring\n    return bitstring.count(\"1\")"}}, "leetcode/csn_python_train_221334.txt": {"score": 0.910526692867279, "content": {"text": "def binary_to_int(binary_list, lower_bound=0, upper_bound=None):\n    \"\"\"Return the base 10 integer corresponding to a binary list.\n\n   The maximum value is determined by the number of bits in binary_list,\n   and upper_bound. The greater allowed by the two.\n\n    Args:\n        binary_list: list<int>; List of 0s and 1s.\n        lower_bound: Minimum value for output, inclusive.\n            A binary list of 0s will have this value.\n        upper_bound: Maximum value for output, inclusive.\n            If greater than this bound, we \"bounce back\".\n            Ex. w/ upper_bound = 2: [0, 1, 2, 2, 1, 0]\n            Ex.\n                raw_integer = 11, upper_bound = 10, return = 10\n                raw_integer = 12, upper_bound = 10, return = 9\n\n    Returns:\n        int; Integer value of the binary input.\n    \"\"\"\n    # Edge case for empty binary_list\n    if binary_list == []:\n        # With 0 bits, only one value can be represented,\n        # and we default to lower_bound\n        return lower_bound\n    else:\n        # The builtin int construction can take a base argument,\n        # but it requires a string,\n        # so we convert our binary list to a string\n        integer = int(''.join([str(bit) for bit in binary_list]), 2)\n\n    # Trim if over upper_bound\n    if (upper_bound is not None) and integer + lower_bound > upper_bound:\n        # Bounce back. Ex. w/ upper_bound = 2: [0, 1, 2, 2, 1, 0]\n        return upper_bound - (integer % (upper_bound - lower_bound + 1))\n    else:\n        # Not over upper_bound\n        return integer + lower_bound"}}, "leetcode/leetcode_401.txt": {"score": 0.9888747930526733, "content": {"text": "def readBinaryWatch(turnedOn: int):\n    \"\"\"A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n*   For example, the below binary watch reads `\"4:51 \"`.\n\nGiven an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in **any order**.\n\nThe hour must not contain a leading zero.\n\n*   For example, `\"01:00 \"` is not valid. It should be `\"1:00 \"`.\n\nThe minute must be consist of two digits and may contain a leading zero.\n\n*   For example, `\"10:2 \"` is not valid. It should be `\"10:02 \"`.\n\n**Example 1:**\n\n**Input:** turnedOn = 1\n**Output:** \\[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"\\]\n\n**Example 2:**\n\n**Input:** turnedOn = 9\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `0 <= turnedOn <= 10`\"\"\"\n\n    def count_bits(n):\n        return bin(n).count('1')\n\n    times = []\n    for h in range(12):\n        for m in range(60):\n            if count_bits(h) + count_bits(m) == turnedOn:\n                times.append(f\"{h}:{m:02d}\")\n    return times"}}}}, "20": {"gold": {"leetcode/leetcode_315.txt": 1, "leetcode/leetcode_2512.txt": 1}, "retrieved": {"leetcode/leetcode_1701.txt": {"score": 0.8664173483848572, "content": {"text": "def maxNumEdgesToRemove(n, edges):\n    \"\"\"There is a restaurant with a single chef. You are given an array `customers`, where `customers[i] = [arrivali, timei]:`\n\n*   `arrivali` is the arrival time of the `ith` customer. The arrival times are sorted in **non-decreasing** order.\n*   `timei` is the time needed to prepare the order of the `ith` customer.\n\nWhen a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers **in the order they were given in the input**.\n\nReturn _the **average** waiting time of all customers_. Solutions within `10-5` from the actual answer are considered accepted.\n\n**Example 1:**\n\n**Input:** customers = \\[\\[1,2\\],\\[2,5\\],\\[4,3\\]\\]\n**Output:** 5.00000\n**Explanation:**\n1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.\n2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.\n3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.\nSo the average waiting time = (2 + 6 + 7) / 3 = 5.\n\n**Example 2:**\n\n**Input:** customers = \\[\\[5,2\\],\\[5,4\\],\\[10,3\\],\\[20,1\\]\\]\n**Output:** 3.25000\n**Explanation:**\n1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.\n2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.\n3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.\n4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.\nSo the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.\n\n**Constraints:**\n\n*   `1 <= customers.length <= 105`\n*   `1 <= arrivali, timei <= 104`\n*   `arrivali <= arrivali+1`\"\"\"\n\n    def find(u):\n        if parent[u] == u:\n            return u\n        else:\n            parent[u] = find(parent[u])\n            return parent[u]\n\n    def unite(u, v):\n        u = find(u)\n        v = find(v)\n        if u != v:\n            parent[u] = v\n            return True\n        return False\n\n    parent = list(range(2 * n + 1))\n    ct = [0, 0]\n    both = n - 1\n    edges.sort(reverse=True)\n    for edge in edges:\n        type, u, v = edge\n        if type == 3 and unite(u, v + n):\n            both -= 1\n        if both == 0:\n            break\n\n    for type in range(1, 3):\n        for edge in edges:\n            a, u, v = edge\n            if a == type and unite(u, v + n):\n                ct[type - 1] += 1\n        if both + ct[type - 1] < n - 1:\n            return -1\n\n    return ct[0] + ct[1] - n + 1"}}, "leetcode/leetcode_2073.txt": {"score": 0.8749739527702332, "content": {"text": "def time_to_buy_tickets(tickets, k):\n    \"\"\"There are `n` people in a line queuing to buy tickets, where the `0th` person is at the **front** of the line and the `(n - 1)th` person is at the **back** of the line.\n\nYou are given a **0-indexed** integer array `tickets` of length `n` where the number of tickets that the `ith` person would like to buy is `tickets[i]`.\n\nEach person takes **exactly 1 second** to buy a ticket. A person can only buy **1 ticket at a time** and has to go back to **the end** of the line (which happens **instantaneously**) in order to buy more tickets. If a person does not have any tickets left to buy, the person will **leave** the line.\n\nReturn _the **time taken** for the person at position_ `k` **_(0-indexed)_** _to finish buying tickets_.\n\n**Example 1:**\n\n**Input:** tickets = \\[2,3,2\\], k = 2\n**Output:** 6\n**Explanation:** \n- In the first pass, everyone in the line buys a ticket and the line becomes \\[1, 2, 1\\].\n- In the second pass, everyone in the line buys a ticket and the line becomes \\[0, 1, 0\\].\nThe person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n\n**Example 2:**\n\n**Input:** tickets = \\[5,1,1,1\\], k = 0\n**Output:** 8\n**Explanation:**\n- In the first pass, everyone in the line buys a ticket and the line becomes \\[4, 0, 0, 0\\].\n- In the next 4 passes, only the person in position 0 is buying tickets.\nThe person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.\n\n**Constraints:**\n\n*   `n == tickets.length`\n*   `1 <= n <= 100`\n*   `1 <= tickets[i] <= 100`\n*   `0 <= k < n`\"\"\"\n\n    time = 0\n    while tickets[k] > 0:\n        for i in range(len(tickets)):\n            if tickets[i] > 0:\n                tickets[i] -= 1\n                time += 1\n                if i == k and tickets[k] == 0:\n                    break\n    return time"}}, "leetcode/leetcode_769.txt": {"score": 0.8684878945350647, "content": {"text": "def orderOfLargestPlusSign(n, mines):\n    \"\"\"You are given an integer array `arr` of length `n` that represents a permutation of the integers in the range `[0, n - 1]`.\n\nWe split `arr` into some number of **chunks** (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\n\nReturn _the largest number of chunks we can make to sort the array_.\n\n**Example 1:**\n\n**Input:** arr = \\[4,3,2,1,0\\]\n**Output:** 1\n**Explanation:**\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into \\[4, 3\\], \\[2, 1, 0\\] will result in \\[3, 4, 0, 1, 2\\], which isn't sorted.\n\n**Example 2:**\n\n**Input:** arr = \\[1,0,2,3,4\\]\n**Output:** 4\n**Explanation:**\nWe can split into two chunks, such as \\[1, 0\\], \\[2, 3, 4\\].\nHowever, splitting into \\[1, 0\\], \\[2\\], \\[3\\], \\[4\\] is the highest number of chunks possible.\n\n**Constraints:**\n\n*   `n == arr.length`\n*   `1 <= n <= 10`\n*   `0 <= arr[i] < n`\n*   All the elements of `arr` are **unique**.\"\"\"\n\n    grid = [[1] * n for _ in range(n)]\n    for mine in mines:\n        grid[mine[0]][mine[1]] = 0\n        \n    left, right, up, down = [list(grid) for _ in range(4)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j]:\n                left[i][j] = 1 + (left[i][j - 1] if j > 0 else 0)\n                up[i][j] = 1 + (up[i - 1][j] if i > 0 else 0)\n\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j]:\n                right[i][j] = 1 + (right[i][j + 1] if j < n - 1 else 0)\n                down[i][j] = 1 + (down[i + 1][j] if i < n - 1 else 0)\n                ans = max(ans, min([left[i][j], right[i][j], up[i][j], down[i][j]]))\n\n    return ans"}}, "leetcode/leetcode_1846.txt": {"score": 0.8810672163963318, "content": {"text": "def maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:\n    \"\"\"You are given an array of positive integers `arr`. Perform some operations (possibly none) on `arr` so that it satisfies these conditions:\n\n*   The value of the **first** element in `arr` must be `1`.\n*   The absolute difference between any 2 adjacent elements must be **less than or equal to** `1`. In other words, `abs(arr[i] - arr[i - 1]) <= 1` for each `i` where `1 <= i < arr.length` (**0-indexed**). `abs(x)` is the absolute value of `x`.\n\nThere are 2 types of operations that you can perform any number of times:\n\n*   **Decrease** the value of any element of `arr` to a **smaller positive integer**.\n*   **Rearrange** the elements of `arr` to be in any order.\n\nReturn _the **maximum** possible value of an element in_ `arr` _after performing the operations to satisfy the conditions_.\n\n**Example 1:**\n\n**Input:** arr = \\[2,2,1,2,1\\]\n**Output:** 2\n**Explanation:** \nWe can satisfy the conditions by rearranging `arr` so it becomes `[1,2,2,2,1]`.\nThe largest element in `arr` is 2.\n\n**Example 2:**\n\n**Input:** arr = \\[100,1,1000\\]\n**Output:** 3\n**Explanation:** \nOne possible way to satisfy the conditions is by doing the following:\n1. Rearrange `arr` so it becomes `[1,100,1000]`.\n2. Decrease the value of the second element to 2.\n3. Decrease the value of the third element to 3.\nNow `arr = [1,2,3], which` satisfies the conditions.\nThe largest element in `arr is 3.`\n\n**Example 3:**\n\n**Input:** arr = \\[1,2,3,4,5\\]\n**Output:** 5\n**Explanation:** The array already satisfies the conditions, and the largest element is 5.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i] <= 109`\"\"\"\n\n    arr.sort()\n    arr[0] = 1\n    for i in range(1, len(arr)):\n        arr[i] = min(arr[i], arr[i - 1] + 1)\n    return arr[-1]"}}, "leetcode/leetcode_2202.txt": {"score": 0.8863253593444824, "content": {"text": "def to_base_k(num, k):\n    \"\"\"You are given a **0-indexed** integer array `nums` representing the contents of a **pile**, where `nums[0]` is the topmost element of the pile.\n\nIn one move, you can perform **either** of the following:\n\n*   If the pile is not empty, **remove** the topmost element of the pile.\n*   If there are one or more removed elements, **add** any one of them back onto the pile. This element becomes the new topmost element.\n\nYou are also given an integer `k`, which denotes the total number of moves to be made.\n\nReturn _the **maximum value** of the topmost element of the pile possible after **exactly**_ `k` _moves_. In case it is not possible to obtain a non-empty pile after `k` moves, return `-1`.\n\n**Example 1:**\n\n**Input:** nums = \\[5,2,2,4,0,6\\], k = 4\n**Output:** 5\n**Explanation:**\nOne of the ways we can end with 5 at the top of the pile after 4 moves is as follows:\n- Step 1: Remove the topmost element = 5. The pile becomes \\[2,2,4,0,6\\].\n- Step 2: Remove the topmost element = 2. The pile becomes \\[2,4,0,6\\].\n- Step 3: Remove the topmost element = 2. The pile becomes \\[4,0,6\\].\n- Step 4: Add 5 back onto the pile. The pile becomes \\[5,4,0,6\\].\nNote that this is not the only way to end with 5 at the top of the pile. It can be shown that 5 is the largest answer possible after 4 moves.\n\n**Example 2:**\n\n**Input:** nums = \\[2\\], k = 1\n**Output:** -1\n**Explanation:** \nIn the first move, our only option is to pop the topmost element of the pile.\nSince it is not possible to obtain a non-empty pile after one move, we return -1.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i], k <= 109`\"\"\"\n\n    base_k_num = ''\n    while num:\n        base_k_num = str(num % k) + base_k_num\n        num //= k\n    return base_k_num\n\ndef is_k_mirror(num, k):\n    base_10_num = str(num)\n    base_k_num = to_base_k(num, k)\n    return base_10_num == base_10_num[::-1] and base_k_num == base_k_num[::-1]\n\ndef sum_k_mirror_numbers(k, n):\n    total = 0\n    num = 0\n    while n:\n        if is_k_mirror(num, k):\n            total += num\n            n -= 1\n        num += 1\n    return total"}}, "leetcode/leetcode_950.txt": {"score": 0.8961694836616516, "content": {"text": "from collections import Counter\n    \"\"\"You are given an integer array `deck`. There is a deck of cards where every card has a unique integer. The integer on the `ith` card is `deck[i]`.\n\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\n\nYou will do the following steps repeatedly until all cards are revealed:\n\n1.  Take the top card of the deck, reveal it, and take it out of the deck.\n2.  If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\n3.  If there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\nReturn _an ordering of the deck that would reveal the cards in increasing order_.\n\n**Note** that the first entry in the answer is considered to be the top of the deck.\n\n**Example 1:**\n\n**Input:** deck = \\[17,13,11,2,3,5,7\\]\n**Output:** \\[2,13,3,11,5,17,7\\]\n**Explanation:** \nWe get the deck in the order \\[17,13,11,2,3,5,7\\] (this order does not matter), and reorder it.\nAfter reordering, the deck starts as \\[2,13,3,11,5,17,7\\], where 2 is the top of the deck.\nWe reveal 2, and move 13 to the bottom.  The deck is now \\[3,11,5,17,7,13\\].\nWe reveal 3, and move 11 to the bottom.  The deck is now \\[5,17,7,13,11\\].\nWe reveal 5, and move 17 to the bottom.  The deck is now \\[7,13,11,17\\].\nWe reveal 7, and move 13 to the bottom.  The deck is now \\[11,17,13\\].\nWe reveal 11, and move 17 to the bottom.  The deck is now \\[13,17\\].\nWe reveal 13, and move 17 to the bottom.  The deck is now \\[17\\].\nWe reveal 17.\nSince all the cards revealed are in increasing order, the answer is correct.\n\n**Example 2:**\n\n**Input:** deck = \\[1,1000\\]\n**Output:** \\[1,1000\\]\n\n**Constraints:**\n\n*   `1 <= deck.length <= 1000`\n*   `1 <= deck[i] <= 106`\n*   All the values of `deck` are **unique**.\"\"\"\n\nfrom math import gcd\nfrom functools import reduce\n\ndef hasGroupsSizeX(deck):\n    counts = Counter(deck)\n    gcd_result = reduce(gcd, counts.values())\n    return gcd_result > 1"}}, "leetcode/leetcode_946.txt": {"score": 0.8929425477981567, "content": {"text": "def minimum_score(nums, k):\n    \"\"\"Given two integer arrays `pushed` and `popped` each with distinct values, return `true` _if this could have been the result of a sequence of push and pop operations on an initially empty stack, or_ `false` _otherwise._\n\n**Example 1:**\n\n**Input:** pushed = \\[1,2,3,4,5\\], popped = \\[4,5,3,2,1\\]\n**Output:** true\n**Explanation:** We might do the following sequence:\npush(1), push(2), push(3), push(4),\npop() -> 4,\npush(5),\npop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\n**Example 2:**\n\n**Input:** pushed = \\[1,2,3,4,5\\], popped = \\[4,3,5,1,2\\]\n**Output:** false\n**Explanation:** 1 cannot be popped before 2.\n\n**Constraints:**\n\n*   `1 <= pushed.length <= 1000`\n*   `0 <= pushed[i] <= 1000`\n*   All the elements of `pushed` are **unique**.\n*   `popped.length == pushed.length`\n*   `popped` is a permutation of `pushed`.\"\"\"\n\n    nums.sort()\n    n = len(nums)\n    res = nums[n - 1] - nums[0]\n\n    for i in range(n - 1):\n        high = max(nums[i] + k, nums[n - 1] - k)\n        low = min(nums[i + 1] - k, nums[0] + k)\n        res = min(res, high - low)\n\n    return res"}}, "leetcode/leetcode_1441.txt": {"score": 0.905159592628479, "content": {"text": "def build_array(target, n):\n    \"\"\"You are given an integer array `target` and an integer `n`.\n\nYou have an empty stack with the two following operations:\n\n*   **`\"Push \"`**: pushes an integer to the top of the stack.\n*   **`\"Pop \"`**: removes the integer on the top of the stack.\n\nYou also have a stream of the integers in the range `[1, n]`.\n\nUse the two stack operations to make the numbers in the stack (from the bottom to the top) equal to `target`. You should follow the following rules:\n\n*   If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.\n*   If the stack is not empty, pop the integer at the top of the stack.\n*   If, at any moment, the elements in the stack (from the bottom to the top) are equal to `target`, do not read new integers from the stream and do not do more operations on the stack.\n\nReturn _the stack operations needed to build_ `target` following the mentioned rules. If there are multiple valid answers, return **any of them**.\n\n**Example 1:**\n\n**Input:** target = \\[1,3\\], n = 3\n**Output:** \\[ \"Push \", \"Push \", \"Pop \", \"Push \"\\]\n**Explanation:** Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = \\[1\\].\nRead 2 from the stream and push it to the stack. s = \\[1,2\\].\nPop the integer on the top of the stack. s = \\[1\\].\nRead 3 from the stream and push it to the stack. s = \\[1,3\\].\n\n**Example 2:**\n\n**Input:** target = \\[1,2,3\\], n = 3\n**Output:** \\[ \"Push \", \"Push \", \"Push \"\\]\n**Explanation:** Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = \\[1\\].\nRead 2 from the stream and push it to the stack. s = \\[1,2\\].\nRead 3 from the stream and push it to the stack. s = \\[1,2,3\\].\n\n**Example 3:**\n\n**Input:** target = \\[1,2\\], n = 4\n**Output:** \\[ \"Push \", \"Push \"\\]\n**Explanation:** Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = \\[1\\].\nRead 2 from the stream and push it to the stack. s = \\[1,2\\].\nSince the stack (from the bottom to the top) is equal to target, we stop the stack operations.\nThe answers that read integer 3 from the stream are not accepted.\n\n**Constraints:**\n\n*   `1 <= target.length <= 100`\n*   `1 <= n <= 100`\n*   `1 <= target[i] <= n`\n*   `target` is strictly increasing.\"\"\"\n\n    result = []\n    current = 1\n    for num in target:\n        while current < num:\n            result.append(\"Push \")\n            result.append(\"Pop \")\n            current += 1\n        result.append(\"Push \")\n        current += 1\n    return result"}}, "leetcode/csn_python_train_3814.txt": {"score": 0.9374207854270935, "content": {"text": "def reconstruct_queue(people):\n    \"\"\"\n    :type people: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n    for h, k in people:\n        queue.insert(k, [h, k])\n    return queue"}}, "leetcode/leetcode_406.txt": {"score": 0.9988697171211243, "content": {"text": "from typing import List\n    \"\"\"You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with **exactly** `ki` other people in front who have a height greater than or equal to `hi`.\n\nReconstruct and return _the queue that is represented by the input array_ `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).\n\n**Example 1:**\n\n**Input:** people = \\[\\[7,0\\],\\[4,4\\],\\[7,1\\],\\[5,0\\],\\[6,1\\],\\[5,2\\]\\]\n**Output:** \\[\\[5,0\\],\\[7,0\\],\\[5,2\\],\\[6,1\\],\\[4,4\\],\\[7,1\\]\\]\n**Explanation:**\nPerson 0 has height 5 with no other people taller or the same height in front.\nPerson 1 has height 7 with no other people taller or the same height in front.\nPerson 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.\nPerson 3 has height 6 with one person taller or the same height in front, which is person 1.\nPerson 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.\nPerson 5 has height 7 with one person taller or the same height in front, which is person 1.\nHence \\[\\[5,0\\],\\[7,0\\],\\[5,2\\],\\[6,1\\],\\[4,4\\],\\[7,1\\]\\] is the reconstructed queue.\n\n**Example 2:**\n\n**Input:** people = \\[\\[6,0\\],\\[5,0\\],\\[4,0\\],\\[3,2\\],\\[2,2\\],\\[1,4\\]\\]\n**Output:** \\[\\[4,0\\],\\[5,0\\],\\[2,2\\],\\[3,2\\],\\[1,4\\],\\[6,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= people.length <= 2000`\n*   `0 <= hi <= 106`\n*   `0 <= ki < people.length`\n*   It is guaranteed that the queue can be reconstructed.\"\"\"\n\n\ndef reconstructQueue(people: List[List[int]]) -> List[List[int]]:\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    result = []\n    for p in people:\n        result.insert(p[1], p)\n    return result"}}}}, "21": {"gold": {"leetcode/leetcode_695.txt": 1, "leetcode/leetcode_733.txt": 1, "leetcode/leetcode_1034.txt": 1}, "retrieved": {"leetcode/csn_python_train_3863.txt": {"score": 0.9091690182685852, "content": {"text": "def pacific_atlantic(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[List[int]]\n    \"\"\"\n    n = len(matrix)\n    if not n: return []\n    m = len(matrix[0])\n    if not m: return []\n    res = []\n    atlantic = [[False for _ in range (n)] for _ in range(m)]\n    pacific =  [[False for _ in range (n)] for _ in range(m)]\n    for i in range(n):\n        dfs(pacific, matrix, float(\"-inf\"), i, 0)\n        dfs(atlantic, matrix, float(\"-inf\"), i, m-1)\n    for i in range(m):\n        dfs(pacific, matrix, float(\"-inf\"), 0, i)\n        dfs(atlantic, matrix, float(\"-inf\"), n-1, i)\n    for i in range(n):\n        for j in range(m):\n            if pacific[i][j] and atlantic[i][j]:\n                res.append([i, j])\n    return res"}}, "leetcode/csn_python_train_320968.txt": {"score": 0.9101411700248718, "content": {"text": "def dfs_grid(grid, i, j, mark='X', free='.'):\n    \"\"\"DFS on a grid, mark connected component, iterative version\n\n    :param grid: matrix, 4-neighborhood\n    :param i,j: cell in this matrix, start of DFS exploration\n    :param free: symbol for walkable cells\n    :param mark: symbol to overwrite visited vertices\n    :complexity: linear\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    to_visit = [(i, j)]\n    grid[i][j] = mark\n    while to_visit:\n        i1, j1 = to_visit.pop()\n        for i2, j2 in [(i1 + 1, j1), (i1, j1 + 1),\n                       (i1 - 1, j1), (i1, j1 - 1)]:\n            if (0 <= i2 < height and 0 <= j2 < width and\n                    grid[i2][j2] == free):\n                grid[i2][j2] = mark  # mark path\n                to_visit.append((i2, j2))"}}, "leetcode/leetcode_130.txt": {"score": 0.9138451814651489, "content": {"text": "class Solution:\n    \"\"\"Given an `m x n` matrix `board` containing `'X'` and `'O'`, _capture all regions that are 4-directionally surrounded by_ `'X'`.\n\nA region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"O \", \"X \"\\],\\[ \"X \", \"X \", \"O \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"X \"\\]\\]\n**Output:** \\[\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"X \"\\]\\]\n**Explanation:** Notice that an 'O' should not be flipped if:\n- It is on the border, or\n- It is adjacent to an 'O' that should not be flipped.\nThe bottom 'O' is on the border, so it is not flipped.\nThe other three 'O' form a surrounded region, so they are flipped.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \"X \"\\]\\]\n**Output:** \\[\\[ \"X \"\\]\\]\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 200`\n*   `board[i][j]` is `'X'` or `'O'`.\"\"\"\n\n    def solve(self, board: List[List[str]]) -> None:\n        if not board:\n            return\n        m, n = len(board), len(board[0])\n\n        def dfs(x, y):\n            if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != 'O':\n                return\n            board[x][y] = '#'\n            dfs(x - 1, y)\n            dfs(x + 1, y)\n            dfs(x, y - 1)\n            dfs(x, y + 1)\n\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for i in range(n):\n            dfs(0, i)\n            dfs(m - 1, i)\n\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '#':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"}}, "leetcode/leetcode_1034.txt": {"score": 0.9257174134254456, "content": {"text": "def good_subarrays(nums, k):\n    \"\"\"You are given an `m x n` integer matrix `grid`, and three integers `row`, `col`, and `color`. Each value in the grid represents the color of the grid square at that location.\n\nTwo squares belong to the same **connected component** if they have the same color and are next to each other in any of the 4 directions.\n\nThe **border of a connected component** is all the squares in the connected component that are either **4-directionally** adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\n\nYou should color the **border** of the **connected component** that contains the square `grid[row][col]` with `color`.\n\nReturn _the final grid_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\n**Output:** \\[\\[3,3\\],\\[3,2\\]\\]\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,2\\],\\[2,3,2\\]\\], row = 0, col = 1, color = 3\n**Output:** \\[\\[1,3,3\\],\\[2,3,3\\]\\]\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], row = 1, col = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j], color <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        frequency = {}\n        for j in range(i, len(nums)):\n            frequency[nums[j]] = frequency.get(nums[j], 0) + 1\n            if len(frequency) > k:\n                break\n            if len(frequency) == k:\n                count += 1\n    return count"}}, "leetcode/leetcode_1391.txt": {"score": 0.9263488054275513, "content": {"text": "def hasValidPath(grid):\n    \"\"\"You are given an `m x n` `grid`. Each cell of `grid` represents a street. The street of `grid[i][j]` can be:\n\n*   `1` which means a street connecting the left cell and the right cell.\n*   `2` which means a street connecting the upper cell and the lower cell.\n*   `3` which means a street connecting the left cell and the lower cell.\n*   `4` which means a street connecting the right cell and the lower cell.\n*   `5` which means a street connecting the left cell and the upper cell.\n*   `6` which means a street connecting the right cell and the upper cell.\n\nYou will initially start at the street of the upper-left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)`. **The path should only follow the streets**.\n\n**Notice** that you are **not allowed** to change any street.\n\nReturn `true` _if there is a valid path in the grid or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[2,4,3\\],\\[6,5,2\\]\\]\n**Output:** true\n**Explanation:** As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,1\\],\\[1,2,1\\]\\]\n**Output:** false\n**Explanation:** As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,2\\]\\]\n**Output:** false\n**Explanation:** You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `1 <= grid[i][j] <= 6`\"\"\"\n\n    m, n = len(grid), len(grid[0])\n\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    allowed = [[], [0, 2], [1, 3], [0, 1], [0, 3], [1, 2], [1, 0]]\n\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        visited[i][j] = True\n        for dir in allowed[grid[i][j]]:\n            x, y = i + directions[dir][0], j + directions[dir][1]\n            if 0 <= x < m and 0 <= y < n and not visited[x][y] and (dir + 2) % 4 in allowed[grid[x][y]]:\n                if dfs(x, y):\n                    return True\n        return False\n\n    return dfs(0, 0)"}}, "leetcode/leetcode_749.txt": {"score": 0.9353926181793213, "content": {"text": "def shortest_completing_word(license_plate, words):\n    \"\"\"A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as an `m x n` binary grid `isInfected`, where `isInfected[i][j] == 0` represents uninfected cells, and `isInfected[i][j] == 1` represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two **4-directionally** adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There **will never be a tie**.\n\nReturn _the number of walls used to quarantine all the infected regions_. If the world will become fully infected, return the number of walls used.\n\n**Example 1:**\n\n**Input:** isInfected = \\[\\[0,1,0,0,0,0,0,1\\],\\[0,1,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 10\n**Explanation:** There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n \nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n \n\n**Example 2:**\n\n**Input:** isInfected = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 4\n**Explanation:** Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n**Example 3:**\n\n**Input:** isInfected = \\[\\[1,1,1,0,0,0,0,0,0\\],\\[1,0,1,0,1,1,1,1,1\\],\\[1,1,1,0,0,0,0,0,0\\]\\]\n**Output:** 13\n**Explanation:** The region on the left only builds two new walls.\n\n**Constraints:**\n\n*   `m == isInfected.length`\n*   `n == isInfected[i].length`\n*   `1 <= m, n <= 50`\n*   `isInfected[i][j]` is either `0` or `1`.\n*   There is always a contiguous viral region throughout the described process that will **infect strictly more uncontaminated squares** in the next round.\"\"\"\n\n    target = [0] * 26\n    for c in license_plate:\n        if c.isalpha():\n            target[ord(c.lower()) - ord('a')] += 1\n\n    result = \"\"\n    for word in words:\n        current = [0] * 26\n        for c in word:\n            if c.isalpha():\n                current[ord(c.lower()) - ord('a')] += 1\n\n        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):\n            result = word\n\n    return result"}}, "leetcode/csn_python_train_338935.txt": {"score": 0.920975923538208, "content": {"text": "def walk_perimeter(self, startx, starty):\n        \"\"\"\n        Starting at a point on the perimeter of a region, 'walk' the perimeter to return\n        to the starting point. Record the path taken.\n\n        Parameters\n        ----------\n        startx, starty : int\n            The starting location. Assumed to be on the perimeter of a region.\n\n        Returns\n        -------\n        perimeter : list\n            A list of pixel coordinates [ [x1,y1], ...] that constitute the perimeter of the region.\n        \"\"\"\n        # checks\n        startx = max(startx, 0)\n        startx = min(startx, self.xsize)\n        starty = max(starty, 0)\n        starty = min(starty, self.ysize)\n\n        points = []\n\n        x, y = startx, starty\n\n        while True:\n            self.step(x, y)\n            if 0 <= x <= self.xsize and 0 <= y <= self.ysize:\n                points.append((x, y))\n            if self.next == self.UP:\n                y -= 1\n            elif self.next == self.LEFT:\n                x -= 1\n            elif self.next == self.DOWN:\n                y += 1\n            elif self.next == self.RIGHT:\n                x += 1\n            # stop if we meet some kind of error\n            elif self.next == self.NOWHERE:\n                break\n            # stop when we return to the starting location\n            if x == startx and y == starty:\n                break\n        return points"}}, "leetcode/leetcode_1992.txt": {"score": 0.94652259349823, "content": {"text": "def findFarmland(land):\n    \"\"\"You are given a **0-indexed** `m x n` binary matrix `land` where a `0` represents a hectare of forested land and a `1` represents a hectare of farmland.\n\nTo keep the land organized, there are designated rectangular areas of hectares that consist **entirely** of farmland. These rectangular areas are called **groups**. No two groups are adjacent, meaning farmland in one group is **not** four-directionally adjacent to another farmland in a different group.\n\n`land` can be represented by a coordinate system where the top left corner of `land` is `(0, 0)` and the bottom right corner of `land` is `(m-1, n-1)`. Find the coordinates of the top left and bottom right corner of each **group** of farmland. A **group** of farmland with a top left corner at `(r1, c1)` and a bottom right corner at `(r2, c2)` is represented by the 4-length array `[r1, c1, r2, c2].`\n\nReturn _a 2D array containing the 4-length arrays described above for each **group** of farmland in_ `land`_. If there are no groups of farmland, return an empty array. You may return the answer in **any order**_.\n\n**Example 1:**\n\n**Input:** land = \\[\\[1,0,0\\],\\[0,1,1\\],\\[0,1,1\\]\\]\n**Output:** \\[\\[0,0,0,0\\],\\[1,1,2,2\\]\\]\n**Explanation:**\nThe first group has a top left corner at land\\[0\\]\\[0\\] and a bottom right corner at land\\[0\\]\\[0\\].\nThe second group has a top left corner at land\\[1\\]\\[1\\] and a bottom right corner at land\\[2\\]\\[2\\].\n\n**Example 2:**\n\n**Input:** land = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** \\[\\[0,0,1,1\\]\\]\n**Explanation:**\nThe first group has a top left corner at land\\[0\\]\\[0\\] and a bottom right corner at land\\[1\\]\\[1\\].\n\n**Example 3:**\n\n**Input:** land = \\[\\[0\\]\\]\n**Output:** \\[\\]\n**Explanation:**\nThere are no groups of farmland.\n\n**Constraints:**\n\n*   `m == land.length`\n*   `n == land[i].length`\n*   `1 <= m, n <= 300`\n*   `land` consists of only `0`'s and `1`'s.\n*   Groups of farmland are **rectangular** in shape.\"\"\"\n\n    m, n = len(land), len(land[0])\n    groups = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r1, c1 = i, j\n                while j + 1 < n and land[i][j + 1] == 1:\n                    j += 1\n                r2, c2 = i, j\n                while r2 + 1 < m and land[r2 + 1][j] == 1:\n                    r2 += 1\n                for r in range(r1, r2 + 1):\n                    for c in range(c1, c2 + 1):\n                        land[r][c] = 0\n                groups.append([r1, c1, r2, c2])\n\n    return groups"}}, "leetcode/leetcode_1020.txt": {"score": 0.934317946434021, "content": {"text": "def maxTurbulenceSize(arr):\n    \"\"\"You are given an `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell.\n\nA **move** consists of walking from one land cell to another adjacent (**4-directionally**) land cell or walking off the boundary of the `grid`.\n\nReturn _the number of land cells in_ `grid` _for which we cannot walk off the boundary of the grid in any number of **moves**_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[1,0,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 0\n**Explanation:** All 1s are either on the boundary or can reach the boundary.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\n\nFor i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is odd, and arr\\[k\\] < arr\\[k + 1\\] when k is even. OR For i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is even, and arr\\[k\\] < arr\\[k + 1\\] when k is odd.\"\"\"\n\n    n = len(arr)\n    result = 1\n    i = 0\n\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 1\n            continue\n\n        j = i + 1\n        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):\n            j += 1\n        \n        result = max(result, j - i + 1)\n        i = j\n\n    return result"}}, "leetcode/leetcode_463.txt": {"score": 0.9960425496101379, "content": {"text": "def islandPerimeter(grid):\n    \"\"\"You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.\"\"\"\n\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter"}}}}, "22": {"gold": {"leetcode/leetcode_375.txt": 1, "leetcode/leetcode_486.txt": 1}, "retrieved": {"leetcode/leetcode_1686.txt": {"score": 0.9041540026664734, "content": {"text": "def stoneGameVI(aliceValues, bobValues):\n    \"\"\"Alice and Bob take turns playing a game, with Alice starting first.\n\nThere are `n` stones in a pile. On each player's turn, they can **remove** a stone from the pile and receive points based on the stone's value. Alice and Bob may **value the stones differently**.\n\nYou are given two integer arrays of length `n`, `aliceValues` and `bobValues`. Each `aliceValues[i]` and `bobValues[i]` represents how Alice and Bob, respectively, value the `ith` stone.\n\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play **optimally**. Both players know the other's values.\n\nDetermine the result of the game, and:\n\n*   If Alice wins, return `1`.\n*   If Bob wins, return `-1`.\n*   If the game results in a draw, return `0`.\n\n**Example 1:**\n\n**Input:** aliceValues = \\[1,3\\], bobValues = \\[2,1\\]\n**Output:** 1\n**Explanation:**\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.\n\n**Example 2:**\n\n**Input:** aliceValues = \\[1,2\\], bobValues = \\[3,1\\]\n**Output:** 0\n**Explanation:**\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.\n\n**Example 3:**\n\n**Input:** aliceValues = \\[2,4,3\\], bobValues = \\[1,6,7\\]\n**Output:** -1\n**Explanation:**\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins.\n\n**Constraints:**\n\n*   `n == aliceValues.length == bobValues.length`\n*   `1 <= n <= 105`\n*   `1 <= aliceValues[i], bobValues[i] <= 100`\"\"\"\n\n    n = len(aliceValues)\n    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceSum, bobSum = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            aliceSum += aliceValues[diff[i][1]]\n        else:\n            bobSum += bobValues[diff[i][1]]\n            \n    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)"}}, "leetcode/leetcode_1025.txt": {"score": 0.9154438972473145, "content": {"text": "def mincostTickets(days, costs):\n    \"\"\"Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there is a number `n` on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n*   Choosing any `x` with `0 < x < n` and `n % x == 0`.\n*   Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso, if a player cannot make a move, they lose the game.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** true\n**Explanation:** Alice chooses 1, and Bob has no more moves.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** false\n**Explanation:** Alice chooses 1, Bob chooses 1, and Alice has no more moves.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\"\"\"\n\n  travel_days = set(days)\n  dp = [0] * 366\n\n  for i in range(1, 366):\n    if i not in travel_days:\n      dp[i] = dp[i - 1]\n    else:\n      dp[i] = min(dp[i - 1] + costs[0],\n                  dp[max(0, i - 7)] + costs[1],\n                  dp[max(0, i - 30)] + costs[2])\n\n  return dp[365]"}}, "leetcode/leetcode_1406.txt": {"score": 0.9135953783988953, "content": {"text": "def stoneGameIII(stoneValue):\n    \"\"\"Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\n\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n\nAssume Alice and Bob **play optimally**.\n\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n\n**Example 1:**\n\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n\n**Example 2:**\n\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n\n**Example 3:**\n\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`\"\"\"\n\n    n = len(stoneValue)\n    dp = [float(\"-inf\")] * (n + 1)\n    dp[n] = 0\n    \n    for i in range(n - 1, -1, -1):\n        curr = 0\n        for j in range(3):\n            if i + j < n:\n                curr += stoneValue[i + j]\n                dp[i] = max(dp[i], curr - dp[i + j + 1])\n                \n    return \"Tie \" if dp[0] == 0 else \"Alice \" if dp[0] > 0 else \"Bob \""}}, "leetcode/leetcode_1753.txt": {"score": 0.9161936640739441, "content": {"text": "import heapq\n    \"\"\"You are playing a solitaire game with **three piles** of stones of sizes `a`\u200b\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two **different non-empty** piles, take one stone from each, and add `1` point to your score. The game stops when there are **fewer than two non-empty** piles (meaning there are no more available moves).\n\nGiven three integers `a`\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b, return _the_ **_maximum_** _**score** you can get._\n\n**Example 1:**\n\n**Input:** a = 2, b = 4, c = 6\n**Output:** 6\n**Explanation:** The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points.\n\n**Example 2:**\n\n**Input:** a = 4, b = 4, c = 6\n**Output:** 7\n**Explanation:** The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points.\n\n**Example 3:**\n\n**Input:** a = 1, b = 8, c = 8\n**Output:** 8\n**Explanation:** One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 105`\"\"\"\n\nfrom typing import List\n\ndef minimumEffortPath(heights: List[List[int]]) -> int:\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    rows = len(heights)\n    cols = len(heights[0])\n    efforts = [[float('inf')] * cols for _ in range(rows)]\n\n    q = [(0, 0, 0)]\n    efforts[0][0] = 0\n    \n    while q:\n        effort, x, y = heapq.heappop(q)\n        \n        if x == rows - 1 and y == cols - 1:\n            return effort\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_effort = max(effort, abs(heights[nx][ny] - heights[x][y]))\n                if new_effort < efforts[nx][ny]:\n                    efforts[nx][ny] = new_effort\n                    heapq.heappush(q, (new_effort, nx, ny))\n    \n    return -1"}}, "leetcode/leetcode_877.txt": {"score": 0.9202654361724854, "content": {"text": "from collections import deque, defaultdict\n    \"\"\"Alice and Bob play a game with piles of stones. There are an **even** number of piles arranged in a row, and each pile has a **positive** integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones. The **total** number of stones across all the piles is **odd**, so there are no ties.\n\nAlice and Bob take turns, with **Alice starting first**. Each turn, a player takes the entire pile of stones either from the **beginning** or from the **end** of the row. This continues until there are no more piles left, at which point the person with the **most stones wins**.\n\nAssuming Alice and Bob play optimally, return `true` _if Alice wins the game, or_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** piles = \\[5,3,4,5\\]\n**Output:** true\n**Explanation:** \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes \\[3, 4, 5\\].\nIf Bob takes 3, then the board is \\[4, 5\\], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is \\[3, 4\\], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\n**Example 2:**\n\n**Input:** piles = \\[3,7,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `2 <= piles.length <= 500`\n*   `piles.length` is **even**.\n*   `1 <= piles[i] <= 500`\n*   `sum(piles[i])` is **odd**.\"\"\"\n\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    q = deque()\n    \n    for i in range(n):\n        q.append((i, 1 << i))\n    steps = -1\n    visited = {i: set() for i in range(n)}\n    \n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            currNode, currVisits = q.popleft()\n            \n            if bin(currVisits).count('1') == n:\n                return steps\n\n            for nextNode in graph[currNode]:\n                nextVisits = currVisits | (1 << nextNode)\n\n                if nextVisits not in visited[nextNode]:\n                    visited[nextNode].add(nextVisits)\n                    q.append((nextNode, nextVisits))\n\n    return -1"}}, "leetcode/leetcode_2029.txt": {"score": 0.9525343179702759, "content": {"text": "def stoneGameIX(stones: List[int]) -> bool:\n    \"\"\"Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array `stones`, where `stones[i]` is the **value** of the `ith` stone.\n\nAlice and Bob take turns, with **Alice** starting first. On each turn, the player may remove any stone from `stones`. The player who removes a stone **loses** if the **sum** of the values of **all removed stones** is divisible by `3`. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\n\nAssuming both players play **optimally**, return `true` _if Alice wins and_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** stones = \\[2,1\\]\n**Output:** true\n**Explanation:** The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\n\n**Example 2:**\n\n**Input:** stones = \\[2\\]\n**Output:** false\n**Explanation:** Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\n\n**Example 3:**\n\n**Input:** stones = \\[5,1,2,4,3\\]\n**Output:** false\n**Explanation:** Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n\n**Constraints:**\n\n*   `1 <= stones.length <= 105`\n*   `1 <= stones[i] <= 104`\"\"\"\n\n    cnt = [0, 0, 0]\n    for s in stones:\n        cnt[s % 3] += 1\n    return (cnt[1] and cnt[2]) or (cnt[1] > cnt[2] if cnt[1] > cnt[2] + 2 else cnt[2] > cnt[1] + 1)"}}, "leetcode/leetcode_1927.txt": {"score": 0.9151068925857544, "content": {"text": "def max_ascending_sum(nums):\n    \"\"\"Alice and Bob take turns playing a game, with **Alice** **starting first**.\n\nYou are given a string `num` of **even length** consisting of digits and `'?'` characters. On each turn, a player will do the following if there is still at least one `'?'` in `num`:\n\n1.  Choose an index `i` where `num[i] == '?'`.\n2.  Replace `num[i]` with any digit between `'0'` and `'9'`.\n\nThe game ends when there are no more `'?'` characters in `num`.\n\nFor Bob to win, the sum of the digits in the first half of `num` must be **equal** to the sum of the digits in the second half. For Alice to win, the sums must **not be equal**.\n\n*   For example, if the game ended with `num = \"243801 \"`, then Bob wins because `2+4+3 = 8+0+1`. If the game ended with `num = \"243803 \"`, then Alice wins because `2+4+3 != 8+0+3`.\n\nAssuming Alice and Bob play **optimally**, return `true` _if Alice will win and_ `false` _if Bob will win_.\n\n**Example 1:**\n\n**Input:** num =  \"5023 \"\n**Output:** false\n**Explanation:** There are no moves to be made.\nThe sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3.\n\n**Example 2:**\n\n**Input:** num =  \"25?? \"\n**Output:** true\n**Explanation:** Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal.\n\n**Example 3:**\n\n**Input:** num =  \"?3295??? \"\n**Output:** false\n**Explanation:** It can be proven that Bob will always win. One possible outcome is:\n- Alice replaces the first '?' with '9'. num =  \"93295??? \".\n- Bob replaces one of the '?' in the right half with '9'. num =  \"932959?? \".\n- Alice replaces one of the '?' in the right half with '2'. num =  \"9329592? \".\n- Bob replaces the last '?' in the right half with '7'. num =  \"93295927 \".\nBob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.\n\n**Constraints:**\n\n*   `2 <= num.length <= 105`\n*   `num.length` is **even**.\n*   `num` consists of only digits and `'?'`.\"\"\"\n\n    max_sum = current_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_sum += nums[i]\n        else:\n            max_sum = max(max_sum, current_sum)\n            current_sum = nums[i]\n\n    return max(max_sum, current_sum)"}}, "leetcode/leetcode_464.txt": {"score": 0.9931848645210266, "content": {"text": "def canIWin(maxChoosableInteger, desiredTotal):\n    \"\"\"In the \"100 game \" two players take turns adding, to a running total, any integer from `1` to `10`. The player who first causes the running total to **reach or exceed** 100 wins.\n\nWhat if we change the game so that players **cannot** re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers `maxChoosableInteger` and `desiredTotal`, return `true` if the first player to move can force a win, otherwise, return `false`. Assume both players play **optimally**.\n\n**Example 1:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 11\n**Output:** false\n**Explanation:**\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n\n**Example 2:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 0\n**Output:** true\n\n**Example 3:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= maxChoosableInteger <= 20`\n*   `0 <= desiredTotal <= 300`\"\"\"\n\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)"}}, "leetcode/leetcode_1140.txt": {"score": 0.9217685461044312, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`\"\"\"\n\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes"}}, "leetcode/leetcode_486.txt": {"score": 0.9302465915679932, "content": {"text": "def can_win(nums):\n    \"\"\"You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,2\\]\n**Output:** false\n**Explanation:** Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,233,7\\]\n**Output:** true\n**Explanation:** Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 107`\"\"\"\n\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = nums[i]\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n    return dp[0][n - 1] >= 0"}}}}, "23": {"gold": {"leetcode/leetcode_2397.txt": 1}, "retrieved": {"leetcode/leetcode_2491.txt": {"score": 0.8904958367347717, "content": {"text": "def maximumChemistry(skill):\n    \"\"\"You are given a positive integer array `skill` of **even** length `n` where `skill[i]` denotes the skill of the `ith` player. Divide the players into `n / 2` teams of size `2` such that the total skill of each team is **equal**.\n\nThe **chemistry** of a team is equal to the **product** of the skills of the players on that team.\n\nReturn _the sum of the **chemistry** of all the teams, or return_ `-1` _if there is no way to divide the players into teams such that the total skill of each team is equal._\n\n**Example 1:**\n\n**Input:** skill = \\[3,2,5,1,3,4\\]\n**Output:** 22\n**Explanation:** \nDivide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\nThe sum of the chemistry of all the teams is: 1 \\* 5 + 2 \\* 4 + 3 \\* 3 = 5 + 8 + 9 = 22.\n\n**Example 2:**\n\n**Input:** skill = \\[3,4\\]\n**Output:** 12\n**Explanation:** \nThe two players form a team with a total skill of 7.\nThe chemistry of the team is 3 \\* 4 = 12.\n\n**Example 3:**\n\n**Input:** skill = \\[1,1,2,3\\]\n**Output:** -1\n**Explanation:** \nThere is no way to divide the players into teams such that the total skill of each team is equal.\n\n**Constraints:**\n\n*   `2 <= skill.length <= 105`\n*   `skill.length` is even.\n*   `1 <= skill[i] <= 1000`\"\"\"\n\n    total_sum = sum(skill)\n    target_sum = total_sum // 2\n    if total_sum % 2 == 1:\n        return -1\n\n    dp = {0: 1}\n    max_chemistry = 0\n\n    for s in skill:\n        for i in range(target_sum - s, -1, -1):\n            if i in dp:\n                dp[i + s] = dp.get(i + s, 0) + dp[i]\n                if i + s == target_sum:\n                    max_chemistry += dp[i] * s\n\n    return max_chemistry if max_chemistry > 0 else -1"}}, "leetcode/leetcode_1395.txt": {"score": 0.8915305137634277, "content": {"text": "def minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    \"\"\"There are `n` soldiers standing in a line. Each soldier is assigned a **unique** `rating` value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\n*   Choose 3 soldiers with index (`i`, `j`, `k`) with rating (`rating[i]`, `rating[j]`, `rating[k]`).\n*   A team is valid if: (`rating[i] < rating[j] < rating[k]`) or (`rating[i] > rating[j] > rating[k]`) where (`0 <= i < j < k < n`).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\n**Example 1:**\n\n**Input:** rating = \\[2,5,3,4,1\\]\n**Output:** 3\n**Explanation:** We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\n**Example 2:**\n\n**Input:** rating = \\[2,1,3\\]\n**Output:** 0\n**Explanation:** We can't form any team given the conditions.\n\n**Example 3:**\n\n**Input:** rating = \\[1,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `n == rating.length`\n*   `3 <= n <= 1000`\n*   `1 <= rating[i] <= 105`\n*   All the integers in `rating` are **unique**.\n\nIn one second, you can either: - Move vertically by one unit, - Move horizontally by one unit, or - Move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in one second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points, but they do not count as visited unless you stop on them.\"\"\"\n\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        time += max(dx, dy)\n    return time"}}, "leetcode/leetcode_1105.txt": {"score": 0.8917973041534424, "content": {"text": "def max_uncrossed_lines(nums1, nums2):\n    \"\"\"You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`.\n\nWe want to place these books in order onto bookcase shelves that have a total width `shelfWidth`.\n\nWe choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n\nNote that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n*   For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\nReturn _the minimum possible height that the total bookshelf can be after placing shelves in this manner_.\n\n**Example 1:**\n\n**Input:** books = \\[\\[1,1\\],\\[2,3\\],\\[2,3\\],\\[1,1\\],\\[1,1\\],\\[1,1\\],\\[1,2\\]\\], shelfWidth = 4\n**Output:** 6\n**Explanation:**\nThe sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n**Example 2:**\n\n**Input:** books = \\[\\[1,3\\],\\[2,4\\],\\[3,2\\]\\], shelfWidth = 6\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= books.length <= 1000`\n*   `1 <= thicknessi <= shelfWidth <= 1000`\n*   `1 <= heighti <= 1000`\"\"\"\n\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]"}}, "leetcode/leetcode_1024.txt": {"score": 0.8924309015274048, "content": {"text": "def count_and_triples(nums):\n    \"\"\"You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n*   For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** clips = \\[\\[0,2\\],\\[4,6\\],\\[8,10\\],\\[1,9\\],\\[1,5\\],\\[5,9\\]\\], time = 10\n**Output:** 3\n**Explanation:** We take the clips \\[0,2\\], \\[8,10\\], \\[1,9\\]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut \\[1,9\\] into segments \\[1,2\\] + \\[2,8\\] + \\[8,9\\].\nNow we have segments \\[0,2\\] + \\[2,8\\] + \\[8,10\\] which cover the sporting event \\[0, 10\\].\n\n**Example 2:**\n\n**Input:** clips = \\[\\[0,1\\],\\[1,2\\]\\], time = 5\n**Output:** -1\n**Explanation:** We cannot cover \\[0,5\\] with only \\[0,1\\] and \\[1,2\\].\n\n**Example 3:**\n\n**Input:** clips = \\[\\[0,1\\],\\[6,8\\],\\[0,2\\],\\[5,6\\],\\[0,4\\],\\[0,3\\],\\[6,7\\],\\[1,3\\],\\[4,7\\],\\[1,4\\],\\[2,5\\],\\[2,6\\],\\[3,4\\],\\[4,5\\],\\[5,7\\],\\[6,9\\]\\], time = 9\n**Output:** 3\n**Explanation:** We can take clips \\[0,4\\], \\[4,7\\], and \\[6,9\\].\n\n**Constraints:**\n\n*   `1 <= clips.length <= 100`\n*   `0 <= starti <= endi <= 100`\n*   `1 <= time <= 100`\n\n0 <= i < j < k < nums.length, and nums\\[i\\] & nums\\[j\\] & nums\\[k\\] != 0. (\\`&\\` represents the bitwise AND operation.)\"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count"}}, "leetcode/leetcode_939.txt": {"score": 0.9034489393234253, "content": {"text": "def find_valid_permutations(s: str) -> int:\n    \"\"\"You are given an array of points in the **X-Y** plane `points` where `points[i] = [xi, yi]`.\n\nReturn _the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes_. If there is not any such rectangle, return `0`.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[1,3\\],\\[3,1\\],\\[3,3\\],\\[2,2\\]\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[1,3\\],\\[3,1\\],\\[3,3\\],\\[4,1\\],\\[4,3\\]\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= points.length <= 500`\n*   `points[i].length == 2`\n*   `0 <= xi, yi <= 4 * 104`\n*   All the given points are **unique**.\"\"\"\n\n    n = len(s)\n    MOD = 1000000007\n    dp = [0] * (n + 2)\n    dp[0] = 1\n\n    for c in s:\n        new_dp = [0] * (n + 2)\n        if c == 'I':\n            for i in range(n):\n                new_dp[i + 1] = (new_dp[i + 1] + dp[i]) % MOD\n        else:\n            for i in range(n - 1, -1, -1):\n                new_dp[i] = (new_dp[i + 1] + dp[i + 1]) % MOD\n        dp = new_dp\n\n    return dp[0]"}}, "leetcode/leetcode_1640.txt": {"score": 0.8959518074989319, "content": {"text": "def canFormArray(arr, pieces):\n    \"\"\"You are given an array of **distinct** integers `arr` and an array of integer arrays `pieces`, where the integers in `pieces` are **distinct**. Your goal is to form `arr` by concatenating the arrays in `pieces` **in any order**. However, you are **not** allowed to reorder the integers in each array `pieces[i]`.\n\nReturn `true` _if it is possible_ _to form the array_ `arr` _from_ `pieces`. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** arr = \\[15,88\\], pieces = \\[\\[88\\],\\[15\\]\\]\n**Output:** true\n**Explanation:** Concatenate \\[15\\] then \\[88\\]\n\n**Example 2:**\n\n**Input:** arr = \\[49,18,16\\], pieces = \\[\\[16,18,49\\]\\]\n**Output:** false\n**Explanation:** Even though the numbers match, we cannot reorder pieces\\[0\\].\n\n**Example 3:**\n\n**Input:** arr = \\[91,4,64,78\\], pieces = \\[\\[78\\],\\[4,64\\],\\[91\\]\\]\n**Output:** true\n**Explanation:** Concatenate \\[91\\] then \\[4,64\\] then \\[78\\]\n\n**Constraints:**\n\n*   `1 <= pieces.length <= arr.length <= 100`\n*   `sum(pieces[i].length) == arr.length`\n*   `1 <= pieces[i].length <= arr.length`\n*   `1 <= arr[i], pieces[i][j] <= 100`\n*   The integers in `arr` are **distinct**.\n*   The integers in `pieces` are **distinct** (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).\"\"\"\n\n    map = {piece[0]: piece for piece in pieces}\n\n    i = 0\n    while i < len(arr):\n        if arr[i] not in map:\n            return False\n        piece = map[arr[i]]\n        for num in piece:\n            if num != arr[i]:\n                return False\n            i += 1\n    return True"}}, "leetcode/leetcode_492.txt": {"score": 0.8984718322753906, "content": {"text": "def constructRectangle(area: int) -> List[int]:\n    \"\"\"A web developer needs to know how to design a web page's size. So, given a specific rectangular web page's area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n1.  The area of the rectangular web page you designed must equal to the given target area.\n2.  The width `W` should not be larger than the length `L`, which means `L >= W`.\n3.  The difference between length `L` and width `W` should be as small as possible.\n\nReturn _an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence._\n\n**Example 1:**\n\n**Input:** area = 4\n**Output:** \\[2,2\\]\n**Explanation:** The target area is 4, and all the possible ways to construct it are \\[1,4\\], \\[2,2\\], \\[4,1\\]. \nBut according to requirement 2, \\[1,4\\] is illegal; according to requirement 3,  \\[4,1\\] is not optimal compared to \\[2,2\\]. So the length L is 2, and the width W is 2.\n\n**Example 2:**\n\n**Input:** area = 37\n**Output:** \\[37,1\\]\n\n**Example 3:**\n\n**Input:** area = 122122\n**Output:** \\[427,286\\]\n\n**Constraints:**\n\n*   `1 <= area <= 107`\"\"\"\n\n    width = int(area**0.5)\n    while area % width != 0:\n        width -= 1\n    length = area // width\n    return [length, width]"}}, "leetcode/leetcode_914.txt": {"score": 0.9020009636878967, "content": {"text": "import random\n    \"\"\"You are given an integer array `deck` where `deck[i]` represents the number written on the `ith` card.\n\nPartition the cards into **one or more groups** such that:\n\n*   Each group has **exactly** `x` cards where `x > 1`, and\n*   All the cards in one group have the same integer written on them.\n\nReturn `true` _if such partition is possible, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** deck = \\[1,2,3,4,4,3,2,1\\]\n**Output:** true\n**Explanation**: Possible partition \\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\].\n\n**Example 2:**\n\n**Input:** deck = \\[1,1,1,2,2,2,3,3\\]\n**Output:** false\n**Explanation**: No possible partition.\n\n**Constraints:**\n\n*   `1 <= deck.length <= 104`\n*   `0 <= deck[i] < 104`\"\"\"\n\nfrom bisect import bisect_left\n\nclass Solution:\n    def __init__(self, rects):\n        self.rects = rects\n        self.areas = []\n        self.total_area = 0\n        for rect in rects:\n            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n            self.total_area += area\n            self.areas.append(self.total_area)\n\n    def pick(self):\n        random_area = random.randint(0, self.total_area - 1)\n        rect_index = bisect_left(self.areas, random_area + 1)\n\n        x = random.randint(self.rects[rect_index][0], self.rects[rect_index][2])\n        y = random.randint(self.rects[rect_index][1], self.rects[rect_index][3])\n\n        return [x, y]"}}, "leetcode/leetcode_1725.txt": {"score": 0.9058566093444824, "content": {"text": "def numberOfSets(n, k):\n    \"\"\"You are given an array `rectangles` where `rectangles[i] = [li, wi]` represents the `ith` rectangle of length `li` and width `wi`.\n\nYou can cut the `ith` rectangle to form a square with a side length of `k` if both `k <= li` and `k <= wi`. For example, if you have a rectangle `[4,6]`, you can cut it to get a square with a side length of at most `4`.\n\nLet `maxLen` be the side length of the **largest** square you can obtain from any of the given rectangles.\n\nReturn _the **number** of rectangles that can make a square with a side length of_ `maxLen`.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[5,8\\],\\[3,9\\],\\[5,12\\],\\[16,5\\]\\]\n**Output:** 3\n**Explanation:** The largest squares you can get from each rectangle are of lengths \\[5,3,5,5\\].\nThe largest possible square is of length 5, and you can get it out of 3 rectangles.\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[2,3\\],\\[3,7\\],\\[4,3\\],\\[3,7\\]\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= rectangles.length <= 1000`\n*   `rectangles[i].length == 2`\n*   `1 <= li, wi <= 109`\n*   `li != wi`\"\"\"\n\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n)]\n    presum = [1] * n\n    \n    for j in range(1, k + 1):\n        for i in range(n):\n            dp[i][j] = presum[i]\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= mod\n            presum[i] = (presum[i] + dp[i][j - 1]) % mod\n    \n    return dp[n - 1][k]"}}, "leetcode/leetcode_473.txt": {"score": 0.9749280214309692, "content": {"text": "from itertools import chain\n    \"\"\"You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use **all the matchsticks** to make one square. You **should not break** any stick, but you can link them up, and each matchstick must be used **exactly one time**.\n\nReturn `true` if you can make this square and `false` otherwise.\n\n**Example 1:**\n\n**Input:** matchsticks = \\[1,1,2,2,2\\]\n**Output:** true\n**Explanation:** You can form a square with length 2, one side of the square came two sticks with length 1.\n\n**Example 2:**\n\n**Input:** matchsticks = \\[3,3,3,3,4\\]\n**Output:** false\n**Explanation:** You cannot find a way to form a square with all the matchsticks.\n\n**Constraints:**\n\n*   `1 <= matchsticks.length <= 15`\n*   `1 <= matchsticks[i] <= 108`\"\"\"\n\n\ndef makesquare(matchsticks):\n    if len(matchsticks) < 4:\n        return False\n    total = sum(matchsticks)\n    if total % 4:\n        return False\n    target = total // 4\n    matchsticks.sort(reverse=True)\n    sums = [0]*4\n    return dfs(matchsticks, sums, target, 0)\n\ndef dfs(matchsticks, sums, target, index):\n    if index == len(matchsticks):\n        return sums[0] == target and sums[1] == target and sums[2] == target\n    for i in range(4):\n        if sums[i] + matchsticks[index] <= target:\n            sums[i] += matchsticks[index]\n            if dfs(matchsticks, sums, target, index + 1):\n                return True\n            sums[i] -= matchsticks[index]\n    return False"}}}}, "24": {"gold": {"leetcode/leetcode_464.txt": 1}, "retrieved": {"leetcode/leetcode_1686.txt": {"score": 0.9256900548934937, "content": {"text": "def stoneGameVI(aliceValues, bobValues):\n    \"\"\"Alice and Bob take turns playing a game, with Alice starting first.\n\nThere are `n` stones in a pile. On each player's turn, they can **remove** a stone from the pile and receive points based on the stone's value. Alice and Bob may **value the stones differently**.\n\nYou are given two integer arrays of length `n`, `aliceValues` and `bobValues`. Each `aliceValues[i]` and `bobValues[i]` represents how Alice and Bob, respectively, value the `ith` stone.\n\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play **optimally**. Both players know the other's values.\n\nDetermine the result of the game, and:\n\n*   If Alice wins, return `1`.\n*   If Bob wins, return `-1`.\n*   If the game results in a draw, return `0`.\n\n**Example 1:**\n\n**Input:** aliceValues = \\[1,3\\], bobValues = \\[2,1\\]\n**Output:** 1\n**Explanation:**\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.\n\n**Example 2:**\n\n**Input:** aliceValues = \\[1,2\\], bobValues = \\[3,1\\]\n**Output:** 0\n**Explanation:**\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.\n\n**Example 3:**\n\n**Input:** aliceValues = \\[2,4,3\\], bobValues = \\[1,6,7\\]\n**Output:** -1\n**Explanation:**\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins.\n\n**Constraints:**\n\n*   `n == aliceValues.length == bobValues.length`\n*   `1 <= n <= 105`\n*   `1 <= aliceValues[i], bobValues[i] <= 100`\"\"\"\n\n    n = len(aliceValues)\n    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceSum, bobSum = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            aliceSum += aliceValues[diff[i][1]]\n        else:\n            bobSum += bobValues[diff[i][1]]\n            \n    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)"}}, "leetcode/leetcode_1753.txt": {"score": 0.9366747736930847, "content": {"text": "import heapq\n    \"\"\"You are playing a solitaire game with **three piles** of stones of sizes `a`\u200b\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two **different non-empty** piles, take one stone from each, and add `1` point to your score. The game stops when there are **fewer than two non-empty** piles (meaning there are no more available moves).\n\nGiven three integers `a`\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b, return _the_ **_maximum_** _**score** you can get._\n\n**Example 1:**\n\n**Input:** a = 2, b = 4, c = 6\n**Output:** 6\n**Explanation:** The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points.\n\n**Example 2:**\n\n**Input:** a = 4, b = 4, c = 6\n**Output:** 7\n**Explanation:** The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points.\n\n**Example 3:**\n\n**Input:** a = 1, b = 8, c = 8\n**Output:** 8\n**Explanation:** One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 105`\"\"\"\n\nfrom typing import List\n\ndef minimumEffortPath(heights: List[List[int]]) -> int:\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    rows = len(heights)\n    cols = len(heights[0])\n    efforts = [[float('inf')] * cols for _ in range(rows)]\n\n    q = [(0, 0, 0)]\n    efforts[0][0] = 0\n    \n    while q:\n        effort, x, y = heapq.heappop(q)\n        \n        if x == rows - 1 and y == cols - 1:\n            return effort\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_effort = max(effort, abs(heights[nx][ny] - heights[x][y]))\n                if new_effort < efforts[nx][ny]:\n                    efforts[nx][ny] = new_effort\n                    heapq.heappush(q, (new_effort, nx, ny))\n    \n    return -1"}}, "leetcode/leetcode_1563.txt": {"score": 0.9300671815872192, "content": {"text": "from math import acos, cos, sin, sqrt\n    \"\"\"There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially **zero**.\n\nReturn _the maximum score that Alice can obtain_.\n\n**Example 1:**\n\n**Input:** stoneValue = \\[6,2,3,4,5,5\\]\n**Output:** 18\n**Explanation:** In the first round, Alice divides the row to \\[6,2,3\\], \\[4,5,5\\]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to \\[6\\], \\[2,3\\]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is \\[2\\], \\[3\\]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\n**Example 2:**\n\n**Input:** stoneValue = \\[7,7,7,7,7,7,7\\]\n**Output:** 28\n\n**Example 3:**\n\n**Input:** stoneValue = \\[4\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 500`\n*   `1 <= stoneValue[i] <= 106`\"\"\"\n\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts"}}, "leetcode/leetcode_1140.txt": {"score": 0.9463015198707581, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`\"\"\"\n\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes"}}, "leetcode/leetcode_1406.txt": {"score": 0.9382989406585693, "content": {"text": "def stoneGameIII(stoneValue):\n    \"\"\"Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\n\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n\nAssume Alice and Bob **play optimally**.\n\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n\n**Example 1:**\n\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n\n**Example 2:**\n\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n\n**Example 3:**\n\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`\"\"\"\n\n    n = len(stoneValue)\n    dp = [float(\"-inf\")] * (n + 1)\n    dp[n] = 0\n    \n    for i in range(n - 1, -1, -1):\n        curr = 0\n        for j in range(3):\n            if i + j < n:\n                curr += stoneValue[i + j]\n                dp[i] = max(dp[i], curr - dp[i + j + 1])\n                \n    return \"Tie \" if dp[0] == 0 else \"Alice \" if dp[0] > 0 else \"Bob \""}}, "leetcode/leetcode_877.txt": {"score": 0.9502415657043457, "content": {"text": "from collections import deque, defaultdict\n    \"\"\"Alice and Bob play a game with piles of stones. There are an **even** number of piles arranged in a row, and each pile has a **positive** integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones. The **total** number of stones across all the piles is **odd**, so there are no ties.\n\nAlice and Bob take turns, with **Alice starting first**. Each turn, a player takes the entire pile of stones either from the **beginning** or from the **end** of the row. This continues until there are no more piles left, at which point the person with the **most stones wins**.\n\nAssuming Alice and Bob play optimally, return `true` _if Alice wins the game, or_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** piles = \\[5,3,4,5\\]\n**Output:** true\n**Explanation:** \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes \\[3, 4, 5\\].\nIf Bob takes 3, then the board is \\[4, 5\\], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is \\[3, 4\\], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\n**Example 2:**\n\n**Input:** piles = \\[3,7,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `2 <= piles.length <= 500`\n*   `piles.length` is **even**.\n*   `1 <= piles[i] <= 500`\n*   `sum(piles[i])` is **odd**.\"\"\"\n\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    q = deque()\n    \n    for i in range(n):\n        q.append((i, 1 << i))\n    steps = -1\n    visited = {i: set() for i in range(n)}\n    \n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            currNode, currVisits = q.popleft()\n            \n            if bin(currVisits).count('1') == n:\n                return steps\n\n            for nextNode in graph[currNode]:\n                nextVisits = currVisits | (1 << nextNode)\n\n                if nextVisits not in visited[nextNode]:\n                    visited[nextNode].add(nextVisits)\n                    q.append((nextNode, nextVisits))\n\n    return -1"}}, "leetcode/leetcode_2029.txt": {"score": 0.9328515529632568, "content": {"text": "def stoneGameIX(stones: List[int]) -> bool:\n    \"\"\"Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array `stones`, where `stones[i]` is the **value** of the `ith` stone.\n\nAlice and Bob take turns, with **Alice** starting first. On each turn, the player may remove any stone from `stones`. The player who removes a stone **loses** if the **sum** of the values of **all removed stones** is divisible by `3`. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\n\nAssuming both players play **optimally**, return `true` _if Alice wins and_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** stones = \\[2,1\\]\n**Output:** true\n**Explanation:** The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\n\n**Example 2:**\n\n**Input:** stones = \\[2\\]\n**Output:** false\n**Explanation:** Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\n\n**Example 3:**\n\n**Input:** stones = \\[5,1,2,4,3\\]\n**Output:** false\n**Explanation:** Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n\n**Constraints:**\n\n*   `1 <= stones.length <= 105`\n*   `1 <= stones[i] <= 104`\"\"\"\n\n    cnt = [0, 0, 0]\n    for s in stones:\n        cnt[s % 3] += 1\n    return (cnt[1] and cnt[2]) or (cnt[1] > cnt[2] if cnt[1] > cnt[2] + 2 else cnt[2] > cnt[1] + 1)"}}, "leetcode/leetcode_1872.txt": {"score": 0.9510561227798462, "content": {"text": "def can_eat(candiesCount, queries):\n    \"\"\"Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, while the number of stones is **more than one**, they will do the following:\n\n1.  Choose an integer `x > 1`, and **remove** the leftmost `x` stones from the row.\n2.  Add the **sum** of the **removed** stones' values to the player's score.\n3.  Place a **new stone**, whose value is equal to that sum, on the left side of the row.\n\nThe game stops when **only** **one** stone is left in the row.\n\nThe **score difference** between Alice and Bob is `(Alice's score - Bob's score)`. Alice's goal is to **maximize** the score difference, and Bob's goal is the **minimize** the score difference.\n\nGiven an integer array `stones` of length `n` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **score difference** between Alice and Bob if they both play **optimally**._\n\n**Example 1:**\n\n**Input:** stones = \\[-1,2,-3,4,-5\\]\n**Output:** 5\n**Explanation:**\n- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of\n  value 2 on the left. stones = \\[2,-5\\].\n- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on\n  the left. stones = \\[-3\\].\nThe difference between their scores is 2 - (-3) = 5.\n\n**Example 2:**\n\n**Input:** stones = \\[7,-6,5,10,5,-2,-6\\]\n**Output:** 13\n**Explanation:**\n- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a\n  stone of value 13 on the left. stones = \\[13\\].\nThe difference between their scores is 13 - 0 = 13.\n\n**Example 3:**\n\n**Input:** stones = \\[-10,-12\\]\n**Output:** -22\n**Explanation:**\n- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her\n  score and places a stone of value -22 on the left. stones = \\[-22\\].\nThe difference between their scores is (-22) - 0 = -22.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 105`\n*   `-104 <= stones[i] <= 104`\"\"\"\n\n    prefix_sum = [0] * (len(candiesCount) + 1)\n    for i in range(len(candiesCount)):\n        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]\n\n    result = [False] * len(queries)\n    for i in range(len(queries)):\n        favoriteType, favoriteDay, dailyCap = queries[i]\n        x1 = favoriteDay + 1\n        y1 = (favoriteDay + 1) * dailyCap\n\n        x2 = prefix_sum[favoriteType] + 1\n        y2 = prefix_sum[favoriteType + 1]\n\n        result[i] = not (x1 > y2 or y1 < x2)\n\n    return result"}}, "leetcode/leetcode_1690.txt": {"score": 0.9568455815315247, "content": {"text": "def getMaxLen(nums):\n    \"\"\"Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, they can **remove** either the leftmost stone or the rightmost stone from the row and receive points equal to the **sum** of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.\n\nBob found that he will always lose this game (poor Bob, he always loses), so he decided to **minimize the score's difference**. Alice's goal is to **maximize the difference** in the score.\n\nGiven an array of integers `stones` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **difference** in Alice and Bob's score if they both play **optimally**._\n\n**Example 1:**\n\n**Input:** stones = \\[5,3,1,4,2\\]\n**Output:** 6\n**Explanation:** \n- Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = \\[5,3,1,4\\].\n- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = \\[3,1,4\\].\n- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = \\[1,4\\].\n- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = \\[4\\].\n- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = \\[\\].\nThe score difference is 18 - 12 = 6.\n\n**Example 2:**\n\n**Input:** stones = \\[7,90,5,1,100,10,10,2\\]\n**Output:** 122\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 1000`\n*   `1 <= stones[i] <= 1000`\"\"\"\n\n    maxLength = currentLen = currentNegLen = 0\n    \n    for num in nums:\n        if num > 0:\n            currentLen += 1\n            if currentNegLen > 0:\n                currentNegLen += 1\n        elif num < 0:\n            currentLen, currentNegLen = currentNegLen, currentLen + 1\n        else:\n            currentLen = currentNegLen = 0\n        maxLength = max(maxLength, currentLen)\n    \n    return maxLength"}}, "leetcode/leetcode_486.txt": {"score": 0.9977572560310364, "content": {"text": "def can_win(nums):\n    \"\"\"You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,2\\]\n**Output:** false\n**Explanation:** Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,233,7\\]\n**Output:** true\n**Explanation:** Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 107`\"\"\"\n\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = nums[i]\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n    return dp[0][n - 1] >= 0"}}}}, "25": {"gold": {"leetcode/leetcode_2542.txt": 1}, "retrieved": {"leetcode/leetcode_1833.txt": {"score": 0.9096113443374634, "content": {"text": "def largestAltitude(gain):\n    \"\"\"It is a sweltering summer day, and a boy wants to buy some ice cream bars.\n\nAt the store, there are `n` ice cream bars. You are given an array `costs` of length `n`, where `costs[i]` is the price of the `ith` ice cream bar in coins. The boy initially has `coins` coins to spend, and he wants to buy as many ice cream bars as possible.\n\n**Note:** The boy can buy the ice cream bars in any order.\n\nReturn _the **maximum** number of ice cream bars the boy can buy with_ `coins` _coins._\n\nYou must solve the problem by counting sort.\n\n**Example 1:**\n\n**Input:** costs = \\[1,3,2,4,1\\], coins = 7\n**Output:** 4\n**Explanation:** The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.\n\n**Example 2:**\n\n**Input:** costs = \\[10,6,8,7,7,8\\], coins = 5\n**Output:** 0\n**Explanation:** The boy cannot afford any of the ice cream bars.\n\n**Example 3:**\n\n**Input:** costs = \\[1,6,3,1,2,5\\], coins = 20\n**Output:** 6\n**Explanation:** The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.\n\n**Constraints:**\n\n*   `costs.length == n`\n*   `1 <= n <= 105`\n*   `1 <= costs[i] <= 105`\n*   `1 <= coins <= 108`\"\"\"\n\n    max_altitude, current_altitude = 0, 0\n    for i in gain:\n        current_altitude += i\n        max_altitude = max(max_altitude, current_altitude)\n    return max_altitude"}}, "leetcode/csn_python_train_320905.txt": {"score": 0.910027027130127, "content": {"text": "def knapsack2(p, v, cmax):\n    \"\"\"Knapsack problem: select maximum value set of items if total size not more than capacity.\n    alternative implementation with same behavior.\n\n    :param p: table with size of items\n    :param v: table with value of items\n    :param cmax: capacity of bag\n    :requires: number of items non-zero\n    :returns: value optimal solution, list of item indexes in solution\n    :complexity: O(n * cmax), for n = number of items\n    \"\"\"\n    n = len(p)\n    # Plus grande valeur obtenable avec objets \u2264 i et capacit\u00e9 c\n    pgv = [[0] * (cmax + 1) for _ in range(n)]\n    for c in range(cmax + 1):  # Initialisation\n        pgv[0][c] = v[0] if c >= p[0] else 0\n    pred = {}  # Pr\u00e9d\u00e9cesseurs pour m\u00e9moriser les choix faits\n    for i in range(1, n):\n        for c in range(cmax + 1):\n            pgv[i][c] = pgv[i - 1][c]  # Si on ne prend pas l'objet i\n            pred[(i, c)] = (i - 1, c)\n            # Est-ce que prendre l'objet i est pr\u00e9f\u00e9rable ?\n            if c >= p[i] and pgv[i - 1][c - p[i]] + v[i] > pgv[i][c]:\n                pgv[i][c] = pgv[i - 1][c - p[i]] + v[i]\n                pred[(i, c)] = (i - 1, c - p[i])  # On marque le pr\u00e9d\u00e9cesseur\n    # On pourrait s'arr\u00eater l\u00e0, mais si on veut un sous-ensemble d'objets\n    # optimal, il faut remonter les marquages\n    cursor = (n - 1, cmax)\n    chosen = []\n    while cursor in pred:\n        # Si la case pr\u00e9d\u00e9cesseur a une capacit\u00e9 inf\u00e9rieure\n        if pred[cursor][1] < cursor[1]:\n            # C'est qu'on a ramass\u00e9 l'objet sur le chemin\n            chosen.append(cursor[0])\n        cursor = pred[cursor]\n    if cursor[1] > 0:  # A-t-on pris le premier objet ?\n        # (La premi\u00e8re ligne n'a pas de pr\u00e9d\u00e9cesseur.)\n        chosen.append(cursor[0])\n    return pgv[n - 1][cmax], chosen"}}, "leetcode/csn_python_train_286763.txt": {"score": 0.9098162055015564, "content": {"text": "def knapsack_iterative_int(items, maxweight):\n    r\"\"\"\n    Iterative knapsack method\n\n    Math:\n        maximize \\sum_{i \\in T} v_i\n        subject to \\sum_{i \\in T} w_i \\leq W\n\n    Notes:\n        dpmat is the dynamic programming memoization matrix.\n        dpmat[i, w] is the total value of the items with weight at most W\n        T is idx_subset, the set of indicies in the optimal solution\n\n    CommandLine:\n        python -m utool.util_alg --exec-knapsack_iterative_int --show\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_alg import *  # NOQA\n        >>> weights = [1, 3, 3, 5, 2, 1] * 2\n        >>> items = [(w, w, i) for i, w in enumerate(weights)]\n        >>> maxweight = 10\n        >>> items = [(.8, 700, 0)]\n        >>> maxweight = 2000\n        >>> print('maxweight = %r' % (maxweight,))\n        >>> print('items = %r' % (items,))\n        >>> total_value, items_subset = knapsack_iterative_int(items, maxweight)\n        >>> total_weight = sum([t[1] for t in items_subset])\n        >>> print('total_weight = %r' % (total_weight,))\n        >>> print('items_subset = %r' % (items_subset,))\n        >>> result =  'total_value = %.2f' % (total_value,)\n        >>> print(result)\n        total_value = 0.80\n\n    Ignore:\n        DPMAT = [[dpmat[r][c] for c in range(maxweight)] for r in range(len(items))]\n        KMAT  = [[kmat[r][c] for c in range(maxweight)] for r in range(len(items))]\n    \"\"\"\n    values  = [t[0] for t in items]\n    weights = [t[1] for t in items]\n    maxsize = maxweight + 1\n    # Sparse representation seems better\n    dpmat = defaultdict(lambda: defaultdict(lambda: np.inf))\n    kmat = defaultdict(lambda: defaultdict(lambda: False))\n    idx_subset = []  # NOQA\n    for w in range(maxsize):\n        dpmat[0][w] = 0\n    # For each item consider to include it or not\n    for idx in range(len(items)):\n        item_val = values[idx]\n        item_weight = weights[idx]\n        # consider at each possible bag size\n        for w in range(maxsize):\n            valid_item = item_weight <= w\n            if idx > 0:\n                prev_val = dpmat[idx - 1][w]\n                prev_noitem_val = dpmat[idx - 1][w - item_weight]\n            else:\n                prev_val = 0\n                prev_noitem_val = 0\n            withitem_val = item_val + prev_noitem_val\n            more_valuable = withitem_val > prev_val\n            if valid_item and more_valuable:\n                dpmat[idx][w] = withitem_val\n                kmat[idx][w] = True\n            else:\n                dpmat[idx][w] = prev_val\n                kmat[idx][w] = False\n    # Trace backwards to get the items used in the solution\n    K = maxweight\n    for idx in reversed(range(len(items))):\n        if kmat[idx][K]:\n            idx_subset.append(idx)\n            K = K - weights[idx]\n    idx_subset = sorted(idx_subset)\n    items_subset = [items[i] for i in idx_subset]\n    total_value = dpmat[len(items) - 1][maxweight]\n    return total_value, items_subset"}}, "leetcode/leetcode_826.txt": {"score": 0.9206600785255432, "content": {"text": "def maxProfitAssignment(difficulty, profit, worker):\n    \"\"\"You have `n` jobs and `m` workers. You are given three arrays: `difficulty`, `profit`, and `worker` where:\n\n*   `difficulty[i]` and `profit[i]` are the difficulty and the profit of the `ith` job, and\n*   `worker[j]` is the ability of `jth` worker (i.e., the `jth` worker can only complete a job with difficulty at most `worker[j]`).\n\nEvery worker can be assigned **at most one job**, but one job can be **completed multiple times**.\n\n*   For example, if three workers attempt the same job that pays `$1`, then the total profit will be `$3`. If a worker cannot complete any job, their profit is `$0`.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n\n**Example 1:**\n\n**Input:** difficulty = \\[2,4,6,8,10\\], profit = \\[10,20,30,40,50\\], worker = \\[4,5,6,7\\]\n**Output:** 100\n**Explanation:** Workers are assigned jobs of difficulty \\[4,4,6,6\\] and they get a profit of \\[20,20,30,30\\] separately.\n\n**Example 2:**\n\n**Input:** difficulty = \\[85,47,57\\], profit = \\[24,66,99\\], worker = \\[40,25,25\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == difficulty.length`\n*   `n == profit.length`\n*   `m == worker.length`\n*   `1 <= n, m <= 104`\n*   `1 <= difficulty[i], profit[i], worker[i] <= 105`\"\"\"\n\n    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit"}}, "leetcode/leetcode_2600.txt": {"score": 0.9137765169143677, "content": {"text": "def max_sum(numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\n    \"\"\"There is a bag that consists of items, each item has a number `1`, `0`, or `-1` written on it.\n\nYou are given four **non-negative** integers `numOnes`, `numZeros`, `numNegOnes`, and `k`.\n\nThe bag initially contains:\n\n*   `numOnes` items with `1`s written on them.\n*   `numZeroes` items with `0`s written on them.\n*   `numNegOnes` items with `-1`s written on them.\n\nWe want to pick exactly `k` items among the available items. Return _the **maximum** possible sum of numbers written on the items_.\n\n**Example 1:**\n\n**Input:** numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\n**Output:** 2\n**Explanation:** We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2.\nIt can be proven that 2 is the maximum possible sum.\n\n**Example 2:**\n\n**Input:** numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\n**Output:** 3\n**Explanation:** We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3.\nIt can be proven that 3 is the maximum possible sum.\n\n**Constraints:**\n\n*   `0 <= numOnes, numZeros, numNegOnes <= 50`\n*   `0 <= k <= numOnes + numZeros + numNegOnes`\"\"\"\n\n    max_sum = 0\n    for i in range(k + 1):\n        ones = min(i, numOnes)\n        neg_ones = min(k - i, numNegOnes)\n        max_sum = max(max_sum, ones - neg_ones)\n    return max_sum"}}, "leetcode/leetcode_740.txt": {"score": 0.914732038974762, "content": {"text": "def max_points(nums):\n    \"\"\"You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:\n\n*   Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.\n\nReturn _the **maximum number of points** you can earn by applying the above operation some number of times_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,4,2\\]\n**Output:** 6\n**Explanation:** You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = \\[2\\].\n- Delete 2 to earn 2 points. nums = \\[\\].\nYou earn a total of 6 points.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,3,3,3,4\\]\n**Output:** 9\n**Explanation:** You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = \\[3,3\\].\n- Delete a 3 again to earn 3 points. nums = \\[3\\].\n- Delete a 3 once more to earn 3 points. nums = \\[\\].\nYou earn a total of 9 points.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 104`\"\"\"\n\n    dp = [0] * 100001\n    max_points = 0\n    for num in nums:\n        dp[num] += 1\n    for i in range(2, len(dp)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])\n        max_points = max(max_points, dp[i])\n    return max_points"}}, "leetcode/leetcode_2530.txt": {"score": 0.9161317348480225, "content": {"text": "import heapq\n    \"\"\"You are given a **0-indexed** integer array `nums` and an integer `k`. You have a **starting score** of `0`.\n\nIn one **operation**:\n\n1.  choose an index `i` such that `0 <= i < nums.length`,\n2.  increase your **score** by `nums[i]`, and\n3.  replace `nums[i]` with `ceil(nums[i] / 3)`.\n\nReturn _the maximum possible **score** you can attain after applying **exactly**_ `k` _operations_.\n\nThe ceiling function `ceil(val)` is the least integer greater than or equal to `val`.\n\n**Example 1:**\n\n**Input:** nums = \\[10,10,10,10,10\\], k = 5\n**Output:** 50\n**Explanation:** Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.\n\n**Example 2:**\n\n**Input:** nums = \\[1,10,3,3,3\\], k = 3\n**Output:** 17\n**Explanation:** You can do the following operations:\nOperation 1: Select i = 1, so nums becomes \\[1,**4**,3,3,3\\]. Your score increases by 10.\nOperation 2: Select i = 1, so nums becomes \\[1,**2**,3,3,3\\]. Your score increases by 4.\nOperation 3: Select i = 2, so nums becomes \\[1,1,**1**,3,3\\]. Your score increases by 3.\nThe final score is 10 + 4 + 3 = 17.\n\n**Constraints:**\n\n*   `1 <= nums.length, k <= 105`\n*   `1 <= nums[i] <= 109`\"\"\"\n\n\ndef max_score(nums, k):\n    pq = [-x for x in nums]\n    heapq.heapify(pq)\n    score = 0\n\n    for _ in range(k):\n        cur = -heapq.heappop(pq)\n        score += cur\n        heapq.heappush(pq, -cur // 3)\n\n    return score"}}, "leetcode/leetcode_502.txt": {"score": 0.9939787983894348, "content": {"text": "import heapq\n    \"\"\"Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the **IPO**. Since it has limited resources, it can only finish at most `k` distinct projects before the **IPO**. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.\n\nYou are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.\n\nInitially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return _the final maximized capital_.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n**Example 1:**\n\n**Input:** k = 2, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,1\\]\n**Output:** 4\n**Explanation:** Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** k = 3, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,2\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= k <= 105`\n*   `0 <= w <= 109`\n*   `n == profits.length`\n*   `n == capital.length`\n*   `1 <= n <= 105`\n*   `0 <= profits[i] <= 104`\n*   `0 <= capital[i] <= 109`\"\"\"\n\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w"}}, "leetcode/leetcode_1710.txt": {"score": 0.9283206462860107, "content": {"text": "import heapq\n    \"\"\"You are assigned to put some amount of boxes onto **one truck**. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`:\n\n*   `numberOfBoxesi` is the number of boxes of type `i`.\n*   `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.\n\nYou are also given an integer `truckSize`, which is the **maximum** number of **boxes** that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.\n\nReturn _the **maximum** total number of **units** that can be put on the truck._\n\n**Example 1:**\n\n**Input:** boxTypes = \\[\\[1,3\\],\\[2,2\\],\\[3,1\\]\\], truckSize = 4\n**Output:** 8\n**Explanation:** There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 \\* 3) + (2 \\* 2) + (1 \\* 1) = 8.\n\n**Example 2:**\n\n**Input:** boxTypes = \\[\\[5,10\\],\\[2,5\\],\\[4,7\\],\\[3,9\\]\\], truckSize = 10\n**Output:** 91\n\n**Constraints:**\n\n*   `1 <= boxTypes.length <= 1000`\n*   `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`\n*   `1 <= truckSize <= 106`\"\"\"\n\n\ndef busiest_servers(k, arrival, load):\n    server_requests = [0] * k\n    pq = []\n    available_servers = list(range(k))\n\n    for i in range(len(arrival)):\n        while pq and pq[0][0] <= arrival[i]:\n            _, server_id = heapq.heappop(pq)\n            available_servers.append(server_id)\n\n        if available_servers:\n            server_id = available_servers.pop(0)\n            server_requests[server_id] += 1\n            heapq.heappush(pq, (arrival[i] + load[i], server_id))\n\n    max_requests = max(server_requests)\n    return [i for i in range(k) if server_requests[i] == max_requests]"}}, "leetcode/leetcode_2218.txt": {"score": 0.9411134719848633, "content": {"text": "import heapq\n    \"\"\"There are `n` **piles** of coins on a table. Each pile consists of a **positive number** of coins of assorted denominations.\n\nIn one move, you can choose any coin on **top** of any pile, remove it, and add it to your wallet.\n\nGiven a list `piles`, where `piles[i]` is a list of integers denoting the composition of the `ith` pile from **top to bottom**, and a positive integer `k`, return _the **maximum total value** of coins you can have in your wallet if you choose **exactly**_ `k` _coins optimally_.\n\n**Example 1:**\n\n**Input:** piles = \\[\\[1,100,3\\],\\[7,8,9\\]\\], k = 2\n**Output:** 101\n**Explanation:**\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n\n**Example 2:**\n\n**Input:** piles = \\[\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[1,1,1,1,1,1,700\\]\\], k = 7\n**Output:** 706\n**Explanation:**\nThe maximum total can be obtained if we choose all coins from the last pile.\n\n**Constraints:**\n\n*   `n == piles.length`\n*   `1 <= n <= 1000`\n*   `1 <= piles[i][j] <= 105`\n*   `1 <= k <= sum(piles[i].length) <= 2000`\"\"\"\n\n\ndef maxCoins(piles, k):\n    pq = []\n    for pile in piles:\n        for coin in pile:\n            heapq.heappush(pq, -coin)\n    \n    max_value = 0\n    while k > 0:\n        max_value += -heapq.heappop(pq)\n        k -= 1\n    return max_value"}}}}, "26": {"gold": {"leetcode/leetcode_70.txt": 1, "leetcode/leetcode_842.txt": 1, "leetcode/leetcode_873.txt": 1, "leetcode/leetcode_1137.txt": 1}, "retrieved": {"leetcode/csn_python_train_286756.txt": {"score": 0.9287466406822205, "content": {"text": "def fibonacci_approx(n):\n    r\"\"\"\n    approximate value (due to numerical errors) of fib(n) using closed form\n    expression\n\n    Args:\n        n (int):\n\n    Returns:\n        int: the n-th fib number\n\n    CommandLine:\n        python -m utool.util_alg fibonacci_approx\n\n    Example:\n        >>> # DISABLE_DOCTEST\n        >>> from utool.util_alg import *  # NOQA\n        >>> import utool as ut\n        >>> series = [int(fibonacci_approx(n)) for n in range(20)]\n        >>> result = ('series = %s' % (str(series[0:10]),))\n        >>> print(result)\n    \"\"\"\n    sqrt_5 = math.sqrt(5)\n    phi = (1 + sqrt_5) / 2\n    return ((phi ** n) - (-phi) ** (-n)) / sqrt_5"}}, "leetcode/csn_python_train_70110.txt": {"score": 0.9347403049468994, "content": {"text": "def isfib(number):\n    \"\"\"\n    Check if a number is in the Fibonacci sequence.\n\n    :type number: integer\n    :param number: Number to check\n    \"\"\"\n\n    num1 = 1\n    num2 = 1\n    while True:\n        if num2 < number:\n            tempnum = num2\n            num2 += num1\n            num1 = tempnum\n        elif num2 == number:\n            return True\n        else:\n            return False"}}, "leetcode/leetcode_1137.txt": {"score": 0.9522654414176941, "content": {"text": "def height_checker(heights):\n    \"\"\"The Tribonacci sequence Tn is defined as follows:\n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven `n`, return the value of Tn.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 4\n**Explanation:**\nT\\_3 = 0 + 1 + 1 = 2\nT\\_4 = 1 + 1 + 2 = 4\n\n**Example 2:**\n\n**Input:** n = 25\n**Output:** 1389537\n\n**Constraints:**\n\n*   `0 <= n <= 37`\n*   The answer is guaranteed to fit within a 32-bit integer, ie. `answer <= 2^31 - 1`.\"\"\"\n\n    expected = sorted(heights)\n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n    return count"}}, "leetcode/csn_python_train_286755.txt": {"score": 0.9489185810089111, "content": {"text": "def fibonacci_iterative(n):\n    \"\"\"\n    Args:\n        n (int):\n\n    Returns:\n        int: the n-th fibonacci number\n\n    References:\n        http://stackoverflow.com/questions/15047116/iterative-alg-fib\n\n    CommandLine:\n        python -m utool.util_alg fibonacci_iterative\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_alg import *  # NOQA\n        >>> import utool as ut\n        >>> with ut.Timer('fib iter'):\n        >>>     series = [fibonacci_iterative(n) for n in range(20)]\n        >>> result = ('series = %s' % (str(series[0:10]),))\n        >>> print(result)\n        series = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(0, n):\n        a, b = b, a + b\n    return a"}}, "leetcode/csn_python_train_3821.txt": {"score": 0.9581979513168335, "content": {"text": "def fib_list(n):\n    \"\"\"[summary]\n    This algorithm computes the n-th fibbonacci number\n    very quick. approximate O(n)\n    The algorithm use dynamic programming.\n    \n    Arguments:\n        n {[int]} -- [description]\n    \n    Returns:\n        [int] -- [description]\n    \"\"\"\n\n    # precondition\n    assert n >= 0, 'n must be a positive integer'\n\n    list_results = [0, 1]\n    for i in range(2, n+1):\n        list_results.append(list_results[i-1] + list_results[i-2])\n    return list_results[n]"}}, "leetcode/csn_python_train_109154.txt": {"score": 0.9541051983833313, "content": {"text": "def fib(n):\n    \"\"\"Fibonacci example function\n\n    Args:\n      n (int): integer\n\n    Returns:\n      int: n-th Fibonacci number\n    \"\"\"\n    assert n > 0\n    a, b = 1, 1\n    for i in range(n - 1):\n        a, b = b, a + b\n    return a"}}, "leetcode/csn_python_train_214832.txt": {"score": 0.9543850421905518, "content": {"text": "def software_fibonacci(n):\n    \"\"\" a normal old python function to return the Nth fibonacci number. \"\"\"\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a"}}, "leetcode/csn_python_train_3822.txt": {"score": 0.959924042224884, "content": {"text": "def fib_iter(n):\n    \"\"\"[summary]\n    Works iterative approximate O(n)\n\n    Arguments:\n        n {[int]} -- [description]\n    \n    Returns:\n        [int] -- [description]\n    \"\"\"\n\n    # precondition\n    assert n >= 0, 'n must be positive integer'\n\n    fib_1 = 0\n    fib_2 = 1\n    sum = 0\n    if n <= 1:\n        return n\n    for _ in range(n-1):\n        sum = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = sum\n    return sum"}}, "leetcode/csn_python_train_293471.txt": {"score": 0.9589248299598694, "content": {"text": "def fib(number: int) -> int:\n    \"\"\"\n    Simple Fibonacci function.\n\n    >>> fib(10)\n    55\n    \"\"\"\n    if number < 2:\n        return number\n    return fib(number - 1) + fib(number - 2)"}}, "leetcode/leetcode_509.txt": {"score": 0.996208906173706, "content": {"text": "def fib(n: int) -> int:\n    \"\"\"The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven `n`, calculate `F(n)`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n**Constraints:**\n\n*   `0 <= n <= 30`\"\"\"\n\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b"}}}}, "27": {"gold": {"leetcode/leetcode_300.txt": 1, "leetcode/leetcode_491.txt": 1}, "retrieved": {"leetcode/leetcode_1235.txt": {"score": 0.9079042673110962, "content": {"text": "from bisect import bisect_left\n    \"\"\"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.\n\nYou're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\nIf you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.\n\n**Example 1:**\n\n**Input:** startTime = \\[1,2,3,3\\], endTime = \\[3,4,5,6\\], profit = \\[50,10,40,70\\]\n**Output:** 120\n**Explanation:** The subset chosen is the first and fourth job. \nTime range \\[1-3\\]+\\[3-6\\] , we get profit of 120 = 50 + 70.\n\n**Example 2:**\n\n**Input:** startTime = \\[1,2,3,4,6\\], endTime = \\[3,5,10,6,9\\], profit = \\[20,20,100,70,60\\]\n**Output:** 150\n**Explanation:** The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n**Example 3:**\n\n**Input:** startTime = \\[1,1,1\\], endTime = \\[2,3,4\\], profit = \\[5,6,4\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`\n*   `1 <= startTime[i] < endTime[i] <= 109`\n*   `1 <= profit[i] <= 104`\"\"\"\n\n\ndef jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(endTime, startTime, profit))\n    dp = [jobs[0][2]]\n    \n    def latestNonConflict(index):\n        startTimeToFind = jobs[index][1]\n        index = bisect_left([job[0] for job in jobs], startTimeToFind)\n        if index:\n            return index - 1\n        return -1\n\n    for i in range(1, len(jobs)):\n        L = latestNonConflict(i)\n        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))\n\n    return dp[-1]"}}, "leetcode/csn_python_train_308104.txt": {"score": 0.9130035042762756, "content": {"text": "def range_chain(ranges):\n    \"\"\"\n    Take list of weighted intervals, find non-overlapping set with max weight.\n    We proceed with each end point (sorted by their relative positions).\n\n    The input are a list of ranges of the form (start, stop, score), output is\n    subset of the non-overlapping ranges that give the highest score, score\n\n    >>> ranges = [Range(\"1\", 0, 9, 22, 0), Range(\"1\", 3, 18, 24, 1), Range(\"1\", 10, 28, 20, 2)]\n    >>> range_chain(ranges)\n    ([Range(seqid='1', start=0, end=9, score=22, id=0), Range(seqid='1', start=10, end=28, score=20, id=2)], 42)\n    >>> ranges = [Range(\"2\", 0, 1, 3, 0), Range(\"2\", 1, 4, 3, 1), Range(\"3\", 5, 7, 3, 2)]\n    >>> range_chain(ranges)\n    ([Range(seqid='2', start=0, end=1, score=3, id=0), Range(seqid='3', start=5, end=7, score=3, id=2)], 6)\n    \"\"\"\n    endpoints = _make_endpoints(ranges)\n\n    # stores the left end index for quick retrieval\n    left_index = {}\n    # dynamic programming, each entry [score, from_index, which_chain]\n    scores = []\n\n    for i, (seqid, pos, leftright, j, score) in enumerate(endpoints):\n\n        cur_score = [0, -1, -1] if i == 0 else scores[-1][:]\n\n        if leftright == LEFT:\n            left_index[j] = i\n\n        else:  # this is right end of j-th interval\n            # update if chaining j-th interval gives a better score\n            left_j = left_index[j]\n            chain_score = scores[left_j][0] + score\n            if chain_score > cur_score[0]:\n                cur_score = [chain_score, left_j, j]\n\n        scores.append(cur_score)\n\n    chains = []\n    score, last, chain_id = scores[-1]  # start backtracking\n    while last != -1:\n        if chain_id != -1:\n            chains.append(chain_id)\n        _, last, chain_id = scores[last]\n\n    chains.reverse()\n\n    selected = [ranges[x] for x in chains]\n\n    return selected, score"}}, "leetcode/leetcode_2398.txt": {"score": 0.9085873961448669, "content": {"text": "def max_consecutive_robots(charge_times, running_costs, budget):\n    \"\"\"You have `n` robots. You are given two **0-indexed** integer arrays, `chargeTimes` and `runningCosts`, both of length `n`. The `ith` robot costs `chargeTimes[i]` units to charge and costs `runningCosts[i]` units to run. You are also given an integer `budget`.\n\nThe **total cost** of running `k` chosen robots is equal to `max(chargeTimes) + k * sum(runningCosts)`, where `max(chargeTimes)` is the largest charge cost among the `k` robots and `sum(runningCosts)` is the sum of running costs among the `k` robots.\n\nReturn _the **maximum** number of **consecutive** robots you can run such that the total cost **does not** exceed_ `budget`.\n\n**Example 1:**\n\n**Input:** chargeTimes = \\[3,6,1,3,4\\], runningCosts = \\[2,1,3,4,5\\], budget = 25\n**Output:** 3\n**Explanation:** \nIt is possible to run all individual and consecutive pairs of robots within budget.\nTo obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 \\* sum(2,1,3) = 6 + 3 \\* 6 = 24 which is less than 25.\nIt can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.\n\n**Example 2:**\n\n**Input:** chargeTimes = \\[11,12,19\\], runningCosts = \\[10,8,7\\], budget = 19\n**Output:** 0\n**Explanation:** No robot can be run that does not exceed the budget, so we return 0.\n\n**Constraints:**\n\n*   `chargeTimes.length == runningCosts.length == n`\n*   `1 <= n <= 5 * 104`\n*   `1 <= chargeTimes[i], runningCosts[i] <= 105`\n*   `1 <= budget <= 1015`\"\"\"\n\n    n = len(charge_times)\n    max_robots = 0\n    for i in range(n):\n        max_charge = 0\n        running_sum = 0\n        for j in range(i, n):\n            max_charge = max(max_charge, charge_times[j])\n            running_sum += running_costs[j]\n            cost = max_charge + running_sum * (j - i + 1)\n            if cost <= budget:\n                max_robots = max(max_robots, j - i + 1)\n            else:\n                break\n    return max_robots"}}, "leetcode/leetcode_1964.txt": {"score": 0.9132803678512573, "content": {"text": "def longest_obstacle_course(obstacles):\n    \"\"\"You want to build some obstacle courses. You are given a **0-indexed** integer array `obstacles` of length `n`, where `obstacles[i]` describes the height of the `ith` obstacle.\n\nFor every index `i` between `0` and `n - 1` (**inclusive**), find the length of the **longest obstacle course** in `obstacles` such that:\n\n*   You choose any number of obstacles between `0` and `i` **inclusive**.\n*   You must include the `ith` obstacle in the course.\n*   You must put the chosen obstacles in the **same order** as they appear in `obstacles`.\n*   Every obstacle (except the first) is **taller** than or the **same height** as the obstacle immediately before it.\n\nReturn _an array_ `ans` _of length_ `n`, _where_ `ans[i]` _is the length of the **longest obstacle course** for index_ `i` _as described above_.\n\n**Example 1:**\n\n**Input:** obstacles = \\[1,2,3,2\\]\n**Output:** \\[1,2,3,3\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[1\\], \\[1\\] has length 1.\n- i = 1: \\[1,2\\], \\[1,2\\] has length 2.\n- i = 2: \\[1,2,3\\], \\[1,2,3\\] has length 3.\n- i = 3: \\[1,2,3,2\\], \\[1,2,2\\] has length 3.\n\n**Example 2:**\n\n**Input:** obstacles = \\[2,2,1\\]\n**Output:** \\[1,2,1\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[2\\], \\[2\\] has length 1.\n- i = 1: \\[2,2\\], \\[2,2\\] has length 2.\n- i = 2: \\[2,2,1\\], \\[1\\] has length 1.\n\n**Example 3:**\n\n**Input:** obstacles = \\[3,1,5,6,4,2\\]\n**Output:** \\[1,1,2,3,2,2\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[3\\], \\[3\\] has length 1.\n- i = 1: \\[3,1\\], \\[1\\] has length 1.\n- i = 2: \\[3,1,5\\], \\[3,5\\] has length 2. \\[1,5\\] is also valid.\n- i = 3: \\[3,1,5,6\\], \\[3,5,6\\] has length 3. \\[1,5,6\\] is also valid.\n- i = 4: \\[3,1,5,6,4\\], \\[3,4\\] has length 2. \\[1,4\\] is also valid.\n- i = 5: \\[3,1,5,6,4,2\\], \\[1,2\\] has length 2.\n\n**Constraints:**\n\n*   `n == obstacles.length`\n*   `1 <= n <= 105`\n*   `1 <= obstacles[i] <= 107`\"\"\"\n\n    dp = []\n    ans = [0] * len(obstacles)\n\n    for obstacle in obstacles:\n        index = bisect_left(dp, obstacle)\n        ans[index] = index + 1\n        if index == len(dp):\n            dp.append(obstacle)\n        else:\n            dp[index] = obstacle\n\n    return ans"}}, "leetcode/leetcode_1626.txt": {"score": 0.9192895889282227, "content": {"text": "def can_make_arithmetic_progression(arr):\n    \"\"\"You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team.\n\nHowever, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age.\n\nGiven two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return _the highest overall score of all possible basketball teams_.\n\n**Example 1:**\n\n**Input:** scores = \\[1,3,5,10,15\\], ages = \\[1,2,3,4,5\\]\n**Output:** 34\n**Explanation:** You can choose all the players.\n\n**Example 2:**\n\n**Input:** scores = \\[4,5,6,5\\], ages = \\[2,1,2,1\\]\n**Output:** 16\n**Explanation:** It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n**Example 3:**\n\n**Input:** scores = \\[1,2,3,5\\], ages = \\[8,9,10,1\\]\n**Output:** 6\n**Explanation:** It is best to choose the first 3 players. \n\n**Constraints:**\n\n*   `1 <= scores.length, ages.length <= 1000`\n*   `scores.length == ages.length`\n*   `1 <= scores[i] <= 106`\n*   `1 <= ages[i] <= 1000`\"\"\"\n\n    arr.sort()\n    difference = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] != difference:\n            return False\n    return True"}}, "leetcode/leetcode_354.txt": {"score": 0.9101663827896118, "content": {"text": "from bisect import bisect_left\n    \"\"\"You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll (i.e., put one inside the other)_.\n\n**Note:** You cannot rotate an envelope.\n\n**Example 1:**\n\n**Input:** envelopes = \\[\\[5,4\\],\\[6,4\\],\\[6,7\\],\\[2,3\\]\\]\n**Output:** 3\n**Explanation:** The maximum number of envelopes you can Russian doll is `3` (\\[2,3\\] => \\[5,4\\] => \\[6,7\\]).\n\n**Example 2:**\n\n**Input:** envelopes = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= envelopes.length <= 105`\n*   `envelopes[i].length == 2`\n*   `1 <= wi, hi <= 105`\"\"\"\n\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)"}}, "leetcode/leetcode_2358.txt": {"score": 0.9094434976577759, "content": {"text": "def max_groups(grades):\n    \"\"\"You are given a positive integer array `grades` which represents the grades of students in a university. You would like to enter **all** these students into a competition in **ordered** non-empty groups, such that the ordering meets the following conditions:\n\n*   The sum of the grades of students in the `ith` group is **less than** the sum of the grades of students in the `(i + 1)th` group, for all groups (except the last).\n*   The total number of students in the `ith` group is **less than** the total number of students in the `(i + 1)th` group, for all groups (except the last).\n\nReturn _the **maximum** number of groups that can be formed_.\n\n**Example 1:**\n\n**Input:** grades = \\[10,6,12,7,3,5\\]\n**Output:** 3\n**Explanation:** The following is a possible way to form 3 groups of students:\n- 1st group has the students with grades = \\[12\\]. Sum of grades: 12. Student count: 1\n- 2nd group has the students with grades = \\[6,7\\]. Sum of grades: 6 + 7 = 13. Student count: 2\n- 3rd group has the students with grades = \\[10,3,5\\]. Sum of grades: 10 + 3 + 5 = 18. Student count: 3\nIt can be shown that it is not possible to form more than 3 groups.\n\n**Example 2:**\n\n**Input:** grades = \\[8,8\\]\n**Output:** 1\n**Explanation:** We can only form 1 group, since forming 2 groups would lead to an equal number of students in both groups.\n\n**Constraints:**\n\n*   `1 <= grades.length <= 105`\n*   `1 <= grades[i] <= 105`\"\"\"\n\n    grades.sort()\n\n    dp = [1] * len(grades)\n\n    for i in range(len(grades)):\n        for j in range(i):\n            if grades[i] + dp[j] * grades[j] > (i+1) * grades[j]:\n                dp[i] = dp[j] + 1\n\n    return dp[-1]"}}, "leetcode/leetcode_1800.txt": {"score": 0.9168341755867004, "content": {"text": "def concatenated_binary(n: int) -> int:\n    \"\"\"Given an array of positive integers `nums`, return the _maximum possible sum of an **ascending** subarray in_ `nums`.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nA subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is **ascending** if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is **ascending**.\n\n**Example 1:**\n\n**Input:** nums = \\[10,20,30,5,10,50\\]\n**Output:** 65\n**Explanation:** \\[5,10,50\\] is the ascending subarray with the maximum sum of 65.\n\n**Example 2:**\n\n**Input:** nums = \\[10,20,30,40,50\\]\n**Output:** 150\n**Explanation:** \\[10,20,30,40,50\\] is the ascending subarray with the maximum sum of 150.\n\n**Example 3:**\n\n**Input:** nums = \\[12,17,15,13,10,11,12\\]\n**Output:** 33\n**Explanation:** \\[10,11,12\\] is the ascending subarray with the maximum sum of 33.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`\"\"\"\n\n    result = 0\n    mod = 1000000007\n    for i in range(1, n + 1):\n        length = len(bin(i)) - 2\n        result = ((result << length) % mod + i) % mod\n    return result"}}, "leetcode/leetcode_2407.txt": {"score": 0.9149224758148193, "content": {"text": "def longestSubsequence(nums, k):\n    \"\"\"You are given an integer array `nums` and an integer `k`.\n\nFind the longest subsequence of `nums` that meets the following requirements:\n\n*   The subsequence is **strictly increasing** and\n*   The difference between adjacent elements in the subsequence is **at most** `k`.\n\nReturn _the length of the **longest** **subsequence** that meets the requirements._\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n\n**Input:** nums = \\[4,2,1,4,3,4,5,8,15\\], k = 3\n**Output:** 5\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[1,3,4,5,8\\].\nThe subsequence has a length of 5, so we return 5.\nNote that the subsequence \\[1,3,4,5,8,15\\] does not meet the requirements because 15 - 8 = 7 is larger than 3.\n\n**Example 2:**\n\n**Input:** nums = \\[7,4,5,1,8,12,4,7\\], k = 5\n**Output:** 4\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[4,5,8,12\\].\nThe subsequence has a length of 4, so we return 4.\n\n**Example 3:**\n\n**Input:** nums = \\[1,5\\], k = 1\n**Output:** 1\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[1\\].\nThe subsequence has a length of 1, so we return 1.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i], k <= 105`\"\"\"\n\n    n = len(nums)\n    dp = {}\n    ans = 0\n\n    for num in nums:\n        temp = 0\n        keys = [key for key in dp if num - k <= key]\n        if keys:\n            temp = dp[max(keys)]\n\n        dp[num] = max(dp.get(num, 0), temp + 1)\n        ans = max(ans, dp[num])\n\n    return ans"}}, "leetcode/leetcode_646.txt": {"score": 0.992572009563446, "content": {"text": "def findLongestChain(pairs):\n    \"\"\"You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.\n\nA pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.\n\nReturn _the length longest chain which can be formed_.\n\nYou do not need to use up all the given intervals. You can select pairs in any order.\n\n**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** The longest chain is \\[1,2\\] -> \\[3,4\\].\n\n**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[7,8\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** The longest chain is \\[1,2\\] -> \\[4,5\\] -> \\[7,8\\].\n\n**Constraints:**\n\n*   `n == pairs.length`\n*   `1 <= n <= 1000`\n*   `-1000 <= lefti < righti <= 1000`\"\"\"\n\n    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length"}}}}, "28": {"gold": {"leetcode/leetcode_495.txt": 1}, "retrieved": {"leetcode/leetcode_1145.txt": {"score": 0.8849949240684509, "content": {"text": "class TreeNode:\n    \"\"\"Two players play a turn based game on a binary tree. We are given the `root` of this binary tree, and the number of nodes `n` in the tree. `n` is odd, and each node has a distinct value from `1` to `n`.\n\nInitially, the first player names a value `x` with `1 <= x <= n`, and the second player names a value `y` with `1 <= y <= n` and `y != x`. The first player colors the node with value `x` red, and the second player colors the node with value `y` blue.\n\nThen, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an **uncolored** neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\n\nIf (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\n\nYou are the second player. If it is possible to choose such a `y` to ensure you win the game, return `true`. If it is not possible, return `false`.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5,6,7,8,9,10,11\\], n = 11, x = 3\n**Output:** true\n**Explanation:** The second player can choose the node with value 2.\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\], n = 3, x = 1\n**Output:** false\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= x <= n <= 100`\n*   `n` is odd.\n*   1 <= Node.val <= n\n*   All the values of the tree are **unique**.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef btree_game_winning_move(root: TreeNode, n: int, x: int) -> bool:\n    def count_nodes(node: TreeNode) -> int:\n        if not node:\n            return 0\n        return count_nodes(node.left) + count_nodes(node.right) + 1\n\n    def find_node(node: TreeNode, x: int) -> TreeNode:\n        if not node:\n            return None\n        if node.val == x:\n            return node\n        left_search = find_node(node.left, x)\n        if left_search:\n            return left_search\n        return find_node(node.right, x)\n\n    x_node = find_node(root, x)\n    left_nodes = count_nodes(x_node.left)\n    right_nodes = count_nodes(x_node.right)\n    parent_nodes = n - left_nodes - right_nodes - 1\n\n    return max(max(left_nodes, right_nodes), parent_nodes) > n // 2"}}, "leetcode/leetcode_2211.txt": {"score": 0.8891736268997192, "content": {"text": "def k_radius_average(nums, k):\n    \"\"\"There are `n` cars on an infinitely long road. The cars are numbered from `0` to `n - 1` from left to right and each car is present at a **unique** point.\n\nYou are given a **0-indexed** string `directions` of length `n`. `directions[i]` can be either `'L'`, `'R'`, or `'S'` denoting whether the `ith` car is moving towards the **left**, towards the **right**, or **staying** at its current point respectively. Each moving car has the **same speed**.\n\nThe number of collisions can be calculated as follows:\n\n*   When two cars moving in **opposite** directions collide with each other, the number of collisions increases by `2`.\n*   When a moving car collides with a stationary car, the number of collisions increases by `1`.\n\nAfter a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\n\nReturn _the **total number of collisions** that will happen on the road_.\n\n**Example 1:**\n\n**Input:** directions =  \"RLRSLL \"\n**Output:** 5\n**Explanation:**\nThe collisions that will happen on the road are:\n- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\nThus, the total number of collisions that will happen on the road is 5. \n\n**Example 2:**\n\n**Input:** directions =  \"LLRR \"\n**Output:** 0\n**Explanation:**\nNo cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.\n\n**Constraints:**\n\n*   `1 <= directions.length <= 105`\n*   `directions[i]` is either `'L'`, `'R'`, or `'S'`.\"\"\"\n\n    n = len(nums)\n    avgs = [-1] * n\n    for i in range(k, n - k):\n        sum = 0\n        for j in range(i - k, i + k + 1):\n            sum += nums[j]\n        avgs[i] = sum // (2 * k + 1)\n    return avgs"}}, "leetcode/leetcode_1894.txt": {"score": 0.8897757530212402, "content": {"text": "def merge_alternately(word1, word2):\n    \"\"\"There are `n` students in a class numbered from `0` to `n - 1`. The teacher will give each student a problem starting with the student number `0`, then the student number `1`, and so on until the teacher reaches the student number `n - 1`. After that, the teacher will restart the process, starting with the student number `0` again.\n\nYou are given a **0-indexed** integer array `chalk` and an integer `k`. There are initially `k` pieces of chalk. When the student number `i` is given a problem to solve, they will use `chalk[i]` pieces of chalk to solve that problem. However, if the current number of chalk pieces is **strictly less** than `chalk[i]`, then the student number `i` will be asked to **replace** the chalk.\n\nReturn _the **index** of the student that will **replace** the chalk pieces_.\n\n**Example 1:**\n\n**Input:** chalk = \\[5,1,5\\], k = 22\n**Output:** 0\n**Explanation:** The students go in turns as follows:\n- Student number 0 uses 5 chalk, so k = 17.\n- Student number 1 uses 1 chalk, so k = 16.\n- Student number 2 uses 5 chalk, so k = 11.\n- Student number 0 uses 5 chalk, so k = 6.\n- Student number 1 uses 1 chalk, so k = 5.\n- Student number 2 uses 5 chalk, so k = 0.\nStudent number 0 does not have enough chalk, so they will have to replace it.\n\n**Example 2:**\n\n**Input:** chalk = \\[3,4,1,2\\], k = 25\n**Output:** 1\n**Explanation:** The students go in turns as follows:\n- Student number 0 uses 3 chalk so k = 22.\n- Student number 1 uses 4 chalk so k = 18.\n- Student number 2 uses 1 chalk so k = 17.\n- Student number 3 uses 2 chalk so k = 15.\n- Student number 0 uses 3 chalk so k = 12.\n- Student number 1 uses 4 chalk so k = 8.\n- Student number 2 uses 1 chalk so k = 7.\n- Student number 3 uses 2 chalk so k = 5.\n- Student number 0 uses 3 chalk so k = 2.\nStudent number 1 does not have enough chalk, so they will have to replace it.\n\n**Constraints:**\n\n*   `chalk.length == n`\n*   `1 <= n <= 105`\n*   `1 <= chalk[i] <= 105`\n*   `1 <= k <= 109`\"\"\"\n\n    merged = []\n    i, j = 0, 0\n    while i < len(word1) or j < len(word2):\n        if i < len(word1):\n            merged.append(word1[i])\n            i += 1\n        if j < len(word2):\n            merged.append(word2[j])\n            j += 1\n    return \"\".join(merged)"}}, "leetcode/leetcode_810.txt": {"score": 0.889641523361206, "content": {"text": "def valid_tic_tac_toe(board: List[str]) -> bool:\n    \"\"\"You are given an array of integers `nums` represents the numbers written on a chalkboard.\n\nAlice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become `0`, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is `0`.\n\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to `0`, then that player wins.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** false\n**Explanation:** \nAlice has two choices: erase 1 or erase 2. \nIf she erases 1, the nums array becomes \\[1, 2\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \nIf Alice erases 2 first, now nums become \\[1, 1\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** true\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < 216`\"\"\"\n\n    x_count = sum(row.count('X') for row in board)\n    o_count = sum(row.count('O') for row in board)\n    if x_count != o_count and x_count != o_count + 1: return False\n\n    x_win, o_win = False, False\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] != ' ':\n            x_win, o_win = (True, o_win) if board[i][0] == 'X' else (x_win, True)\n        if board[0][i] == board[1][i] == board[2][i] != ' ':\n            x_win, o_win = (True, o_win) if board[0][i] == 'X' else (x_win, True)\n    if board[0][0] == board[1][1] == board[2][2] != ' ':\n        x_win, o_win = (True, o_win) if board[0][0] == 'X' else (x_win, True)\n    if board[0][2] == board[1][1] == board[2][0] != ' ':\n        x_win, o_win = (True, o_win) if board[0][2] == 'X' else (x_win, True)\n\n    if x_win and o_win: return False\n    if x_win and x_count == o_count: return False\n    if o_win and x_count > o_count: return False\n\n    return True"}}, "leetcode/csn_python_train_276647.txt": {"score": 0.8924140930175781, "content": {"text": "def guess_winner(self, i):\n        \"\"\"Guess if a player won.\n\n        Find what team the player was on. If anyone\n        on their team resigned, assume the player lost.\n        \"\"\"\n        for team in self.get_teams():\n            if i not in team:\n                continue\n            for p in team:\n                if p in self._cache['resigned']:\n                    return False\n        return True"}}, "leetcode/leetcode_2038.txt": {"score": 0.9128103852272034, "content": {"text": "from collections import deque\n    \"\"\"There are `n` pieces arranged in a line, and each piece is colored either by `'A'` or by `'B'`. You are given a string `colors` of length `n` where `colors[i]` is the color of the `ith` piece.\n\nAlice and Bob are playing a game where they take **alternating turns** removing pieces from the line. In this game, Alice moves **first**.\n\n*   Alice is only allowed to remove a piece colored `'A'` if **both its neighbors** are also colored `'A'`. She is **not allowed** to remove pieces that are colored `'B'`.\n*   Bob is only allowed to remove a piece colored `'B'` if **both its neighbors** are also colored `'B'`. He is **not allowed** to remove pieces that are colored `'A'`.\n*   Alice and Bob **cannot** remove pieces from the edge of the line.\n*   If a player cannot make a move on their turn, that player **loses** and the other player **wins**.\n\nAssuming Alice and Bob play optimally, return `true` _if Alice wins, or return_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** colors =  \"AAABABB \"\n**Output:** true\n**Explanation:**\nAAABABB -> AABABB\nAlice moves first.\nShe removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n\nNow it's Bob's turn.\nBob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\nThus, Alice wins, so return true.\n\n**Example 2:**\n\n**Input:** colors =  \"AA \"\n**Output:** false\n**Explanation:**\nAlice has her turn first.\nThere are only two 'A's and both are on the edge of the line, so she cannot move on her turn.\nThus, Bob wins, so return false.\n\n**Example 3:**\n\n**Input:** colors =  \"ABBBBBBBAAA \"\n**Output:** false\n**Explanation:**\nABBBBBBBAAA -> ABBBBBBBAA\nAlice moves first.\nHer only option is to remove the second to last 'A' from the right.\n\nABBBBBBBAA -> ABBBBBBAA\nNext is Bob's turn.\nHe has many options for which 'B' piece to remove. He can pick any.\n\nOn Alice's second turn, she has no more pieces that she can remove.\nThus, Bob wins, so return false.\n\n**Constraints:**\n\n*   `1 <= colors.length <= 105`\n*   `colors` consists of only the letters `'A'` and `'B'`\"\"\"\n\n\ndef nearest_exit(maze, entrance):\n    m, n = len(maze), len(maze[0])\n    directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n    q = deque()\n    maze[entrance[0]][entrance[1]] = '+'\n    q.append((entrance[0], entrance[1]))\n    steps = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            x, y = q.popleft()\n            if (x == 0 or x == m - 1 or y == 0 or y == n - 1) and (x != entrance[0] or y != entrance[1]):\n                return steps\n\n            for dir in directions:\n                xx, yy = x + dir[0], y + dir[1]\n                if 0 <= xx < m and 0 <= yy < n and maze[xx][yy] == '.':\n                    maze[xx][yy] = '+'\n                    q.append((xx, yy))\n        steps += 1\n\n    return -1"}}, "leetcode/leetcode_877.txt": {"score": 0.8936070799827576, "content": {"text": "from collections import deque, defaultdict\n    \"\"\"Alice and Bob play a game with piles of stones. There are an **even** number of piles arranged in a row, and each pile has a **positive** integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones. The **total** number of stones across all the piles is **odd**, so there are no ties.\n\nAlice and Bob take turns, with **Alice starting first**. Each turn, a player takes the entire pile of stones either from the **beginning** or from the **end** of the row. This continues until there are no more piles left, at which point the person with the **most stones wins**.\n\nAssuming Alice and Bob play optimally, return `true` _if Alice wins the game, or_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** piles = \\[5,3,4,5\\]\n**Output:** true\n**Explanation:** \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes \\[3, 4, 5\\].\nIf Bob takes 3, then the board is \\[4, 5\\], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is \\[3, 4\\], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\n**Example 2:**\n\n**Input:** piles = \\[3,7,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `2 <= piles.length <= 500`\n*   `piles.length` is **even**.\n*   `1 <= piles[i] <= 500`\n*   `sum(piles[i])` is **odd**.\"\"\"\n\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    q = deque()\n    \n    for i in range(n):\n        q.append((i, 1 << i))\n    steps = -1\n    visited = {i: set() for i in range(n)}\n    \n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            currNode, currVisits = q.popleft()\n            \n            if bin(currVisits).count('1') == n:\n                return steps\n\n            for nextNode in graph[currNode]:\n                nextVisits = currVisits | (1 << nextNode)\n\n                if nextVisits not in visited[nextNode]:\n                    visited[nextNode].add(nextVisits)\n                    q.append((nextNode, nextVisits))\n\n    return -1"}}, "leetcode/leetcode_649.txt": {"score": 0.9860687255859375, "content": {"text": "from collections import deque\n    \"\"\"In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise **one** of the two rights:\n\n*   **Ban one senator's right:** A senator can make another senator lose all his rights in this and all the following rounds.\n*   **Announce the victory:** If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\n\nGiven a string `senate` representing each senator's party belonging. The character `'R'` and `'D'` represent the Radiant party and the Dire party. Then if there are `n` senators, the size of the given string will be `n`.\n\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n\nSuppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be `\"Radiant \"` or `\"Dire \"`.\n\n**Example 1:**\n\n**Input:** senate =  \"RD \"\n**Output:**  \"Radiant \"\n**Explanation:** \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n\n**Example 2:**\n\n**Input:** senate =  \"RDD \"\n**Output:**  \"Dire \"\n**Explanation:** \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator's right in round 1. \nAnd in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n\n**Constraints:**\n\n*   `n == senate.length`\n*   `1 <= n <= 104`\n*   `senate[i]` is either `'R'` or `'D'`.\"\"\"\n\n\ndef predict_party_victory(senate: str) -> str:\n    radiant = deque()\n    dire = deque()\n    n = len(senate)\n    \n    for i, s in enumerate(senate):\n        if s == 'R':\n            radiant.append(i)\n        else:\n            dire.append(i)\n\n    while radiant and dire:\n        r = radiant.popleft()\n        d = dire.popleft()\n\n        if r < d:\n            radiant.append(r + n)\n        else:\n            dire.append(d + n)\n\n    return \"Dire\" if not radiant else \"Radiant\""}}, "leetcode/leetcode_2029.txt": {"score": 0.8991045355796814, "content": {"text": "def stoneGameIX(stones: List[int]) -> bool:\n    \"\"\"Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array `stones`, where `stones[i]` is the **value** of the `ith` stone.\n\nAlice and Bob take turns, with **Alice** starting first. On each turn, the player may remove any stone from `stones`. The player who removes a stone **loses** if the **sum** of the values of **all removed stones** is divisible by `3`. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\n\nAssuming both players play **optimally**, return `true` _if Alice wins and_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** stones = \\[2,1\\]\n**Output:** true\n**Explanation:** The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\n\n**Example 2:**\n\n**Input:** stones = \\[2\\]\n**Output:** false\n**Explanation:** Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\n\n**Example 3:**\n\n**Input:** stones = \\[5,1,2,4,3\\]\n**Output:** false\n**Explanation:** Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n\n**Constraints:**\n\n*   `1 <= stones.length <= 105`\n*   `1 <= stones[i] <= 104`\"\"\"\n\n    cnt = [0, 0, 0]\n    for s in stones:\n        cnt[s % 3] += 1\n    return (cnt[1] and cnt[2]) or (cnt[1] > cnt[2] if cnt[1] > cnt[2] + 2 else cnt[2] > cnt[1] + 1)"}}, "leetcode/leetcode_2151.txt": {"score": 0.9003300666809082, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There are two types of persons:\n\n*   The **good person**: The person who always tells the truth.\n*   The **bad person**: The person who might tell the truth and might lie.\n\nYou are given a **0-indexed** 2D integer array `statements` of size `n x n` that represents the statements made by `n` people about each other. More specifically, `statements[i][j]` could be one of the following:\n\n*   `0` which represents a statement made by person `i` that person `j` is a **bad** person.\n*   `1` which represents a statement made by person `i` that person `j` is a **good** person.\n*   `2` represents that **no statement** is made by person `i` about person `j`.\n\nAdditionally, no person ever makes a statement about themselves. Formally, we have that `statements[i][i] = 2` for all `0 <= i < n`.\n\nReturn _the **maximum** number of people who can be **good** based on the statements made by the_ `n` _people_.\n\n**Example 1:**\n\n**Input:** statements = \\[\\[2,1,2\\],\\[1,2,2\\],\\[2,0,2\\]\\]\n**Output:** 2\n**Explanation:** Each person makes a single statement.\n- Person 0 states that person 1 is good.\n- Person 1 states that person 0 is good.\n- Person 2 states that person 1 is bad.\nLet's take person 2 as the key.\n- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n    - **Following that person 2 is a good person, there will be only one good person in the group**.\n- Assuming that person 2 is a bad person:\n    - Based on the statement made by person 2, and since person 2 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.\n            - **Following that person 2 is bad but told the truth, there will be no good persons in the group**.\n        - lying. In this case person 1 is a good person.\n            - Since person 1 is a good person, person 0 is also a good person.\n            - **Following that person 2 is bad and lied, there will be two good persons in the group**.\nWe can see that at most 2 persons are good in the best case, so we return 2.\nNote that there is more than one way to arrive at this conclusion.\n\n**Example 2:**\n\n**Input:** statements = \\[\\[2,0\\],\\[0,2\\]\\]\n**Output:** 1\n**Explanation:** Each person makes a single statement.\n- Person 0 states that person 1 is bad.\n- Person 1 states that person 0 is bad.\nLet's take person 0 as the key.\n- Assuming that person 0 is a good person:\n    - Based on the statement made by person 0, person 1 is a bad person and was lying.\n    - **Following that person 0 is a good person, there will be only one good person in the group**.\n- Assuming that person 0 is a bad person:\n    - Based on the statement made by person 0, and since person 0 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad.\n            - **Following that person 0 is bad but told the truth, there will be no good persons in the group**.\n        - lying. In this case person 1 is a good person.\n            - **Following that person 0 is bad and lied, there will be only one good person in the group**.\nWe can see that at most, one person is good in the best case, so we return 1.\nNote that there is more than one way to arrive at this conclusion.\n\n**Constraints:**\n\n*   `n == statements.length == statements[i].length`\n*   `2 <= n <= 15`\n*   `statements[i][j]` is either `0`, `1`, or `2`.\n*   `statements[i][i] == 2`\"\"\"\n\n\ndef network_becomes_idle(edges, patience):\n    n = len(patience)\n    graph = defaultdict(list)\n    \n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    dist = [-1] * n\n    dist[0] = 0\n    q = deque([0])\n    \n    while q:\n        node = q.popleft()\n        \n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                q.append(neighbor)\n\n    max_time = 0\n    for i in range(1, n):\n        time = ((2 * dist[i] - 1) // patience[i]) * patience[i] + 2 * dist[i]\n        max_time = max(max_time, time)\n    \n    return max_time + 1"}}}}, "29": {"gold": {"leetcode/leetcode_547.txt": 1, "leetcode/leetcode_2120.txt": 1}, "retrieved": {"leetcode/leetcode_2582.txt": {"score": 0.8527445197105408, "content": {"text": "def pillowHolder(n, time):\n    \"\"\"There are `n` people standing in a line labeled from `1` to `n`. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\n\n*   For example, once the pillow reaches the `nth` person they pass it to the `n - 1th` person, then to the `n - 2th` person and so on.\n\nGiven the two positive integers `n` and `time`, return _the index of the person holding the pillow after_ `time` _seconds_.\n\n**Example 1:**\n\n**Input:** n = 4, time = 5\n**Output:** 2\n**Explanation:** People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.\nAfer five seconds, the pillow is given to the 2nd person.\n\n**Example 2:**\n\n**Input:** n = 3, time = 2\n**Output:** 3\n**Explanation:** People pass the pillow in the following way: 1 -> 2 -> 3.\nAfer two seconds, the pillow is given to the 3rd person.\n\n**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= time <= 1000`\"\"\"\n\n    time %= (2 * n - 2)\n    if time <= n - 1:\n        return time + 1\n    else:\n        return 2 * n - time - 1"}}, "leetcode/leetcode_1041.txt": {"score": 0.8557723760604858, "content": {"text": "def numRookCaptures(board):\n    \"\"\"On an infinite plane, a robot initially stands at `(0, 0)` and faces north. Note that:\n\n*   The **north direction** is the positive direction of the y-axis.\n*   The **south direction** is the negative direction of the y-axis.\n*   The **east direction** is the positive direction of the x-axis.\n*   The **west direction** is the negative direction of the x-axis.\n\nThe robot can receive one of three instructions:\n\n*   `\"G \"`: go straight 1 unit.\n*   `\"L \"`: turn 90 degrees to the left (i.e., anti-clockwise direction).\n*   `\"R \"`: turn 90 degrees to the right (i.e., clockwise direction).\n\nThe robot performs the `instructions` given in order, and repeats them forever.\n\nReturn `true` if and only if there exists a circle in the plane such that the robot never leaves the circle.\n\n**Example 1:**\n\n**Input:** instructions =  \"GGLLGG \"\n**Output:** true\n**Explanation:** The robot is initially at (0, 0) facing the north direction.\n \"G \": move one step. Position: (0, 1). Direction: North.\n \"G \": move one step. Position: (0, 2). Direction: North.\n \"L \": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.\n \"L \": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.\n \"G \": move one step. Position: (0, 1). Direction: South.\n \"G \": move one step. Position: (0, 0). Direction: South.\nRepeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (0, 2) --> (0, 1) --> (0, 0).\nBased on that, we return true.\n\n**Example 2:**\n\n**Input:** instructions =  \"GG \"\n**Output:** false\n**Explanation:** The robot is initially at (0, 0) facing the north direction.\n \"G \": move one step. Position: (0, 1). Direction: North.\n \"G \": move one step. Position: (0, 2). Direction: North.\nRepeating the instructions, keeps advancing in the north direction and does not go into cycles.\nBased on that, we return false.\n\n**Example 3:**\n\n**Input:** instructions =  \"GL \"\n**Output:** true\n**Explanation:** The robot is initially at (0, 0) facing the north direction.\n \"G \": move one step. Position: (0, 1). Direction: North.\n \"L \": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.\n \"G \": move one step. Position: (-1, 1). Direction: West.\n \"L \": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.\n \"G \": move one step. Position: (-1, 0). Direction: South.\n \"L \": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.\n \"G \": move one step. Position: (0, 0). Direction: East.\n \"L \": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.\nRepeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (-1, 1) --> (-1, 0) --> (0, 0).\nBased on that, we return true.\n\n**Constraints:**\n\n*   `1 <= instructions.length <= 100`\n*   `instructions[i]` is `'G'`, `'L'` or, `'R'`.\"\"\"\n\n    x, y, captures = 0, 0, 0\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                x, y = i, j\n                break\n        if board[x][y] == 'R':\n            break\n\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for dx, dy in dirs:\n        nx, ny = x + dx, y + dy\n        while 0 <= nx < 8 and 0 <= ny < 8:\n            if board[nx][ny] == 'p':\n                captures += 1\n                break\n            elif board[nx][ny] == 'B':\n                break\n            nx += dx\n            ny += dy\n\n    return captures"}}, "leetcode/csn_python_train_191139.txt": {"score": 0.8538916110992432, "content": {"text": "def move(self, direction=0):\n        \"\"\"\n            direction = int range(0, 4)\n\n            0 = Down\n            1 = Left\n            2 = Up\n            3 = Right\n        \"\"\"\n        direction = int(direction)\n        self.position = list(self.position)\n\n        if direction == 0:\n            self.position[1] += 1\n        elif direction == 1:\n            self.position[0] -= 1\n        elif direction == 2:\n            self.position[1] -= 1\n        elif direction == 3:\n            self.position[0] += 1"}}, "leetcode/leetcode_2543.txt": {"score": 0.8616498708724976, "content": {"text": "def canReach(targetX, targetY):\n    \"\"\"There exists an infinitely large grid. You are currently at point `(1, 1)`, and you need to reach the point `(targetX, targetY)` using a finite number of steps.\n\nIn one **step**, you can move from point `(x, y)` to any one of the following points:\n\n*   `(x, y - x)`\n*   `(x - y, y)`\n*   `(2 * x, y)`\n*   `(x, 2 * y)`\n\nGiven two integers `targetX` and `targetY` representing the X-coordinate and Y-coordinate of your final position, return `true` _if you can reach the point from_ `(1, 1)` _using some number of steps, and_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** targetX = 6, targetY = 9\n**Output:** false\n**Explanation:** It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.\n\n**Example 2:**\n\n**Input:** targetX = 4, targetY = 7\n**Output:** true\n**Explanation:** You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7).\n\n**Constraints:**\n\n*   `1 <= targetX, targetY <= 109`\"\"\"\n\n    while targetX > 1 and targetY > 1:\n        if targetX < targetY:\n            targetX, targetY = targetY, targetX\n        targetX -= targetY\n    return targetX == 1 or targetY == 1"}}, "leetcode/leetcode_1823.txt": {"score": 0.8683084845542908, "content": {"text": "def halves_are_alike(s: str) -> bool:\n    \"\"\"There are `n` friends that are playing a game. The friends are sitting in a circle and are numbered from `1` to `n` in **clockwise order**. More formally, moving clockwise from the `ith` friend brings you to the `(i+1)th` friend for `1 <= i < n`, and moving clockwise from the `nth` friend brings you to the `1st` friend.\n\nThe rules of the game are as follows:\n\n1.  **Start** at the `1st` friend.\n2.  Count the next `k` friends in the clockwise direction **including** the friend you started at. The counting wraps around the circle and may count some friends more than once.\n3.  The last friend you counted leaves the circle and loses the game.\n4.  If there is still more than one friend in the circle, go back to step `2` **starting** from the friend **immediately clockwise** of the friend who just lost and repeat.\n5.  Else, the last friend in the circle wins the game.\n\nGiven the number of friends, `n`, and an integer `k`, return _the winner of the game_.\n\n**Example 1:**\n\n**Input:** n = 5, k = 2\n**Output:** 3\n**Explanation:** Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.\n\n**Example 2:**\n\n**Input:** n = 6, k = 5\n**Output:** 1\n**Explanation:** The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.\n\n**Constraints:**\n\n*   `1 <= k <= n <= 500`\n\n**Follow up:**\n\nCould you solve this problem in linear time with constant space?\"\"\"\n\n    half_length = len(s) // 2\n    count_a, count_b = 0, 0\n\n    for i in range(half_length):\n        if s[i] in \"aeiouAEIOU\": count_a += 1\n\n    for i in range(half_length, len(s)):\n        if s[i] in \"aeiouAEIOU\": count_b += 1\n\n    return count_a == count_b"}}, "leetcode/leetcode_2120.txt": {"score": 0.8718259930610657, "content": {"text": "def findNoOfInstructions(n: int, startPos: List[int], s: str) -> List[int]:\n    \"\"\"There is an `n x n` grid, with the top-left cell at `(0, 0)` and the bottom-right cell at `(n - 1, n - 1)`. You are given the integer `n` and an integer array `startPos` where `startPos = [startrow, startcol]` indicates that a robot is initially at cell `(startrow, startcol)`.\n\nYou are also given a **0-indexed** string `s` of length `m` where `s[i]` is the `ith` instruction for the robot: `'L'` (move left), `'R'` (move right), `'U'` (move up), and `'D'` (move down).\n\nThe robot can begin executing from any `ith` instruction in `s`. It executes the instructions one by one towards the end of `s` but it stops if either of these conditions is met:\n\n*   The next instruction will move the robot off the grid.\n*   There are no more instructions left to execute.\n\nReturn _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is **the number of instructions** the robot can execute if the robot **begins executing from** the_ `ith` _instruction in_ `s`.\n\n**Example 1:**\n\n**Input:** n = 3, startPos = \\[0,1\\], s =  \"RRDDLU \"\n**Output:** \\[1,5,4,3,1,0\\]\n**Explanation:** Starting from startPos and beginning execution from the ith instruction:\n- 0th:  \"**R**RDDLU \". Only one instruction  \"R \" can be executed before it moves off the grid.\n- 1st:   \"**RDDLU** \". All five instructions can be executed while it stays in the grid and ends at (1, 1).\n- 2nd:    \"**DDLU** \". All four instructions can be executed while it stays in the grid and ends at (1, 0).\n- 3rd:     \"**DLU** \". All three instructions can be executed while it stays in the grid and ends at (0, 0).\n- 4th:      \"**L**U \". Only one instruction  \"L \" can be executed before it moves off the grid.\n- 5th:       \"U \". If moving up, it would move off the grid.\n\n**Example 2:**\n\n**Input:** n = 2, startPos = \\[1,1\\], s =  \"LURD \"\n**Output:** \\[4,1,0,0\\]\n**Explanation:**\n- 0th:  \"**LURD** \".\n- 1st:   \"**U**RD \".\n- 2nd:    \"RD \".\n- 3rd:     \"D \".\n\n**Example 3:**\n\n**Input:** n = 1, startPos = \\[0,0\\], s =  \"LRUD \"\n**Output:** \\[0,0,0,0\\]\n**Explanation:** No matter which instruction the robot begins execution from, it would move off the grid.\n\n**Constraints:**\n\n*   `m == s.length`\n*   `1 <= n, m <= 500`\n*   `startPos.length == 2`\n*   `0 <= startrow, startcol < n`\n*   `s` consists of `'L'`, `'R'`, `'U'`, and `'D'`.\"\"\"\n\n    answer = [0] * len(s)\n    x, y = startPos\n\n    for i in range(len(s)):\n        cnt = 0\n        cx, cy = x, y\n        for j in range(i, len(s)):\n            step = s[j]\n            if step == 'L':\n                if cy == 0: break\n                cy -= 1\n            elif step == 'R':\n                if cy == n - 1: break\n                cy += 1\n            elif step == 'U':\n                if cx == 0: break\n                cx -= 1\n            else:\n                if cx == n - 1: break\n                cx += 1\n            cnt += 1\n            if j == len(s) - 1: break\n        answer[i] = cnt\n\n    return answer"}}, "leetcode/leetcode_1496.txt": {"score": 0.8675740957260132, "content": {"text": "def lucky_numbers(matrix):\n    \"\"\"Given a string `path`, where `path[i] = 'N'`, `'S'`, `'E'` or `'W'`, each representing moving one unit north, south, east, or west, respectively. You start at the origin `(0, 0)` on a 2D plane and walk on the path specified by `path`.\n\nReturn `true` _if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited_. Return `false` otherwise.\n\n**Example 1:**\n\n**Input:** path =  \"NES \"\n**Output:** false \n**Explanation:** Notice that the path doesn't cross any point more than once.\n\n**Example 2:**\n\n**Input:** path =  \"NESWW \"\n**Output:** true\n**Explanation:** Notice that the path visits the origin twice.\n\n**Constraints:**\n\n*   `1 <= path.length <= 104`\n*   `path[i]` is either `'N'`, `'S'`, `'E'`, or `'W'`.\"\"\"\n\n    m, n = len(matrix), len(matrix[0])\n    lucky_numbers = []\n\n    for i in range(m):\n        min_row = min(matrix[i])\n        min_row_idx = matrix[i].index(min_row)\n        is_lucky = all(matrix[k][min_row_idx] <= min_row for k in range(m))\n\n        if is_lucky:\n            lucky_numbers.append(min_row)\n\n    return lucky_numbers"}}, "leetcode/leetcode_874.txt": {"score": 0.8983325362205505, "content": {"text": "def backspace_compare(s, t):\n    \"\"\"A robot on an infinite XY-plane starts at point `(0, 0)` facing north. The robot can receive a sequence of these three possible types of `commands`:\n\n*   `-2`: Turn left `90` degrees.\n*   `-1`: Turn right `90` degrees.\n*   `1 <= k <= 9`: Move forward `k` units, one unit at a time.\n\nSome of the grid squares are `obstacles`. The `ith` obstacle is at grid point `obstacles[i] = (xi, yi)`. If the robot runs into an obstacle, then it will instead stay in its current location and move on to the next command.\n\nReturn _the **maximum Euclidean distance** that the robot ever gets from the origin **squared** (i.e. if the distance is_ `5`_, return_ `25`_)_.\n\n**Note:**\n\n*   North means +Y direction.\n*   East means +X direction.\n*   South means -Y direction.\n*   West means -X direction.\n\n**Example 1:**\n\n**Input:** commands = \\[4,-1,3\\], obstacles = \\[\\]\n**Output:** 25\n**Explanation:** The robot starts at (0, 0):\n1. Move north 4 units to (0, 4).\n2. Turn right.\n3. Move east 3 units to (3, 4).\nThe furthest point the robot ever gets from the origin is (3, 4), which squared is 32 + 42 = 25 units away.\n\n**Example 2:**\n\n**Input:** commands = \\[4,-1,4,-2,4\\], obstacles = \\[\\[2,4\\]\\]\n**Output:** 65\n**Explanation:** The robot starts at (0, 0):\n1. Move north 4 units to (0, 4).\n2. Turn right.\n3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).\n4. Turn left.\n5. Move north 4 units to (1, 8).\nThe furthest point the robot ever gets from the origin is (1, 8), which squared is 12 + 82 = 65 units away.\n\n**Example 3:**\n\n**Input:** commands = \\[6,-1,-1,6\\], obstacles = \\[\\]\n**Output:** 36\n**Explanation:** The robot starts at (0, 0):\n1. Move north 6 units to (0, 6).\n2. Turn right.\n3. Turn right.\n4. Move south 6 units to (0, 0).\nThe furthest point the robot ever gets from the origin is (0, 6), which squared is 62 = 36 units away.\n\n**Constraints:**\n\n*   `1 <= commands.length <= 104`\n*   `commands[i]` is either `-2`, `-1`, or an integer in the range `[1, 9]`.\n*   `0 <= obstacles.length <= 104`\n*   `-3 * 104 <= xi, yi <= 3 * 104`\n*   The answer is guaranteed to be less than `231`.\"\"\"\n\n    def process_backspaces(string):\n        stack = []\n        for c in string:\n            if c != '#':\n                stack.append(c)\n            elif stack:\n                stack.pop()\n        return stack\n\n    return process_backspaces(s) == process_backspaces(t)"}}, "leetcode/leetcode_335.txt": {"score": 0.8798352479934692, "content": {"text": "def is_path_crossing(distance):\n    \"\"\"You are given an array of integers `distance`.\n\nYou start at the point `(0, 0)` on an **X-Y plane,** and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\n\nReturn `true` _if your path crosses itself or_ `false` _if it does not_.\n\n**Example 1:**\n\n**Input:** distance = \\[2,1,1,2\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 1).\n\n**Example 2:**\n\n**Input:** distance = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** The path does not cross itself at any point.\n\n**Example 3:**\n\n**Input:** distance = \\[1,1,1,2,1\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 0).\n\n**Constraints:**\n\n*   `1 <= distance.length <= 105`\n*   `1 <= distance[i] <= 105`\"\"\"\n\n    visited = set([(0, 0)])\n    x, y = 0, 0\n    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n    \n    for i, d in enumerate(distance):\n        dx, dy = directions[i % 4]\n        for _ in range(d):\n            x += dx\n            y += dy\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n    return False"}}, "leetcode/leetcode_657.txt": {"score": 0.9855473637580872, "content": {"text": "def judgeCircle(moves: str) -> bool:\n    \"\"\"There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at** `(0, 0)` after it completes its moves.\n\nYou are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).\n\nReturn `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.\n\n**Note**: The way that the robot is \"facing \" is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n\n**Example 1:**\n\n**Input:** moves =  \"UD \"\n**Output:** true\n**Explanation**: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n\n**Example 2:**\n\n**Input:** moves =  \"LL \"\n**Output:** false\n**Explanation**: The robot moves left twice. It ends up two  \"moves \" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n\n**Constraints:**\n\n*   `1 <= moves.length <= 2 * 104`\n*   `moves` only contains the characters `'U'`, `'D'`, `'L'` and `'R'`.\"\"\"\n\n    x, y = 0, 0\n    for move in moves:\n        if move == 'U': y += 1\n        elif move == 'D': y -= 1\n        elif move == 'R': x += 1\n        elif move == 'L': x -= 1\n    return x == 0 and y == 0"}}}}, "30": {"gold": {"leetcode/leetcode_378.txt": 1, "leetcode/leetcode_719.txt": 1, "leetcode/leetcode_786.txt": 1}, "retrieved": {"leetcode/leetcode_1292.txt": {"score": 0.8769470453262329, "content": {"text": "def maxSideLength(mat: List[List[int]], threshold: int) -> int:\n    \"\"\"Given a `m x n` matrix `mat` and an integer `threshold`, return _the maximum side-length of a square with a sum less than or equal to_ `threshold` _or return_ `0` _if there is no such square_.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[1,1,3,2,4,3,2\\],\\[1,1,3,2,4,3,2\\],\\[1,1,3,2,4,3,2\\]\\], threshold = 4\n**Output:** 2\n**Explanation:** The maximum side length of square with sum less than 4 is 2 as shown.\n\n**Example 2:**\n\n**Input:** mat = \\[\\[2,2,2,2,2\\],\\[2,2,2,2,2\\],\\[2,2,2,2,2\\],\\[2,2,2,2,2\\],\\[2,2,2,2,2\\]\\], threshold = 1\n**Output:** 0\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 300`\n*   `0 <= mat[i][j] <= 104`\n*   `0 <= threshold <= 105`\"\"\"\n\n    m, n = len(mat), len(mat[0])\n    preSum = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            preSum[i][j] = mat[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1]\n\n    maxSide = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, min(m, n) + 1):\n                endX, endY = i + k - 1, j + k - 1\n                if endX <= m and endY <= n:\n                    sum = preSum[endX][endY] - preSum[endX][j - 1] - preSum[i - 1][endY] + preSum[i - 1][j - 1]\n                    if sum <= threshold:\n                        maxSide = max(maxSide, k)\n                else:\n                    break\n    return maxSide"}}, "leetcode/leetcode_598.txt": {"score": 0.8810189962387085, "content": {"text": "def maxCount(m: int, n: int, ops: List[List[int]]) -> int:\n    \"\"\"You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`.\n\nCount and return _the number of maximum integers in the matrix after performing all the operations_.\n\n**Example 1:**\n\n**Input:** m = 3, n = 3, ops = \\[\\[2,2\\],\\[3,3\\]\\]\n**Output:** 4\n**Explanation:** The maximum integer in M is 2, and there are four of it in M. So return 4.\n\n**Example 2:**\n\n**Input:** m = 3, n = 3, ops = \\[\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\],\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\],\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** m = 3, n = 3, ops = \\[\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `1 <= m, n <= 4 * 104`\n*   `0 <= ops.length <= 104`\n*   `ops[i].length == 2`\n*   `1 <= ai <= m`\n*   `1 <= bi <= n`\"\"\"\n\n    for op in ops:\n        m = min(m, op[0])\n        n = min(n, op[1])\n    return m * n"}}, "leetcode/leetcode_967.txt": {"score": 0.8780951499938965, "content": {"text": "def minFallingPathSum(matrix):\n    \"\"\"Given two integers n and k, return _an array of all the integers of length_ `n` _where the difference between every two consecutive digits is_ `k`. You may return the answer in **any order**.\n\nNote that the integers should not have leading zeros. Integers as `02` and `043` are not allowed.\n\n**Example 1:**\n\n**Input:** n = 3, k = 7\n**Output:** \\[181,292,707,818,929\\]\n**Explanation:** Note that 070 is not a valid number, because it has leading zeroes.\n\n**Example 2:**\n\n**Input:** n = 2, k = 1\n**Output:** \\[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98\\]\n\n**Constraints:**\n\n*   `2 <= n <= 9`\n*   `0 <= k <= 9`\"\"\"\n\n    n = len(matrix)\n    for i in range(1, n):\n        for j in range(n):\n            min_val = matrix[i - 1][j]\n            if j > 0: min_val = min(min_val, matrix[i - 1][j - 1])\n            if j < n - 1: min_val = min(min_val, matrix[i - 1][j + 1])\n            matrix[i][j] += min_val\n    return min(matrix[-1])"}}, "leetcode/leetcode_1632.txt": {"score": 0.8819870352745056, "content": {"text": "def numSplits(s: str) -> int:\n    \"\"\"Given an `m x n` `matrix`, return _a new matrix_ `answer` _where_ `answer[row][col]` _is the_ _**rank** of_ `matrix[row][col]`.\n\nThe **rank** is an **integer** that represents how large an element is compared to other elements. It is calculated using the following rules:\n\n*   The rank is an integer starting from `1`.\n*   If two elements `p` and `q` are in the **same row or column**, then:\n    *   If `p < q` then `rank(p) < rank(q)`\n    *   If `p == q` then `rank(p) == rank(q)`\n    *   If `p > q` then `rank(p) > rank(q)`\n*   The **rank** should be as **small** as possible.\n\nThe test cases are generated so that `answer` is unique under the given rules.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** \\[\\[1,2\\],\\[2,3\\]\\]\n**Explanation:**\nThe rank of matrix\\[0\\]\\[0\\] is 1 because it is the smallest integer in its row and column.\nThe rank of matrix\\[0\\]\\[1\\] is 2 because matrix\\[0\\]\\[1\\] > matrix\\[0\\]\\[0\\] and matrix\\[0\\]\\[0\\] is rank 1.\nThe rank of matrix\\[1\\]\\[0\\] is 2 because matrix\\[1\\]\\[0\\] > matrix\\[0\\]\\[0\\] and matrix\\[0\\]\\[0\\] is rank 1.\nThe rank of matrix\\[1\\]\\[1\\] is 3 because matrix\\[1\\]\\[1\\] > matrix\\[0\\]\\[1\\], matrix\\[1\\]\\[1\\] > matrix\\[1\\]\\[0\\], and both matrix\\[0\\]\\[1\\] and matrix\\[1\\]\\[0\\] are rank 2.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[7,7\\],\\[7,7\\]\\]\n**Output:** \\[\\[1,1\\],\\[1,1\\]\\]\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[20,-21,14\\],\\[-19,4,19\\],\\[22,-47,24\\],\\[-19,4,19\\]\\]\n**Output:** \\[\\[4,2,3\\],\\[1,3,4\\],\\[5,1,6\\],\\[1,3,4\\]\\]\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 500`\n*   `-109 <= matrix[row][col] <= 109`\"\"\"\n\n    left_set, right_set = set(), set()\n    left, right = [0] * len(s), [0] * len(s)\n    count = 0\n\n    for i, char in enumerate(s):\n        left_set.add(char)\n        left[i] = len(left_set)\n\n    for i in range(len(s) - 1, 0, -1):\n        right_set.add(s[i])\n        right[i] = len(right_set)\n\n    for i in range(len(s) - 1):\n        if left[i] == right[i + 1]:\n            count += 1\n\n    return count"}}, "leetcode/leetcode_1738.txt": {"score": 0.8993686437606812, "content": {"text": "def maximalNetworkRank(n, roads):\n    \"\"\"You are given a 2D `matrix` of size `m x n`, consisting of non-negative integers. You are also given an integer `k`.\n\nThe **value** of coordinate `(a, b)` of the matrix is the XOR of all `matrix[i][j]` where `0 <= i <= a < m` and `0 <= j <= b < n` **(0-indexed)**.\n\nFind the `kth` largest value **(1-indexed)** of all the coordinates of `matrix`.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[5,2\\],\\[1,6\\]\\], k = 1\n**Output:** 7\n**Explanation:** The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[5,2\\],\\[1,6\\]\\], k = 2\n**Output:** 5\n**Explanation:** The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[5,2\\],\\[1,6\\]\\], k = 3\n**Output:** 4\n**Explanation:** The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 1000`\n*   `0 <= matrix[i][j] <= 106`\n*   `1 <= k <= m * n`\"\"\"\n\n    degree = [0] * n\n    s = set()\n    \n    for road in roads:\n        degree[road[0]] += 1\n        degree[road[1]] += 1\n        s.add(tuple(sorted(road)))\n    \n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans = max(ans, degree[i] + degree[j] - (1 if (i, j) in s else 0))\n    return ans"}}, "leetcode/leetcode_668.txt": {"score": 0.9894912242889404, "content": {"text": "def findKthNumber(m, n, k):\n    \"\"\"Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j` (**1-indexed**).\n\nGiven three integers `m`, `n`, and `k`, return _the_ `kth` _smallest element in the_ `m x n` _multiplication table_.\n\n**Example 1:**\n\n**Input:** m = 3, n = 3, k = 5\n**Output:** 3\n**Explanation:** The 5th smallest number is 3.\n\n**Example 2:**\n\n**Input:** m = 2, n = 3, k = 6\n**Output:** 6\n**Explanation:** The 6th smallest number is 6.\n\n**Constraints:**\n\n*   `1 <= m, n <= 3 * 104`\n*   `1 <= k <= m * n`\"\"\"\n\n    low, high = 1, m * n\n    while low < high:\n        mid = low + (high - low) // 2\n        count = 0\n        for i in range(1, m+1):\n            count += min(mid // i, n)\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low"}}, "leetcode/leetcode_1252.txt": {"score": 0.8787225484848022, "content": {"text": "def break_palindrome(palindrome: str) -> str:\n    \"\"\"There is an `m x n` matrix that is initialized to all `0`'s. There is also a 2D array `indices` where each `indices[i] = [ri, ci]` represents a **0-indexed location** to perform some increment operations on the matrix.\n\nFor each location `indices[i]`, do **both** of the following:\n\n1.  Increment **all** the cells on row `ri`.\n2.  Increment **all** the cells on column `ci`.\n\nGiven `m`, `n`, and `indices`, return _the **number of odd-valued cells** in the matrix after applying the increment to all locations in_ `indices`.\n\n**Example 1:**\n\n**Input:** m = 2, n = 3, indices = \\[\\[0,1\\],\\[1,1\\]\\]\n**Output:** 6\n**Explanation:** Initial matrix = \\[\\[0,0,0\\],\\[0,0,0\\]\\].\nAfter applying first increment it becomes \\[\\[1,2,1\\],\\[0,1,0\\]\\].\nThe final matrix is \\[\\[1,3,1\\],\\[1,3,1\\]\\], which contains 6 odd numbers.\n\n**Example 2:**\n\n**Input:** m = 2, n = 2, indices = \\[\\[1,1\\],\\[0,0\\]\\]\n**Output:** 0\n**Explanation:** Final matrix = \\[\\[2,2\\],\\[2,2\\]\\]. There are no odd numbers in the final matrix.\n\n**Constraints:**\n\n*   `1 <= m, n <= 50`\n*   `1 <= indices.length <= 100`\n*   `0 <= ri < m`\n*   `0 <= ci < n`\n\n**Follow up:** Could you solve this in `O(n + m + indices.length)` time with only `O(n + m)` extra space?\"\"\"\n\n    n = len(palindrome)\n    if n < 2:\n        return \"\"\n    \n    palindrome = list(palindrome)\n    for i in range(n // 2):\n        if palindrome[i] != 'a':\n            palindrome[i] = 'a'\n            return \"\".join(palindrome)\n    \n    palindrome[-1] = 'b'\n    return \"\".join(palindrome)"}}, "leetcode/leetcode_378.txt": {"score": 0.8847752809524536, "content": {"text": "import heapq\n    \"\"\"Given an `n x n` `matrix` where each of the rows and columns is sorted in ascending order, return _the_ `kth` _smallest element in the matrix_.\n\nNote that it is the `kth` smallest element **in the sorted order**, not the `kth` **distinct** element.\n\nYou must find a solution with a memory complexity better than `O(n2)`.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,5,9\\],\\[10,11,13\\],\\[12,13,15\\]\\], k = 8\n**Output:** 13\n**Explanation:** The elements in the matrix are \\[1,5,9,10,11,12,13,**13**,15\\], and the 8th smallest number is 13\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[-5\\]\\], k = 1\n**Output:** -5\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 300`\n*   `-109 <= matrix[i][j] <= 109`\n*   All the rows and columns of `matrix` are **guaranteed** to be sorted in **non-decreasing order**.\n*   `1 <= k <= n2`\n\n**Follow up:**\n\n*   Could you solve the problem with a constant memory (i.e., `O(1)` memory complexity)?\n*   Could you solve the problem in `O(n)` time complexity? The solution may be too advanced for an interview but you may find reading [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) fun.\"\"\"\n\n\ndef kthSmallest(matrix, k):\n    n = len(matrix)\n    min_heap = []\n\n    for i in range(n):\n        heapq.heappush(min_heap, (matrix[i][0], i, 0))\n\n    while k > 1:\n        val, row, col = heapq.heappop(min_heap)\n\n        if col + 1 < n:\n            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))\n\n        k -= 1\n\n    return min_heap[0][0]"}}, "leetcode/leetcode_1380.txt": {"score": 0.8893783688545227, "content": {"text": "dx = [-1, 1, 0, 0]\n    \"\"\"Given an `m x n` matrix of **distinct** numbers, return _all **lucky numbers** in the matrix in **any** order_.\n\nA **lucky number** is an element of the matrix such that it is the minimum element in its row and maximum in its column.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[3,7,8\\],\\[9,11,13\\],\\[15,16,17\\]\\]\n**Output:** \\[15\\]\n**Explanation:** 15 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[1,10,4,2\\],\\[9,3,8,7\\],\\[15,16,17,12\\]\\]\n**Output:** \\[12\\]\n**Explanation:** 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[7,8\\],\\[1,2\\]\\]\n**Output:** \\[7\\]\n**Explanation:** 7 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= n, m <= 50`\n*   `1 <= matrix[i][j] <= 105`.\n*   All elements in the matrix are distinct.\"\"\"\n\ndy = [0, 0, -1, 1]\n\ndef dfs(grid, x, y):\n    n, m = len(grid), len(grid[0])\n    grid[x][y] = 1\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0:\n            dfs(grid, nx, ny)\n\ndef closedIsland(grid):\n    n, m = len(grid), len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n                if grid[i][j] == 0:\n                    dfs(grid, i, j)\n    res = 0\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if grid[i][j] == 0:\n                dfs(grid, i, j)\n                res += 1\n    return res"}}, "leetcode/leetcode_1550.txt": {"score": 0.9087740778923035, "content": {"text": "import heapq\n    \"\"\"Given an integer array `arr`, return `true` if there are three consecutive odd numbers in the array. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** arr = \\[2,6,4,1\\]\n**Output:** false\n**Explanation:** There are no three consecutive odds.\n\n**Example 2:**\n\n**Input:** arr = \\[1,2,34,3,4,5,7,23,12\\]\n**Output:** true\n**Explanation:** \\[5,7,23\\] are three consecutive odds.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 1000`\"\"\"\n\n\ndef kthSmallest(mat, k):\n    m, n = len(mat), len(mat[0])\n    \n    minHeap = [(mat[0][0], 0, 0)]\n    visited = [[False for _ in range(n)] for _ in range(m)]\n    visited[0][0] = True\n    \n    for _ in range(k):\n        res, i, j = heapq.heappop(minHeap)\n        \n        if i < m - 1 and not visited[i+1][j]:\n            heapq.heappush(minHeap, (res - mat[i][j] + mat[i + 1][j], i + 1, j))\n            visited[i+1][j] = True\n        if j < n - 1 and not visited[i][j+1]:\n            heapq.heappush(minHeap, (res - mat[i][j] + mat[i][j + 1], i, j + 1))\n            visited[i][j+1] = True\n            \n    return res"}}}}, "31": {"gold": {"leetcode/leetcode_319.txt": 1, "leetcode/leetcode_1375.txt": 1}, "retrieved": {"leetcode/leetcode_1223.txt": {"score": 0.877312958240509, "content": {"text": "def areConnected(n, threshold, queries):\n    \"\"\"A die simulator generates a random number from `1` to `6` for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (**1-indexed**) consecutive times.\n\nGiven an array of integers `rollMax` and an integer `n`, return _the number of distinct sequences that can be obtained with exact_ `n` _rolls_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\nTwo sequences are considered different if at least one element differs from each other.\n\n**Example 1:**\n\n**Input:** n = 2, rollMax = \\[1,1,2,2,2,3\\]\n**Output:** 34\n**Explanation:** There will be 2 rolls of die, if there are no constraints on the die, there are 6 \\* 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n\n**Example 2:**\n\n**Input:** n = 2, rollMax = \\[1,1,1,1,1,1\\]\n**Output:** 30\n\n**Example 3:**\n\n**Input:** n = 3, rollMax = \\[1,1,1,2,2,3\\]\n**Output:** 181\n\n**Constraints:**\n\n*   `1 <= n <= 5000`\n*   `rollMax.length == 6`\n*   `1 <= rollMax[i] <= 15`\"\"\"\n\n    answer = [False] * len(queries)\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def unite(x, y):\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                rootx, rooty = rooty, rootx\n            parent[rootx] = rooty\n            if rank[rootx] == rank[rooty]:\n                rank[rooty] += 1\n\n    for i in range(threshold + 1, n + 1):\n        for j in range(i * 2, n + 1, i):\n            unite(i, j)\n\n    for i, query in enumerate(queries):\n        answer[i] = find(query[0]) == find(query[1])\n\n    return answer"}}, "leetcode/leetcode_1969.txt": {"score": 0.8812227249145508, "content": {"text": "def minNonZeroProduct(p: int) -> int:\n    \"\"\"You are given a positive integer `p`. Consider an array `nums` (**1-indexed**) that consists of the integers in the **inclusive** range `[1, 2p - 1]` in their binary representations. You are allowed to do the following operation **any** number of times:\n\n*   Choose two elements `x` and `y` from `nums`.\n*   Choose a bit in `x` and swap it with its corresponding bit in `y`. Corresponding bit refers to the bit that is in the **same position** in the other integer.\n\nFor example, if `x = 1101` and `y = 0011`, after swapping the `2nd` bit from the right, we have `x = 1111` and `y = 0001`.\n\nFind the **minimum non-zero** product of `nums` after performing the above operation **any** number of times. Return _this product_ _**modulo**_ `109 + 7`.\n\n**Note:** The answer should be the minimum product **before** the modulo operation is done.\n\n**Example 1:**\n\n**Input:** p = 1\n**Output:** 1\n**Explanation:** nums = \\[1\\].\nThere is only one element, so the product equals that element.\n\n**Example 2:**\n\n**Input:** p = 2\n**Output:** 6\n**Explanation:** nums = \\[01, 10, 11\\].\nAny swap would either make the product 0 or stay the same.\nThus, the array product of 1 \\* 2 \\* 3 = 6 is already minimized.\n\n**Example 3:**\n\n**Input:** p = 3\n**Output:** 1512\n**Explanation:** nums = \\[001, 010, 011, 100, 101, 110, 111\\]\n- In the first operation we can swap the leftmost bit of the second and fifth elements.\n    - The resulting array is \\[001, 110, 011, 100, 001, 110, 111\\].\n- In the second operation we can swap the middle bit of the third and fourth elements.\n    - The resulting array is \\[001, 110, 001, 110, 001, 110, 111\\].\nThe array product is 1 \\* 6 \\* 1 \\* 6 \\* 1 \\* 6 \\* 7 = 1512, which is the minimum possible product.\n\n**Constraints:**\n\n*   `1 <= p <= 60`\"\"\"\n\n    mod = 10**9 + 7\n    x = (1 << p) - 1\n    y = (1 << p) - 2\n    z = pow(y, x - 1, mod)\n    return x * z % mod"}}, "leetcode/leetcode_1931.txt": {"score": 0.8776643872261047, "content": {"text": "def numOfWays(m, n):\n    \"\"\"You are given two integers `m` and `n`. Consider an `m x n` grid where each cell is initially white. You can paint each cell **red**, **green**, or **blue**. All cells **must** be painted.\n\nReturn _the number of ways to color the grid with **no two adjacent cells having the same color**_. Since the answer can be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** m = 1, n = 1\n**Output:** 3\n**Explanation:** The three possible colorings are shown in the image above.\n\n**Example 2:**\n\n**Input:** m = 1, n = 2\n**Output:** 6\n**Explanation:** The six possible colorings are shown in the image above.\n\n**Example 3:**\n\n**Input:** m = 5, n = 5\n**Output:** 580986\n\n**Constraints:**\n\n*   `1 <= m <= 5`\n*   `1 <= n <= 1000`\"\"\"\n\n    mod = 1000000007\n    a, b, c, d = 6, 6, 3, 3\n    while n > 1:\n        n -= 1\n        temp_a = a\n        temp_c = c\n        a = (a * 3 + b * 2) % mod\n        b = (temp_a * 2 + b * 2) % mod\n        c = (c * 3 + d * 2) % mod\n        d = (temp_c * 2 + d * 2) % mod\n    return b if m == 1 else (a + c) % mod"}}, "leetcode/leetcode_810.txt": {"score": 0.8880943655967712, "content": {"text": "def valid_tic_tac_toe(board: List[str]) -> bool:\n    \"\"\"You are given an array of integers `nums` represents the numbers written on a chalkboard.\n\nAlice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become `0`, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is `0`.\n\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to `0`, then that player wins.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** false\n**Explanation:** \nAlice has two choices: erase 1 or erase 2. \nIf she erases 1, the nums array becomes \\[1, 2\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \nIf Alice erases 2 first, now nums become \\[1, 1\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** true\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < 216`\"\"\"\n\n    x_count = sum(row.count('X') for row in board)\n    o_count = sum(row.count('O') for row in board)\n    if x_count != o_count and x_count != o_count + 1: return False\n\n    x_win, o_win = False, False\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] != ' ':\n            x_win, o_win = (True, o_win) if board[i][0] == 'X' else (x_win, True)\n        if board[0][i] == board[1][i] == board[2][i] != ' ':\n            x_win, o_win = (True, o_win) if board[0][i] == 'X' else (x_win, True)\n    if board[0][0] == board[1][1] == board[2][2] != ' ':\n        x_win, o_win = (True, o_win) if board[0][0] == 'X' else (x_win, True)\n    if board[0][2] == board[1][1] == board[2][0] != ' ':\n        x_win, o_win = (True, o_win) if board[0][2] == 'X' else (x_win, True)\n\n    if x_win and o_win: return False\n    if x_win and x_count == o_count: return False\n    if o_win and x_count > o_count: return False\n\n    return True"}}, "leetcode/leetcode_2327.txt": {"score": 0.88164883852005, "content": {"text": "def largest_swap_permutations(num):\n    \"\"\"On day `1`, one person discovers a secret.\n\nYou are given an integer `delay`, which means that each person will **share** the secret with a new person **every day**, starting from `delay` days after discovering the secret. You are also given an integer `forget`, which means that each person will **forget** the secret `forget` days after discovering it. A person **cannot** share the secret on the same day they forgot it, or on any day afterwards.\n\nGiven an integer `n`, return _the number of people who know the secret at the end of day_ `n`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 6, delay = 2, forget = 4\n**Output:** 5\n**Explanation:**\nDay 1: Suppose the first person is named A. (1 person)\nDay 2: A is the only person who knows the secret. (1 person)\nDay 3: A shares the secret with a new person, B. (2 people)\nDay 4: A shares the secret with a new person, C. (3 people)\nDay 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)\nDay 6: B shares the secret with E, and C shares the secret with F. (5 people)\n\n**Example 2:**\n\n**Input:** n = 4, delay = 1, forget = 3\n**Output:** 6\n**Explanation:**\nDay 1: The first person is named A. (1 person)\nDay 2: A shares the secret with B. (2 people)\nDay 3: A and B share the secret with 2 new people, C and D. (4 people)\nDay 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)\n\n**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= delay < forget <= n`\"\"\"\n\n    num_str = str(num)\n    even_digits = sorted([c for c in num_str if int(c) % 2 == 0], reverse=True)\n    odd_digits = sorted([c for c in num_str if int(c) % 2 == 1], reverse=True)\n\n    result = []\n    for c in num_str:\n        if int(c) % 2 == 0:\n            result.append(even_digits.pop(0))\n        else:\n            result.append(odd_digits.pop(0))\n\n    return int(''.join(result))"}}, "leetcode/leetcode_1997.txt": {"score": 0.8828591108322144, "content": {"text": "def firstDayBeenInAllRooms(nextVisit):\n    \"\"\"There are `n` rooms you need to visit, labeled from `0` to `n - 1`. Each day is labeled, starting from `0`. You will go in and visit one room a day.\n\nInitially on day `0`, you visit room `0`. The **order** you visit the rooms for the coming days is determined by the following **rules** and a given **0-indexed** array `nextVisit` of length `n`:\n\n*   Assuming that on a day, you visit room `i`,\n*   if you have been in room `i` an **odd** number of times (**including** the current visit), on the **next** day you will visit a room with a **lower or equal room number** specified by `nextVisit[i]` where `0 <= nextVisit[i] <= i`;\n*   if you have been in room `i` an **even** number of times (**including** the current visit), on the **next** day you will visit room `(i + 1) mod n`.\n\nReturn _the label of the **first** day where you have been in **all** the rooms_. It can be shown that such a day exists. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** nextVisit = \\[0,0\\]\n**Output:** 2\n**Explanation:**\n- On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n  On the next day you will visit room nextVisit\\[0\\] = 0\n- On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n  On the next day you will visit room (0 + 1) mod 2 = 1\n- On day 2, you visit room 1. This is the first day where you have been in all the rooms.\n\n**Example 2:**\n\n**Input:** nextVisit = \\[0,0,2\\]\n**Output:** 6\n**Explanation:**\nYour room visiting order for each day is: \\[0,0,1,0,0,1,2,...\\].\nDay 6 is the first day where you have been in all the rooms.\n\n**Example 3:**\n\n**Input:** nextVisit = \\[0,1,2,0\\]\n**Output:** 6\n**Explanation:**\nYour room visiting order for each day is: \\[0,0,1,1,2,2,3,...\\].\nDay 6 is the first day where you have been in all the rooms.\n\n**Constraints:**\n\n*   `n == nextVisit.length`\n*   `2 <= n <= 105`\n*   `0 <= nextVisit[i] <= i`\"\"\"\n\n    n = len(nextVisit)\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[n - 1]"}}, "leetcode/leetcode_1411.txt": {"score": 0.9090246558189392, "content": {"text": "class ListNode:\n    \"\"\"You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow,** or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\n\nGiven `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 12\n**Explanation:** There are 12 possible way to paint the grid as shown.\n\n**Example 2:**\n\n**Input:** n = 5000\n**Output:** 30228214\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `1 <= n <= 5000`\"\"\"\n\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head: ListNode) -> int:\n    num = 0\n    while head:\n        num = (num << 1) | head.val\n        head = head.next\n    return num"}}, "leetcode/leetcode_319.txt": {"score": 0.9150148630142212, "content": {"text": "def bulbSwitch(n):\n    \"\"\"There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after `n` rounds_.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 1\n**Explanation:** At first, the three bulbs are \\[off, off, off\\].\nAfter the first round, the three bulbs are \\[on, on, on\\].\nAfter the second round, the three bulbs are \\[on, off, on\\].\nAfter the third round, the three bulbs are \\[on, off, off\\]. \nSo you should return 1 because there is only one bulb is on.\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Example 3:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= n <= 109`\"\"\"\n\n    return int(n**0.5)"}}, "leetcode/leetcode_957.txt": {"score": 0.9010334610939026, "content": {"text": "def minAddToMakeValid(s: str) -> int:\n    \"\"\"There are `8` prison cells in a row and each cell is either occupied or vacant.\n\nEach day, whether the cell is occupied or vacant changes according to the following rules:\n\n*   If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.\n*   Otherwise, it becomes vacant.\n\n**Note** that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.\n\nYou are given an integer array `cells` where `cells[i] == 1` if the `ith` cell is occupied and `cells[i] == 0` if the `ith` cell is vacant, and you are given an integer `n`.\n\nReturn the state of the prison after `n` days (i.e., `n` such changes described above).\n\n**Example 1:**\n\n**Input:** cells = \\[0,1,0,1,1,0,0,1\\], n = 7\n**Output:** \\[0,0,1,1,0,0,0,0\\]\n**Explanation:** The following table summarizes the state of the prison on each day:\nDay 0: \\[0, 1, 0, 1, 1, 0, 0, 1\\]\nDay 1: \\[0, 1, 1, 0, 0, 0, 0, 0\\]\nDay 2: \\[0, 0, 0, 0, 1, 1, 1, 0\\]\nDay 3: \\[0, 1, 1, 0, 0, 1, 0, 0\\]\nDay 4: \\[0, 0, 0, 0, 0, 1, 0, 0\\]\nDay 5: \\[0, 1, 1, 1, 0, 1, 0, 0\\]\nDay 6: \\[0, 0, 1, 0, 1, 1, 0, 0\\]\nDay 7: \\[0, 0, 1, 1, 0, 0, 0, 0\\]\n\n**Example 2:**\n\n**Input:** cells = \\[1,0,0,1,0,0,1,0\\], n = 1000000000\n**Output:** \\[0,0,1,1,1,1,1,0\\]\n\n**Constraints:**\n\n*   `cells.length == 8`\n*   `cells[i]` is either `0` or `1`.\n*   `1 <= n <= 109`\"\"\"\n\n    result = balance = 0\n    for c in s:\n        balance += 1 if c == '(' else -1\n        if balance == -1:\n            result += 1\n            balance += 1\n    return result + balance"}}, "leetcode/leetcode_672.txt": {"score": 0.9979743361473083, "content": {"text": "def num_light_configuration(n, presses):\n    \"\"\"There is a room with `n` bulbs labeled from `1` to `n` that all are turned on initially, and **four buttons** on the wall. Each of the four buttons has a different functionality where:\n\n*   **Button 1:** Flips the status of all the bulbs.\n*   **Button 2:** Flips the status of all the bulbs with even labels (i.e., `2, 4, ...`).\n*   **Button 3:** Flips the status of all the bulbs with odd labels (i.e., `1, 3, ...`).\n*   **Button 4:** Flips the status of all the bulbs with a label `j = 3k + 1` where `k = 0, 1, 2, ...` (i.e., `1, 4, 7, 10, ...`).\n\nYou must make **exactly** `presses` button presses in total. For each press, you may pick **any** of the four buttons to press.\n\nGiven the two integers `n` and `presses`, return _the number of **different possible statuses** after performing all_ `presses` _button presses_.\n\n**Example 1:**\n\n**Input:** n = 1, presses = 1\n**Output:** 2\n**Explanation:** Status can be:\n- \\[off\\] by pressing button 1\n- \\[on\\] by pressing button 2\n\n**Example 2:**\n\n**Input:** n = 2, presses = 1\n**Output:** 3\n**Explanation:** Status can be:\n- \\[off, off\\] by pressing button 1\n- \\[on, off\\] by pressing button 2\n- \\[off, on\\] by pressing button 3\n\n**Example 3:**\n\n**Input:** n = 3, presses = 1\n**Output:** 4\n**Explanation:** Status can be:\n- \\[off, off, off\\] by pressing button 1\n- \\[off, on, off\\] by pressing button 2\n- \\[on, off, on\\] by pressing button 3\n- \\[off, on, on\\] by pressing button 4\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= presses <= 1000`\"\"\"\n\n    dp = [[0] * (presses + 1) for _ in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(n + 1):\n        for j in range(1, presses + 1):\n            dp[i][j] = dp[i][j - 1] * (i + 1) + (dp[i - 1][j - 1] if i > 0 else 0)\n\n    return dp[n][presses]"}}}}, "32": {"gold": {"leetcode/leetcode_1598.txt": 1}, "retrieved": {"leetcode/leetcode_224.txt": {"score": 0.8657758235931396, "content": {"text": "def calculate(s: str) -> int:\n    \"\"\"Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return _the result of the evaluation_.\n\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n\n**Example 1:**\n\n**Input:** s =  \"1 + 1 \"\n**Output:** 2\n\n**Example 2:**\n\n**Input:** s =  \" 2-1 + 2  \"\n**Output:** 3\n\n**Example 3:**\n\n**Input:** s =  \"(1+(4+5+2)-3)+(6+8) \"\n**Output:** 23\n\n**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.\n*   `s` represents a valid expression.\n*   `'+'` is **not** used as a unary operation (i.e., `\"+1 \"` and `\"+(2 + 3) \"` is invalid).\n*   `'-'` could be used as a unary operation (i.e., `\"-1 \"` and `\"-(2 + 3) \"` is valid).\n*   There will be no two consecutive operators in the input.\n*   Every number and running calculation will fit in a signed 32-bit integer.\"\"\"\n\n    result = 0\n    sign = 1\n    num = 0\n    st = []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        else:\n            result += sign * num\n            num = 0\n            if c == '+':\n                sign = 1\n            elif c == '-':\n                sign = -1\n            elif c == '(':\n                st.append(result)\n                st.append(sign)\n                result = 0\n                sign = 1\n            elif c == ')':\n                prev_sign = st.pop()\n                prev_result = st.pop()\n                result = prev_result + prev_sign * result\n    result += sign * num\n    return result"}}, "leetcode/leetcode_2221.txt": {"score": 0.8704230189323425, "content": {"text": "def is_valid_parentheses_string(s: str, locked: str) -> bool:\n    \"\"\"You are given a **0-indexed** integer array `nums`, where `nums[i]` is a digit between `0` and `9` (**inclusive**).\n\nThe **triangular sum** of `nums` is the value of the only element present in `nums` after the following process terminates:\n\n1.  Let `nums` comprise of `n` elements. If `n == 1`, **end** the process. Otherwise, **create** a new **0-indexed** integer array `newNums` of length `n - 1`.\n2.  For each index `i`, where `0 <= i < n - 1`, **assign** the value of `newNums[i]` as `(nums[i] + nums[i+1]) % 10`, where `%` denotes modulo operator.\n3.  **Replace** the array `nums` with `newNums`.\n4.  **Repeat** the entire process starting from step 1.\n\nReturn _the triangular sum of_ `nums`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** 8\n**Explanation:**\nThe above diagram depicts the process from which we obtain the triangular sum of the array.\n\n**Example 2:**\n\n**Input:** nums = \\[5\\]\n**Output:** 5\n**Explanation:**\nSince there is only one element in nums, the triangular sum is the value of that element itself.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 9`\"\"\"\n\n    balance = 0\n    for i in range(len(s)):\n        if locked[i] == '0':\n            balance += 1 if s[i] == '(' else -1\n            if balance < 0:\n                return False\n    return balance == 0"}}, "leetcode/csn_python_train_294196.txt": {"score": 0.8678345680236816, "content": {"text": "def increase_last(self, k):\n        \"\"\"\n        Increase the last result by k.\n        \"\"\"\n        idx = self._last_idx\n        if idx is not None:\n            self.results[idx] += k"}}, "leetcode/leetcode_150.txt": {"score": 0.8725560307502747, "content": {"text": "def evalRPN(tokens):\n    \"\"\"You are given an array of strings `tokens` that represents an arithmetic expression in a [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nEvaluate the expression. Return _an integer that represents the value of the expression_.\n\n**Note** that:\n\n*   The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.\n*   Each operand may be an integer or another expression.\n*   The division between two integers always **truncates toward zero**.\n*   There will not be any division by zero.\n*   The input represents a valid arithmetic expression in a reverse polish notation.\n*   The answer and all the intermediate calculations can be represented in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** tokens = \\[ \"2 \", \"1 \", \"+ \", \"3 \", \"\\* \"\\]\n**Output:** 9\n**Explanation:** ((2 + 1) \\* 3) = 9\n\n**Example 2:**\n\n**Input:** tokens = \\[ \"4 \", \"13 \", \"5 \", \"/ \", \"+ \"\\]\n**Output:** 6\n**Explanation:** (4 + (13 / 5)) = 6\n\n**Example 3:**\n\n**Input:** tokens = \\[ \"10 \", \"6 \", \"9 \", \"3 \", \"+ \", \"-11 \", \"\\* \", \"/ \", \"\\* \", \"17 \", \"+ \", \"5 \", \"+ \"\\]\n**Output:** 22\n**Explanation:** ((10 \\* (6 / ((9 + 3) \\* -11))) + 17) + 5\n= ((10 \\* (6 / (12 \\* -11))) + 17) + 5\n= ((10 \\* (6 / -132)) + 17) + 5\n= ((10 \\* 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n**Constraints:**\n\n*   `1 <= tokens.length <= 104`\n*   `tokens[i]` is either an operator: `\"+ \"`, `\"- \"`, `\"* \"`, or `\"/ \"`, or an integer in the range `[-200, 200]`.\"\"\"\n\n    stack = []\n    for token in tokens:\n        if token in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                stack.append(a + b)\n            elif token == \"-\":\n                stack.append(a - b)\n            elif token == \"*\":\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[-1]"}}, "leetcode/leetcode_2202.txt": {"score": 0.8788437247276306, "content": {"text": "def to_base_k(num, k):\n    \"\"\"You are given a **0-indexed** integer array `nums` representing the contents of a **pile**, where `nums[0]` is the topmost element of the pile.\n\nIn one move, you can perform **either** of the following:\n\n*   If the pile is not empty, **remove** the topmost element of the pile.\n*   If there are one or more removed elements, **add** any one of them back onto the pile. This element becomes the new topmost element.\n\nYou are also given an integer `k`, which denotes the total number of moves to be made.\n\nReturn _the **maximum value** of the topmost element of the pile possible after **exactly**_ `k` _moves_. In case it is not possible to obtain a non-empty pile after `k` moves, return `-1`.\n\n**Example 1:**\n\n**Input:** nums = \\[5,2,2,4,0,6\\], k = 4\n**Output:** 5\n**Explanation:**\nOne of the ways we can end with 5 at the top of the pile after 4 moves is as follows:\n- Step 1: Remove the topmost element = 5. The pile becomes \\[2,2,4,0,6\\].\n- Step 2: Remove the topmost element = 2. The pile becomes \\[2,4,0,6\\].\n- Step 3: Remove the topmost element = 2. The pile becomes \\[4,0,6\\].\n- Step 4: Add 5 back onto the pile. The pile becomes \\[5,4,0,6\\].\nNote that this is not the only way to end with 5 at the top of the pile. It can be shown that 5 is the largest answer possible after 4 moves.\n\n**Example 2:**\n\n**Input:** nums = \\[2\\], k = 1\n**Output:** -1\n**Explanation:** \nIn the first move, our only option is to pop the topmost element of the pile.\nSince it is not possible to obtain a non-empty pile after one move, we return -1.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i], k <= 109`\"\"\"\n\n    base_k_num = ''\n    while num:\n        base_k_num = str(num % k) + base_k_num\n        num //= k\n    return base_k_num\n\ndef is_k_mirror(num, k):\n    base_10_num = str(num)\n    base_k_num = to_base_k(num, k)\n    return base_10_num == base_10_num[::-1] and base_k_num == base_k_num[::-1]\n\ndef sum_k_mirror_numbers(k, n):\n    total = 0\n    num = 0\n    while n:\n        if is_k_mirror(num, k):\n            total += num\n            n -= 1\n        num += 1\n    return total"}}, "leetcode/leetcode_1441.txt": {"score": 0.8967328071594238, "content": {"text": "def build_array(target, n):\n    \"\"\"You are given an integer array `target` and an integer `n`.\n\nYou have an empty stack with the two following operations:\n\n*   **`\"Push \"`**: pushes an integer to the top of the stack.\n*   **`\"Pop \"`**: removes the integer on the top of the stack.\n\nYou also have a stream of the integers in the range `[1, n]`.\n\nUse the two stack operations to make the numbers in the stack (from the bottom to the top) equal to `target`. You should follow the following rules:\n\n*   If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.\n*   If the stack is not empty, pop the integer at the top of the stack.\n*   If, at any moment, the elements in the stack (from the bottom to the top) are equal to `target`, do not read new integers from the stream and do not do more operations on the stack.\n\nReturn _the stack operations needed to build_ `target` following the mentioned rules. If there are multiple valid answers, return **any of them**.\n\n**Example 1:**\n\n**Input:** target = \\[1,3\\], n = 3\n**Output:** \\[ \"Push \", \"Push \", \"Pop \", \"Push \"\\]\n**Explanation:** Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = \\[1\\].\nRead 2 from the stream and push it to the stack. s = \\[1,2\\].\nPop the integer on the top of the stack. s = \\[1\\].\nRead 3 from the stream and push it to the stack. s = \\[1,3\\].\n\n**Example 2:**\n\n**Input:** target = \\[1,2,3\\], n = 3\n**Output:** \\[ \"Push \", \"Push \", \"Push \"\\]\n**Explanation:** Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = \\[1\\].\nRead 2 from the stream and push it to the stack. s = \\[1,2\\].\nRead 3 from the stream and push it to the stack. s = \\[1,2,3\\].\n\n**Example 3:**\n\n**Input:** target = \\[1,2\\], n = 4\n**Output:** \\[ \"Push \", \"Push \"\\]\n**Explanation:** Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = \\[1\\].\nRead 2 from the stream and push it to the stack. s = \\[1,2\\].\nSince the stack (from the bottom to the top) is equal to target, we stop the stack operations.\nThe answers that read integer 3 from the stream are not accepted.\n\n**Constraints:**\n\n*   `1 <= target.length <= 100`\n*   `1 <= n <= 100`\n*   `1 <= target[i] <= n`\n*   `target` is strictly increasing.\"\"\"\n\n    result = []\n    current = 1\n    for num in target:\n        while current < num:\n            result.append(\"Push \")\n            result.append(\"Pop \")\n            current += 1\n        result.append(\"Push \")\n        current += 1\n    return result"}}, "leetcode/leetcode_2460.txt": {"score": 0.8690318465232849, "content": {"text": "def performOps(nums):\n    \"\"\"You are given a **0-indexed** array `nums` of size `n` consisting of **non-negative** integers.\n\nYou need to apply `n - 1` operations to this array where, in the `ith` operation (**0-indexed**), you will apply the following on the `ith` element of `nums`:\n\n*   If `nums[i] == nums[i + 1]`, then multiply `nums[i]` by `2` and set `nums[i + 1]` to `0`. Otherwise, you skip this operation.\n\nAfter performing **all** the operations, **shift** all the `0`'s to the **end** of the array.\n\n*   For example, the array `[1,0,2,0,0,1]` after shifting all its `0`'s to the end, is `[1,2,1,0,0,0]`.\n\nReturn _the resulting array_.\n\n**Note** that the operations are applied **sequentially**, not all at once.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,2,1,1,0\\]\n**Output:** \\[1,4,2,0,0,0\\]\n**Explanation:** We do the following operations:\n- i = 0: nums\\[0\\] and nums\\[1\\] are not equal, so we skip this operation.\n- i = 1: nums\\[1\\] and nums\\[2\\] are equal, we multiply nums\\[1\\] by 2 and change nums\\[2\\] to 0. The array becomes \\[1,**4**,**0**,1,1,0\\].\n- i = 2: nums\\[2\\] and nums\\[3\\] are not equal, so we skip this operation.\n- i = 3: nums\\[3\\] and nums\\[4\\] are equal, we multiply nums\\[3\\] by 2 and change nums\\[4\\] to 0. The array becomes \\[1,4,0,**2**,**0**,0\\].\n- i = 4: nums\\[4\\] and nums\\[5\\] are equal, we multiply nums\\[4\\] by 2 and change nums\\[5\\] to 0. The array becomes \\[1,4,0,2,**0**,**0**\\].\nAfter that, we shift the 0's to the end, which gives the array \\[1,4,2,0,0,0\\].\n\n**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** \\[1,0\\]\n**Explanation:** No operation can be applied, we just shift the 0 to the end.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 2000`\n*   `0 <= nums[i] <= 1000`\"\"\"\n\n    n = len(nums)\n    for i in range(n - 1):\n        if nums[i] == nums[i + 1]:\n            nums[i] *= 2\n            nums[i + 1] = 0\n    nonZeroIndex = 0\n    for i in range(n):\n        if nums[i] != 0:\n            nums[nonZeroIndex] = nums[i]\n            nonZeroIndex += 1\n    while(nonZeroIndex < n):\n        nums[nonZeroIndex] = 0\n        nonZeroIndex += 1\n    return nums"}}, "leetcode/leetcode_682.txt": {"score": 0.9926907420158386, "content": {"text": "def calPoints(ops):\n    \"\"\"You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n\nYou are given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record and is one of the following:\n\n*   An integer `x`.\n    *   Record a new score of `x`.\n*   `'+'`.\n    *   Record a new score that is the sum of the previous two scores.\n*   `'D'`.\n    *   Record a new score that is the double of the previous score.\n*   `'C'`.\n    *   Invalidate the previous score, removing it from the record.\n\nReturn _the sum of all the scores on the record after applying all the operations_.\n\nThe test cases are generated such that the answer and all intermediate calculations fit in a **32-bit** integer and that all operations are valid.\n\n**Example 1:**\n\n**Input:** ops = \\[ \"5 \", \"2 \", \"C \", \"D \", \"+ \"\\]\n**Output:** 30\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"2 \" - Add 2 to the record, record is now \\[5, 2\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5\\].\n \"D \" - Add 2 \\* 5 = 10 to the record, record is now \\[5, 10\\].\n \"+ \" - Add 5 + 10 = 15 to the record, record is now \\[5, 10, 15\\].\nThe total sum is 5 + 10 + 15 = 30.\n\n**Example 2:**\n\n**Input:** ops = \\[ \"5 \", \"-2 \", \"4 \", \"C \", \"D \", \"9 \", \"+ \", \"+ \"\\]\n**Output:** 27\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"-2 \" - Add -2 to the record, record is now \\[5, -2\\].\n \"4 \" - Add 4 to the record, record is now \\[5, -2, 4\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5, -2\\].\n \"D \" - Add 2 \\* -2 = -4 to the record, record is now \\[5, -2, -4\\].\n \"9 \" - Add 9 to the record, record is now \\[5, -2, -4, 9\\].\n \"+ \" - Add -4 + 9 = 5 to the record, record is now \\[5, -2, -4, 9, 5\\].\n \"+ \" - Add 9 + 5 = 14 to the record, record is now \\[5, -2, -4, 9, 5, 14\\].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n\n**Example 3:**\n\n**Input:** ops = \\[ \"1 \", \"C \"\\]\n**Output:** 0\n**Explanation:**\n \"1 \" - Add 1 to the record, record is now \\[1\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[\\].\nSince the record is empty, the total sum is 0.\n\n**Constraints:**\n\n*   `1 <= operations.length <= 1000`\n*   `operations[i]` is `\"C \"`, `\"D \"`, `\"+ \"`, or a string representing an integer in the range `[-3 * 104, 3 * 104]`.\n*   For operation `\"+ \"`, there will always be at least two previous scores on the record.\n*   For operations `\"C \"` and `\"D \"`, there will always be at least one previous score on the record.\"\"\"\n\n    record = []\n    for op in ops:\n        if op == '+':\n            record.append(record[-1] + record[-2])\n        elif op == 'D':\n            record.append(record[-1] * 2)\n        elif op == 'C':\n            record.pop()\n        else:\n            record.append(int(op))\n    return sum(record)"}}, "leetcode/leetcode_2562.txt": {"score": 0.8783992528915405, "content": {"text": "def concatenationValue(nums):\n    \"\"\"You are given a **0-indexed** integer array `nums`.\n\nThe **concatenation** of two numbers is the number formed by concatenating their numerals.\n\n*   For example, the concatenation of `15`, `49` is `1549`.\n\nThe **concatenation value** of `nums` is initially equal to `0`. Perform this operation until `nums` becomes empty:\n\n*   If there exists more than one number in `nums`, pick the first element and last element in `nums` respectively and add the value of their concatenation to the **concatenation value** of `nums`, then delete the first and last element from `nums`.\n*   If one element exists, add its value to the **concatenation value** of `nums`, then delete it.\n\nReturn _the concatenation value of the `nums`_.\n\n**Example 1:**\n\n**Input:** nums = \\[7,52,2,4\\]\n**Output:** 596\n**Explanation:** Before performing any operation, nums is \\[7,52,2,4\\] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to \\[52,2\\].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.\n\n**Example 2:**\n\n**Input:** nums = \\[5,14,13,8,12\\]\n**Output:** 673\n**Explanation:** Before performing any operation, nums is \\[5,14,13,8,12\\] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to \\[14,13,8\\].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to \\[13\\].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 104`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;\u00a0 } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n    value = 0\n    while nums:\n        n = len(nums)\n        if n == 1:\n            value += nums[0]\n            nums.pop()\n        else:\n            value += int(str(nums[0]) + str(nums[-1]))\n            nums.pop(0)\n            nums.pop()\n    return value"}}, "leetcode/leetcode_2011.txt": {"score": 0.9307632446289062, "content": {"text": "def max_value(n: str, x: int) -> str:\n    \"\"\"There is a programming language with only **four** operations and **one** variable `X`:\n\n*   `++X` and `X++` **increments** the value of the variable `X` by `1`.\n*   `--X` and `X--` **decrements** the value of the variable `X` by `1`.\n\nInitially, the value of `X` is `0`.\n\nGiven an array of strings `operations` containing a list of operations, return _the **final** value of_ `X` _after performing all the operations_.\n\n**Example 1:**\n\n**Input:** operations = \\[ \"--X \", \"X++ \", \"X++ \"\\]\n**Output:** 1\n**Explanation:** The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1.\n\n**Example 2:**\n\n**Input:** operations = \\[ \"++X \", \"++X \", \"X++ \"\\]\n**Output:** 3\n**Explanation:** The operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3.\n\n**Example 3:**\n\n**Input:** operations = \\[ \"X++ \", \"++X \", \"--X \", \"X-- \"\\]\n**Output:** 0\n**Explanation:** The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0.\n\n**Constraints:**\n\n*   `1 <= operations.length <= 100`\n*   `operations[i]` will be either `\"++X \"`, `\"X++ \"`, `\"--X \"`, or `\"X-- \"`.\"\"\"\n\n    is_negative = n[0] == '-'\n    pos = 1 if is_negative else 0\n\n    while pos < len(n):\n        if (is_negative and int(n[pos]) > x) or (not is_negative and int(n[pos]) < x):\n            break\n        pos += 1\n\n    return n[:pos] + str(x) + n[pos:]"}}}}, "33": {"gold": {"leetcode/leetcode_685.txt": 1, "leetcode/leetcode_721.txt": 1, "leetcode/leetcode_2127.txt": 1, "leetcode/leetcode_2608.txt": 1}, "retrieved": {"leetcode/leetcode_2493.txt": {"score": 0.910839855670929, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"You are given a positive integer `n` representing the number of nodes in an **undirected** graph. The nodes are labeled from `1` to `n`.\n\nYou are also given a 2D integer array `edges`, where `edges[i] = [ai, bi]` indicates that there is a **bidirectional** edge between nodes `ai` and `bi`. **Notice** that the given graph may be disconnected.\n\nDivide the nodes of the graph into `m` groups (**1-indexed**) such that:\n\n*   Each node in the graph belongs to exactly one group.\n*   For every pair of nodes in the graph that are connected by an edge `[ai, bi]`, if `ai` belongs to the group with index `x`, and `bi` belongs to the group with index `y`, then `|y - x| = 1`.\n\nReturn _the maximum number of groups (i.e., maximum_ `m`_) into which you can divide the nodes_. Return `-1` _if it is impossible to group the nodes with the given conditions_.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[1,2\\],\\[1,4\\],\\[1,5\\],\\[2,6\\],\\[2,3\\],\\[4,6\\]\\]\n**Output:** 4\n**Explanation:** As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1\n**Explanation:** If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible.\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n*   `1 <= edges.length <= 104`\n*   `edges[i].length == 2`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   There is at most one edge between any pair of vertices.\"\"\"\n\n\ndef maxGroups(n, edges):\n    graph = defaultdict(list)\n    color = [0] * (n + 1)\n\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    max_group = 0\n    for i in range(1, n + 1):\n        if color[i] == 0:\n            q = deque([i])\n            color[i] = 1\n            while q:\n                node = q.popleft()\n                max_group = max(max_group, color[node])\n                for neighbor in graph[node]:\n                    if color[neighbor] == 0:\n                        color[neighbor] = color[node] + 1\n                        q.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return -1\n                        \n    return max_group"}}, "leetcode/csn_python_train_320959.txt": {"score": 0.912773609161377, "content": {"text": "def cut_nodes_edges2(graph):\n    \"\"\"Bi-connected components, alternative recursive implementation\n\n    :param graph: undirected graph. in listlist format. Cannot be in listdict format.\n    :assumes: graph has about 5000 vertices at most, otherwise memory limit is reached\n    :returns: a tuple with the list of cut-nodes and the list of cut-edges\n    :complexity: `O(|V|+|E|)` in average, `O(|V|+|E|^2)` in worst case due to use of dictionary\n    \"\"\"\n    N = len(graph)\n    assert N <= 5000\n    recursionlimit = getrecursionlimit()\n    setrecursionlimit(max(recursionlimit, N + 42))\n    edges = set((i, j) for i in range(N) for j in graph[i] if i <= j)\n    nodes = set()\n    NOT = -2  # not visited yet; -1 would be buggy `marked[v] != prof - 1`\n    FIN = -3  # already visited\n    marked = [NOT] * N  # if >= 0, it means depth within the DFS\n\n    def DFS(n, prof=0):\n        \"\"\"\n        Recursively search graph, update edge list and returns the first\n        node the first edge within search to which we can come back.\n        \"\"\"\n        if marked[n] == FIN:\n            return  # only when there are several connected components\n        if marked[n] != NOT:\n            return marked[n]\n        marked[n] = prof\n        m = float('inf')\n        count = 0  # useful only for prof == 0\n        for v in graph[n]:\n            if marked[v] != FIN and marked[v] != prof - 1:\n                count += 1\n                r = DFS(v, prof+1)\n                if r <= prof:\n                    edges.discard(tuple(sorted((n, v))))\n                if prof and r >= prof:  # only if we are not at root\n                    nodes.add(n)\n                m = min(m, r)\n        # root is an articulation point iff it has more than 2 childs\n        if prof == 0 and count >= 2:\n            nodes.add(n)\n        marked[n] = FIN\n        return m\n    for r in range(N):\n        DFS(r)  # we can count connected components by nb += DFS(r)\n    setrecursionlimit(recursionlimit)\n    return nodes, edges"}}, "leetcode/leetcode_2421.txt": {"score": 0.9128646850585938, "content": {"text": "from collections import defaultdict\n    \"\"\"There is a tree (i.e. a connected, undirected graph with no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges.\n\nYou are given a **0-indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nA **good path** is a simple path that satisfies the following conditions:\n\n1.  The starting node and the ending node have the **same** value.\n2.  All nodes between the starting node and the ending node have values **less than or equal to** the starting node (i.e. the starting node's value should be the maximum value along the path).\n\nReturn _the number of distinct good paths_.\n\nNote that a path and its reverse are counted as the **same** path. For example, `0 -> 1` is considered to be the same as `1 -> 0`. A single node is also considered as a valid path.\n\n**Example 1:**\n\n**Input:** vals = \\[1,3,2,1,3\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 6\n**Explanation:** There are 5 good paths consisting of a single node.\nThere is 1 additional good path: 1 -> 0 -> 2 -> 4.\n(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\nNote that 0 -> 2 -> 3 is not a good path because vals\\[2\\] > vals\\[0\\].\n\n**Example 2:**\n\n**Input:** vals = \\[1,1,2,2,3\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 7\n**Explanation:** There are 5 good paths consisting of a single node.\nThere are 2 additional good paths: 0 -> 1 and 2 -> 3.\n\n**Example 3:**\n\n**Input:** vals = \\[1\\], edges = \\[\\]\n**Output:** 1\n**Explanation:** The tree consists of only one node, so there is one good path.\n\n**Constraints:**\n\n*   `n == vals.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= vals[i] <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef dfs(node, parent, adj, vals, cur_max, count):\n    if vals[node] >= cur_max:\n        if vals[node] > cur_max:\n            count[0] += 1\n            cur_max = vals[node]\n        for next in adj[node]:\n            if next != parent:\n                dfs(next, node, adj, vals, cur_max, count)\n\ndef number_of_good_paths(vals, edges):\n    n = len(vals)\n    adj = defaultdict(list)\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    count = [0]\n    for i in range(n):\n        dfs(i, -1, adj, vals, -1, count)\n    return count[0]"}}, "leetcode/leetcode_1192.txt": {"score": 0.9365397095680237, "content": {"text": "from collections import defaultdict\n    \"\"\"There are `n` servers numbered from `0` to `n - 1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between servers `ai` and `bi`. Any server can reach other servers directly or indirectly through the network.\n\nA _critical connection_ is a connection that, if removed, will make some servers unable to reach some other server.\n\nReturn all critical connections in the network in any order.\n\n**Example 1:**\n\n**Input:** n = 4, connections = \\[\\[0,1\\],\\[1,2\\],\\[2,0\\],\\[1,3\\]\\]\n**Output:** \\[\\[1,3\\]\\]\n**Explanation:** \\[\\[3,1\\]\\] is also accepted.\n\n**Example 2:**\n\n**Input:** n = 2, connections = \\[\\[0,1\\]\\]\n**Output:** \\[\\[0,1\\]\\]\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `n - 1 <= connections.length <= 105`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\n*   There are no repeated connections.\"\"\"\n\n\ndef criticalConnections(n, connections):\n    def dfs(node, parent, depth, rank, graph, result):\n        rank[node] = depth\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if rank[neighbor] == -1:\n                dfs(neighbor, node, depth + 1, rank, graph, result)\n            rank[node] = min(rank[node], rank[neighbor])\n            if rank[neighbor] == depth + 1:\n                result.append((node, neighbor))\n\n    graph = defaultdict(list)\n    for fr, to in connections:\n        graph[fr].append(to)\n        graph[to].append(fr)\n\n    rank = [-1] * n\n    result = []\n    dfs(0, -1, 0, rank, graph, result)\n    return result"}}, "leetcode/csn_python_train_110867.txt": {"score": 0.9180595874786377, "content": {"text": "def cut_edges(graph):\n    \"\"\"\n    Return the cut-edges of the given graph.\n    \n    A cut edge, or bridge, is an edge of a graph whose removal increases the number of connected\n    components in the graph.\n    \n    @type  graph: graph, hypergraph\n    @param graph: Graph.\n    \n    @rtype:  list\n    @return: List of cut-edges.\n    \"\"\"\n    recursionlimit = getrecursionlimit()\n    setrecursionlimit(max(len(graph.nodes())*2,recursionlimit))\n\n    # Dispatch if we have a hypergraph\n    if 'hypergraph' == graph.__class__.__name__:\n        return _cut_hyperedges(graph)\n\n    pre = {}    # Pre-ordering\n    low = {}    # Lowest pre[] reachable from this node going down the spanning tree + one backedge\n    spanning_tree = {}\n    reply = []\n    pre[None] = 0\n\n    for each in graph:\n        if (each not in pre):\n            spanning_tree[each] = None\n            _cut_dfs(graph, spanning_tree, pre, low, reply, each)\n    \n    setrecursionlimit(recursionlimit)\n    return reply"}}, "leetcode/leetcode_1719.txt": {"score": 0.9231503009796143, "content": {"text": "def check_ways(pairs):\n    \"\"\"You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and:\n\n*   There are no duplicates.\n*   `xi < yi`\n\nLet `ways` be the number of rooted trees that satisfy the following conditions:\n\n*   The tree consists of nodes whose values appeared in `pairs`.\n*   A pair `[xi, yi]` exists in `pairs` **if and only if** `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.\n*   **Note:** the tree does not have to be a binary tree.\n\nTwo ways are considered to be different if there is at least one node that has different parents in both ways.\n\nReturn:\n\n*   `0` if `ways == 0`\n*   `1` if `ways == 1`\n*   `2` if `ways > 1`\n\nA **rooted tree** is a tree that has a single root node, and all edges are oriented to be outgoing from the root.\n\nAn **ancestor** of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.\n\n**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:** There is exactly one valid rooted tree, which is shown in the above figure.\n\n**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[1,3\\]\\]\n**Output:** 2\n**Explanation:** There are multiple valid rooted trees. Three of them are shown in the above figures.\n\n**Example 3:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\],\\[1,5\\]\\]\n**Output:** 0\n**Explanation:** There are no valid rooted trees.\n\n**Constraints:**\n\n*   `1 <= pairs.length <= 105`\n*   `1 <= xi < yi <= 500`\n*   The elements in `pairs` are unique.\"\"\"\n\n    candidates = {}\n    for x, y in pairs:\n        candidates[x] = candidates.get(x, 0) + 1\n        candidates[y] = candidates.get(y, 0) + 1\n\n    root_count = sum(1 for v in candidates.values() if v == 1)\n    return min(root_count, 2)"}}, "leetcode/leetcode_1319.txt": {"score": 0.923346221446991, "content": {"text": "def unique_occurrences(arr):\n    \"\"\"There are `n` computers numbered from `0` to `n - 1` connected by ethernet cables `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between computers `ai` and `bi`. Any computer can reach any other computer directly or indirectly through the network.\n\nYou are given an initial computer network `connections`. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.\n\nReturn _the minimum number of times you need to do this in order to make all the computers connected_. If it is not possible, return `-1`.\n\n**Example 1:**\n\n**Input:** n = 4, connections = \\[\\[0,1\\],\\[0,2\\],\\[1,2\\]\\]\n**Output:** 1\n**Explanation:** Remove cable between computer 1 and 2 and place between computers 1 and 3.\n\n**Example 2:**\n\n**Input:** n = 6, connections = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** n = 6, connections = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\],\\[1,2\\]\\]\n**Output:** -1\n**Explanation:** There are not enough cables.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= connections.length <= min(n * (n - 1) / 2, 105)`\n*   `connections[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   There are no repeated connections.\n*   No two computers are connected by more than one cable.\"\"\"\n\n    counts = {}\n    for num in arr:\n        counts[num] = counts.get(num, 0) + 1\n    \n    unique_counts = set()\n    for count in counts.values():\n        if count in unique_counts:\n            return False\n        unique_counts.add(count)\n    \n    return True"}}, "leetcode/leetcode_1579.txt": {"score": 0.9386886954307556, "content": {"text": "class UnionFind:\n    \"\"\"Alice and Bob have an undirected graph of `n` nodes and three types of edges:\n\n*   Type 1: Can be traversed by Alice only.\n*   Type 2: Can be traversed by Bob only.\n*   Type 3: Can be traversed by both Alice and Bob.\n\nGiven an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\n\nReturn _the maximum number of edges you can remove, or return_ `-1` _if Alice and Bob cannot fully traverse the graph._\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[3,1,2\\],\\[3,2,3\\],\\[1,1,3\\],\\[1,2,4\\],\\[1,1,2\\],\\[2,3,4\\]\\]\n**Output:** 2\n**Explanation:** If we remove the 2 edges \\[1,1,2\\] and \\[1,1,3\\]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n\n**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[3,1,2\\],\\[3,2,3\\],\\[1,1,4\\],\\[2,1,4\\]\\]\n**Output:** 0\n**Explanation:** Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n\n**Example 3:**\n\n**Input:** n = 4, edges = \\[\\[3,2,3\\],\\[1,1,2\\],\\[2,3,4\\]\\]\n**Output:** -1\n**Explanation:** In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= edges.length <= min(105, 3 * n * (n - 1) / 2)`\n*   `edges[i].length == 3`\n*   `1 <= typei <= 3`\n*   `1 <= ui < vi <= n`\n*   All tuples `(typei, ui, vi)` are distinct.\"\"\"\n\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.components = size\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def unite(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x != root_y:\n            self.parent[root_x] = root_y\n            self.components -= 1\n            return True\n        return False\n\ndef max_num_edges_to_remove(n, edges):\n    ufA, ufB = UnionFind(n + 1), UnionFind(n + 1)\n    common_edges = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if ufA.unite(u, v):\n                ufB.unite(u, v)\n                common_edges += 1\n\n    removed_edges = 0\n    for t, u, v in edges:\n        uf = ufA if t == 1 else ufB if t == 2 else None\n        if uf and not uf.unite(u, v):\n            removed_edges += 1\n\n    return -1 if ufA.components != 2 or ufB.components != 2 else removed_edges - common_edges"}}, "leetcode/leetcode_685.txt": {"score": 0.9633329510688782, "content": {"text": "def findRedundantDirectedConnection(edges):\n    \"\"\"In this problem, a rooted tree is a **directed** graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n\nThe given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a **directed** edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.\n\nReturn _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2D-array.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** \\[2,3\\]\n\n**Example 2:**\n\n**Input:** edges = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,1\\],\\[1,5\\]\\]\n**Output:** \\[4,1\\]\n\n**Constraints:**\n\n*   `n == edges.length`\n*   `3 <= n <= 1000`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\"\"\"\n\n    parent = [0] * (len(edges) + 1)\n    candidateA = candidateB = None\n\n    for u, v in edges:\n        if parent[v] > 0:\n            candidateA = [parent[v], v]\n            candidateB = [u, v]\n        else:\n            parent[v] = u\n\n    for i in range(1, len(edges) + 1):\n        cycle = i\n        steps = len(edges)\n        while parent[cycle] != 0 and steps > 0:\n            cycle = parent[cycle]\n            steps -= 1\n        if steps == 0:\n            if not candidateA:\n                return [parent[i], i]\n            else:\n                return candidateA\n\n    return candidateB"}}, "leetcode/leetcode_684.txt": {"score": 0.9894763231277466, "content": {"text": "from typing import List\n    \"\"\"In this problem, a tree is an **undirected graph** that is connected and has no cycles.\n\nYou are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two **different** vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.\n\nReturn _an edge that can be removed so that the resulting graph is a tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the input.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** \\[2,3\\]\n\n**Example 2:**\n\n**Input:** edges = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,4\\],\\[1,5\\]\\]\n**Output:** \\[1,4\\]\n\n**Constraints:**\n\n*   `n == edges.length`\n*   `3 <= n <= 1000`\n*   `edges[i].length == 2`\n*   `1 <= ai < bi <= edges.length`\n*   `ai != bi`\n*   There are no repeated edges.\n*   The given graph is connected.\"\"\"\n\n\ndef findRedundantConnection(edges: List[List[int]]) -> List[int]:\n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n\n    parent = list(range(len(edges) + 1))\n    for edge in edges:\n        root1 = find(parent, edge[0])\n        root2 = find(parent, edge[1])\n        if root1 == root2:\n            return edge\n        parent[root1] = root2\n    return []"}}}}, "34": {"gold": {"leetcode/leetcode_463.txt": 1, "leetcode/leetcode_1727.txt": 1, "leetcode/leetcode_2101.txt": 1}, "retrieved": {"leetcode/csn_python_train_48381.txt": {"score": 0.907256543636322, "content": {"text": "def paths(self):\n    \"\"\"\n    Assuming the skeleton is structured as a single tree, return a \n    list of all traversal paths across all components. For each component, \n    start from the first vertex, find the most distant vertex by \n    hops and set that as the root. Then use depth first traversal \n    to produce paths.\n\n    Returns: [ [(x,y,z), (x,y,z), ...], path_2, path_3, ... ]\n    \"\"\"\n    paths = []\n    for tree in self.components():\n      paths += self._single_tree_paths(tree)\n    return paths"}}, "leetcode/csn_python_train_390945.txt": {"score": 0.9089756608009338, "content": {"text": "def traverse_core(core_area, world_size=(60, 60),\n                  neighbor_func=get_moore_neighbors_toroidal):\n    \"\"\"\n    Treat cells in core_area like a graph and traverse it to\n    see how many connected components there are.\n    \"\"\"\n\n    if not core_area:\n        return []\n    core_area = [tuple(i) for i in core_area]\n    curr = core_area[0]\n    core_area = set(core_area[1:])\n    to_explore = []\n    cores = [[curr]]\n\n    while core_area:\n        neighbors = neighbor_func(curr, world_size)\n\n        for n in neighbors:\n            if n in core_area:\n                core_area.remove(n)\n                to_explore.append(n)\n                cores[-1].append(n)\n\n        if to_explore:\n            curr = to_explore.pop()\n        else:\n            curr = core_area.pop()\n            cores.append([curr])\n\n    return cores"}}, "leetcode/leetcode_733.txt": {"score": 0.9091342687606812, "content": {"text": "def floodFill(image, sr, sc, newColor):\n    \"\"\"An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\n\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\n\nReturn _the modified image after performing the flood fill_.\n\n**Example 1:**\n\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n\n**Example 2:**\n\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image.\n\n**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`\"\"\"\n\n    startColor = image[sr][sc]\n    def fill(sr, sc):\n        if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: \n            return\n        image[sr][sc] = newColor\n        fill(sr - 1, sc)\n        fill(sr + 1, sc)\n        fill(sr, sc - 1)\n        fill(sr, sc + 1)\n    \n    fill(sr, sc)\n    return image"}}, "leetcode/leetcode_1992.txt": {"score": 0.925830066204071, "content": {"text": "def findFarmland(land):\n    \"\"\"You are given a **0-indexed** `m x n` binary matrix `land` where a `0` represents a hectare of forested land and a `1` represents a hectare of farmland.\n\nTo keep the land organized, there are designated rectangular areas of hectares that consist **entirely** of farmland. These rectangular areas are called **groups**. No two groups are adjacent, meaning farmland in one group is **not** four-directionally adjacent to another farmland in a different group.\n\n`land` can be represented by a coordinate system where the top left corner of `land` is `(0, 0)` and the bottom right corner of `land` is `(m-1, n-1)`. Find the coordinates of the top left and bottom right corner of each **group** of farmland. A **group** of farmland with a top left corner at `(r1, c1)` and a bottom right corner at `(r2, c2)` is represented by the 4-length array `[r1, c1, r2, c2].`\n\nReturn _a 2D array containing the 4-length arrays described above for each **group** of farmland in_ `land`_. If there are no groups of farmland, return an empty array. You may return the answer in **any order**_.\n\n**Example 1:**\n\n**Input:** land = \\[\\[1,0,0\\],\\[0,1,1\\],\\[0,1,1\\]\\]\n**Output:** \\[\\[0,0,0,0\\],\\[1,1,2,2\\]\\]\n**Explanation:**\nThe first group has a top left corner at land\\[0\\]\\[0\\] and a bottom right corner at land\\[0\\]\\[0\\].\nThe second group has a top left corner at land\\[1\\]\\[1\\] and a bottom right corner at land\\[2\\]\\[2\\].\n\n**Example 2:**\n\n**Input:** land = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** \\[\\[0,0,1,1\\]\\]\n**Explanation:**\nThe first group has a top left corner at land\\[0\\]\\[0\\] and a bottom right corner at land\\[1\\]\\[1\\].\n\n**Example 3:**\n\n**Input:** land = \\[\\[0\\]\\]\n**Output:** \\[\\]\n**Explanation:**\nThere are no groups of farmland.\n\n**Constraints:**\n\n*   `m == land.length`\n*   `n == land[i].length`\n*   `1 <= m, n <= 300`\n*   `land` consists of only `0`'s and `1`'s.\n*   Groups of farmland are **rectangular** in shape.\"\"\"\n\n    m, n = len(land), len(land[0])\n    groups = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r1, c1 = i, j\n                while j + 1 < n and land[i][j + 1] == 1:\n                    j += 1\n                r2, c2 = i, j\n                while r2 + 1 < m and land[r2 + 1][j] == 1:\n                    r2 += 1\n                for r in range(r1, r2 + 1):\n                    for c in range(c1, c2 + 1):\n                        land[r][c] = 0\n                groups.append([r1, c1, r2, c2])\n\n    return groups"}}, "leetcode/csn_python_train_320968.txt": {"score": 0.9119247198104858, "content": {"text": "def dfs_grid(grid, i, j, mark='X', free='.'):\n    \"\"\"DFS on a grid, mark connected component, iterative version\n\n    :param grid: matrix, 4-neighborhood\n    :param i,j: cell in this matrix, start of DFS exploration\n    :param free: symbol for walkable cells\n    :param mark: symbol to overwrite visited vertices\n    :complexity: linear\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    to_visit = [(i, j)]\n    grid[i][j] = mark\n    while to_visit:\n        i1, j1 = to_visit.pop()\n        for i2, j2 in [(i1 + 1, j1), (i1, j1 + 1),\n                       (i1 - 1, j1), (i1, j1 - 1)]:\n            if (0 <= i2 < height and 0 <= j2 < width and\n                    grid[i2][j2] == free):\n                grid[i2][j2] = mark  # mark path\n                to_visit.append((i2, j2))"}}, "leetcode/csn_python_train_320967.txt": {"score": 0.909654974937439, "content": {"text": "def dfs_grid_recursive(grid, i, j, mark='X', free='.'):\n    \"\"\"DFS on a grid, mark connected component, iterative version\n\n    :param grid: matrix, 4-neighborhood\n    :param i,j: cell in this matrix, start of DFS exploration\n    :param free: symbol for walkable cells\n    :param mark: symbol to overwrite visited vertices\n    :complexity: linear\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    grid[i][j] = mark              # mark path\n    for ni, nj in [(i + 1, j), (i, j + 1),\n                   (i - 1, j), (i, j - 1)]:\n        if 0 <= ni < height and 0 <= nj < width:\n            if grid[ni][nj] == free:\n                dfs_grid(grid, ni, nj)"}}, "leetcode/leetcode_1020.txt": {"score": 0.9195380806922913, "content": {"text": "def maxTurbulenceSize(arr):\n    \"\"\"You are given an `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell.\n\nA **move** consists of walking from one land cell to another adjacent (**4-directionally**) land cell or walking off the boundary of the `grid`.\n\nReturn _the number of land cells in_ `grid` _for which we cannot walk off the boundary of the grid in any number of **moves**_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[1,0,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 0\n**Explanation:** All 1s are either on the boundary or can reach the boundary.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\n\nFor i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is odd, and arr\\[k\\] < arr\\[k + 1\\] when k is even. OR For i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is even, and arr\\[k\\] < arr\\[k + 1\\] when k is odd.\"\"\"\n\n    n = len(arr)\n    result = 1\n    i = 0\n\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 1\n            continue\n\n        j = i + 1\n        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):\n            j += 1\n        \n        result = max(result, j - i + 1)\n        i = j\n\n    return result"}}, "leetcode/leetcode_1034.txt": {"score": 0.9267318248748779, "content": {"text": "def good_subarrays(nums, k):\n    \"\"\"You are given an `m x n` integer matrix `grid`, and three integers `row`, `col`, and `color`. Each value in the grid represents the color of the grid square at that location.\n\nTwo squares belong to the same **connected component** if they have the same color and are next to each other in any of the 4 directions.\n\nThe **border of a connected component** is all the squares in the connected component that are either **4-directionally** adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\n\nYou should color the **border** of the **connected component** that contains the square `grid[row][col]` with `color`.\n\nReturn _the final grid_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\n**Output:** \\[\\[3,3\\],\\[3,2\\]\\]\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,2\\],\\[2,3,2\\]\\], row = 0, col = 1, color = 3\n**Output:** \\[\\[1,3,3\\],\\[2,3,3\\]\\]\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], row = 1, col = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j], color <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        frequency = {}\n        for j in range(i, len(nums)):\n            frequency[nums[j]] = frequency.get(nums[j], 0) + 1\n            if len(frequency) > k:\n                break\n            if len(frequency) == k:\n                count += 1\n    return count"}}, "leetcode/leetcode_827.txt": {"score": 0.9670066237449646, "content": {"text": "def maxAreaOfIsland(grid):\n    \"\"\"You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`.\n\nReturn _the size of the largest **island** in_ `grid` _after applying this operation_.\n\nAn **island** is a 4-directionally connected group of `1`s.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** 3\n**Explanation:** Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** 4\n**Explanation:** Change the 0 to 1 and make the island bigger, only one island with area = 4.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** 4\n**Explanation:** Can't change any 0 to 1, only one island with area = 4.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    def dfs(x, y):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:\n            return 0\n        grid[x][y] = 0\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1\n\n    ans = 0\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 0:\n                grid[i][j] = 1\n                ans = max(ans, dfs(i, j))\n                grid[i][j] = 0\n    return ans"}}, "leetcode/leetcode_695.txt": {"score": 0.9973334670066833, "content": {"text": "def maxAreaOfIsland(grid):\n    \"\"\"You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is the number of cells with a value `1` in the island.\n\nReturn _the maximum **area** of an island in_ `grid`. If there is no island, return `0`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,1,0,0,0,0,1,0,0,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,1,1,0,1,0,0,0,0,0,0,0,0\\],\\[0,1,0,0,1,1,0,0,1,0,1,0,0\\],\\[0,1,0,0,1,1,0,0,1,1,1,0,0\\],\\[0,0,0,0,0,0,0,0,0,0,1,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,0,0,0,0\\]\\]\n**Output:** 6\n**Explanation:** The answer is not 11, because the island must be connected 4-directionally.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                max_area = max(max_area, dfs(i, j))\n    return max_area"}}}}, "35": {"gold": {"leetcode/leetcode_218.txt": 1}, "retrieved": {"leetcode/leetcode_1288.txt": {"score": 0.875421404838562, "content": {"text": "def maximum_sum(arr):\n    \"\"\"Given an array `intervals` where `intervals[i] = [li, ri]` represent the interval `[li, ri)`, remove all intervals that are covered by another interval in the list.\n\nThe interval `[a, b)` is covered by the interval `[c, d)` if and only if `c <= a` and `b <= d`.\n\nReturn _the number of remaining intervals_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[3,6\\],\\[2,8\\]\\]\n**Output:** 2\n**Explanation:** Interval \\[3,6\\] is covered by \\[2,8\\], therefore it is removed.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[2,3\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 1000`\n*   `intervals[i].length == 2`\n*   `0 <= li < ri <= 105`\n*   All the given intervals are **unique**.\"\"\"\n\n    n = len(arr)\n    sum_without_deletion = [0] * n\n    sum_with_deletion = [0] * n\n    sum_without_deletion[0] = arr[0]\n    sum_with_deletion[0] = 0\n    max_sum = arr[0]\n\n    for i in range(1, n):\n        sum_without_deletion[i] = max(arr[i], sum_without_deletion[i - 1] + arr[i])\n        sum_with_deletion[i] = max(sum_with_deletion[i - 1] + arr[i], sum_without_deletion[i - 1])\n        max_sum = max(max_sum, max(sum_without_deletion[i], sum_with_deletion[i]))\n    return max_sum"}}, "leetcode/leetcode_1563.txt": {"score": 0.8831258416175842, "content": {"text": "from math import acos, cos, sin, sqrt\n    \"\"\"There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially **zero**.\n\nReturn _the maximum score that Alice can obtain_.\n\n**Example 1:**\n\n**Input:** stoneValue = \\[6,2,3,4,5,5\\]\n**Output:** 18\n**Explanation:** In the first round, Alice divides the row to \\[6,2,3\\], \\[4,5,5\\]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to \\[6\\], \\[2,3\\]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is \\[2\\], \\[3\\]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\n**Example 2:**\n\n**Input:** stoneValue = \\[7,7,7,7,7,7,7\\]\n**Output:** 28\n\n**Example 3:**\n\n**Input:** stoneValue = \\[4\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 500`\n*   `1 <= stoneValue[i] <= 106`\"\"\"\n\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts"}}, "leetcode/leetcode_799.txt": {"score": 0.8771102428436279, "content": {"text": "class TreeNode:\n    \"\"\"We stack glasses in a pyramid, where the **first** row has `1` glass, the **second** row has `2` glasses, and so on until the 100th row. Each glass holds one cup of champagne.\n\nThen, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has its excess champagne fall on the floor.)\n\nFor example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\nNow after pouring some non-negative integer cups of champagne, return how full the `jth` glass in the `ith` row is (both `i` and `j` are 0-indexed.)\n\n**Example 1:**\n\n**Input:** poured = 1, query\\_row = 1, query\\_glass = 1\n**Output:** 0.00000\n**Explanation:** We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n\n**Example 2:**\n\n**Input:** poured = 2, query\\_row = 1, query\\_glass = 1\n**Output:** 0.50000\n**Explanation:** We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\n\n**Example 3:**\n\n**Input:** poured = 100000009, query\\_row = 33, query\\_glass = 17\n**Output:** 1.00000\n\n**Constraints:**\n\n*   `0 <= poured <= 109`\n*   `0 <= query_glass <= query_row < 100`\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.min_diff = float(\"inf\")\n        self.prev = None\n\n    def minDiffInBST(self, root: TreeNode) -> int:\n        self.in_order_traversal(root)\n        return self.min_diff\n\n    def in_order_traversal(self, node: TreeNode) -> None:\n        if not node: return\n        self.in_order_traversal(node.left)\n        if self.prev:\n            self.min_diff = min(self.min_diff, node.val - self.prev.val)\n        self.prev = node\n        self.in_order_traversal(node.right)"}}, "leetcode/leetcode_354.txt": {"score": 0.8852918148040771, "content": {"text": "from bisect import bisect_left\n    \"\"\"You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll (i.e., put one inside the other)_.\n\n**Note:** You cannot rotate an envelope.\n\n**Example 1:**\n\n**Input:** envelopes = \\[\\[5,4\\],\\[6,4\\],\\[6,7\\],\\[2,3\\]\\]\n**Output:** 3\n**Explanation:** The maximum number of envelopes you can Russian doll is `3` (\\[2,3\\] => \\[5,4\\] => \\[6,7\\]).\n\n**Example 2:**\n\n**Input:** envelopes = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= envelopes.length <= 105`\n*   `envelopes[i].length == 2`\n*   `1 <= wi, hi <= 105`\"\"\"\n\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)"}}, "leetcode/leetcode_2382.txt": {"score": 0.883947491645813, "content": {"text": "def max_seg_sum_after_queries(nums, removeQueries):\n    \"\"\"You are given two **0-indexed** integer arrays `nums` and `removeQueries`, both of length `n`. For the `ith` query, the element in `nums` at the index `removeQueries[i]` is removed, splitting `nums` into different segments.\n\nA **segment** is a contiguous sequence of **positive** integers in `nums`. A **segment sum** is the sum of every element in a segment.\n\nReturn _an integer array_ `answer`_, of length_ `n`_, where_ `answer[i]` _is the **maximum** segment sum after applying the_ `ith` _removal._\n\n**Note:** The same index will **not** be removed more than once.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,5,6,1\\], removeQueries = \\[0,3,2,4,1\\]\n**Output:** \\[14,7,2,2,0\\]\n**Explanation:** Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 0th element, nums becomes \\[0,2,5,6,1\\] and the maximum segment sum is 14 for segment \\[2,5,6,1\\].\nQuery 2: Remove the 3rd element, nums becomes \\[0,2,5,0,1\\] and the maximum segment sum is 7 for segment \\[2,5\\].\nQuery 3: Remove the 2nd element, nums becomes \\[0,2,0,0,1\\] and the maximum segment sum is 2 for segment \\[2\\]. \nQuery 4: Remove the 4th element, nums becomes \\[0,2,0,0,0\\] and the maximum segment sum is 2 for segment \\[2\\]. \nQuery 5: Remove the 1st element, nums becomes \\[0,0,0,0,0\\] and the maximum segment sum is 0, since there are no segments.\nFinally, we return \\[14,7,2,2,0\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,11,1\\], removeQueries = \\[3,2,1,0\\]\n**Output:** \\[16,5,3,0\\]\n**Explanation:** Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 3rd element, nums becomes \\[3,2,11,0\\] and the maximum segment sum is 16 for segment \\[3,2,11\\].\nQuery 2: Remove the 2nd element, nums becomes \\[3,2,0,0\\] and the maximum segment sum is 5 for segment \\[3,2\\].\nQuery 3: Remove the 1st element, nums becomes \\[3,0,0,0\\] and the maximum segment sum is 3 for segment \\[3\\].\nQuery 4: Remove the 0th element, nums becomes \\[0,0,0,0\\] and the maximum segment sum is 0, since there are no segments.\nFinally, we return \\[16,5,3,0\\].\n\n**Constraints:**\n\n*   `n == nums.length == removeQueries.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 109`\n*   `0 <= removeQueries[i] < n`\n*   All the values of `removeQueries` are **unique**.\"\"\"\n\n    n = len(nums)\n    answer = [0] * n\n    removed = {-1, n}\n    \n    current_sum = 0\n    max_sum = 0\n    for x in nums:\n        if x > 0:\n            current_sum += x\n        else:\n            max_sum = max(max_sum, current_sum)\n            current_sum = 0\n    max_sum = max(max_sum, current_sum)\n    \n    for i, remove_idx in enumerate(removeQueries):\n        answer[i] = max_sum\n        nums[remove_idx] = -nums[remove_idx]\n        \n        left_idx = max(x for x in removed if x < remove_idx)\n        right_idx = min(x for x in removed if x > remove_idx)\n        \n        left_sum = 0\n        right_sum = 0\n        for j in range(right_idx - 1, -1, -1):\n            if nums[j] < 0:\n                left_sum -= nums[j]\n            else:\n                break\n        for j in range(left_idx + 1, n):\n            if nums[j] < 0:\n                right_sum -= nums[j]\n            else:\n                break\n                \n        max_sum -= max(0, left_sum - (-nums[remove_idx]))\n        max_sum -= max(0, right_sum - (-nums[remove_idx]))\n        max_sum += max(0, left_sum + right_sum - (-nums[remove_idx]))\n        \n        removed.add(remove_idx)\n    \n    return answer"}}, "leetcode/leetcode_1105.txt": {"score": 0.9067282676696777, "content": {"text": "def max_uncrossed_lines(nums1, nums2):\n    \"\"\"You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`.\n\nWe want to place these books in order onto bookcase shelves that have a total width `shelfWidth`.\n\nWe choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n\nNote that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n*   For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\nReturn _the minimum possible height that the total bookshelf can be after placing shelves in this manner_.\n\n**Example 1:**\n\n**Input:** books = \\[\\[1,1\\],\\[2,3\\],\\[2,3\\],\\[1,1\\],\\[1,1\\],\\[1,1\\],\\[1,2\\]\\], shelfWidth = 4\n**Output:** 6\n**Explanation:**\nThe sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n**Example 2:**\n\n**Input:** books = \\[\\[1,3\\],\\[2,4\\],\\[3,2\\]\\], shelfWidth = 6\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= books.length <= 1000`\n*   `1 <= thicknessi <= shelfWidth <= 1000`\n*   `1 <= heighti <= 1000`\"\"\"\n\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]"}}, "leetcode/leetcode_1331.txt": {"score": 0.878734827041626, "content": {"text": "def getMaximumGold(grid):\n    \"\"\"Given an array of integers `arr`, replace each element with its rank.\n\nThe rank represents how large the element is. The rank has the following rules:\n\n*   Rank is an integer starting from 1.\n*   The larger the element, the larger the rank. If two elements are equal, their rank must be the same.\n*   Rank should be as small as possible.\n\n**Example 1:**\n\n**Input:** arr = \\[40,10,20,30\\]\n**Output:** \\[4,1,2,3\\]\n**Explanation**: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.\n\n**Example 2:**\n\n**Input:** arr = \\[100,100,100\\]\n**Output:** \\[1,1,1\\]\n**Explanation**: Same elements share the same rank.\n\n**Example 3:**\n\n**Input:** arr = \\[37,12,28,9,100,56,80,5,12\\]\n**Output:** \\[5,3,4,2,8,6,7,1,3\\]\n\n**Constraints:**\n\n*   `0 <= arr.length <= 105`\n*   `-109 <= arr[i] <= 109`\n\n\\- Every time you are in a cell you will collect all the gold in that cell. - From your position, you can walk one step to the left, right, up, or down. - You can't visit the same cell more than once. - Never visit a cell with 0 gold. - You can start and stop collecting gold from any position in the grid that has some gold.\"\"\"\n\n    m, n, max_gold = len(grid), len(grid[0]), 0\n\n    def getMaximumGoldHelper(x, y):\n        if not (0 <= x < m) or not (0 <= y < n) or grid[x][y] == 0:\n            return 0\n\n        original_gold = grid[x][y]\n        grid[x][y] = 0\n\n        max_gold = 0\n        max_gold = max(max_gold, getMaximumGoldHelper(x + 1, y))\n        max_gold = max(max_gold, getMaximumGoldHelper(x - 1, y))\n        max_gold = max(max_gold, getMaximumGoldHelper(x, y + 1))\n        max_gold = max(max_gold, getMaximumGoldHelper(x, y - 1))\n\n        grid[x][y] = original_gold\n        return max_gold + original_gold\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                max_gold = max(max_gold, getMaximumGoldHelper(i, j))\n\n    return max_gold"}}, "leetcode/leetcode_699.txt": {"score": 0.9975147843360901, "content": {"text": "def fallingSquares(positions):\n    \"\"\"There are several squares being dropped onto the X-axis of a 2D plane.\n\nYou are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`.\n\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands **on the top side of another square** or **on the X-axis**. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n\nAfter each square is dropped, you must record the **height of the current tallest stack of squares**.\n\nReturn _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_.\n\n**Example 1:**\n\n**Input:** positions = \\[\\[1,2\\],\\[2,3\\],\\[6,1\\]\\]\n**Output:** \\[2,5,5\\]\n**Explanation:**\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of \\[2, 5, 5\\].\n\n**Example 2:**\n\n**Input:** positions = \\[\\[100,100\\],\\[200,100\\]\\]\n**Output:** \\[100,100\\]\n**Explanation:**\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of \\[100, 100\\].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it.\n\n**Constraints:**\n\n*   `1 <= positions.length <= 1000`\n*   `1 <= lefti <= 108`\n*   `1 <= sideLengthi <= 106`\"\"\"\n\n    ans = []\n    intervals = []\n\n    for p in positions:\n        L, size = p\n        R = L + size\n        h = size\n        for h2, R2 in intervals:\n            if R2 > L and R > R2:\n                h = max(h, size + h2)\n\n        maxHeight = max((h2 for h2, R2 in intervals), default=0)\n        ans.append(max(maxHeight, h))\n        intervals.append((h, R))\n\n    return ans"}}, "leetcode/csn_python_train_126434.txt": {"score": 0.8891112208366394, "content": {"text": "def append_panel(panels, size_x, size_y, max_col=12):\n    \"\"\"\n    Appends a panel to the list of panels. Finds the highest palce at the left for the new panel.\n    :param panels:\n    :param size_x:\n    :param size_y:\n    :param max_col:\n    :return: a new panel or None if it is not possible to place a panel with such size_x\n    \"\"\"\n    bottom_lines = bottoms(panels)\n    shape = find_shape(bottom_lines, max_col)\n    lines = longest_lines(shape)\n    line = find_place(lines, size_x)\n    if not line:\n        return\n    panel = {\n        'col': line['col'],\n        'row': line['row'],\n        'size_x': size_x,\n        'size_y': size_y,\n    }\n    panels.append(panel)\n    return panel"}}, "leetcode/leetcode_1046.txt": {"score": 0.8906185626983643, "content": {"text": "def longestOnes(nums, k):\n    \"\"\"You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.\n\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n\n*   If `x == y`, both stones are destroyed, and\n*   If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is **at most one** stone left.\n\nReturn _the weight of the last remaining stone_. If there are no stones left, return `0`.\n\n**Example 1:**\n\n**Input:** stones = \\[2,7,4,1,8,1\\]\n**Output:** 1\n**Explanation:** \nWe combine 7 and 8 to get 1 so the array converts to \\[2,4,1,1,1\\] then,\nwe combine 2 and 4 to get 2 so the array converts to \\[2,1,1,1\\] then,\nwe combine 2 and 1 to get 1 so the array converts to \\[1,1,1\\] then,\nwe combine 1 and 1 to get 0 so the array converts to \\[1\\] then that's the value of the last stone.\n\n**Example 2:**\n\n**Input:** stones = \\[1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= stones.length <= 30`\n*   `1 <= stones[i] <= 1000`\"\"\"\n\n    left, right, max_ones, zero_count = 0, 0, 0, 0\n    while right < len(nums):\n        if nums[right] == 0:\n            zero_count += 1\n        while zero_count > k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n        max_ones = max(max_ones, right - left + 1)\n        right += 1\n    return max_ones"}}}}, "36": {"gold": {"leetcode/leetcode_496.txt": 1}, "retrieved": {"leetcode/leetcode_2210.txt": {"score": 0.8621439337730408, "content": {"text": "def sorted_target_indices(nums, target):\n    \"\"\"You are given a **0-indexed** integer array `nums`. An index `i` is part of a **hill** in `nums` if the closest non-equal neighbors of `i` are smaller than `nums[i]`. Similarly, an index `i` is part of a **valley** in `nums` if the closest non-equal neighbors of `i` are larger than `nums[i]`. Adjacent indices `i` and `j` are part of the **same** hill or valley if `nums[i] == nums[j]`.\n\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on **both** the left and right of the index.\n\nReturn _the number of hills and valleys in_ `nums`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,1,1,6,5\\]\n**Output:** 3\n**Explanation:**\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\n**Example 2:**\n\n**Input:** nums = \\[6,6,5,5,4,1\\]\n**Output:** 0\n**Explanation:**\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`\"\"\"\n\n    result = [i for i, num in enumerate(nums) if num == target]\n    return sorted(result)"}}, "leetcode/leetcode_456.txt": {"score": 0.8623948097229004, "content": {"text": "def find132pattern(nums):\n    \"\"\"Given an array of `n` integers `nums`, a **132 pattern** is a subsequence of three integers `nums[i]`, `nums[j]` and `nums[k]` such that `i < j < k` and `nums[i] < nums[k] < nums[j]`.\n\nReturn `true` _if there is a **132 pattern** in_ `nums`_, otherwise, return_ `false`_._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** There is no 132 pattern in the sequence.\n\n**Example 2:**\n\n**Input:** nums = \\[3,1,4,2\\]\n**Output:** true\n**Explanation:** There is a 132 pattern in the sequence: \\[1, 4, 2\\].\n\n**Example 3:**\n\n**Input:** nums = \\[-1,3,2,0\\]\n**Output:** true\n**Explanation:** There are three 132 patterns in the sequence: \\[-1, 3, 2\\], \\[-1, 3, 0\\] and \\[-1, 2, 0\\].\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 2 * 105`\n*   `-109 <= nums[i] <= 109`\"\"\"\n\n    third, stack = float('-inf'), []\n    for num in reversed(nums):\n        if num < third:\n            return True\n        while stack and stack[-1] < num:\n            third = stack.pop()\n        stack.append(num)\n    return False"}}, "leetcode/leetcode_962.txt": {"score": 0.8683839440345764, "content": {"text": "def minFlipsMonoIncr(s: str) -> int:\n    \"\"\"A **ramp** in an integer array `nums` is a pair `(i, j)` for which `i < j` and `nums[i] <= nums[j]`. The **width** of such a ramp is `j - i`.\n\nGiven an integer array `nums`, return _the maximum width of a **ramp** in_ `nums`. If there is no **ramp** in `nums`, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[6,0,8,2,1,5\\]\n**Output:** 4\n**Explanation:** The maximum width ramp is achieved at (i, j) = (1, 5): nums\\[1\\] = 0 and nums\\[5\\] = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[9,8,1,0,1,9,4,0,4,1\\]\n**Output:** 7\n**Explanation:** The maximum width ramp is achieved at (i, j) = (2, 9): nums\\[2\\] = 1 and nums\\[9\\] = 1.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 5 * 104`\"\"\"\n\n    flipCount, oneCount = 0, 0\n    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)\n    return flipCount"}}, "leetcode/leetcode_2274.txt": {"score": 0.8654745221138, "content": {"text": "def final_value(nums, original):\n    \"\"\"Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.\n\nYou are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.\n\nReturn _the **maximum** number of consecutive floors without a special floor_.\n\n**Example 1:**\n\n**Input:** bottom = 2, top = 9, special = \\[4,6\\]\n**Output:** 3\n**Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors.\n\n**Example 2:**\n\n**Input:** bottom = 6, top = 8, special = \\[7,6,8\\]\n**Output:** 0\n**Explanation:** Every floor rented is a special floor, so we return 0.\n\n**Constraints:**\n\n*   `1 <= special.length <= 105`\n*   `1 <= bottom <= special[i] <= top <= 109`\n*   All the values of `special` are **unique**.\"\"\"\n\n    while original in nums:\n        original += 1\n    return original"}}, "leetcode/leetcode_1019.txt": {"score": 0.87787264585495, "content": {"text": "def sortedSquares(nums):\n    \"\"\"You are given the `head` of a linked list with `n` nodes.\n\nFor each node in the list, find the value of the **next greater node**. That is, for each node, find the value of the first node that is next to it and has a **strictly larger** value than it.\n\nReturn an integer array `answer` where `answer[i]` is the value of the next greater node of the `ith` node (**1-indexed**). If the `ith` node does not have a next greater node, set `answer[i] = 0`.\n\n**Example 1:**\n\n**Input:** head = \\[2,1,5\\]\n**Output:** \\[5,5,0\\]\n\n**Example 2:**\n\n**Input:** head = \\[2,7,4,3,5\\]\n**Output:** \\[7,0,5,5,0\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is `n`.\n*   `1 <= n <= 104`\n*   `1 <= Node.val <= 109`\"\"\"\n\n    return sorted([x ** 2 for x in nums])"}}, "leetcode/leetcode_1482.txt": {"score": 0.8687751293182373, "content": {"text": "def smallerNumbersThanCurrent(nums):\n    \"\"\"You are given an integer array `bloomDay`, an integer `m` and an integer `k`.\n\nYou want to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden.\n\nThe garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet.\n\nReturn _the minimum number of days you need to wait to be able to make_ `m` _bouquets from the garden_. If it is impossible to make m bouquets return `-1`.\n\n**Example 1:**\n\n**Input:** bloomDay = \\[1,10,3,10,2\\], m = 3, k = 1\n**Output:** 3\n**Explanation:** Let us see what happened in the first three days. x means flower bloomed and \\_ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: \\[x, \\_, \\_, \\_, \\_\\]   // we can only make one bouquet.\nAfter day 2: \\[x, \\_, \\_, \\_, x\\]   // we can only make two bouquets.\nAfter day 3: \\[x, \\_, x, \\_, x\\]   // we can make 3 bouquets. The answer is 3.\n\n**Example 2:**\n\n**Input:** bloomDay = \\[1,10,3,10,2\\], m = 3, k = 2\n**Output:** -1\n**Explanation:** We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n\n**Example 3:**\n\n**Input:** bloomDay = \\[7,7,7,7,12,7,7\\], m = 2, k = 3\n**Output:** 12\n**Explanation:** We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: \\[x, x, x, x, \\_, x, x\\]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: \\[x, x, x, x, x, x, x\\]\nIt is obvious that we can make two bouquets in different ways.\n\n**Constraints:**\n\n*   `bloomDay.length == n`\n*   `1 <= n <= 105`\n*   `1 <= bloomDay[i] <= 109`\n*   `1 <= m <= 106`\n*   `1 <= k <= n`\"\"\"\n\n    result = [0] * len(nums)\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if nums[j] < nums[i]:\n                result[i] += 1\n    return result"}}, "leetcode/leetcode_739.txt": {"score": 0.9916947484016418, "content": {"text": "def daily_temperatures(temperatures):\n    \"\"\"Given an array of integers `temperatures` represents the daily temperatures, return _an array_ `answer` _such that_ `answer[i]` _is the number of days you have to wait after the_ `ith` _day to get a warmer temperature_. If there is no future day for which this is possible, keep `answer[i] == 0` instead.\n\n**Example 1:**\n\n**Input:** temperatures = \\[73,74,75,71,69,72,76,73\\]\n**Output:** \\[1,1,4,2,1,1,0,0\\]\n\n**Example 2:**\n\n**Input:** temperatures = \\[30,40,50,60\\]\n**Output:** \\[1,1,1,0\\]\n\n**Example 3:**\n\n**Input:** temperatures = \\[30,60,90\\]\n**Output:** \\[1,1,0\\]\n\n**Constraints:**\n\n*   `1 <= temperatures.length <= 105`\n*   `30 <= temperatures[i] <= 100`\"\"\"\n\n    result = [0] * len(temperatures)\n    stack = []\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp > temperatures[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n\n    return result"}}, "leetcode/leetcode_496.txt": {"score": 0.8967657685279846, "content": {"text": "def next_greater_element(nums1, nums2):\n    \"\"\"The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.\n\nYou are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.\n\nFor each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.\n\nReturn _an array_ `ans` _of length_ `nums1.length` _such that_ `ans[i]` _is the **next greater element** as described above._\n\n**Example 1:**\n\n**Input:** nums1 = \\[4,1,2\\], nums2 = \\[1,3,4,2\\]\n**Output:** \\[-1,3,-1\\]\n**Explanation:** The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = \\[1,3,4,2\\]. The next greater element is 3.\n- 2 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n\n**Example 2:**\n\n**Input:** nums1 = \\[2,4\\], nums2 = \\[1,2,3,4\\]\n**Output:** \\[3,-1\\]\n**Explanation:** The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = \\[1,2,3,4\\]. The next greater element is 3.\n- 4 is underlined in nums2 = \\[1,2,3,4\\]. There is no next greater element, so the answer is -1.\n\n**Constraints:**\n\n*   `1 <= nums1.length <= nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 104`\n*   All integers in `nums1` and `nums2` are **unique**.\n*   All the integers of `nums1` also appear in `nums2`.\n\n**Follow up:** Could you find an `O(nums1.length + nums2.length)` solution?\"\"\"\n\n    next_greater = {}\n    stack = []\n\n    for num in nums2:\n        while stack and stack[-1] < num:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    return [next_greater.get(n, -1) for n in nums1]"}}, "leetcode/leetcode_2089.txt": {"score": 0.8669312596321106, "content": {"text": "def maxMatrixSum(matrix):\n    \"\"\"You are given a **0-indexed** integer array `nums` and a target element `target`.\n\nA **target index** is an index `i` such that `nums[i] == target`.\n\nReturn _a list of the target indices of_ `nums` after _sorting_ `nums` _in **non-decreasing** order_. If there are no target indices, return _an **empty** list_. The returned list must be sorted in **increasing** order.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,5,2,3\\], target = 2\n**Output:** \\[1,2\\]\n**Explanation:** After sorting, nums is \\[1,**2**,**2**,3,5\\].\nThe indices where nums\\[i\\] == 2 are 1 and 2.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,5,2,3\\], target = 3\n**Output:** \\[3\\]\n**Explanation:** After sorting, nums is \\[1,2,2,**3**,5\\].\nThe index where nums\\[i\\] == 3 is 3.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,5,2,3\\], target = 5\n**Output:** \\[4\\]\n**Explanation:** After sorting, nums is \\[1,2,2,3,**5**\\].\nThe index where nums\\[i\\] == 5 is 4.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i], target <= 100`\"\"\"\n\n    n = len(matrix)\n    minValue, negativeCount, total = float('inf'), 0, 0\n\n    for i in range(n):\n        for j in range(n):\n            total += abs(matrix[i][j])\n            minValue = min(minValue, abs(matrix[i][j]))\n            if matrix[i][j] < 0:\n                negativeCount += 1\n\n    if negativeCount % 2 == 0:\n        return total\n    else:\n        return total - 2 * minValue"}}, "leetcode/leetcode_2454.txt": {"score": 0.8900676369667053, "content": {"text": "def find_second_greater(nums):\n    \"\"\"You are given a **0-indexed** array of non-negative integers `nums`. For each integer in `nums`, you must find its respective **second greater** integer.\n\nThe **second greater** integer of `nums[i]` is `nums[j]` such that:\n\n*   `j > i`\n*   `nums[j] > nums[i]`\n*   There exists **exactly one** index `k` such that `nums[k] > nums[i]` and `i < k < j`.\n\nIf there is no such `nums[j]`, the second greater integer is considered to be `-1`.\n\n*   For example, in the array `[1, 2, 4, 3]`, the second greater integer of `1` is `4`, `2` is `3`, and that of `3` and `4` is `-1`.\n\nReturn _an integer array_ `answer`_, where_ `answer[i]` _is the second greater integer of_ `nums[i]`_._\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,0,9,6\\]\n**Output:** \\[9,6,6,-1,-1\\]\n**Explanation:**\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return \\[9,6,6,-1,-1\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,3\\]\n**Output:** \\[-1,-1\\]\n**Explanation:**\nWe return \\[-1,-1\\] since neither integer has any integer greater than it.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`\"\"\"\n\n    n = len(nums)\n    answer = [-1] * n\n    for i in range(n):\n        k = -1\n        for j in range(i + 1, n):\n            if nums[j] > nums[i]:\n                if k == -1:\n                    k = j\n                else:\n                    answer[i] = nums[j]\n                    break\n    return answer"}}}}, "37": {"gold": {"leetcode/leetcode_2400.txt": 1}, "retrieved": {"leetcode/leetcode_2571.txt": {"score": 0.9078676700592041, "content": {"text": "def minOperations(n: int) -> int:\n    \"\"\"You are given a positive integer `n`, you can do the following operation **any** number of times:\n\n*   Add or subtract a **power** of `2` from `n`.\n\nReturn _the **minimum** number of operations to make_ `n` _equal to_ `0`.\n\nA number `x` is power of `2` if `x == 2i` where `i >= 0`_._\n\n**Example 1:**\n\n**Input:** n = 39\n**Output:** 3\n**Explanation:** We can do the following operations:\n- Add 20 = 1 to n, so now n = 40.\n- Subtract 23 = 8 from n, so now n = 32.\n- Subtract 25 = 32 from n, so now n = 0.\nIt can be shown that 3 is the minimum number of operations we need to make n equal to 0.\n\n**Example 2:**\n\n**Input:** n = 54\n**Output:** 3\n**Explanation:** We can do the following operations:\n- Add 21 = 2 to n, so now n = 56.\n- Add 23 = 8 to n, so now n = 64.\n- Subtract 26 = 64 from n, so now n = 0.\nSo the minimum number of operations is 3.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\"\"\"\n\n    operations = 0\n    while n:\n        operations += n % 2\n        n //= 2\n    return operations"}}, "leetcode/leetcode_991.txt": {"score": 0.9120762944221497, "content": {"text": "def can_reorder_array(arr):\n    \"\"\"There is a broken calculator that has the integer `startValue` on its display initially. In one operation, you can:\n\n*   multiply the number on display by `2`, or\n*   subtract `1` from the number on display.\n\nGiven two integers `startValue` and `target`, return _the minimum number of operations needed to display_ `target` _on the calculator_.\n\n**Example 1:**\n\n**Input:** startValue = 2, target = 3\n**Output:** 2\n**Explanation:** Use double operation and then decrement operation {2 -> 4 -> 3}.\n\n**Example 2:**\n\n**Input:** startValue = 5, target = 8\n**Output:** 2\n**Explanation:** Use decrement and then double {5 -> 4 -> 8}.\n\n**Example 3:**\n\n**Input:** startValue = 3, target = 10\n**Output:** 3\n**Explanation:** Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n\n**Constraints:**\n\n*   `1 <= startValue, target <= 109`\"\"\"\n\n    from collections import Counter\n    \n    count = Counter(arr)\n    arr = sorted(arr)\n    for x in arr:\n        if count[x] == 0:\n            continue\n        if count[2 * x] > 0:\n            count[x] -= 1\n            count[2 * x] -= 1\n        else:\n            return False\n    return True"}}, "leetcode/leetcode_1769.txt": {"score": 0.9113993048667908, "content": {"text": "def maximum_generated(n: int) -> int:\n    \"\"\"You have `n` boxes. You are given a binary string `boxes` of length `n`, where `boxes[i]` is `'0'` if the `ith` box is **empty**, and `'1'` if it contains **one** ball.\n\nIn one operation, you can move **one** ball from a box to an adjacent box. Box `i` is adjacent to box `j` if `abs(i - j) == 1`. Note that after doing so, there may be more than one ball in some boxes.\n\nReturn an array `answer` of size `n`, where `answer[i]` is the **minimum** number of operations needed to move all the balls to the `ith` box.\n\nEach `answer[i]` is calculated considering the **initial** state of the boxes.\n\n**Example 1:**\n\n**Input:** boxes =  \"110 \"\n**Output:** \\[1,1,3\\]\n**Explanation:** The answer for each box is as follows:\n1) First box: you will have to move one ball from the second box to the first box in one operation.\n2) Second box: you will have to move one ball from the first box to the second box in one operation.\n3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.\n\n**Example 2:**\n\n**Input:** boxes =  \"001011 \"\n**Output:** \\[11,8,5,4,3,4\\]\n\n**Constraints:**\n\n*   `n == boxes.length`\n*   `1 <= n <= 2000`\n*   `boxes[i]` is either `'0'` or `'1'`.\"\"\"\n\n    if n == 0:\n        return 0\n    nums = [0] * (n + 1)\n    nums[1] = 1\n    for i in range(2, n + 1):\n        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]\n    return max(nums)"}}, "leetcode/leetcode_1306.txt": {"score": 0.9138651490211487, "content": {"text": "def minimumAbsDifference(arr):\n    \"\"\"Given an array of non-negative integers `arr`, you are initially positioned at `start` index of the array. When you are at index `i`, you can jump to `i + arr[i]` or `i - arr[i]`, check if you can reach to **any** index with value 0.\n\nNotice that you can not jump outside of the array at any time.\n\n**Example 1:**\n\n**Input:** arr = \\[4,2,3,0,3,1,2\\], start = 5\n**Output:** true\n**Explanation:** \nAll possible ways to reach at index 3 with value 0 are: \nindex 5 -> index 4 -> index 1 -> index 3 \nindex 5 -> index 6 -> index 4 -> index 1 -> index 3 \n\n**Example 2:**\n\n**Input:** arr = \\[4,2,3,0,3,1,2\\], start = 0\n**Output:** true \n**Explanation:** \nOne possible way to reach at index 3 with value 0 is: \nindex 0 -> index 4 -> index 1 -> index 3\n\n**Example 3:**\n\n**Input:** arr = \\[3,0,2,1,2\\], start = 2\n**Output:** false\n**Explanation:** There is no way to reach at index 1 with value 0.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 5 * 104`\n*   `0 <= arr[i] < arr.length`\n*   `0 <= start < arr.length`\n\na, b are from arr a < b b - a equals to the minimum absolute difference of any two elements in arr\"\"\"\n\n    arr.sort()\n    min_difference = float('inf')\n    result = []\n\n    for i in range(1, len(arr)):\n        difference = arr[i] - arr[i - 1]\n        if difference < min_difference:\n            min_difference = difference\n            result = [[arr[i - 1], arr[i]]]\n        elif difference == min_difference:\n            result.append([arr[i - 1], arr[i]])\n\n    return result"}}, "leetcode/leetcode_818.txt": {"score": 0.9443721771240234, "content": {"text": "def racecar(target: int) -> int:\n    \"\"\"Your car starts at position `0` and speed `+1` on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions `'A'` (accelerate) and `'R'` (reverse):\n\n*   When you get an instruction `'A'`, your car does the following:\n    *   `position += speed`\n    *   `speed *= 2`\n*   When you get an instruction `'R'`, your car does the following:\n    *   If your speed is positive then `speed = -1`\n    *   otherwise `speed = 1`Your position stays the same.\n\nFor example, after commands `\"AAR \"`, your car goes to positions `0 --> 1 --> 3 --> 3`, and your speed goes to `1 --> 2 --> 4 --> -1`.\n\nGiven a target position `target`, return _the length of the shortest sequence of instructions to get there_.\n\n**Example 1:**\n\n**Input:** target = 3\n**Output:** 2\n**Explanation:** \nThe shortest instruction sequence is  \"AA \".\nYour position goes from 0 --> 1 --> 3.\n\n**Example 2:**\n\n**Input:** target = 6\n**Output:** 5\n**Explanation:** \nThe shortest instruction sequence is  \"AAARA \".\nYour position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6.\n\n**Constraints:**\n\n*   `1 <= target <= 104`\"\"\"\n\n    memo = {}\n    def dp(position, speed):\n        if abs(position) > 2 * target:\n            return target + 1\n        if position == target:\n            return 0 if speed == 1 else 1\n        if (position, speed) in memo:\n            return memo[(position, speed)]\n        \n        ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1\n        ans = min(ans, dp(position + speed, speed * 2) + 1)\n        memo[(position, speed)] = ans\n        return ans\n    \n    return dp(0, 1)"}}, "leetcode/leetcode_2037.txt": {"score": 0.921696662902832, "content": {"text": "def count_square_triples(n):\n    \"\"\"There are `n` seats and `n` students in a room. You are given an array `seats` of length `n`, where `seats[i]` is the position of the `ith` seat. You are also given the array `students` of length `n`, where `students[j]` is the position of the `jth` student.\n\nYou may perform the following move any number of times:\n\n*   Increase or decrease the position of the `ith` student by `1` (i.e., moving the `ith` student from position `x` to `x + 1` or `x - 1`)\n\nReturn _the **minimum number of moves** required to move each student to a seat_ _such that no two students are in the same seat._\n\nNote that there may be **multiple** seats or students in the **same** position at the beginning.\n\n**Example 1:**\n\n**Input:** seats = \\[3,1,5\\], students = \\[2,7,4\\]\n**Output:** 4\n**Explanation:** The students are moved as follows:\n- The first student is moved from from position 2 to position 1 using 1 move.\n- The second student is moved from from position 7 to position 5 using 2 moves.\n- The third student is moved from from position 4 to position 3 using 1 move.\nIn total, 1 + 2 + 1 = 4 moves were used.\n\n**Example 2:**\n\n**Input:** seats = \\[4,1,5,9\\], students = \\[1,3,2,6\\]\n**Output:** 7\n**Explanation:** The students are moved as follows:\n- The first student is not moved.\n- The second student is moved from from position 3 to position 4 using 1 move.\n- The third student is moved from from position 2 to position 5 using 3 moves.\n- The fourth student is moved from from position 6 to position 9 using 3 moves.\nIn total, 0 + 1 + 3 + 3 = 7 moves were used.\n\n**Example 3:**\n\n**Input:** seats = \\[2,2,6,6\\], students = \\[1,3,2,6\\]\n**Output:** 4\n**Explanation:** Note that there are two seats at position 2 and two seats at position 6.\nThe students are moved as follows:\n- The first student is moved from from position 1 to position 2 using 1 move.\n- The second student is moved from from position 3 to position 6 using 3 moves.\n- The third student is not moved.\n- The fourth student is not moved.\nIn total, 1 + 3 + 0 + 0 = 4 moves were used.\n\n**Constraints:**\n\n*   `n == seats.length == students.length`\n*   `1 <= n <= 100`\n*   `1 <= seats[i], students[j] <= 100`\"\"\"\n\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = int((a * a + b * b)**0.5)\n            if c * c == a * a + b * b and c <= n:\n                count += 1\n    return count"}}, "leetcode/leetcode_1033.txt": {"score": 0.912677526473999, "content": {"text": "def broken_calc(startValue: int, target: int) -> int:\n    \"\"\"There are three stones in different positions on the X-axis. You are given three integers `a`, `b`, and `c`, the positions of the stones.\n\nIn one move, you pick up a stone at an endpoint (i.e., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. Formally, let's say the stones are currently at positions `x`, `y`, and `z` with `x < y < z`. You pick up the stone at either position `x` or position `z`, and move that stone to an integer position `k`, with `x < k < z` and `k != y`.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n\nReturn _an integer array_ `answer` _of length_ `2` _where_:\n\n*   `answer[0]` _is the minimum number of moves you can play, and_\n*   `answer[1]` _is the maximum number of moves you can play_.\n\n**Example 1:**\n\n**Input:** a = 1, b = 2, c = 5\n**Output:** \\[1,2\\]\n**Explanation:** Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.\n\n**Example 2:**\n\n**Input:** a = 4, b = 3, c = 2\n**Output:** \\[0,0\\]\n**Explanation:** We cannot make any moves.\n\n**Example 3:**\n\n**Input:** a = 3, b = 5, c = 1\n**Output:** \\[1,2\\]\n**Explanation:** Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 100`\n*   `a`, `b`, and `c` have different values.\"\"\"\n\n    operations = 0\n    while target > startValue:\n        target = target // 2 if target % 2 == 0 else target + 1\n        operations += 1\n    return operations + startValue - target"}}, "leetcode/leetcode_1654.txt": {"score": 0.927595317363739, "content": {"text": "from collections import deque\n    \"\"\"A certain bug's home is on the x-axis at position `x`. Help them get there from position `0`.\n\nThe bug jumps according to the following rules:\n\n*   It can jump exactly `a` positions **forward** (to the right).\n*   It can jump exactly `b` positions **backward** (to the left).\n*   It cannot jump backward twice in a row.\n*   It cannot jump to any `forbidden` positions.\n\nThe bug may jump forward **beyond** its home, but it **cannot jump** to positions numbered with **negative** integers.\n\nGiven an array of integers `forbidden`, where `forbidden[i]` means that the bug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and `x`, return _the minimum number of jumps needed for the bug to reach its home_. If there is no possible sequence of jumps that lands the bug on position `x`, return `-1.`\n\n**Example 1:**\n\n**Input:** forbidden = \\[14,4,18,1,15\\], a = 3, b = 15, x = 9\n**Output:** 3\n**Explanation:** 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.\n\n**Example 2:**\n\n**Input:** forbidden = \\[8,3,16,6,12,20\\], a = 15, b = 13, x = 11\n**Output:** -1\n\n**Example 3:**\n\n**Input:** forbidden = \\[1,6,2,14,5,17,4\\], a = 16, b = 9, x = 7\n**Output:** 2\n**Explanation:** One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.\n\n**Constraints:**\n\n*   `1 <= forbidden.length <= 1000`\n*   `1 <= a, b, forbidden[i] <= 2000`\n*   `0 <= x <= 2000`\n*   All the elements in `forbidden` are distinct.\n*   Position `x` is not forbidden.\"\"\"\n\n\ndef minimumJumps(forbidden, a, b, x):\n    forbidden_positions = set(forbidden)\n    q = deque([(0, 0, 0)])\n    visited = {(0, 0)}\n    while q:\n        pos, steps, backward = q.popleft()\n        if pos == x:\n            return steps\n        forward_pos = pos + a\n        backward_pos = pos - b\n        if forward_pos <= 6000 and forward_pos not in forbidden_positions and (forward_pos, 0) not in visited:\n            visited.add((forward_pos, 0))\n            q.append((forward_pos, steps + 1, 0))\n        if backward == 0 and backward_pos > 0 and backward_pos not in forbidden_positions and (backward_pos, 1) not in visited:\n            visited.add((backward_pos, 1))\n            q.append((backward_pos, steps + 1, 1))\n    return -1"}}, "leetcode/leetcode_2139.txt": {"score": 0.9161911606788635, "content": {"text": "class DetectSquares:\n    \"\"\"You are playing a game with integers. You start with the integer `1` and you want to reach the integer `target`.\n\nIn one move, you can either:\n\n*   **Increment** the current integer by one (i.e., `x = x + 1`).\n*   **Double** the current integer (i.e., `x = 2 * x`).\n\nYou can use the **increment** operation **any** number of times, however, you can only use the **double** operation **at most** `maxDoubles` times.\n\nGiven the two integers `target` and `maxDoubles`, return _the minimum number of moves needed to reach_ `target` _starting with_ `1`.\n\n**Example 1:**\n\n**Input:** target = 5, maxDoubles = 0\n**Output:** 4\n**Explanation:** Keep incrementing by 1 until you reach target.\n\n**Example 2:**\n\n**Input:** target = 19, maxDoubles = 2\n**Output:** 7\n**Explanation:** Initially, x = 1\nIncrement 3 times so x = 4\nDouble once so x = 8\nIncrement once so x = 9\nDouble again so x = 18\nIncrement once so x = 19\n\n**Example 3:**\n\n**Input:** target = 10, maxDoubles = 4\n**Output:** 4\n**Explanation:** Initially, x = 1\nIncrement once so x = 2\nDouble once so x = 4\nIncrement once so x = 5\nDouble again so x = 10\n\n**Constraints:**\n\n*   `1 <= target <= 109`\n*   `0 <= maxDoubles <= 100`\"\"\"\n\n\n    def __init__(self):\n        self.points = collections.defaultdict(lambda: collections.defaultdict(int))\n\n    def add(self, point):\n        self.points[point[0]][point[1]] += 1\n\n    def count(self, point):\n        ans = 0\n        for x2 in self.points[point[0]]:\n            if x2 == point[1]:\n                continue\n            for y2 in self.points[x2]:\n                if y2 == point[1] or abs(x2 - point[1]) != abs(y2 - point[0]):\n                    continue\n                ans += self.points[point[0]][x2] * self.points[x2][y2] * self.points[point[0]][y2]\n        return ans"}}, "leetcode/leetcode_754.txt": {"score": 0.9696030616760254, "content": {"text": "def reachNumber(target: int) -> int:\n    \"\"\"You are standing at position `0` on an infinite number line. There is a destination at position `target`.\n\nYou can make some number of moves `numMoves` so that:\n\n*   On each move, you can either go left or right.\n*   During the `ith` move (starting from `i == 1` to `i == numMoves`), you take `i` steps in the chosen direction.\n\nGiven the integer `target`, return _the **minimum** number of moves required (i.e., the minimum_ `numMoves`_) to reach the destination_.\n\n**Example 1:**\n\n**Input:** target = 2\n**Output:** 3\n**Explanation:**\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to -1 (2 steps).\nOn the 3rd move, we step from -1 to 2 (3 steps).\n\n**Example 2:**\n\n**Input:** target = 3\n**Output:** 2\n**Explanation:**\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to 3 (2 steps).\n\n**Constraints:**\n\n*   `-109 <= target <= 109`\n*   `target != 0`\"\"\"\n\n    target = abs(target)\n    step = 0\n    sum = 0\n    while sum < target:\n        step += 1\n        sum += step\n    while (sum - target) % 2 != 0:\n        step += 1\n        sum += step\n    return step"}}}}, "38": {"gold": {"leetcode/leetcode_41.txt": 1, "leetcode/leetcode_268.txt": 1, "leetcode/leetcode_854.txt": 1}, "retrieved": {"leetcode/leetcode_1033.txt": {"score": 0.9275497794151306, "content": {"text": "def broken_calc(startValue: int, target: int) -> int:\n    \"\"\"There are three stones in different positions on the X-axis. You are given three integers `a`, `b`, and `c`, the positions of the stones.\n\nIn one move, you pick up a stone at an endpoint (i.e., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. Formally, let's say the stones are currently at positions `x`, `y`, and `z` with `x < y < z`. You pick up the stone at either position `x` or position `z`, and move that stone to an integer position `k`, with `x < k < z` and `k != y`.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n\nReturn _an integer array_ `answer` _of length_ `2` _where_:\n\n*   `answer[0]` _is the minimum number of moves you can play, and_\n*   `answer[1]` _is the maximum number of moves you can play_.\n\n**Example 1:**\n\n**Input:** a = 1, b = 2, c = 5\n**Output:** \\[1,2\\]\n**Explanation:** Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.\n\n**Example 2:**\n\n**Input:** a = 4, b = 3, c = 2\n**Output:** \\[0,0\\]\n**Explanation:** We cannot make any moves.\n\n**Example 3:**\n\n**Input:** a = 3, b = 5, c = 1\n**Output:** \\[1,2\\]\n**Explanation:** Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 100`\n*   `a`, `b`, and `c` have different values.\"\"\"\n\n    operations = 0\n    while target > startValue:\n        target = target // 2 if target % 2 == 0 else target + 1\n        operations += 1\n    return operations + startValue - target"}}, "leetcode/leetcode_1007.txt": {"score": 0.9298917651176453, "content": {"text": "def numsSameConsecDiff(n, k):\n    \"\"\"In a row of dominoes, `tops[i]` and `bottoms[i]` represent the top and bottom halves of the `ith` domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\n\nWe may rotate the `ith` domino, so that `tops[i]` and `bottoms[i]` swap values.\n\nReturn the minimum number of rotations so that all the values in `tops` are the same, or all the values in `bottoms` are the same.\n\nIf it cannot be done, return `-1`.\n\n**Example 1:**\n\n**Input:** tops = \\[2,1,2,4,2,2\\], bottoms = \\[5,2,6,2,3,2\\]\n**Output:** 2\n**Explanation:** \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n\n**Example 2:**\n\n**Input:** tops = \\[3,5,1,2,3\\], bottoms = \\[3,6,3,3,4\\]\n**Output:** -1\n**Explanation:** \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n\n**Constraints:**\n\n*   `2 <= tops.length <= 2 * 104`\n*   `bottoms.length == tops.length`\n*   `1 <= tops[i], bottoms[i] <= 6`\"\"\"\n\n    result = []\n    if n == 1: result.append(0)\n\n    def dfs(current):\n        if len(current) == n:\n            result.append(int(current))\n            return\n\n        last_digit = current[-1]\n        if last_digit - k >= 0: dfs(current + str(last_digit - k))\n        if k != 0 and last_digit + k <= 9: dfs(current + str(last_digit + k))\n\n    for i in range(1, 10):\n        dfs(str(i))\n\n    return result"}}, "leetcode/leetcode_2037.txt": {"score": 0.9339796900749207, "content": {"text": "def count_square_triples(n):\n    \"\"\"There are `n` seats and `n` students in a room. You are given an array `seats` of length `n`, where `seats[i]` is the position of the `ith` seat. You are also given the array `students` of length `n`, where `students[j]` is the position of the `jth` student.\n\nYou may perform the following move any number of times:\n\n*   Increase or decrease the position of the `ith` student by `1` (i.e., moving the `ith` student from position `x` to `x + 1` or `x - 1`)\n\nReturn _the **minimum number of moves** required to move each student to a seat_ _such that no two students are in the same seat._\n\nNote that there may be **multiple** seats or students in the **same** position at the beginning.\n\n**Example 1:**\n\n**Input:** seats = \\[3,1,5\\], students = \\[2,7,4\\]\n**Output:** 4\n**Explanation:** The students are moved as follows:\n- The first student is moved from from position 2 to position 1 using 1 move.\n- The second student is moved from from position 7 to position 5 using 2 moves.\n- The third student is moved from from position 4 to position 3 using 1 move.\nIn total, 1 + 2 + 1 = 4 moves were used.\n\n**Example 2:**\n\n**Input:** seats = \\[4,1,5,9\\], students = \\[1,3,2,6\\]\n**Output:** 7\n**Explanation:** The students are moved as follows:\n- The first student is not moved.\n- The second student is moved from from position 3 to position 4 using 1 move.\n- The third student is moved from from position 2 to position 5 using 3 moves.\n- The fourth student is moved from from position 6 to position 9 using 3 moves.\nIn total, 0 + 1 + 3 + 3 = 7 moves were used.\n\n**Example 3:**\n\n**Input:** seats = \\[2,2,6,6\\], students = \\[1,3,2,6\\]\n**Output:** 4\n**Explanation:** Note that there are two seats at position 2 and two seats at position 6.\nThe students are moved as follows:\n- The first student is moved from from position 1 to position 2 using 1 move.\n- The second student is moved from from position 3 to position 6 using 3 moves.\n- The third student is not moved.\n- The fourth student is not moved.\nIn total, 1 + 3 + 0 + 0 = 4 moves were used.\n\n**Constraints:**\n\n*   `n == seats.length == students.length`\n*   `1 <= n <= 100`\n*   `1 <= seats[i], students[j] <= 100`\"\"\"\n\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = int((a * a + b * b)**0.5)\n            if c * c == a * a + b * b and c <= n:\n                count += 1\n    return count"}}, "leetcode/leetcode_1703.txt": {"score": 0.9411280155181885, "content": {"text": "def minMoves(nums, k):\n    \"\"\"You are given an integer array, `nums`, and an integer `k`. `nums` comprises of only `0`'s and `1`'s. In one move, you can choose two **adjacent** indices and swap their values.\n\nReturn _the **minimum** number of moves required so that_ `nums` _has_ `k` _**consecutive**_ `1`_'s_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,0,0,1,0,1\\], k = 2\n**Output:** 1\n**Explanation:** In 1 move, nums could be \\[1,0,0,0,1,1\\] and have 2 consecutive 1's.\n\n**Example 2:**\n\n**Input:** nums = \\[1,0,0,0,0,0,1,1\\], k = 3\n**Output:** 5\n**Explanation:** In 5 moves, the leftmost 1 can be shifted right until nums = \\[0,0,0,0,0,1,1,1\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,0,1\\], k = 2\n**Output:** 0\n**Explanation:** nums already has 2 consecutive 1's.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is `0` or `1`.\n*   `1 <= k <= sum(nums)`\"\"\"\n\n    ones_pos = [i for i, x in enumerate(nums) if x == 1]\n    to_move = [i_b - i_a for i_a, i_b in zip(range(k), ones_pos)]\n    min_moves = sum(to_move[k // 2:])\n    move = min_moves\n    for left, right in zip(\n        to_move[:-k],       # left \"window\" of k-sized sliding window\n        to_move[k // 2 + 1:],  # right \"window\" of k-sized sliding window\n    ):\n        move += left - right\n        min_moves = min(min_moves, move)\n    return min_moves"}}, "leetcode/leetcode_801.txt": {"score": 0.9303563833236694, "content": {"text": "from collections import deque\n    \"\"\"You are given two integer arrays of the same length `nums1` and `nums2`. In one operation, you are allowed to swap `nums1[i]` with `nums2[i]`.\n\n*   For example, if `nums1 = [1,2,3,8]`, and `nums2 = [5,6,7,4]`, you can swap the element at `i = 3` to obtain `nums1 = [1,2,3,4]` and `nums2 = [5,6,7,8]`.\n\nReturn _the minimum number of needed operations to make_ `nums1` _and_ `nums2` _**strictly increasing**_. The test cases are generated so that the given input always makes it possible.\n\nAn array `arr` is **strictly increasing** if and only if `arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1]`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,3,5,4\\], nums2 = \\[1,2,3,7\\]\n**Output:** 1\n**Explanation:** \nSwap nums1\\[3\\] and nums2\\[3\\]. Then the sequences are:\nnums1 = \\[1, 3, 5, 7\\] and nums2 = \\[1, 2, 3, 4\\]\nwhich are both strictly increasing.\n\n**Example 2:**\n\n**Input:** nums1 = \\[0,3,5,8,9\\], nums2 = \\[2,1,4,6,9\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `2 <= nums1.length <= 105`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 2 * 105`\"\"\"\n\n\ndef isBipartite(graph):\n    colors = [0] * len(graph)\n    for i in range(len(graph)):\n        if colors[i] != 0:\n            continue\n        colors[i] = 1\n        queue = deque([i])\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if colors[neighbor] == 0:\n                    colors[neighbor] = -colors[node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[node]:\n                    return False\n    return True"}}, "leetcode/leetcode_1217.txt": {"score": 0.9350822567939758, "content": {"text": "def sort_array(arr1, arr2):\n    \"\"\"We have `n` chips, where the position of the `ith` chip is `position[i]`.\n\nWe need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:\n\n*   `position[i] + 2` or `position[i] - 2` with `cost = 0`.\n*   `position[i] + 1` or `position[i] - 1` with `cost = 1`.\n\nReturn _the minimum cost_ needed to move all the chips to the same position.\n\n**Example 1:**\n\n**Input:** position = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n**Example 2:**\n\n**Input:** position = \\[2,2,2,3,3\\]\n**Output:** 2\n**Explanation:** We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n**Example 3:**\n\n**Input:** position = \\[1,1000000000\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= position.length <= 100`\n*   `1 <= position[i] <= 10^9`\"\"\"\n\n    counts = {}\n    result = []\n\n    for num in arr1:\n        counts[num] = counts.get(num, 0) + 1\n\n    for num in arr2:\n        if num in counts:\n            result.extend([num] * counts[num])\n            del counts[num]\n\n    for num in sorted(counts.keys()):\n        result.extend([num] * counts[num])\n\n    return result"}}, "leetcode/leetcode_1864.txt": {"score": 0.9382402896881104, "content": {"text": "def minSwaps(s):\n    \"\"\"Given a binary string `s`, return _the **minimum** number of character swaps to make it **alternating**, or_ `-1` _if it is impossible._\n\nThe string is called **alternating** if no two adjacent characters are equal. For example, the strings `\"010 \"` and `\"1010 \"` are alternating, while the string `\"0100 \"` is not.\n\nAny two characters may be swapped, even if they are **not adjacent**.\n\n**Example 1:**\n\n**Input:** s =  \"111000 \"\n**Output:** 1\n**Explanation:** Swap positions 1 and 4:  \"111000 \" ->  \"101010 \"\nThe string is now alternating.\n\n**Example 2:**\n\n**Input:** s =  \"010 \"\n**Output:** 0\n**Explanation:** The string is already alternating, no swaps are needed.\n\n**Example 3:**\n\n**Input:** s =  \"1110 \"\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'0'` or `'1'`.\"\"\"\n\n    zeroCount = s.count('0')\n    oneCount = len(s) - zeroCount\n\n    if abs(zeroCount - oneCount) > 1:\n        return -1\n\n    swaps1 = swaps2 = 0\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '0':\n            swaps1 += 1\n        if i % 2 == 1 and c != '1':\n            swaps1 += 1\n    swaps1 = swaps1 // 2\n\n    for i, c in enumerate(s):\n        if i % 2 == 0 and c != '1':\n            swaps2 += 1\n        if i % 2 == 1 and c != '0':\n            swaps2 += 1\n    swaps2 = swaps2 // 2\n\n    if zeroCount == oneCount:\n        return min(swaps1, swaps2)\n    return swaps2 if zeroCount > oneCount else swaps1"}}, "leetcode/leetcode_2499.txt": {"score": 0.9436984658241272, "content": {"text": "def min_cost(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"You are given two **0-indexed** integer arrays `nums1` and `nums2`, of equal length `n`.\n\nIn one operation, you can swap the values of any two indices of `nums1`. The **cost** of this operation is the **sum** of the indices.\n\nFind the **minimum** total cost of performing the given operation **any** number of times such that `nums1[i] != nums2[i]` for all `0 <= i <= n - 1` after performing all the operations.\n\nReturn _the **minimum total cost** such that_ `nums1` and `nums2` _satisfy the above condition_. In case it is not possible, return `-1`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[1,2,3,4,5\\]\n**Output:** 10\n**Explanation:** \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = \\[4,2,3,1,5\\]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = \\[4,3,2,1,5\\].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =\\[5,3,2,1,4\\].\nWe can see that for each index i, nums1\\[i\\] != nums2\\[i\\]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.\n\n**Example 2:**\n\n**Input:** nums1 = \\[2,2,2,1,3\\], nums2 = \\[1,2,2,3,3\\]\n**Output:** 10\n**Explanation:** \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = \\[2,2,1,2,3\\].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = \\[2,3,1,2,2\\].\nThe total cost needed here is 10, which is the minimum possible.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,2\\], nums2 = \\[1,2,2\\]\n**Output:** -1\n**Explanation:** \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1.\n\n**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `1 <= nums1[i], nums2[i] <= n`\"\"\"\n\n    value_to_indices = {}\n    for i, val in enumerate(nums1):\n        value_to_indices.setdefault(val, []).append(i)\n\n    result = 0\n    for val in nums2:\n        if not value_to_indices[val]:\n            return -1\n        result += value_to_indices[val].pop()\n\n    return result"}}, "leetcode/leetcode_517.txt": {"score": 0.9445213675498962, "content": {"text": "def find_min_moves(machines):\n    \"\"\"You have `n` super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n\nFor each move, you could choose any `m` (`1 <= m <= n`) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n\nGiven an integer array `machines` representing the number of dresses in each washing machine from left to right on the line, return _the minimum number of moves to make all the washing machines have the same number of dresses_. If it is not possible to do it, return `-1`.\n\n**Example 1:**\n\n**Input:** machines = \\[1,0,5\\]\n**Output:** 3\n**Explanation:**\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\n**Example 2:**\n\n**Input:** machines = \\[0,3,0\\]\n**Output:** 2\n**Explanation:**\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\n**Example 3:**\n\n**Input:** machines = \\[0,2,0\\]\n**Output:** -1\n**Explanation:**\nIt's impossible to make all three washing machines have the same number of dresses.\n\n**Constraints:**\n\n*   `n == machines.length`\n*   `1 <= n <= 104`\n*   `0 <= machines[i] <= 105`\"\"\"\n\n    n = len(machines)\n    total_dresses = sum(machines)\n    if total_dresses % n != 0:\n        return -1\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n    \n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n        \n    return moves"}}, "leetcode/leetcode_765.txt": {"score": 0.9925259947776794, "content": {"text": "def minSwapsCouples(row):\n    \"\"\"There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands.\n\nThe people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats.\n\n**Example 1:**\n\n**Input:** row = \\[0,2,1,3\\]\n**Output:** 1\n**Explanation:** We only need to swap the second (row\\[1\\]) and third (row\\[2\\]) person.\n\n**Example 2:**\n\n**Input:** row = \\[3,2,0,1\\]\n**Output:** 0\n**Explanation:** All couples are already seated side by side.\n\n**Constraints:**\n\n*   `2n == row.length`\n*   `2 <= n <= 30`\n*   `n` is even.\n*   `0 <= row[i] < 2n`\n*   All the elements of `row` are **unique**.\"\"\"\n\n    n = len(row)\n    position = [0] * n\n    for i in range(n):\n        position[row[i]] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1\n        if row[i + 1] != partner:\n            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]\n            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]\n            swaps += 1\n    return swaps"}}}}, "39": {"gold": {"leetcode/leetcode_1631.txt": 1}, "retrieved": {"leetcode/leetcode_2477.txt": {"score": 0.9084348678588867, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of `n` cities numbered from `0` to `n - 1` and exactly `n - 1` roads. The capital city is city `0`. You are given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a **bidirectional road** connecting cities `ai` and `bi`.\n\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\n\nThere is a car in each city. You are given an integer `seats` that indicates the number of seats in each car.\n\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\n\nReturn _the minimum number of liters of fuel to reach the capital city_.\n\n**Example 1:**\n\n**Input:** roads = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\]\\], seats = 5\n**Output:** 3\n**Explanation:** \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\n**Example 2:**\n\n**Input:** roads = \\[\\[3,1\\],\\[3,2\\],\\[1,0\\],\\[0,4\\],\\[0,5\\],\\[4,6\\]\\], seats = 2\n**Output:** 7\n**Explanation:** \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\n**Example 3:**\n\n**Input:** roads = \\[\\], seats = 1\n**Output:** 0\n**Explanation:** No representatives need to travel to the capital city.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `roads.length == n - 1`\n*   `roads[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `roads` represents a valid tree.\n*   `1 <= seats <= 105`\"\"\"\n\n\n\ndef min_fuel(roads, seats):\n    n = len(roads) + 1\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n\n    distance = [-1] * n\n    q = deque([0])\n    distance[0] = 0\n\n    while q:\n        city = q.popleft()\n        for neighbor in graph[city]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[city] + 1\n                q.append(neighbor)\n\n    total_fuel = 0\n    for city in range(1, n):\n        total_fuel += (distance[city] - 1) // (seats - 1) + 1\n    return total_fuel"}}, "leetcode/leetcode_1631.txt": {"score": 0.9095445871353149, "content": {"text": "def numOfSubarrays(arr):\n    \"\"\"You are a hiker preparing for an upcoming hike. You are given `heights`, a 2D array of size `rows x columns`, where `heights[row][col]` represents the height of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`, and you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e., **0-indexed**). You can move **up**, **down**, **left**, or **right**, and you wish to find a route that requires the minimum **effort**.\n\nA route's **effort** is the **maximum absolute difference** in heights between two consecutive cells of the route.\n\nReturn _the minimum **effort** required to travel from the top-left cell to the bottom-right cell._\n\n**Example 1:**\n\n**Input:** heights = \\[\\[1,2,2\\],\\[3,8,2\\],\\[5,3,5\\]\\]\n**Output:** 2\n**Explanation:** The route of \\[1,3,5,3,5\\] has a maximum absolute difference of 2 in consecutive cells.\nThis is better than the route of \\[1,2,2,2,5\\], where the maximum absolute difference is 3.\n\n**Example 2:**\n\n**Input:** heights = \\[\\[1,2,3\\],\\[3,8,4\\],\\[5,3,5\\]\\]\n**Output:** 1\n**Explanation:** The route of \\[1,2,3,4,5\\] has a maximum absolute difference of 1 in consecutive cells, which is better than route \\[1,3,5,3,5\\].\n\n**Example 3:**\n\n**Input:** heights = \\[\\[1,2,1,1,1\\],\\[1,2,1,2,1\\],\\[1,2,1,2,1\\],\\[1,2,1,2,1\\],\\[1,1,1,2,1\\]\\]\n**Output:** 0\n**Explanation:** This route does not require any effort.\n\n**Constraints:**\n\n*   `rows == heights.length`\n*   `columns == heights[i].length`\n*   `1 <= rows, columns <= 100`\n*   `1 <= heights[i][j] <= 106`\"\"\"\n\n    odd, even, sum_, result = 0, 1, 0, 0\n    mod = 10**9 + 7\n    for x in arr:\n        sum_ = (sum_ + x) % 2\n        if sum_ % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n        result = (result + odd) % mod\n    return result"}}, "leetcode/leetcode_1494.txt": {"score": 0.914359986782074, "content": {"text": "from collections import deque\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`.\n\nIn one semester, you can take **at most** `k` courses as long as you have taken all the prerequisites in the **previous** semesters for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course.\n\n**Example 1:**\n\n**Input:** n = 4, relations = \\[\\[2,1\\],\\[3,1\\],\\[1,4\\]\\], k = 2\n**Output:** 3\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[2,1\\],\\[3,1\\],\\[4,1\\],\\[1,5\\]\\], k = 2\n**Output:** 4\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5.\n\n**Constraints:**\n\n*   `1 <= n <= 15`\n*   `1 <= k <= n`\n*   `0 <= relations.length <= n * (n-1) / 2`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.\n*   The given graph is a directed acyclic graph.\"\"\"\n\n\ndef minNumberOfSemesters(n, relations, k):\n    indegree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev_course, next_course in relations:\n        graph[prev_course].append(next_course)\n        indegree[next_course] += 1\n\n    semesters = 0\n    while n > 0:\n        zero_indegree = deque()\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                zero_indegree.append(i)\n                indegree[i] = -1\n\n        courses = 0\n        while zero_indegree and courses < k:\n            curr_course = zero_indegree.popleft()\n            n -= 1\n\n            for next_course in graph[curr_course]:\n                indegree[next_course] -= 1\n            courses += 1\n        semesters += 1\n    return semesters"}}, "leetcode/leetcode_675.txt": {"score": 0.9116024374961853, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:\n\n*   `0` means the cell cannot be walked through.\n*   `1` represents an empty cell that can be walked through.\n*   A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).\n\nStarting from the point `(0, 0)`, return _the minimum steps you need to walk to cut off all the trees_. If you cannot cut off all the trees, return `-1`.\n\n**Note:** The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n**Example 1:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,4\\],\\[7,6,5\\]\\]\n**Output:** 6\n**Explanation:** Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n**Example 2:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,0\\],\\[7,6,5\\]\\]\n**Output:** -1\n**Explanation:** The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n**Example 3:**\n\n**Input:** forest = \\[\\[2,3,4\\],\\[0,0,5\\],\\[8,7,6\\]\\]\n**Output:** 6\n**Explanation:** You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n\n**Constraints:**\n\n*   `m == forest.length`\n*   `n == forest[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= forest[i][j] <= 109`\n*   Heights of all trees are **distinct**.\"\"\"\n\nfrom collections import deque\n\ndef cutOffTree(forest: List[List[int]]) -> int:\n    if not forest or not forest[0]: return 0\n    m, n = len(forest), len(forest[0])\n    trees = []\n    \n    for i in range(m):\n        for j in range(n):\n            if forest[i][j] > 1:\n                heappush(trees, (forest[i][j], i, j))\n    \n    startX, startY = 0, 0\n    totalSteps = 0\n    while trees:\n        tree, endX, endY = heappop(trees)\n        steps = bfs(forest, startX, startY, endX, endY)\n        if steps == -1:\n            return -1\n        totalSteps += steps\n        startX, startY = endX, endY\n    \n    return totalSteps\n\ndef bfs(forest, startX, startY, endX, endY):\n    if startX == endX and startY == endY:\n        return 0\n        \n    m, n = len(forest), len(forest[0])\n    visited = [[False] * n for _ in range(m)]\n    q = deque([(startX, startY, 0)])\n    visited[startX][startY] = True\n    dirs = [-1, 0, 1, 0, -1]\n    \n    while q:\n        x, y, steps = q.popleft()\n        for k in range(4):\n            newX, newY = x + dirs[k], y + dirs[k+1]\n            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:\n                if newX == endX and newY == endY:\n                    return steps + 1\n                q.append((newX, newY, steps + 1))\n                visited[newX][newY] = True\n    \n    return -1"}}, "leetcode/leetcode_542.txt": {"score": 0.9173990488052368, "content": {"text": "from collections import deque\n    \"\"\"Given an `m x n` binary matrix `mat`, return _the distance of the nearest_ `0` _for each cell_.\n\nThe distance between two adjacent cells is `1`.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n\n**Example 2:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,2,1\\]\\]\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 104`\n*   `1 <= m * n <= 104`\n*   `mat[i][j]` is either `0` or `1`.\n*   There is at least one `0` in `mat`.\"\"\"\n\n\ndef updateMatrix(mat):\n    m, n = len(mat), len(mat[0])\n    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]\n    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            newX, newY = x + dx, y + dy\n            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:\n                distance[newX][newY] = distance[x][y] + 1\n                queue.append((newX, newY))\n\n    return distance"}}, "leetcode/leetcode_2577.txt": {"score": 0.9457049369812012, "content": {"text": "from collections import deque\n    \"\"\"You are given a `m x n` matrix `grid` consisting of **non-negative** integers where `grid[row][col]` represents the **minimum** time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.\n\nYou are standing in the **top-left** cell of the matrix in the `0th` second, and you must move to **any** adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\nReturn _the **minimum** time required in which you can visit the bottom-right cell of the matrix_. If you cannot visit the bottom-right cell, then return `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,3,2\\],\\[5,1,2,5\\],\\[4,3,8,6\\]\\]\n**Output:** 7\n**Explanation:** One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid\\[0\\]\\[1\\] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid\\[1\\]\\[3\\] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid\\[2\\]\\[3\\] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,2,4\\],\\[3,2,1\\],\\[1,0,4\\]\\]\n**Output:** -1\n**Explanation:** There is no path from the top left to the bottom-right cell.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 1000`\n*   `4 <= m * n <= 105`\n*   `0 <= grid[i][j] <= 105`\n*   `grid[0][0] == 0`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n\ndef minTime(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    visited = [[1000000] * n for _ in range(m)]\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    visited[0][0] = 0\n\n    q = deque([(0, 0)])\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n\n            if 0 <= nx < m and 0 <= ny < n:\n                t = max(grid[nx][ny], visited[x][y] + 1)\n                if visited[nx][ny] > t:\n                    visited[nx][ny] = t\n                    q.append((nx, ny))\n\n    return visited[m - 1][n - 1] if visited[m - 1][n - 1] != 1000000 else -1"}}, "leetcode/leetcode_2050.txt": {"score": 0.9178214073181152, "content": {"text": "def count_good_digit_strings(n):\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.\"\"\"\n\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total"}}, "leetcode/leetcode_778.txt": {"score": 0.9967285990715027, "content": {"text": "import heapq\n    \"\"\"You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.\n\nThe rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nReturn _the least time until you can reach the bottom right square_ `(n - 1, n - 1)` _if you start at the top left square_ `(0, 0)`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2\\],\\[1,3\\]\\]\n**Output:** 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,2,3,4\\],\\[24,23,22,21,5\\],\\[12,13,14,15,16\\],\\[11,17,18,19,20\\],\\[10,9,8,7,6\\]\\]\n**Output:** 16\n**Explanation:** The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] < n2`\n*   Each value `grid[i][j]` is **unique**.\"\"\"\n\n\ndef rearrange_string(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    \n    pq = [(-count, char) for char, count in counts.items()]\n    heapq.heapify(pq)\n    \n    result = []\n    previous = (0, '')\n    \n    while pq:\n        count, char = heapq.heappop(pq)\n        result.append(char)\n        \n        if previous[0] < 0:\n            heapq.heappush(pq, previous)\n        \n        count += 1\n        previous = (count, char)\n    \n    result_str = ''.join(result)\n    return result_str if len(result_str) == len(s) else \"\""}}, "leetcode/leetcode_1824.txt": {"score": 0.920975923538208, "content": {"text": "import heapq\n    \"\"\"There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** lane and wants to jump to point `n`. However, there could be obstacles along the way.\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n*   For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n*   For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn _the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n**Example 1:**\n\n**Input:** obstacles = \\[0,1,2,3,0\\]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n**Example 2:**\n\n**Input:** obstacles = \\[0,1,1,3,3,0\\]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n**Example 3:**\n\n**Input:** obstacles = \\[0,2,1,0,3,0\\]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n**Constraints:**\n\n*   `obstacles.length == n + 1`\n*   `1 <= n <= 5 * 105`\n*   `0 <= obstacles[i] <= 3`\n*   `obstacles[0] == obstacles[n] == 0`\"\"\"\n\n\ndef eatenApples(apples, days):\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans"}}, "leetcode/leetcode_2045.txt": {"score": 0.9306051731109619, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"A city is represented as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from **green** to **red** and vice versa every `change` minutes. All signals change **at the same time**. You can enter a vertex at **any time**, but can leave a vertex **only when the signal is green**. You **cannot wait** at a vertex if the signal is **green**.\n\nThe **second minimum value** is defined as the smallest value **strictly larger** than the minimum value.\n\n*   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return _the **second minimum time** it will take to go from vertex_ `1` _to vertex_ `n`.\n\n**Notes:**\n\n*   You can go through any vertex **any** number of times, **including** `1` and `n`.\n*   You can assume that when the journey **starts**, all signals have just turned **green**.\n\n**Example 1:**\n\n\u2003 \u2003 \u2003 \u2003\n\n**Input:** n = 5, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[3,4\\],\\[4,5\\]\\], time = 3, change = 5\n**Output:** 13\n**Explanation:**\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\], time = 3, change = 2\n**Output:** 11\n**Explanation:**\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n**Constraints:**\n\n*   `2 <= n <= 104`\n*   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each vertex can be reached directly or indirectly from every other vertex.\n*   `1 <= time, change <= 103`\"\"\"\n\n\ndef secondMinimum(n, edges, time, change):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dist = [float('inf')] * (n + 1)\n    dist2 = [float('inf')] * (n + 1)\n    dist[1] = 0\n\n    q = deque([1])\n\n    while q:\n        cur = q.popleft()\n\n        nextDist = dist[cur] + time\n        waitTime = change if (nextDist // change) % 2 == 1 else 0\n        nextDist += waitTime\n\n        for next in graph[cur]:\n            if nextDist < dist[next]:\n                nextDist, dist[next] = dist[next], nextDist\n                q.append(next)\n            if nextDist < dist2[next]:\n                nextDist, dist2[next] = dist2[next], nextDist\n                q.append(next)\n\n    return dist2[n]"}}}}, "40": {"gold": {"leetcode/leetcode_976.txt": 1}, "retrieved": {"leetcode/leetcode_1453.txt": {"score": 0.8621279001235962, "content": {"text": "def numPoints(darts, r):\n    \"\"\"Alice is throwing `n` darts on a very large wall. You are given an array `darts` where `darts[i] = [xi, yi]` is the position of the `ith` dart that Alice threw on the wall.\n\nBob knows the positions of the `n` darts on the wall. He wants to place a dartboard of radius `r` on the wall so that the maximum number of darts that Alice throws lies on the dartboard.\n\nGiven the integer `r`, return _the maximum number of darts that can lie on the dartboard_.\n\n**Example 1:**\n\n**Input:** darts = \\[\\[-2,0\\],\\[2,0\\],\\[0,2\\],\\[0,-2\\]\\], r = 2\n**Output:** 4\n**Explanation:** Circle dartboard with center in (0,0) and radius = 2 contain all points.\n\n**Example 2:**\n\n**Input:** darts = \\[\\[-3,0\\],\\[3,0\\],\\[2,6\\],\\[5,4\\],\\[0,9\\],\\[7,8\\]\\], r = 5\n**Output:** 5\n**Explanation:** Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n\n**Constraints:**\n\n*   `1 <= darts.length <= 100`\n*   `darts[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `darts` are unique\n*   `1 <= r <= 5000`\"\"\"\n\n    n = len(darts)\n    result = 1\n    \n    for i in range(n):\n        for j in range(n):\n            cnt = 0\n            for k in range(n):\n                dx = darts[i][0] - darts[k][0]\n                dy = darts[i][1] - darts[k][1]\n                if (dx * dx + dy * dy) ** 0.5 <= r:\n                    cnt += 1\n                    \n            if cnt > result:\n                result = cnt\n                \n    return result"}}, "leetcode/csn_python_train_368756.txt": {"score": 0.8650119304656982, "content": {"text": "def triangle_area(pt1, pt2, pt3):\n    r\"\"\"Return the area of a triangle.\n\n    Parameters\n    ----------\n    pt1: (X,Y) ndarray\n        Starting vertex of a triangle\n    pt2: (X,Y) ndarray\n        Second vertex of a triangle\n    pt3: (X,Y) ndarray\n        Ending vertex of a triangle\n\n    Returns\n    -------\n    area: float\n        Area of the given triangle.\n\n    \"\"\"\n    a = 0.0\n\n    a += pt1[0] * pt2[1] - pt2[0] * pt1[1]\n    a += pt2[0] * pt3[1] - pt3[0] * pt2[1]\n    a += pt3[0] * pt1[1] - pt1[0] * pt3[1]\n\n    return abs(a) / 2"}}, "leetcode/leetcode_593.txt": {"score": 0.8696615099906921, "content": {"text": "def validSquare(p1, p2, p3, p4):\n    \"\"\"Given the coordinates of four points in 2D space `p1`, `p2`, `p3` and `p4`, return `true` _if the four points construct a square_.\n\nThe coordinate of a point `pi` is represented as `[xi, yi]`. The input is **not** given in any order.\n\nA **valid square** has four equal sides with positive length and four equal angles (90-degree angles).\n\n**Example 1:**\n\n**Input:** p1 = \\[0,0\\], p2 = \\[1,1\\], p3 = \\[1,0\\], p4 = \\[0,1\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** p1 = \\[0,0\\], p2 = \\[1,1\\], p3 = \\[1,0\\], p4 = \\[0,12\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** p1 = \\[1,0\\], p2 = \\[-1,0\\], p3 = \\[0,1\\], p4 = \\[0,-1\\]\n**Output:** true\n\n**Constraints:**\n\n*   `p1.length == p2.length == p3.length == p4.length == 2`\n*   `-104 <= xi, yi <= 104`\"\"\"\n\n    def dist_sq(p, q):\n        return (p[0] - q[0])**2 + (p[1] - q[1])**2\n\n    points = [p1, p2, p3, p4]\n    dists = set()\n\n    for i in range(4):\n        for j in range(i + 1, 4):\n            dists.add(dist_sq(points[i], points[j]))\n\n    return len(dists) == 2 and 0 not in dists"}}, "leetcode/csn_python_train_320957.txt": {"score": 0.8688673973083496, "content": {"text": "def rectangles_from_points(S):\n    \"\"\"How many rectangles can be formed from a set of points\n\n    :param S: list of points, as coordinate pairs\n    :returns: the number of rectangles\n    :complexity: :math:`O(n^2)`\n    \"\"\"\n    answ = 0\n    pairs = {}\n    for j in range(len(S)):\n        for i in range(j):\n            px, py = S[i]\n            qx, qy = S[j]\n            center = (px + qx, py + qy)\n            dist = (px - qx) ** 2 + (py - qy) ** 2\n            sign = (center, dist)\n            if sign in pairs:\n                answ += len(pairs[sign])\n                pairs[sign].append((i, j))\n            else:\n                pairs[sign] = [(i, j)]\n    return answ"}}, "leetcode/leetcode_963.txt": {"score": 0.9188275933265686, "content": {"text": "def find_same_binary_value_parts(arr):\n    \"\"\"You are given an array of points in the **X-Y** plane `points` where `points[i] = [xi, yi]`.\n\nReturn _the minimum area of any rectangle formed from these points, with sides **not necessarily parallel** to the X and Y axes_. If there is not any such rectangle, return `0`.\n\nAnswers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,2\\],\\[2,1\\],\\[1,0\\],\\[0,1\\]\\]\n**Output:** 2.00000\n**Explanation:** The minimum area rectangle occurs at \\[1,2\\],\\[2,1\\],\\[1,0\\],\\[0,1\\], with an area of 2.\n\n**Example 2:**\n\n**Input:** points = \\[\\[0,1\\],\\[2,1\\],\\[1,1\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:** 1.00000\n**Explanation:** The minimum area rectangle occurs at \\[1,0\\],\\[1,1\\],\\[2,1\\],\\[2,0\\], with an area of 1.\n\n**Example 3:**\n\n**Input:** points = \\[\\[0,3\\],\\[1,2\\],\\[3,1\\],\\[1,3\\],\\[2,1\\]\\]\n**Output:** 0\n**Explanation:** There is no possible rectangle to form from these points.\n\n**Constraints:**\n\n*   `1 <= points.length <= 50`\n*   `points[i].length == 2`\n*   `0 <= xi, yi <= 4 * 104`\n*   All the given points are **unique**.\"\"\"\n\n    ones = sum(arr)\n\n    if ones % 3 != 0:\n        return [-1, -1]\n\n    target = ones // 3\n    if target == 0:\n        return [0, len(arr) - 2]\n\n    count = 0\n    i = j = -1\n    ones = 0\n    for idx, n in enumerate(arr):\n        if n == 1:\n            ones += 1\n            if ones == target + 1:\n                count += 1\n            if count == 1 and i == -1:\n                i = idx\n            if count == 2 and j == -1:\n                j = idx\n            if count == 3:\n                break\n\n    return [i, j]"}}, "leetcode/csn_python_train_59778.txt": {"score": 0.8823529481887817, "content": {"text": "def triangle_area(a,b,c):\n    '''\n    triangle_area(a, b, c) yields the area of the triangle whose vertices are given by the points a,\n    b, and c.\n    '''\n    (a,b,c) = [np.asarray(x) for x in (a,b,c)]\n    sides = np.sqrt(np.sum([(p1 - p2)**2 for (p1,p2) in zip([b,c,a],[c,a,b])], axis=1))\n    s = 0.5 * np.sum(sides, axis=0)\n    s = np.clip(s * np.prod(s - sides, axis=0), 0.0, None)\n    return np.sqrt(s)"}}, "leetcode/csn_python_train_240152.txt": {"score": 0.8710546493530273, "content": {"text": "def triangle_area(e1, e2, e3):\n    \"\"\"\n    Get the area of triangle formed by three vectors.\n\n    Parameters are three three-dimensional numpy arrays representing\n    vectors of triangle's edges in Cartesian space.\n\n    :returns:\n        Float number, the area of the triangle in squared units of coordinates,\n        or numpy array of shape of edges with one dimension less.\n\n    Uses Heron formula, see http://mathworld.wolfram.com/HeronsFormula.html.\n    \"\"\"\n    # calculating edges length\n    e1_length = numpy.sqrt(numpy.sum(e1 * e1, axis=-1))\n    e2_length = numpy.sqrt(numpy.sum(e2 * e2, axis=-1))\n    e3_length = numpy.sqrt(numpy.sum(e3 * e3, axis=-1))\n    # calculating half perimeter\n    s = (e1_length + e2_length + e3_length) / 2.0\n    # applying Heron's formula\n    return numpy.sqrt(s * (s - e1_length) * (s - e2_length) * (s - e3_length))"}}, "leetcode/leetcode_812.txt": {"score": 0.9872980117797852, "content": {"text": "def is_shifted(s, goal):\n    \"\"\"Given an array of points on the **X-Y** plane `points` where `points[i] = [xi, yi]`, return _the area of the largest triangle that can be formed by any three different points_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[0,1\\],\\[1,0\\],\\[0,2\\],\\[2,0\\]\\]\n**Output:** 2.00000\n**Explanation:** The five points are shown in the above figure. The red triangle is the largest.\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,0\\],\\[0,0\\],\\[0,1\\]\\]\n**Output:** 0.50000\n\n**Constraints:**\n\n*   `3 <= points.length <= 50`\n*   `-50 <= xi, yi <= 50`\n*   All the given points are **unique**.\"\"\"\n\n    if len(s) != len(goal): return False\n\n    s = s + s\n    return goal in s"}}, "leetcode/csn_python_train_171863.txt": {"score": 0.8713673949241638, "content": {"text": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri"}}, "leetcode/leetcode_976.txt": {"score": 0.9306527376174927, "content": {"text": "def min_area_rect(points):\n    \"\"\"Given an integer array `nums`, return _the largest perimeter of a triangle with a non-zero area, formed from three of these lengths_. If it is impossible to form any triangle of a non-zero area, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,1,2\\]\n**Output:** 5\n**Explanation:** You can form a triangle with three side lengths: 1, 2, and 2.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,10\\]\n**Output:** 0\n**Explanation:** \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `1 <= nums[i] <= 106`\"\"\"\n\n    point_set = {(x, y) for x, y in points}\n    min_area = float('inf')\n\n    for p1 in point_set:\n        for p2 in point_set:\n            if p1[0] != p2[0] and p1[1] != p2[1]:\n                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n\n    return min_area if min_area != float('inf') else 0"}}}}, "41": {"gold": {"leetcode/leetcode_979.txt": 1, "leetcode/leetcode_2049.txt": 1, "leetcode/leetcode_2603.txt": 1}, "retrieved": {"leetcode/leetcode_1782.txt": {"score": 0.9092804193496704, "content": {"text": "def get_smallest_string(n: int, k: int) -> str:\n    \"\"\"You are given an undirected graph defined by an integer `n`, the number of nodes, and a 2D integer array `edges`, the edges in the graph, where `edges[i] = [ui, vi]` indicates that there is an **undirected** edge between `ui` and `vi`. You are also given an integer array `queries`.\n\nLet `incident(a, b)` be defined as the **number of edges** that are connected to **either** node `a` or `b`.\n\nThe answer to the `jth` query is the **number of pairs** of nodes `(a, b)` that satisfy **both** of the following conditions:\n\n*   `a < b`\n*   `incident(a, b) > queries[j]`\n\nReturn _an array_ `answers` _such that_ `answers.length == queries.length` _and_ `answers[j]` _is the answer of the_ `jth` _query_.\n\nNote that there can be **multiple edges** between the same two nodes.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,4\\],\\[1,3\\],\\[2,3\\],\\[2,1\\]\\], queries = \\[2,3\\]\n**Output:** \\[6,5\\]\n**Explanation:** The calculations for incident(a, b) are shown in the table above.\nThe answers for each of the queries are as follows:\n- answers\\[0\\] = 6. All the pairs have an incident(a, b) value greater than 2.\n- answers\\[1\\] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[1,5\\],\\[1,5\\],\\[3,4\\],\\[2,5\\],\\[1,3\\],\\[5,1\\],\\[2,3\\],\\[2,5\\]\\], queries = \\[1,2,3,4,5\\]\n**Output:** \\[10,10,9,8,6\\]\n\n**Constraints:**\n\n*   `2 <= n <= 2 * 104`\n*   `1 <= edges.length <= 105`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= queries.length <= 20`\n*   `0 <= queries[j] < edges.length`\"\"\"\n\n    result = ['a'] * n\n    k -= n\n    idx = n - 1\n    while k > 0:\n        value = min(k, 25)\n        result[idx] = chr(ord(result[idx]) + value)\n        k -= value\n        idx -= 1\n    return ''.join(result)"}}, "leetcode/leetcode_2603.txt": {"score": 0.9128957986831665, "content": {"text": "from collections import defaultdict\n    \"\"\"There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef min_edges_to_collect_coins(coins, edges):\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(adj, coins, 0, -1)[1] // 2\n\ndef dfs(adj, coins, node, parent):\n    sum_coins = coins[node]\n    distance = 0\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            result = dfs(adj, coins, neighbor, node)\n            sum_coins += result[0]\n            distance += 2 * result[0] + result[1]\n    return (sum_coins, distance)"}}, "leetcode/leetcode_1376.txt": {"score": 0.9150568842887878, "content": {"text": "def numOfMinutes(n, headID, manager, informTime):\n    \"\"\"A company has `n` employees with a unique ID for each employee from `0` to `n - 1`. The head of the company is the one with `headID`.\n\nEach employee has one direct manager given in the `manager` array where `manager[i]` is the direct manager of the `i-th` employee, `manager[headID] = -1`. Also, it is guaranteed that the subordination relationships have a tree structure.\n\nThe head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.\n\nThe `i-th` employee needs `informTime[i]` minutes to inform all of his direct subordinates (i.e., After informTime\\[i\\] minutes, all his direct subordinates can start spreading the news).\n\nReturn _the number of minutes_ needed to inform all the employees about the urgent news.\n\n**Example 1:**\n\n**Input:** n = 1, headID = 0, manager = \\[-1\\], informTime = \\[0\\]\n**Output:** 0\n**Explanation:** The head of the company is the only employee in the company.\n\n**Example 2:**\n\n**Input:** n = 6, headID = 2, manager = \\[2,2,-1,2,2,2\\], informTime = \\[0,0,1,0,0,0\\]\n**Output:** 1\n**Explanation:** The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\nThe tree structure of the employees in the company is shown.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `0 <= headID < n`\n*   `manager.length == n`\n*   `0 <= manager[i] < n`\n*   `manager[headID] == -1`\n*   `informTime.length == n`\n*   `0 <= informTime[i] <= 1000`\n*   `informTime[i] == 0` if employee `i` has no subordinates.\n*   It is **guaranteed** that all the employees can be informed.\"\"\"\n\n    subordinates = [[] for _ in range(n)]\n    for i in range(n):\n        if manager[i] != -1:\n            subordinates[manager[i]].append(i)\n    return dfs(headID, subordinates, informTime)\n\ndef dfs(employee, subordinates, informTime):\n    if informTime[employee] == 0:\n        return 0\n    max_time = 0\n    for i in subordinates[employee]:\n        max_time = max(max_time, dfs(i, subordinates, informTime))\n    return max_time + informTime[employee]"}}, "leetcode/leetcode_2322.txt": {"score": 0.9188808798789978, "content": {"text": "def dfs(node, parent, xor_values, tree):\n    \"\"\"There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nRemove two **distinct** edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n\n1.  Get the XOR of all the values of the nodes for **each** of the three components respectively.\n2.  The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair.\n\n*   For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = **6**`, `1 ^ 9 = **8**`, and `3 ^ 3 ^ 3 = **3**`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn _the **minimum** score of any possible pair of edge removals on the given tree_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,5,4,11\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\]\n**Output:** 9\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[1,3,4\\] with values \\[5,4,11\\]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2nd component has node \\[0\\] with value \\[1\\]. Its XOR value is 1 = 1.\n- The 3rd component has node \\[2\\] with value \\[5\\]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9.\n\n**Example 2:**\n\n**Input:** nums = \\[5,5,2,4,4,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[5,2\\],\\[4,3\\],\\[1,3\\]\\]\n**Output:** 0\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[3,4\\] with values \\[4,4\\]. Its XOR value is 4 ^ 4 = 0.\n- The 2nd component has nodes \\[1,0\\] with values \\[5,5\\]. Its XOR value is 5 ^ 5 = 0.\n- The 3rd component has nodes \\[2,5\\] with values \\[2,2\\]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `3 <= n <= 1000`\n*   `1 <= nums[i] <= 108`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n    xor_value = xor_values[node]\n    for child in tree[node]:\n        if child != parent:\n            xor_value ^= dfs(child, node, xor_values, tree)\n    return xor_value\n\n\ndef minimumScore(nums, edges):\n    n = len(nums)\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]\n    \n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor1 = xor_values[i]\n            xor2 = xor_values[j] ^ nums[i]\n            xor3 = nums[i] ^ nums[j]\n            max_xor = max(xor1, xor2, xor3)\n            min_xor = min(xor1, xor2, xor3)\n            ans = min(ans, max_xor - min_xor)\n    \n    return ans"}}, "leetcode/leetcode_2477.txt": {"score": 0.9270879626274109, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of `n` cities numbered from `0` to `n - 1` and exactly `n - 1` roads. The capital city is city `0`. You are given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a **bidirectional road** connecting cities `ai` and `bi`.\n\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\n\nThere is a car in each city. You are given an integer `seats` that indicates the number of seats in each car.\n\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\n\nReturn _the minimum number of liters of fuel to reach the capital city_.\n\n**Example 1:**\n\n**Input:** roads = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\]\\], seats = 5\n**Output:** 3\n**Explanation:** \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\n**Example 2:**\n\n**Input:** roads = \\[\\[3,1\\],\\[3,2\\],\\[1,0\\],\\[0,4\\],\\[0,5\\],\\[4,6\\]\\], seats = 2\n**Output:** 7\n**Explanation:** \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\n**Example 3:**\n\n**Input:** roads = \\[\\], seats = 1\n**Output:** 0\n**Explanation:** No representatives need to travel to the capital city.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `roads.length == n - 1`\n*   `roads[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `roads` represents a valid tree.\n*   `1 <= seats <= 105`\"\"\"\n\n\n\ndef min_fuel(roads, seats):\n    n = len(roads) + 1\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n\n    distance = [-1] * n\n    q = deque([0])\n    distance[0] = 0\n\n    while q:\n        city = q.popleft()\n        for neighbor in graph[city]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[city] + 1\n                q.append(neighbor)\n\n    total_fuel = 0\n    for city in range(1, n):\n        total_fuel += (distance[city] - 1) // (seats - 1) + 1\n    return total_fuel"}}, "leetcode/leetcode_1519.txt": {"score": 0.9273010492324829, "content": {"text": "def min_subsequence(nums):\n    \"\"\"You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` `edges`. The **root** of the tree is the node `0`, and each node of the tree has **a label** which is a lower-case character given in the string `labels` (i.e. The node with the number `i` has the label `labels[i]`).\n\nThe `edges` array is given on the form `edges[i] = [ai, bi]`, which means there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn _an array of size `n`_ where `ans[i]` is the number of nodes in the subtree of the `ith` node which have the same label as node `i`.\n\nA subtree of a tree `T` is the tree consisting of a node in `T` and all of its descendant nodes.\n\n**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,4\\],\\[1,5\\],\\[2,3\\],\\[2,6\\]\\], labels =  \"abaedcd \"\n**Output:** \\[2,1,1,1,1,1,1\\]\n**Explanation:** Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.\nNode 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).\n\n**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,3\\]\\], labels =  \"bbbb \"\n**Output:** \\[4,2,1,1\\]\n**Explanation:** The sub-tree of node 2 contains only node 2, so the answer is 1.\nThe sub-tree of node 3 contains only node 3, so the answer is 1.\nThe sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.\nThe sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.\n\n**Example 3:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[0,4\\]\\], labels =  \"aabab \"\n**Output:** \\[3,2,1,1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `labels.length == n`\n*   `labels` is consisting of only of lowercase English letters.\"\"\"\n\n    nums.sort(reverse=True)\n    total_sum, current_sum = sum(nums), 0\n    result = []\n    for num in nums:\n        current_sum += num\n        result.append(num)\n        if current_sum > total_sum - current_sum:\n            break\n    return result"}}, "leetcode/leetcode_2509.txt": {"score": 0.9187963604927063, "content": {"text": "def length_of_cycle(n, queries):\n    \"\"\"You are given an integer `n`. There is a **complete binary tree** with `2n - 1` nodes. The root of that tree is the node with the value `1`, and every node with a value `val` in the range `[1, 2n - 1 - 1]` has two children where:\n\n*   The left node has the value `2 * val`, and\n*   The right node has the value `2 * val + 1`.\n\nYou are also given a 2D integer array `queries` of length `m`, where `queries[i] = [ai, bi]`. For each query, solve the following problem:\n\n1.  Add an edge between the nodes with values `ai` and `bi`.\n2.  Find the length of the cycle in the graph.\n3.  Remove the added edge between nodes with values `ai` and `bi`.\n\n**Note** that:\n\n*   A **cycle** is a path that starts and ends at the same node, and each edge in the path is visited only once.\n*   The length of a cycle is the number of edges visited in the cycle.\n*   There could be multiple edges between two nodes in the tree after adding the edge of the query.\n\nReturn _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is the answer to the_ `ith` _query._\n\n**Example 1:**\n\n**Input:** n = 3, queries = \\[\\[5,3\\],\\[4,7\\],\\[2,3\\]\\]\n**Output:** \\[4,5,3\\]\n**Explanation:** The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes \\[5,2,1,3\\]. Thus answer to the first query is 4. We delete the added edge and process the next query.\n- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes \\[4,2,1,3,7\\]. Thus answer to the second query is 5. We delete the added edge and process the next query.\n- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes \\[2,1,3\\]. Thus answer to the third query is 3. We delete the added edge.\n\n**Example 2:**\n\n**Input:** n = 2, queries = \\[\\[1,2\\]\\]\n**Output:** \\[2\\]\n**Explanation:** The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes \\[2,1\\]. Thus answer for the first query is 2. We delete the added edge.\n\n**Constraints:**\n\n*   `2 <= n <= 30`\n*   `m == queries.length`\n*   `1 <= m <= 105`\n*   `queries[i].length == 2`\n*   `1 <= ai, bi <= 2n - 1`\n*   `ai != bi`\"\"\"\n\n    result = []\n    for A, B in queries:\n        depth_A, depth_B = 0, 0\n        while A != B:\n            if A < B:\n                A, B = B, A\n            A >>= 1\n            depth_A += 1\n        result.append(depth_A + depth_B)\n    return result"}}, "leetcode/leetcode_310.txt": {"score": 0.9280266165733337, "content": {"text": "from collections import deque\n    \"\"\"A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\n\nReturn _a list of all **MHTs'** root labels_. You can return the answer in **any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[1\\]\n**Explanation:** As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n**Example 2:**\n\n**Input:** n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]\n**Output:** \\[3,4\\]\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs `(ai, bi)` are distinct.\n*   The given input is **guaranteed** to be a tree and there will be **no repeated** edges.\"\"\"\n\nfrom typing import List\n\ndef find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1:\n        return [0]\n\n    adj_list = [set() for _ in range(n)]\n    for a, b in edges:\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)\n\n    while n > 2:\n        leaves_size = len(leaves)\n        n -= leaves_size\n        for _ in range(leaves_size):\n            leaf = leaves.popleft()\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)"}}, "leetcode/leetcode_1617.txt": {"score": 0.9481055736541748, "content": {"text": "def winnerSquareGame(n: int) -> bool:\n    \"\"\"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.\"\"\"\n\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]"}}, "leetcode/leetcode_834.txt": {"score": 0.9892674684524536, "content": {"text": "def ambiguousCoordinates(s):\n    \"\"\"There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[8,12,6,10,10,10\\]\n**Explanation:** The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on.\n\n**Example 2:**\n\n**Input:** n = 1, edges = \\[\\]\n**Output:** \\[0\\]\n\n**Example 3:**\n\n**Input:** n = 2, edges = \\[\\[1,0\\]\\]\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 3 * 104`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   The given input represents a valid tree.\"\"\"\n\n    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n    \n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n        \n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n    \n    return res"}}}}, "42": {"gold": {"leetcode/leetcode_1671.txt": 1, "leetcode/leetcode_2100.txt": 1}, "retrieved": {"leetcode/leetcode_1964.txt": {"score": 0.9002150297164917, "content": {"text": "def longest_obstacle_course(obstacles):\n    \"\"\"You want to build some obstacle courses. You are given a **0-indexed** integer array `obstacles` of length `n`, where `obstacles[i]` describes the height of the `ith` obstacle.\n\nFor every index `i` between `0` and `n - 1` (**inclusive**), find the length of the **longest obstacle course** in `obstacles` such that:\n\n*   You choose any number of obstacles between `0` and `i` **inclusive**.\n*   You must include the `ith` obstacle in the course.\n*   You must put the chosen obstacles in the **same order** as they appear in `obstacles`.\n*   Every obstacle (except the first) is **taller** than or the **same height** as the obstacle immediately before it.\n\nReturn _an array_ `ans` _of length_ `n`, _where_ `ans[i]` _is the length of the **longest obstacle course** for index_ `i` _as described above_.\n\n**Example 1:**\n\n**Input:** obstacles = \\[1,2,3,2\\]\n**Output:** \\[1,2,3,3\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[1\\], \\[1\\] has length 1.\n- i = 1: \\[1,2\\], \\[1,2\\] has length 2.\n- i = 2: \\[1,2,3\\], \\[1,2,3\\] has length 3.\n- i = 3: \\[1,2,3,2\\], \\[1,2,2\\] has length 3.\n\n**Example 2:**\n\n**Input:** obstacles = \\[2,2,1\\]\n**Output:** \\[1,2,1\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[2\\], \\[2\\] has length 1.\n- i = 1: \\[2,2\\], \\[2,2\\] has length 2.\n- i = 2: \\[2,2,1\\], \\[1\\] has length 1.\n\n**Example 3:**\n\n**Input:** obstacles = \\[3,1,5,6,4,2\\]\n**Output:** \\[1,1,2,3,2,2\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[3\\], \\[3\\] has length 1.\n- i = 1: \\[3,1\\], \\[1\\] has length 1.\n- i = 2: \\[3,1,5\\], \\[3,5\\] has length 2. \\[1,5\\] is also valid.\n- i = 3: \\[3,1,5,6\\], \\[3,5,6\\] has length 3. \\[1,5,6\\] is also valid.\n- i = 4: \\[3,1,5,6,4\\], \\[3,4\\] has length 2. \\[1,4\\] is also valid.\n- i = 5: \\[3,1,5,6,4,2\\], \\[1,2\\] has length 2.\n\n**Constraints:**\n\n*   `n == obstacles.length`\n*   `1 <= n <= 105`\n*   `1 <= obstacles[i] <= 107`\"\"\"\n\n    dp = []\n    ans = [0] * len(obstacles)\n\n    for obstacle in obstacles:\n        index = bisect_left(dp, obstacle)\n        ans[index] = index + 1\n        if index == len(dp):\n            dp.append(obstacle)\n        else:\n            dp[index] = obstacle\n\n    return ans"}}, "leetcode/leetcode_896.txt": {"score": 0.9009042978286743, "content": {"text": "class TreeNode:\n    \"\"\"An array is **monotonic** if it is either monotone increasing or monotone decreasing.\n\nAn array `nums` is monotone increasing if for all `i <= j`, `nums[i] <= nums[j]`. An array `nums` is monotone decreasing if for all `i <= j`, `nums[i] >= nums[j]`.\n\nGiven an integer array `nums`, return `true` _if the given array is monotonic, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,2,3\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** nums = \\[6,5,4,4\\]\n**Output:** true\n\n**Example 3:**\n\n**Input:** nums = \\[1,3,2\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-105 <= nums[i] <= 105`\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxDepth(node):\n    if node is None:\n        return 0\n    else:\n        return max(maxDepth(node.left), maxDepth(node.right)) + 1\n\ndef subtreeWithAllDeepest(root):\n    if root is None:\n        return None\n\n    leftDepth = maxDepth(root.left)\n    rightDepth = maxDepth(root.right)\n\n    if leftDepth == rightDepth:\n        return root\n\n    if leftDepth > rightDepth:\n        return subtreeWithAllDeepest(root.left)\n    else:\n        return subtreeWithAllDeepest(root.right)"}}, "leetcode/leetcode_941.txt": {"score": 0.9067723155021667, "content": {"text": "def move_even_odd(nums):\n    \"\"\"Given an array of integers `arr`, return _`true` if and only if it is a valid mountain array_.\n\nRecall that arr is a mountain array if and only if:\n\n*   `arr.length >= 3`\n*   There exists some `i` with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\n**Example 1:**\n\n**Input:** arr = \\[2,1\\]\n**Output:** false\n\n**Example 2:**\n\n**Input:** arr = \\[3,5,5\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** arr = \\[0,3,2,1\\]\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`\"\"\"\n\n    even_index = 0\n    odd_index = len(nums) - 1\n\n    while even_index < odd_index:\n        if nums[even_index] % 2 == 0:\n            even_index += 1\n        else:\n            nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]\n            odd_index -= 1\n\n    return nums"}}, "leetcode/leetcode_1671.txt": {"score": 0.9216432571411133, "content": {"text": "def minimumMountainRemovals(nums):\n    \"\"\"You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `nums`\u200b\u200b\u200b, return _the **minimum** number of elements to remove to make_ `nums_\u200b\u200b\u200b_` _a **mountain array**._\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,1\\]\n**Output:** 0\n**Explanation:** The array itself is a mountain array so we do not need to remove any elements.\n\n**Example 2:**\n\n**Input:** nums = \\[2,1,1,5,6,2,3,1\\]\n**Output:** 3\n**Explanation:** One solution is to remove the elements at indices 0, 1, and 5, making the array nums = \\[1,5,6,3,1\\].\n\n**Constraints:**\n\n*   `3 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 109`\n*   It is guaranteed that you can make a mountain array out of `nums`.\"\"\"\n\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(1, n):\n        left[i] = left[i - 1] + int(nums[i] > nums[i - 1])\n        right[n - i - 1] = right[n - i] + int(nums[n - i - 1] > nums[n - i])\n    ans = n - 3\n    for i in range(1, n - 1):\n        ans = min(ans, n - 1 - left[i] - right[i])\n    return ans"}}, "leetcode/leetcode_852.txt": {"score": 0.9386694431304932, "content": {"text": "def numFriendRequests(ages):\n    \"\"\"An array `arr` a **mountain** if the following properties hold:\n\n*   `arr.length >= 3`\n*   There exists some `i` with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven a mountain array `arr`, return the index `i` such that `arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`.\n\nYou must solve it in `O(log(arr.length))` time complexity.\n\n**Example 1:**\n\n**Input:** arr = \\[0,1,0\\]\n**Output:** 1\n\n**Example 2:**\n\n**Input:** arr = \\[0,2,1,0\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** arr = \\[0,10,5,2\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `3 <= arr.length <= 105`\n*   `0 <= arr[i] <= 106`\n*   `arr` is **guaranteed** to be a mountain array.\"\"\"\n\n    count = [0] * 121\n    total_requests = 0\n\n    for age in ages:\n        count[age] += 1\n\n    for a in range(1, 121):\n        for b in range(1, 121):\n            if a * 0.5 + 7 >= b:\n                continue\n            if a < b:\n                continue\n            if a < b * 2:\n                total_requests += count[a] * count[b]\n                if a == b:\n                    total_requests -= count[a]\n\n    return total_requests"}}, "leetcode/leetcode_962.txt": {"score": 0.9193159341812134, "content": {"text": "def minFlipsMonoIncr(s: str) -> int:\n    \"\"\"A **ramp** in an integer array `nums` is a pair `(i, j)` for which `i < j` and `nums[i] <= nums[j]`. The **width** of such a ramp is `j - i`.\n\nGiven an integer array `nums`, return _the maximum width of a **ramp** in_ `nums`. If there is no **ramp** in `nums`, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[6,0,8,2,1,5\\]\n**Output:** 4\n**Explanation:** The maximum width ramp is achieved at (i, j) = (1, 5): nums\\[1\\] = 0 and nums\\[5\\] = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[9,8,1,0,1,9,4,0,4,1\\]\n**Output:** 7\n**Explanation:** The maximum width ramp is achieved at (i, j) = (2, 9): nums\\[2\\] = 1 and nums\\[9\\] = 1.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 5 * 104`\"\"\"\n\n    flipCount, oneCount = 0, 0\n    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)\n    return flipCount"}}, "leetcode/leetcode_456.txt": {"score": 0.9277063012123108, "content": {"text": "def find132pattern(nums):\n    \"\"\"Given an array of `n` integers `nums`, a **132 pattern** is a subsequence of three integers `nums[i]`, `nums[j]` and `nums[k]` such that `i < j < k` and `nums[i] < nums[k] < nums[j]`.\n\nReturn `true` _if there is a **132 pattern** in_ `nums`_, otherwise, return_ `false`_._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** There is no 132 pattern in the sequence.\n\n**Example 2:**\n\n**Input:** nums = \\[3,1,4,2\\]\n**Output:** true\n**Explanation:** There is a 132 pattern in the sequence: \\[1, 4, 2\\].\n\n**Example 3:**\n\n**Input:** nums = \\[-1,3,2,0\\]\n**Output:** true\n**Explanation:** There are three 132 patterns in the sequence: \\[-1, 3, 2\\], \\[-1, 3, 0\\] and \\[-1, 2, 0\\].\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 2 * 105`\n*   `-109 <= nums[i] <= 109`\"\"\"\n\n    third, stack = float('-inf'), []\n    for num in reversed(nums):\n        if num < third:\n            return True\n        while stack and stack[-1] < num:\n            third = stack.pop()\n        stack.append(num)\n    return False"}}, "leetcode/leetcode_2210.txt": {"score": 0.9410381317138672, "content": {"text": "def sorted_target_indices(nums, target):\n    \"\"\"You are given a **0-indexed** integer array `nums`. An index `i` is part of a **hill** in `nums` if the closest non-equal neighbors of `i` are smaller than `nums[i]`. Similarly, an index `i` is part of a **valley** in `nums` if the closest non-equal neighbors of `i` are larger than `nums[i]`. Adjacent indices `i` and `j` are part of the **same** hill or valley if `nums[i] == nums[j]`.\n\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on **both** the left and right of the index.\n\nReturn _the number of hills and valleys in_ `nums`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,1,1,6,5\\]\n**Output:** 3\n**Explanation:**\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\n**Example 2:**\n\n**Input:** nums = \\[6,6,5,5,4,1\\]\n**Output:** 0\n**Explanation:**\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`\"\"\"\n\n    result = [i for i, num in enumerate(nums) if num == target]\n    return sorted(result)"}}, "leetcode/leetcode_978.txt": {"score": 0.944535493850708, "content": {"text": "def valid_mountain_array(arr):\n    \"\"\"Given an integer array `arr`, return _the length of a maximum size turbulent subarray of_ `arr`.\n\nA subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray.\n\nMore formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if:\n\n*   For `i <= k < j`:\n    *   `arr[k] > arr[k + 1]` when `k` is odd, and\n    *   `arr[k] < arr[k + 1]` when `k` is even.\n*   Or, for `i <= k < j`:\n    *   `arr[k] > arr[k + 1]` when `k` is even, and\n    *   `arr[k] < arr[k + 1]` when `k` is odd.\n\n**Example 1:**\n\n**Input:** arr = \\[9,4,2,10,7,8,8,1,9\\]\n**Output:** 5\n**Explanation:** arr\\[1\\] > arr\\[2\\] < arr\\[3\\] > arr\\[4\\] < arr\\[5\\]\n\n**Example 2:**\n\n**Input:** arr = \\[4,8,12,16\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** arr = \\[100\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= arr.length <= 4 * 104`\n*   `0 <= arr[i] <= 109`\"\"\"\n\n    n, i, j = len(arr), 0, len(arr) - 1\n    while i + 1 < n and arr[i] < arr[i + 1]:\n        i += 1\n    while j > 0 and arr[j - 1] > arr[j]:\n        j -= 1\n    return i > 0 and i == j and j < n - 1"}}, "leetcode/leetcode_845.txt": {"score": 0.9928308725357056, "content": {"text": "def longestMountain(arr):\n    \"\"\"You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.\n\n**Example 1:**\n\n**Input:** arr = \\[2,1,4,7,3,2,5\\]\n**Output:** 5\n**Explanation:** The largest mountain is \\[1,4,7,3,2\\] which has length 5.\n\n**Example 2:**\n\n**Input:** arr = \\[2,2,2\\]\n**Output:** 0\n**Explanation:** There is no mountain.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`\n\n**Follow up:**\n\n*   Can you solve it using only one pass?\n*   Can you solve it in `O(1)` space?\"\"\"\n\n    n = len(arr)\n    res = up = down = 0\n\n    for i in range(1, n):\n        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:\n            up = down = 0\n\n        up += arr[i - 1] < arr[i]\n        down += arr[i - 1] > arr[i]\n\n        if up and down:\n            res = max(res, up + down + 1)\n\n    return res"}}}}, "43": {"gold": {"leetcode/leetcode_1776.txt": 1, "leetcode/leetcode_2211.txt": 1}, "retrieved": {"leetcode/leetcode_1326.txt": {"score": 0.9056406021118164, "content": {"text": "def sum_of_floored_pairs(nums):\n    \"\"\"There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).\n\nThere are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.\n\nGiven an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.\n\nReturn _the minimum number of taps_ that should be open to water the whole garden, If the garden cannot be watered return **\\-1**.\n\n**Example 1:**\n\n**Input:** n = 5, ranges = \\[3,4,1,1,0,0\\]\n**Output:** 1\n**Explanation:** The tap at point 0 can cover the interval \\[-3,3\\]\nThe tap at point 1 can cover the interval \\[-3,5\\]\nThe tap at point 2 can cover the interval \\[1,3\\]\nThe tap at point 3 can cover the interval \\[2,4\\]\nThe tap at point 4 can cover the interval \\[4,4\\]\nThe tap at point 5 can cover the interval \\[5,5\\]\nOpening Only the second tap will water the whole garden \\[0,5\\]\n\n**Example 2:**\n\n**Input:** n = 3, ranges = \\[0,0,0,0\\]\n**Output:** -1\n**Explanation:** Even if you activate all the four taps you cannot water the whole garden.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `ranges.length == n + 1`\n*   `0 <= ranges[i] <= 100`\"\"\"\n\n    mod = 10**9 + 7\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    pref_sum = [0] * (max_val + 1)\n\n    for num in nums:\n        count[num] += 1\n\n    for i in range(1, max_val + 1):\n        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod\n\n    res = 0\n    for x in range(1, max_val + 1):\n        nx = x\n        k = 1\n        while nx <= max_val:\n            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod\n            k += 1\n            nx += x\n    return res"}}, "leetcode/leetcode_2432.txt": {"score": 0.9061343669891357, "content": {"text": "def worker_with_longest_task(n, logs):\n    \"\"\"There are `n` employees, each with a unique id from `0` to `n - 1`.\n\nYou are given a 2D integer array `logs` where `logs[i] = [idi, leaveTimei]` where:\n\n*   `idi` is the id of the employee that worked on the `ith` task, and\n*   `leaveTimei` is the time at which the employee finished the `ith` task. All the values `leaveTimei` are **unique**.\n\nNote that the `ith` task starts the moment right after the `(i - 1)th` task ends, and the `0th` task starts at time `0`.\n\nReturn _the id of the employee that worked the task with the longest time._ If there is a tie between two or more employees, return _the **smallest** id among them_.\n\n**Example 1:**\n\n**Input:** n = 10, logs = \\[\\[0,3\\],\\[2,5\\],\\[0,9\\],\\[1,15\\]\\]\n**Output:** 1\n**Explanation:** \nTask 0 started at 0 and ended at 3 with 3 units of times.\nTask 1 started at 3 and ended at 5 with 2 units of times.\nTask 2 started at 5 and ended at 9 with 4 units of times.\nTask 3 started at 9 and ended at 15 with 6 units of times.\nThe task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n\n**Example 2:**\n\n**Input:** n = 26, logs = \\[\\[1,1\\],\\[3,7\\],\\[2,12\\],\\[7,17\\]\\]\n**Output:** 3\n**Explanation:** \nTask 0 started at 0 and ended at 1 with 1 unit of times.\nTask 1 started at 1 and ended at 7 with 6 units of times.\nTask 2 started at 7 and ended at 12 with 5 units of times.\nTask 3 started at 12 and ended at 17 with 5 units of times.\nThe tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3.\n\n**Example 3:**\n\n**Input:** n = 2, logs = \\[\\[0,10\\],\\[1,20\\]\\]\n**Output:** 0\n**Explanation:** \nTask 0 started at 0 and ended at 10 with 10 units of times.\nTask 1 started at 10 and ended at 20 with 10 units of times.\nThe tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.\n\n**Constraints:**\n\n*   `2 <= n <= 500`\n*   `1 <= logs.length <= 500`\n*   `logs[i].length == 2`\n*   `0 <= idi <= n - 1`\n*   `1 <= leaveTimei <= 500`\n*   `idi != idi+1`\n*   `leaveTimei` are sorted in a strictly increasing order.\"\"\"\n\n    result = 0\n    max_time = logs[0][1] - 0\n\n    for i in range(1, len(logs)):\n        time = logs[i][1] - logs[i-1][1]\n        if time > max_time:\n            max_time = time\n            result = logs[i][0]\n\n    return result"}}, "leetcode/leetcode_1503.txt": {"score": 0.913468062877655, "content": {"text": "def max_satisfaction(satisfaction):\n    \"\"\"We have a wooden plank of the length `n` **units**. Some ants are walking on the plank, each ant moves with a speed of **1 unit per second**. Some of the ants move to the **left**, the other move to the **right**.\n\nWhen two ants moving in two **different** directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\n\nWhen an ant reaches **one end** of the plank at a time `t`, it falls out of the plank immediately.\n\nGiven an integer `n` and two integer arrays `left` and `right`, the positions of the ants moving to the left and the right, return _the moment when the last ant(s) fall out of the plank_.\n\n**Example 1:**\n\n**Input:** n = 4, left = \\[4,3\\], right = \\[0,1\\]\n**Output:** 4\n**Explanation:** In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n\n**Example 2:**\n\n**Input:** n = 7, left = \\[\\], right = \\[0,1,2,3,4,5,6,7\\]\n**Output:** 7\n**Explanation:** All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n\n**Example 3:**\n\n**Input:** n = 7, left = \\[0,1,2,3,4,5,6,7\\], right = \\[\\]\n**Output:** 7\n**Explanation:** All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `0 <= left.length <= n + 1`\n*   `0 <= left[i] <= n`\n*   `0 <= right.length <= n + 1`\n*   `0 <= right[i] <= n`\n*   `1 <= left.length + right.length <= n + 1`\n*   All values of `left` and `right` are unique, and each value can appear **only in one** of the two arrays.\"\"\"\n\n    satisfaction.sort(reverse=True)\n    ans = total = sum = 0\n    for i in satisfaction:\n        total += i\n        if total > 0:\n            sum += total\n            ans = max(ans, sum)\n    return ans"}}, "leetcode/leetcode_2589.txt": {"score": 0.9103987812995911, "content": {"text": "def min_time_on(tasks):\n    \"\"\"There is a computer that can run an unlimited number of tasks **at the same time**. You are given a 2D integer array `tasks` where `tasks[i] = [starti, endi, durationi]` indicates that the `ith` task should run for a total of `durationi` seconds (not necessarily continuous) within the **inclusive** time range `[starti, endi]`.\n\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\n\nReturn _the minimum time during which the computer should be turned on to complete all tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[2,3,1\\],\\[4,5,1\\],\\[1,5,2\\]\\]\n**Output:** 2\n**Explanation:** \n- The first task can be run in the inclusive time range \\[2, 2\\].\n- The second task can be run in the inclusive time range \\[5, 5\\].\n- The third task can be run in the two inclusive time ranges \\[2, 2\\] and \\[5, 5\\].\nThe computer will be on for a total of 2 seconds.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3,2\\],\\[2,5,3\\],\\[5,6,2\\]\\]\n**Output:** 4\n**Explanation:** \n- The first task can be run in the inclusive time range \\[2, 3\\].\n- The second task can be run in the inclusive time ranges \\[2, 3\\] and \\[5, 5\\].\n- The third task can be run in the two inclusive time range \\[5, 6\\].\nThe computer will be on for a total of 4 seconds.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 2000`\n*   `tasks[i].length == 3`\n*   `1 <= starti, endi <= 2000`\n*   `1 <= durationi <= endi - starti + 1`\"\"\"\n\n    intervals = sorted([[task[1] + 1, task[2]] for task in tasks])\n\n    dp = [0] * 2001\n    for interval in intervals:\n        for i in range(2000, interval[0] - 1, -1):\n            dp[i] = max(dp[i], dp[i - interval[1]] + interval[1])\n\n    return dp[-1]"}}, "leetcode/leetcode_2410.txt": {"score": 0.9138387441635132, "content": {"text": "def max_matchings(players, trainers):\n    \"\"\"You are given a **0-indexed** integer array `players`, where `players[i]` represents the **ability** of the `ith` player. You are also given a **0-indexed** integer array `trainers`, where `trainers[j]` represents the **training capacity** of the `jth` trainer.\n\nThe `ith` player can **match** with the `jth` trainer if the player's ability is **less than or equal to** the trainer's training capacity. Additionally, the `ith` player can be matched with at most one trainer, and the `jth` trainer can be matched with at most one player.\n\nReturn _the **maximum** number of matchings between_ `players` _and_ `trainers` _that satisfy these conditions._\n\n**Example 1:**\n\n**Input:** players = \\[4,7,9\\], trainers = \\[8,2,5,8\\]\n**Output:** 2\n**Explanation:**\nOne of the ways we can form two matchings is as follows:\n- players\\[0\\] can be matched with trainers\\[0\\] since 4 <= 8.\n- players\\[1\\] can be matched with trainers\\[3\\] since 7 <= 8.\nIt can be proven that 2 is the maximum number of matchings that can be formed.\n\n**Example 2:**\n\n**Input:** players = \\[1,1,1\\], trainers = \\[10\\]\n**Output:** 1\n**Explanation:**\nThe trainer can be matched with any of the 3 players.\nEach player can only be matched with one trainer, so the maximum answer is 1.\n\n**Constraints:**\n\n*   `1 <= players.length, trainers.length <= 105`\n*   `1 <= players[i], trainers[j] <= 109`\"\"\"\n\n    players.sort()\n    trainers.sort()\n\n    player_index, trainer_index, match_count = 0, 0, 0\n    while (player_index < len(players)) and (trainer_index < len(trainers)):\n        if players[player_index] <= trainers[trainer_index]:\n            match_count += 1\n            player_index += 1\n            trainer_index += 1\n        else:\n            trainer_index += 1\n\n    return match_count"}}, "leetcode/leetcode_1776.txt": {"score": 0.9381906986236572, "content": {"text": "def minOperations(nums, x):\n    \"\"\"There are `n` cars traveling at different speeds in the same direction along a one-lane road. You are given an array `cars` of length `n`, where `cars[i] = [positioni, speedi]` represents:\n\n*   `positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`.\n*   `speedi` is the initial speed of the `ith` car in meters per second.\n\nFor simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the **slowest** car in the fleet.\n\nReturn an array `answer`, where `answer[i]` is the time, in seconds, at which the `ith` car collides with the next car, or `-1` if the car does not collide with the next car. Answers within `10-5` of the actual answers are accepted.\n\n**Example 1:**\n\n**Input:** cars = \\[\\[1,2\\],\\[2,1\\],\\[4,3\\],\\[7,2\\]\\]\n**Output:** \\[1.00000,-1.00000,3.00000,-1.00000\\]\n**Explanation:** After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.\n\n**Example 2:**\n\n**Input:** cars = \\[\\[3,4\\],\\[5,4\\],\\[6,3\\],\\[9,1\\]\\]\n**Output:** \\[2.00000,1.00000,1.50000,-1.00000\\]\n\n**Constraints:**\n\n*   `1 <= cars.length <= 105`\n*   `1 <= positioni, speedi <= 106`\n*   `positioni < positioni+1`\"\"\"\n\n    total = sum(nums)\n    target = total - x\n    if target < 0:\n        return -1\n\n    maxLength = -1\n    left = 0\n    current_sum = 0\n\n    for right in range(len(nums)):\n        current_sum += nums[right]\n\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n\n        if current_sum == target:\n            maxLength = max(maxLength, right - left + 1)\n\n    return -1 if maxLength == -1 else len(nums) - maxLength"}}, "leetcode/leetcode_2141.txt": {"score": 0.9167424440383911, "content": {"text": "def max_computer_runtime(n, batteries):\n    \"\"\"You have `n` computers. You are given the integer `n` and a **0-indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries.\n\nInitially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\nNote that the batteries cannot be recharged.\n\nReturn _the **maximum** number of minutes you can run all the_ `n` _computers simultaneously._\n\n**Example 1:**\n\n**Input:** n = 2, batteries = \\[3,3,3\\]\n**Output:** 4\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n**Example 2:**\n\n**Input:** n = 2, batteries = \\[1,1,1,1\\]\n**Output:** 2\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.\n\n**Constraints:**\n\n*   `1 <= n <= batteries.length <= 105`\n*   `1 <= batteries[i] <= 109`\"\"\"\n\n    batteries.sort()\n    result = 0\n    for i in range(len(batteries)):\n        result = max(result, min(n, len(batteries) - i) * batteries[i])\n    return result"}}, "leetcode/leetcode_853.txt": {"score": 0.9860876202583313, "content": {"text": "def max_profit_assignment(difficulty, profit, worker):\n    \"\"\"There are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\n\nYou are given two integer array `position` and `speed`, both of length `n`, where `position[i]` is the position of the `ith` car and `speed[i]` is the speed of the `ith` car (in miles per hour).\n\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper **at the same speed**. The faster car will **slow down** to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n\nA **car fleet** is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\n\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\n\nReturn _the **number of car fleets** that will arrive at the destination_.\n\n**Example 1:**\n\n**Input:** target = 12, position = \\[10,8,0,5,3\\], speed = \\[2,4,1,1,3\\]\n**Output:** 3\n**Explanation:**\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\nNote that no other cars meet these fleets before the destination, so the answer is 3.\n\n**Example 2:**\n\n**Input:** target = 10, position = \\[3\\], speed = \\[3\\]\n**Output:** 1\n**Explanation:** There is only one car, hence there is only one fleet.\n\n**Example 3:**\n\n**Input:** target = 100, position = \\[0,2,4\\], speed = \\[4,2,1\\]\n**Output:** 1\n**Explanation:**\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n\n**Constraints:**\n\n*   `n == position.length == speed.length`\n*   `1 <= n <= 105`\n*   `0 < target <= 106`\n*   `0 <= position[i] < target`\n*   All the values of `position` are **unique**.\n*   `0 < speed[i] <= 106`\"\"\"\n\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    i, max_profit, total_profit = 0, 0, 0\n    for ability in worker:\n        while i < len(difficulty) and ability >= jobs[i][0]:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        total_profit += max_profit\n    return total_profit"}}, "leetcode/leetcode_1921.txt": {"score": 0.9171462059020996, "content": {"text": "def eliminate_maximum(dist, speed):\n    \"\"\"You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0-indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city.\n\nThe monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute.\n\nYou have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge.The weapon is fully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon.\n\nReturn _the **maximum** number of monsters that you can eliminate before you lose, or_ `n` _if you can eliminate all the monsters before they reach the city._\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,4\\], speed = \\[1,1,1\\]\n**Output:** 3\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,3,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,2,3\\]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are \\[X,X,2\\]. You eliminate the thrid monster.\nAll 3 monsters can be eliminated.\n\n**Example 2:**\n\n**Input:** dist = \\[1,1,2,3\\], speed = \\[1,1,1,1\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,1,2,3\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,1,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Example 3:**\n\n**Input:** dist = \\[3,2,4\\], speed = \\[5,3,2\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[3,2,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Constraints:**\n\n*   `n == dist.length == speed.length`\n*   `1 <= n <= 105`\n*   `1 <= dist[i], speed[i] <= 105`\"\"\"\n\n    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated"}}, "leetcode/leetcode_2332.txt": {"score": 0.9280493855476379, "content": {"text": "def last_passenger_time(buses, passengers, capacity):\n    \"\"\"You are given a **0-indexed** integer array `buses` of length `n`, where `buses[i]` represents the departure time of the `ith` bus. You are also given a **0-indexed** integer array `passengers` of length `m`, where `passengers[j]` represents the arrival time of the `jth` passenger. All bus departure times are unique. All passenger arrival times are unique.\n\nYou are given an integer `capacity`, which represents the **maximum** number of passengers that can get on each bus.\n\nWhen a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at `x` minutes if you arrive at `y` minutes where `y <= x`, and the bus is not full. Passengers with the **earliest** arrival times get on the bus first.\n\nMore formally when a bus arrives, either:\n\n*   If `capacity` or fewer passengers are waiting for a bus, they will **all** get on the bus, or\n*   The `capacity` passengers with the **earliest** arrival times will get on the bus.\n\nReturn _the latest time you may arrive at the bus station to catch a bus_. You **cannot** arrive at the same time as another passenger.\n\n**Note:** The arrays `buses` and `passengers` are not necessarily sorted.\n\n**Example 1:**\n\n**Input:** buses = \\[10,20\\], passengers = \\[2,17,18,19\\], capacity = 2\n**Output:** 16\n**Explanation:** Suppose you arrive at time 16.\nAt time 10, the first bus departs with the 0th passenger. \nAt time 20, the second bus departs with you and the 1st passenger.\nNote that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus.\n\n**Example 2:**\n\n**Input:** buses = \\[20,30,10\\], passengers = \\[19,13,26,4,25,11,21\\], capacity = 2\n**Output:** 20\n**Explanation:** Suppose you arrive at time 20.\nAt time 10, the first bus departs with the 3rd passenger. \nAt time 20, the second bus departs with the 5th and 1st passengers.\nAt time 30, the third bus departs with the 0th passenger and you.\nNotice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus.\n\n**Constraints:**\n\n*   `n == buses.length`\n*   `m == passengers.length`\n*   `1 <= n, m, capacity <= 105`\n*   `2 <= buses[i], passengers[i] <= 109`\n*   Each element in `buses` is **unique**.\n*   Each element in `passengers` is **unique**.\"\"\"\n\n    buses.sort()\n    passengers.sort()\n\n    last_index = 0\n    for bus in buses:\n        cnt = 0\n        while last_index < len(passengers) and passengers[last_index] <= bus and cnt < capacity:\n            cnt += 1\n            last_index += 1\n\n    return buses[0] - 1 if last_index == 0 else passengers[last_index - 1] - 1"}}}}, "44": {"gold": {"leetcode/leetcode_2542.txt": 1}, "retrieved": {"leetcode/leetcode_2226.txt": {"score": 0.9220059514045715, "content": {"text": "def count_rods_with_all_colors(rings: str) -> int:\n    \"\"\"You are given a **0-indexed** integer array `candies`. Each element in the array denotes a pile of candies of size `candies[i]`. You can divide each pile into any number of **sub piles**, but you **cannot** merge two piles together.\n\nYou are also given an integer `k`. You should allocate piles of candies to `k` children such that each child gets the **same** number of candies. Each child can take **at most one** pile of candies and some piles of candies may go unused.\n\nReturn _the **maximum number of candies** each child can get._\n\n**Example 1:**\n\n**Input:** candies = \\[5,8,6\\], k = 3\n**Output:** 5\n**Explanation:** We can divide candies\\[1\\] into 2 piles of size 5 and 3, and candies\\[2\\] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n\n**Example 2:**\n\n**Input:** candies = \\[2,5\\], k = 11\n**Output:** 0\n**Explanation:** There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n\n**Constraints:**\n\n*   `1 <= candies.length <= 105`\n*   `1 <= candies[i] <= 107`\n*   `1 <= k <= 1012`\"\"\"\n\n    rod_colors = [0] * 10\n\n    for i in range(0, len(rings), 2):\n        color = ord(rings[i]) - ord('A')\n        rod = int(rings[i + 1])\n\n        rod_colors[rod] |= (1 << color)\n\n    return rod_colors.count(7)"}}, "leetcode/leetcode_2141.txt": {"score": 0.9247315526008606, "content": {"text": "def max_computer_runtime(n, batteries):\n    \"\"\"You have `n` computers. You are given the integer `n` and a **0-indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries.\n\nInitially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\nNote that the batteries cannot be recharged.\n\nReturn _the **maximum** number of minutes you can run all the_ `n` _computers simultaneously._\n\n**Example 1:**\n\n**Input:** n = 2, batteries = \\[3,3,3\\]\n**Output:** 4\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n**Example 2:**\n\n**Input:** n = 2, batteries = \\[1,1,1,1\\]\n**Output:** 2\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.\n\n**Constraints:**\n\n*   `1 <= n <= batteries.length <= 105`\n*   `1 <= batteries[i] <= 109`\"\"\"\n\n    batteries.sort()\n    result = 0\n    for i in range(len(batteries)):\n        result = max(result, min(n, len(batteries) - i) * batteries[i])\n    return result"}}, "leetcode/leetcode_2144.txt": {"score": 0.9236319661140442, "content": {"text": "def max_difference(nums):\n    \"\"\"A shop is selling candies at a discount. For **every two** candies sold, the shop gives a **third** candy for **free**.\n\nThe customer can choose **any** candy to take away for free as long as the cost of the chosen candy is less than or equal to the **minimum** cost of the two candies bought.\n\n*   For example, if there are `4` candies with costs `1`, `2`, `3`, and `4`, and the customer buys candies with costs `2` and `3`, they can take the candy with cost `1` for free, but not the candy with cost `4`.\n\nGiven a **0-indexed** integer array `cost`, where `cost[i]` denotes the cost of the `ith` candy, return _the **minimum cost** of buying **all** the candies_.\n\n**Example 1:**\n\n**Input:** cost = \\[1,2,3\\]\n**Output:** 5\n**Explanation:** We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.\nThe total cost of buying all candies is 2 + 3 = 5. This is the **only** way we can buy the candies.\nNote that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.\nThe cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.\n\n**Example 2:**\n\n**Input:** cost = \\[6,5,7,9,2,2\\]\n**Output:** 23\n**Explanation:** The way in which we can get the minimum cost is described below:\n- Buy candies with costs 9 and 7\n- Take the candy with cost 6 for free\n- We buy candies with costs 5 and 2\n- Take the last remaining candy with cost 2 for free\nHence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.\n\n**Example 3:**\n\n**Input:** cost = \\[5,5\\]\n**Output:** 10\n**Explanation:** Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.\nHence, the minimum cost to buy all candies is 5 + 5 = 10.\n\n**Constraints:**\n\n*   `1 <= cost.length <= 100`\n*   `1 <= cost[i] <= 100`\"\"\"\n\n    min_val = nums[0]\n    max_diff = -1\n\n    for i in range(1, len(nums)):\n        if nums[i] > min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n\n    return max_diff"}}, "leetcode/leetcode_2064.txt": {"score": 0.9326798319816589, "content": {"text": "def minimum_maximum(n, quantities):\n    \"\"\"You are given an integer `n` indicating there are `n` specialty retail stores. There are `m` product types of varying amounts, which are given as a **0-indexed** integer array `quantities`, where `quantities[i]` represents the number of products of the `ith` product type.\n\nYou need to distribute **all products** to the retail stores following these rules:\n\n*   A store can only be given **at most one product type** but can be given **any** amount of it.\n*   After distribution, each store will have been given some number of products (possibly `0`). Let `x` represent the maximum number of products given to any store. You want `x` to be as small as possible, i.e., you want to **minimize** the **maximum** number of products that are given to any store.\n\nReturn _the minimum possible_ `x`.\n\n**Example 1:**\n\n**Input:** n = 6, quantities = \\[11,6\\]\n**Output:** 3\n**Explanation:** One optimal way is:\n- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3\n- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3\nThe maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.\n\n**Example 2:**\n\n**Input:** n = 7, quantities = \\[15,10,10\\]\n**Output:** 5\n**Explanation:** One optimal way is:\n- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5\n- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5\n- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5\nThe maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.\n\n**Example 3:**\n\n**Input:** n = 1, quantities = \\[100000\\]\n**Output:** 100000\n**Explanation:** The only optimal way is:\n- The 100000 products of type 0 are distributed to the only store.\nThe maximum number of products given to any store is max(100000) = 100000.\n\n**Constraints:**\n\n*   `m == quantities.length`\n*   `1 <= m <= n <= 105`\n*   `1 <= quantities[i] <= 105`\"\"\"\n\n    sum_products = sum(quantities)\n    x = (sum_products + n - 1) // n\n    remaining_stores = n\n    for q in quantities:\n        remaining_stores -= (q + x - 1) // x\n        if remaining_stores < 0:\n            x = (sum_products + remaining_stores) // (n + remaining_stores)\n            remaining_stores = n\n    return x"}}, "leetcode/leetcode_2594.txt": {"score": 0.9287206530570984, "content": {"text": "def min_time_to_repair(ranks, cars):\n    \"\"\"You are given an integer array `ranks` representing the **ranks** of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank `r` can repair n cars in `r * n2` minutes.\n\nYou are also given an integer `cars` representing the total number of cars waiting in the garage to be repaired.\n\nReturn _the **minimum** time taken to repair all the cars._\n\n**Note:** All the mechanics can repair the cars simultaneously.\n\n**Example 1:**\n\n**Input:** ranks = \\[4,2,3,1\\], cars = 10\n**Output:** 16\n**Explanation:** \n- The first mechanic will repair two cars. The time required is 4 \\* 2 \\* 2 = 16 minutes.\n- The second mechanic will repair two cars. The time required is 2 \\* 2 \\* 2 = 8 minutes.\n- The third mechanic will repair two cars. The time required is 3 \\* 2 \\* 2 = 12 minutes.\n- The fourth mechanic will repair four cars. The time required is 1 \\* 4 \\* 4 = 16 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.\u200b\u200b\u200b\u200b\u200b\n\n**Example 2:**\n\n**Input:** ranks = \\[5,1,8\\], cars = 6\n**Output:** 16\n**Explanation:** \n- The first mechanic will repair one car. The time required is 5 \\* 1 \\* 1 = 5 minutes.\n- The second mechanic will repair four cars. The time required is 1 \\* 4 \\* 4 = 16 minutes.\n- The third mechanic will repair one car. The time required is 8 \\* 1 \\* 1 = 8 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.\u200b\u200b\u200b\u200b\u200b\n\n**Constraints:**\n\n*   `1 <= ranks.length <= 105`\n*   `1 <= ranks[i] <= 100`\n*   `1 <= cars <= 106`\"\"\"\n\n    ranks.sort()\n    low, high = 0, 100 * cars * cars\n    \n    while low < high:\n        mid = low + (high - low) // 2\n        total_cars_repaired = 0\n        for rank in ranks:\n            cars_repaired = min(cars, mid // (rank * rank))\n            total_cars_repaired += cars_repaired\n            if total_cars_repaired >= cars:\n                break\n        if total_cars_repaired >= cars:\n            high = mid\n        else:\n            low = mid + 1\n            \n    return low"}}, "leetcode/leetcode_1383.txt": {"score": 0.9318483471870422, "content": {"text": "import heapq\n    \"\"\"You are given two integers `n` and `k` and two integer arrays `speed` and `efficiency` both of length `n`. There are `n` engineers numbered from `1` to `n`. `speed[i]` and `efficiency[i]` represent the speed and efficiency of the `ith` engineer respectively.\n\nChoose **at most** `k` different engineers out of the `n` engineers to form a team with the maximum **performance**.\n\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\n\nReturn _the maximum performance of this team_. Since the answer can be a huge number, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 2\n**Output:** 60\n**Explanation:** \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) \\* min(4, 7) = 60.\n\n**Example 2:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 3\n**Output:** 68\n**Explanation:**\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) \\* min(5, 4, 7) = 68.\n\n**Example 3:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 4\n**Output:** 72\n\n**Constraints:**\n\n*   `1 <= k <= n <= 105`\n*   `speed.length == n`\n*   `efficiency.length == n`\n*   `1 <= speed[i] <= 105`\n*   `1 <= efficiency[i] <= 108`\"\"\"\n\nfrom typing import List\n\ndef max_performance(n: int, k: int, speed: List[int], efficiency: List[int]) -> int:\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    min_heap = []\n    speed_sum = 0\n    max_performance = 0\n\n    for e, s in engineers:\n        speed_sum += s\n        heapq.heappush(min_heap, s)\n\n        if len(min_heap) > k:\n            speed_sum -= heapq.heappop(min_heap)\n\n        max_performance = max(max_performance, speed_sum * e)\n\n    return max_performance % (10**9 + 7)"}}, "leetcode/leetcode_2305.txt": {"score": 0.9294350147247314, "content": {"text": "def min_append_k_sum(nums, k):\n    \"\"\"You are given an integer array `cookies`, where `cookies[i]` denotes the number of cookies in the `ith` bag. You are also given an integer `k` that denotes the number of children to distribute **all** the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.\n\nThe **unfairness** of a distribution is defined as the **maximum** **total** cookies obtained by a single child in the distribution.\n\nReturn _the **minimum** unfairness of all distributions_.\n\n**Example 1:**\n\n**Input:** cookies = \\[8,15,10,20,8\\], k = 2\n**Output:** 31\n**Explanation:** One optimal distribution is \\[8,15,8\\] and \\[10,20\\]\n- The 1st child receives \\[8,15,8\\] which has a total of 8 + 15 + 8 = 31 cookies.\n- The 2nd child receives \\[10,20\\] which has a total of 10 + 20 = 30 cookies.\nThe unfairness of the distribution is max(31,30) = 31.\nIt can be shown that there is no distribution with an unfairness less than 31.\n\n**Example 2:**\n\n**Input:** cookies = \\[6,1,3,2,2,4,1,2\\], k = 3\n**Output:** 7\n**Explanation:** One optimal distribution is \\[6,1\\], \\[3,2,2\\], and \\[4,1,2\\]\n- The 1st child receives \\[6,1\\] which has a total of 6 + 1 = 7 cookies.\n- The 2nd child receives \\[3,2,2\\] which has a total of 3 + 2 + 2 = 7 cookies.\n- The 3rd child receives \\[4,1,2\\] which has a total of 4 + 1 + 2 = 7 cookies.\nThe unfairness of the distribution is max(7,7,7) = 7.\nIt can be shown that there is no distribution with an unfairness less than 7.\n\n**Constraints:**\n\n*   `2 <= cookies.length <= 8`\n*   `1 <= cookies[i] <= 105`\n*   `2 <= k <= cookies.length`\"\"\"\n\n    max_elem = max(nums)\n    return sum(range(max_elem + 1, max_elem + k + 1))"}}, "leetcode/leetcode_1792.txt": {"score": 0.9335025548934937, "content": {"text": "def most_competitive(nums, k):\n    \"\"\"There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array `classes`, where `classes[i] = [passi, totali]`. You know beforehand that in the `ith` class, there are `totali` total students, but only `passi` number of students will pass the exam.\n\nYou are also given an integer `extraStudents`. There are another `extraStudents` brilliant students that are **guaranteed** to pass the exam of any class they are assigned to. You want to assign each of the `extraStudents` students to a class in a way that **maximizes** the **average** pass ratio across **all** the classes.\n\nThe **pass ratio** of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The **average pass ratio** is the sum of pass ratios of all the classes divided by the number of the classes.\n\nReturn _the **maximum** possible average pass ratio after assigning the_ `extraStudents` _students._ Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** classes = \\[\\[1,2\\],\\[3,5\\],\\[2,2\\]\\], `extraStudents` = 2\n**Output:** 0.78333\n**Explanation:** You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.\n\n**Example 2:**\n\n**Input:** classes = \\[\\[2,4\\],\\[3,9\\],\\[4,5\\],\\[2,10\\]\\], `extraStudents` = 4\n**Output:** 0.53485\n\n**Constraints:**\n\n*   `1 <= classes.length <= 105`\n*   `classes[i].length == 2`\n*   `1 <= passi <= totali <= 105`\n*   `1 <= extraStudents <= 105`\"\"\"\n\n    stack = []\n    n = len(nums)\n\n    for i in range(n):\n        while stack and nums[i] < stack[-1] and len(stack) + n - i > k:\n            stack.pop()\n        if len(stack) < k:\n            stack.append(nums[i])\n\n    return stack"}}, "leetcode/leetcode_1723.txt": {"score": 0.9372373223304749, "content": {"text": "def max_achievable_requests(n, requests, idx=0, counts=None):\n    \"\"\"You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`\"\"\"\n\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)"}}, "leetcode/leetcode_857.txt": {"score": 0.9878977537155151, "content": {"text": "def largeGroupPositions(s: str):\n    \"\"\"There are `n` workers. You are given two integer arrays `quality` and `wage` where `quality[i]` is the quality of the `ith` worker and `wage[i]` is the minimum wage expectation for the `ith` worker.\n\nWe want to hire exactly `k` workers to form a paid group. To hire a group of `k` workers, we must pay them according to the following rules:\n\n1.  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2.  Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer `k`, return _the least amount of money needed to form a paid group satisfying the above conditions_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** quality = \\[10,20,5\\], wage = \\[70,50,30\\], k = 2\n**Output:** 105.00000\n**Explanation:** We pay 70 to 0th worker and 35 to 2nd worker.\n\n**Example 2:**\n\n**Input:** quality = \\[3,1,10,10,1\\], wage = \\[4,8,2,2,7\\], k = 3\n**Output:** 30.66667\n**Explanation:** We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.\n\n**Constraints:**\n\n*   `n == quality.length == wage.length`\n*   `1 <= k <= n <= 104`\n*   `1 <= quality[i], wage[i] <= 104`\"\"\"\n\n    result = []\n    start = 0\n    for i in range(1, len(s)):\n        if s[i] != s[start]:\n            if i - start >= 3:\n                result.append([start, i - 1])\n            start = i\n    if len(s) - start >= 3:\n        result.append([start, len(s) - 1])\n    return result"}}}}, "45": {"gold": {"leetcode/leetcode_2092.txt": 1}, "retrieved": {"leetcode/csn_python_train_54995.txt": {"score": 0.916932225227356, "content": {"text": "def get_hops(self, start, end=None, forward=True):\n        \"\"\"\n        Computes the hop distance to all nodes centered around a specified node.\n\n        First order neighbours are at hop 1, their neigbours are at hop 2 etc.\n        Uses :py:meth:`forw_bfs` or :py:meth:`back_bfs` depending on the value of the forward\n        parameter.  If the distance between all neighbouring nodes is 1 the hop\n        number corresponds to the shortest distance between the nodes.\n\n        :param start: the starting node\n        :param end: ending node (optional). When not specified will search the whole graph.\n        :param forward: directionality parameter (optional). If C{True} (default) it uses L{forw_bfs} otherwise L{back_bfs}.\n        :return: returns a list of tuples where each tuple contains the node and the hop.\n\n        Typical usage::\n\n            >>> print graph.get_hops(1, 8)\n            >>> [(1, 0), (2, 1), (3, 1), (4, 2), (5, 3), (7, 4), (8, 5)]\n            # node 1 is at 0 hops\n            # node 2 is at 1 hop\n            # ...\n            # node 8 is at 5 hops\n        \"\"\"\n        if forward:\n            return list(self._iterbfs(start=start, end=end, forward=True))\n        else:\n            return list(self._iterbfs(start=start, end=end, forward=False))"}}, "leetcode/csn_python_train_334016.txt": {"score": 0.9185964465141296, "content": {"text": "def get_new_edges(self, level):\n        \"\"\"Get new edges from the pattern graph for the graph search algorithm\n\n           The level argument denotes the distance of the new edges from the\n           starting vertex in the pattern graph.\n        \"\"\"\n        if level == 0:\n            edges0 = [(0, 1), (0, 2)]\n        elif level >= (self.max_size-1)//2:\n            edges0 = []\n        else:\n            l2 = level*2\n            edges0 = [(l2-1, l2+1), (l2, l2+2)]\n        return edges0, []"}}, "leetcode/leetcode_924.txt": {"score": 0.9195491671562195, "content": {"text": "def fair_candy_swap(aliceSizes, bobSizes):\n    \"\"\"You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.\n\nSome nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\nSuppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove **exactly one node** from `initial`.\n\nReturn the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with **the smallest index**.\n\nNote that if a node was removed from the `initial` list of infected nodes, it might still be infected later due to the malware spread.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[1,1,0\\],\\[1,1,0\\],\\[0,0,1\\]\\], initial = \\[0,1\\]\n**Output:** 0\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,0,0\\],\\[0,1,0\\],\\[0,0,1\\]\\], initial = \\[0,2\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** graph = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], initial = \\[1,2\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == graph.length`\n*   `n == graph[i].length`\n*   `2 <= n <= 300`\n*   `graph[i][j]` is `0` or `1`.\n*   `graph[i][j] == graph[j][i]`\n*   `graph[i][i] == 1`\n*   `1 <= initial.length <= n`\n*   `0 <= initial[i] <= n - 1`\n*   All the integers in `initial` are **unique**.\"\"\"\n\n    aliceTotal, bobTotal = sum(aliceSizes), sum(bobSizes)\n    delta = (bobTotal - aliceTotal) // 2\n    for a in aliceSizes:\n        for b in bobSizes:\n            if a + delta == b:\n                return [a, b]\n    return []"}}, "leetcode/leetcode_1617.txt": {"score": 0.9199154376983643, "content": {"text": "def winnerSquareGame(n: int) -> bool:\n    \"\"\"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.\"\"\"\n\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]"}}, "leetcode/leetcode_2050.txt": {"score": 0.91939377784729, "content": {"text": "def count_good_digit_strings(n):\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.\"\"\"\n\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total"}}, "leetcode/leetcode_2039.txt": {"score": 0.9248713254928589, "content": {"text": "def sumGame(num: str) -> bool:\n    \"\"\"There is a network of `n` servers, labeled from `0` to `n - 1`. You are given a 2D integer array `edges`, where `edges[i] = [ui, vi]` indicates there is a message channel between servers `ui` and `vi`, and they can pass **any** number of messages to **each other** directly in **one** second. You are also given a **0-indexed** integer array `patience` of length `n`.\n\nAll servers are **connected**, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.\n\nThe server labeled `0` is the **master** server. The rest are **data** servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers **optimally**, so every message takes the **least amount of time** to arrive at the master server. The master server will process all newly arrived messages **instantly** and send a reply to the originating server via the **reversed path** the message had gone through.\n\nAt the beginning of second `0`, each data server sends its message to be processed. Starting from second `1`, at the **beginning** of **every** second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:\n\n*   If it has not, it will **resend** the message periodically. The data server `i` will resend the message every `patience[i]` second(s), i.e., the data server `i` will resend the message if `patience[i]` second(s) have **elapsed** since the **last** time the message was sent from this server.\n*   Otherwise, **no more resending** will occur from this server.\n\nThe network becomes **idle** when there are **no** messages passing between servers or arriving at servers.\n\nReturn _the **earliest second** starting from which the network becomes **idle**_.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\]\\], patience = \\[0,2,1\\]\n**Output:** 8\n**Explanation:**\nAt (the beginning of) second 0,\n- Data server 1 sends its message (denoted 1A) to the master server.\n- Data server 2 sends its message (denoted 2A) to the master server.\n\nAt second 1,\n- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n- Server 1 has not received any reply. 1 second (1 < patience\\[1\\] = 2) elapsed since this server has sent the message, therefore it does not resend the message.\n- Server 2 has not received any reply. 1 second (1 == patience\\[2\\] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).\n\nAt second 2,\n- The reply 1A arrives at server 1. No more resending will occur from server 1.\n- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n- Server 2 resends the message (denoted 2C).\n...\nAt second 4,\n- The reply 2A arrives at server 2. No more resending will occur from server 2.\n...\nAt second 7, reply 2D arrives at server 2.\n\nStarting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.\nThis is the time when the network becomes idle.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\],\\[0,2\\],\\[1,2\\]\\], patience = \\[0,10,10\\]\n**Output:** 3\n**Explanation:** Data servers 1 and 2 receive a reply back at the beginning of second 2.\nFrom the beginning of the second 3, the network becomes idle.\n\n**Constraints:**\n\n*   `n == patience.length`\n*   `2 <= n <= 105`\n*   `patience[0] == 0`\n*   `1 <= patience[i] <= 105` for `1 <= i < n`\n*   `1 <= edges.length <= min(105, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `0 <= ui, vi < n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each server can directly or indirectly reach another server.\"\"\"\n\n    n = len(num)\n    sum1, sum2, cnt1, cnt2 = 0, 0, 0, 0\n\n    for i in range(n // 2):\n        if num[i] == '?': cnt1 += 1\n        else: sum1 += int(num[i])\n\n    for i in range(n // 2, n):\n        if num[i] == '?': cnt2 += 1\n        else: sum2 += int(num[i])\n\n    return (sum1 - sum2) != ((cnt2 - cnt1) // 2) * 9"}}, "leetcode/leetcode_1916.txt": {"score": 0.9196661114692688, "content": {"text": "def findCenter(edges):\n    \"\"\"You are an ant tasked with adding `n` new rooms numbered `0` to `n-1` to your colony. You are given the expansion plan as a **0-indexed** integer array of length `n`, `prevRoom`, where `prevRoom[i]` indicates that you must build room `prevRoom[i]` before building room `i`, and these two rooms must be connected **directly**. Room `0` is already built, so `prevRoom[0] = -1`. The expansion plan is given such that once all the rooms are built, every room will be reachable from room `0`.\n\nYou can only build **one room** at a time, and you can travel freely between rooms you have **already built** only if they are **connected**. You can choose to build **any room** as long as its **previous room** is already built.\n\nReturn _the **number of different orders** you can build all the rooms in_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** prevRoom = \\[-1,0,1\\]\n**Output:** 1\n**Explanation:** There is only one way to build the additional rooms: 0 -> 1 -> 2\n\n**Example 2:**\n\n**Input:** prevRoom = \\[-1,0,0,1,2\\]\n**Output:** 6\n**Explanation:**\nThe 6 ways are:\n0 -> 1 -> 3 -> 2 -> 4\n0 -> 2 -> 4 -> 1 -> 3\n0 -> 1 -> 2 -> 3 -> 4\n0 -> 1 -> 2 -> 4 -> 3\n0 -> 2 -> 1 -> 3 -> 4\n0 -> 2 -> 1 -> 4 -> 3\n\n**Constraints:**\n\n*   `n == prevRoom.length`\n*   `2 <= n <= 105`\n*   `prevRoom[0] == -1`\n*   `0 <= prevRoom[i] < n` for all `1 <= i < n`\n*   Every room is reachable from room `0` once all the rooms are built.\"\"\"\n\n    if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1]:\n        return edges[0][0]\n    return edges[0][1]"}}, "leetcode/leetcode_882.txt": {"score": 0.9865153431892395, "content": {"text": "def peakIndexInMountainArray(arr):\n    \"\"\"You are given an undirected graph (the **\"original graph \"**) with `n` nodes labeled from `0` to `n - 1`. You decide to **subdivide** each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.\n\nThe graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]` indicates that there is an edge between nodes `ui` and `vi` in the original graph, and `cnti` is the total number of new nodes that you will **subdivide** the edge into. Note that `cnti == 0` means you will not subdivide the edge.\n\nTo **subdivide** the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and `cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti-1, xcnti]`, `[xcnti, vi]`.\n\nIn this **new graph**, you want to know how many nodes are **reachable** from the node `0`, where a node is **reachable** if the distance is `maxMoves` or less.\n\nGiven the original graph and `maxMoves`, return _the number of nodes that are **reachable** from node_ `0` _in the new graph_.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1,10\\],\\[0,2,1\\],\\[1,2,2\\]\\], maxMoves = 6, n = 3\n**Output:** 13\n**Explanation:** The edge subdivisions are shown in the image above.\nThe nodes that are reachable are highlighted in yellow.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1,4\\],\\[1,2,6\\],\\[0,2,8\\],\\[1,3,1\\]\\], maxMoves = 10, n = 4\n**Output:** 23\n\n**Example 3:**\n\n**Input:** edges = \\[\\[1,2,4\\],\\[1,4,5\\],\\[1,3,1\\],\\[2,3,4\\],\\[3,4,5\\]\\], maxMoves = 17, n = 5\n**Output:** 1\n**Explanation:** Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.\n\n**Constraints:**\n\n*   `0 <= edges.length <= min(n * (n - 1) / 2, 104)`\n*   `edges[i].length == 3`\n*   `0 <= ui < vi < n`\n*   There are **no multiple edges** in the graph.\n*   `0 <= cnti <= 104`\n*   `0 <= maxMoves <= 109`\n*   `1 <= n <= 3000`\"\"\"\n\n    low, high = 0, len(arr) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if arr[mid] < arr[mid + 1]:\n            low = mid + 1\n        else:\n            high = mid\n    return low"}}, "leetcode/leetcode_1129.txt": {"score": 0.9204667806625366, "content": {"text": "def longestStrChain(words):\n    \"\"\"You are given an integer `n`, the number of nodes in a directed graph where the nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n\nYou are given two arrays `redEdges` and `blueEdges` where:\n\n*   `redEdges[i] = [ai, bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph, and\n*   `blueEdges[j] = [uj, vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.\n\nReturn an array `answer` of length `n`, where each `answer[x]` is the length of the shortest path from node `0` to node `x` such that the edge colors alternate along the path, or `-1` if such a path does not exist.\n\n**Example 1:**\n\n**Input:** n = 3, redEdges = \\[\\[0,1\\],\\[1,2\\]\\], blueEdges = \\[\\]\n**Output:** \\[0,1,-1\\]\n\n**Example 2:**\n\n**Input:** n = 3, redEdges = \\[\\[0,1\\]\\], blueEdges = \\[\\[2,1\\]\\]\n**Output:** \\[0,1,-1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= redEdges.length, blueEdges.length <= 400`\n*   `redEdges[i].length == blueEdges[j].length == 2`\n*   `0 <= ai, bi, uj, vj < n`\"\"\"\n\n    words.sort(key=lambda x: len(x))\n    dp = {}\n\n    max_len = 0\n    for word in words:\n        for i in range(len(word)):\n            pre = word[:i] + word[i + 1:]\n            dp[word] = max(dp.get(word, 0), dp.get(pre, 0) + 1)\n        max_len = max(max_len, dp[word])\n\n    return max_len"}}, "leetcode/leetcode_2368.txt": {"score": 0.9221357107162476, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an undirected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an integer array `restricted` which represents **restricted** nodes.\n\nReturn _the **maximum** number of nodes you can reach from node_ `0` _without visiting a restricted node._\n\nNote that node `0` will **not** be a restricted node.\n\n**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,1\\],\\[4,0\\],\\[0,5\\],\\[5,6\\]\\], restricted = \\[4,5\\]\n**Output:** 4\n**Explanation:** The diagram above shows the tree.\nWe have that \\[0,1,2,3\\] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[0,2\\],\\[0,5\\],\\[0,4\\],\\[3,2\\],\\[6,5\\]\\], restricted = \\[4,2,1\\]\n**Output:** 3\n**Explanation:** The diagram above shows the tree.\nWe have that \\[0,5,6\\] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\n*   `1 <= restricted.length < n`\n*   `1 <= restricted[i] < n`\n*   All the values of `restricted` are **unique**.\"\"\"\n\n\ndef max_nodes_without_restricted(n, edges, restricted):\n    tree = defaultdict(list)\n    blocked_nodes = set(restricted)\n\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    max_nodes = [0]\n\n    def dfs(node, depth, parent):\n        if node in blocked_nodes:\n            return\n        max_nodes[0] = max(max_nodes[0], depth)\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, depth + 1, node)\n\n    dfs(0, 1, -1)\n    return max_nodes[0]"}}}}, "46": {"gold": {"leetcode/leetcode_54.txt": 1, "leetcode/leetcode_59.txt": 1, "leetcode/leetcode_2326.txt": 1}, "retrieved": {"leetcode/csn_python_train_338935.txt": {"score": 0.8827192783355713, "content": {"text": "def walk_perimeter(self, startx, starty):\n        \"\"\"\n        Starting at a point on the perimeter of a region, 'walk' the perimeter to return\n        to the starting point. Record the path taken.\n\n        Parameters\n        ----------\n        startx, starty : int\n            The starting location. Assumed to be on the perimeter of a region.\n\n        Returns\n        -------\n        perimeter : list\n            A list of pixel coordinates [ [x1,y1], ...] that constitute the perimeter of the region.\n        \"\"\"\n        # checks\n        startx = max(startx, 0)\n        startx = min(startx, self.xsize)\n        starty = max(starty, 0)\n        starty = min(starty, self.ysize)\n\n        points = []\n\n        x, y = startx, starty\n\n        while True:\n            self.step(x, y)\n            if 0 <= x <= self.xsize and 0 <= y <= self.ysize:\n                points.append((x, y))\n            if self.next == self.UP:\n                y -= 1\n            elif self.next == self.LEFT:\n                x -= 1\n            elif self.next == self.DOWN:\n                y += 1\n            elif self.next == self.RIGHT:\n                x += 1\n            # stop if we meet some kind of error\n            elif self.next == self.NOWHERE:\n                break\n            # stop when we return to the starting location\n            if x == startx and y == starty:\n                break\n        return points"}}, "leetcode/leetcode_1424.txt": {"score": 0.8851612210273743, "content": {"text": "from collections import deque\n    \"\"\"Given a 2D integer array `nums`, return _all elements of_ `nums` _in diagonal order as shown in the below images_.\n\n**Example 1:**\n\n**Input:** nums = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[1,4,2,7,5,3,8,6,9\\]\n\n**Example 2:**\n\n**Input:** nums = \\[\\[1,2,3,4,5\\],\\[6,7\\],\\[8\\],\\[9,10,11\\],\\[12,13,14,15,16\\]\\]\n**Output:** \\[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i].length <= 105`\n*   `1 <= sum(nums[i].length) <= 105`\n*   `1 <= nums[i][j] <= 105`\"\"\"\n\n\ndef maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    max_candies = 0\n    visited = set()\n    to_process = deque(initialBoxes)\n\n    while to_process:\n        box = to_process.popleft()\n\n        if box in visited:\n            continue\n\n        visited.add(box)\n\n        if status[box]:\n            max_candies += candies[box]\n            for key in keys[box]:\n                status[key] = 1\n                if key in visited:\n                    to_process.append(key)\n            for contained in containedBoxes[box]:\n                to_process.append(contained)\n        else:\n            to_process.append(box)\n\n    return max_candies"}}, "leetcode/leetcode_59.txt": {"score": 0.895143449306488, "content": {"text": "def generateMatrix(n: int) -> List[List[int]]:\n    \"\"\"Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\\[1,2,3\\],\\[8,9,4\\],\\[7,6,5\\]\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 20`\"\"\"\n\n    matrix = [[0] * n for _ in range(n)]\n    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1\n\n    while value <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = value\n            value += 1\n\n        for i in range(top + 1, bottom + 1):\n            matrix[i][right] = value\n            value += 1\n\n        if top < bottom and left < right:\n            for i in range(right - 1, left - 1, -1):\n                matrix[bottom][i] = value\n                value += 1\n\n            for i in range(bottom - 1, top, -1):\n                matrix[i][left] = value\n                value += 1\n\n        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1\n\n    return matrix"}}, "leetcode/csn_python_train_144105.txt": {"score": 0.8875166773796082, "content": {"text": "def hilbert_chip_order(machine):\n    \"\"\"A generator which iterates over a set of chips in a machine in a hilbert\n    path.\n\n    For use as a chip ordering for the sequential placer.\n    \"\"\"\n    max_dimen = max(machine.width, machine.height)\n    hilbert_levels = int(ceil(log(max_dimen, 2.0))) if max_dimen >= 1 else 0\n    return hilbert(hilbert_levels)"}}, "leetcode/csn_python_train_245873.txt": {"score": 0.9168672561645508, "content": {"text": "def concentric_rectangle_path(size):\n    \"\"\"\n    Creates a generator for progressing through an image\n    :param size: A tuple (width, height) of the image size\n    :return: A generator that yields a set of rows through the image.\n    Each row is a generator that yields pixel coordinates.\n    \"\"\"\n\n    def conc_rect_iter():\n        for x in range(min_x, max_x):\n            yield (x, min_y)\n        # if rectangle only has height of 1, prevent path from doubling back along x\n        if min_y + 1 == max_y:\n            return\n        for y in range(min_y + 1, max_y):\n            yield (max_x - 1, y)\n        for x in range(max_x - 2, min_x - 1, -1):\n            yield (x, max_y - 1)\n        for y in range(max_y - 2, min_y, -1):\n            yield (min_x, y)\n\n    width, height = size\n    min_x, max_x = 0, width\n    min_y, max_y = 0, height\n\n    while min_x < max_x and min_y < max_y:\n        yield conc_rect_iter()\n\n        min_x += 1\n        min_y += 1\n        max_x -= 1\n        max_y -= 1"}}, "leetcode/leetcode_980.txt": {"score": 0.8981775641441345, "content": {"text": "from itertools import permutations\n    \"\"\"You are given an `m x n` integer array `grid` where `grid[i][j]` could be:\n\n*   `1` representing the starting square. There is exactly one starting square.\n*   `2` representing the ending square. There is exactly one ending square.\n*   `0` representing empty squares we can walk over.\n*   `-1` representing obstacles that we cannot walk over.\n\nReturn _the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,0,0,0\\],\\[0,0,2,-1\\]\\]\n**Output:** 2\n**Explanation:** We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,0,0,0\\],\\[0,0,0,2\\]\\]\n**Output:** 4\n**Explanation:** We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,1\\],\\[2,0\\]\\]\n**Output:** 0\n**Explanation:** There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 20`\n*   `1 <= m * n <= 20`\n*   `-1 <= grid[i][j] <= 2`\n*   There is exactly one starting cell and one ending cell.\"\"\"\n\n\ndef smallestSuperstring(words):\n    def get_shared_length(a, b):\n        for shared_length in range(min(len(a), len(b)), 0, -1):\n            if a[-shared_length:] == b[:shared_length]:\n                return shared_length\n        return 0\n\n    def merge(a, b, shared_length):\n        return a + b[shared_length:]\n\n    def get_total_length(merged_words):\n        return sum(len(word) for word in merged_words)\n\n    best = None\n    for perm in permutations(words):\n        merged_words = list(perm)\n        for i in range(len(words) - 1):\n            shared_length = get_shared_length(merged_words[i], merged_words[i + 1])\n            merged_words[i + 1] = merge(merged_words[i], merged_words[i + 1], shared_length)\n        if best is None or get_total_length(merged_words) < len(best):\n            best = \"\".join(merged_words)\n\n    return best"}}, "leetcode/csn_python_train_200484.txt": {"score": 0.9110650420188904, "content": {"text": "def _rspiral(width, height):\n        \"\"\"Reversed spiral generator.\n\n        Parameters\n        ----------\n        width : `int`\n            Spiral width.\n        height : `int`\n            Spiral height.\n\n        Returns\n        -------\n        `generator` of (`int`, `int`)\n            Points.\n        \"\"\"\n\n        x0 = 0\n        y0 = 0\n        x1 = width - 1\n        y1 = height - 1\n\n        while x0 < x1 and y0 < y1:\n            for x in range(x0, x1):\n                yield x, y0\n            for y in range(y0, y1):\n                yield x1, y\n            for x in range(x1, x0, -1):\n                yield x, y1\n            for y in range(y1, y0, -1):\n                yield x0, y\n\n            x0 += 1\n            y0 += 1\n            x1 -= 1\n            y1 -= 1\n\n        if x0 == x1:\n            for y in range(y0, y1 + 1):\n                yield x0, y\n        elif y0 == y1:\n            for x in range(x0, x1 + 1):\n                yield x, y0"}}, "leetcode/leetcode_885.txt": {"score": 0.9937114119529724, "content": {"text": "from bisect import bisect_left, insort_left\n    \"\"\"You start at the cell `(rStart, cStart)` of an `rows x cols` grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\n\nYou will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all `rows * cols` spaces of the grid.\n\nReturn _an array of coordinates representing the positions of the grid in the order you visited them_.\n\n**Example 1:**\n\n**Input:** rows = 1, cols = 4, rStart = 0, cStart = 0\n**Output:** \\[\\[0,0\\],\\[0,1\\],\\[0,2\\],\\[0,3\\]\\]\n\n**Example 2:**\n\n**Input:** rows = 5, cols = 6, rStart = 1, cStart = 4\n**Output:** \\[\\[1,4\\],\\[1,5\\],\\[2,5\\],\\[2,4\\],\\[2,3\\],\\[1,3\\],\\[0,3\\],\\[0,4\\],\\[0,5\\],\\[3,5\\],\\[3,4\\],\\[3,3\\],\\[3,2\\],\\[2,2\\],\\[1,2\\],\\[0,2\\],\\[4,5\\],\\[4,4\\],\\[4,3\\],\\[4,2\\],\\[4,1\\],\\[3,1\\],\\[2,1\\],\\[1,1\\],\\[0,1\\],\\[4,0\\],\\[3,0\\],\\[2,0\\],\\[1,0\\],\\[0,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 100`\n*   `0 <= rStart < rows`\n*   `0 <= cStart < cols`\"\"\"\n\n\nclass ExamRoom:\n\n    def __init__(self, n: int):\n        self.students = []\n        self.n = n\n\n    def seat(self) -> int:\n        if not self.students:\n            seat_index = 0\n        else:\n            distance, seat_index = self.students[0], 0\n            \n            for i in range(1, len(self.students)):\n                d = (self.students[i] - self.students[i - 1]) // 2\n                if d > distance:\n                    distance = d\n                    seat_index = self.students[i - 1] + d\n                    \n            if self.n - 1 - self.students[-1] > distance:\n                seat_index = self.n - 1\n                \n        insort_left(self.students, seat_index)\n        return seat_index\n\n    def leave(self, p: int) -> None:\n        index = bisect_left(self.students, p)\n        self.students.pop(index)"}}, "leetcode/csn_python_train_200485.txt": {"score": 0.8959381580352783, "content": {"text": "def _spiral(width, height):\n        \"\"\"Spiral generator.\n\n        Parameters\n        ----------\n        width : `int`\n            Spiral width.\n        height : `int`\n            Spiral height.\n\n        Returns\n        -------\n        `generator` of (`int`, `int`)\n            Points.\n        \"\"\"\n\n        if width == 1:\n            for y in range(height - 1, -1, -1):\n                yield 0, y\n            return\n        if height == 1:\n            for x in range(width - 1, -1, -1):\n                yield x, 0\n            return\n\n        if width <= height:\n            x0 = width // 2\n            if width % 2:\n                for y in range(height - 1 - x0, x0 - 1, -1):\n                    yield x0, y\n            x0 -= 1\n            y0 = x0\n        else:\n            y0 = height // 2\n            if height % 2:\n                for x in range(width - 1 - y0, y0 - 1, -1):\n                    yield x, y0\n            y0 -= 1\n            x0 = y0\n\n        while x0 >= 0:\n            x1 = width - x0 - 1\n            y1 = height - y0 - 1\n\n            for y in range(y0 + 1, y1):\n                yield x0, y\n            for x in range(x0, x1):\n                yield x, y1\n            for y in range(y1, y0, -1):\n                yield x1, y\n            for x in range(x1, x0 - 1, -1):\n                yield x, y0\n\n            x0 -= 1\n            y0 -= 1"}}, "leetcode/leetcode_54.txt": {"score": 0.9615174531936646, "content": {"text": "def spiralOrder(matrix):\n    \"\"\"Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[1,2,3,6,9,8,7,4,5\\]\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[1,2,3,4\\],\\[5,6,7,8\\],\\[9,10,11,12\\]\\]\n**Output:** \\[1,2,3,4,8,12,11,10,9,5,6,7\\]\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 10`\n*   `-100 <= matrix[i][j] <= 100`\"\"\"\n\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result"}}}}, "47": {"gold": {"leetcode/leetcode_2401.txt": 1}, "retrieved": {"leetcode/leetcode_455.txt": {"score": 0.9270944595336914, "content": {"text": "def find_content_children(g, s):\n    \"\"\"Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n**Example 1:**\n\n**Input:** g = \\[1,2,3\\], s = \\[1,1\\]\n**Output:** 1\n**Explanation:** You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n**Example 2:**\n\n**Input:** g = \\[1,2\\], s = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n\n**Constraints:**\n\n*   `1 <= g.length <= 3 * 104`\n*   `0 <= s.length <= 3 * 104`\n*   `1 <= g[i], s[j] <= 231 - 1`\"\"\"\n\n    g.sort()\n    s.sort()\n    i = j = 0\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n\n        j += 1\n\n    return i"}}, "leetcode/leetcode_2398.txt": {"score": 0.9281724095344543, "content": {"text": "def max_consecutive_robots(charge_times, running_costs, budget):\n    \"\"\"You have `n` robots. You are given two **0-indexed** integer arrays, `chargeTimes` and `runningCosts`, both of length `n`. The `ith` robot costs `chargeTimes[i]` units to charge and costs `runningCosts[i]` units to run. You are also given an integer `budget`.\n\nThe **total cost** of running `k` chosen robots is equal to `max(chargeTimes) + k * sum(runningCosts)`, where `max(chargeTimes)` is the largest charge cost among the `k` robots and `sum(runningCosts)` is the sum of running costs among the `k` robots.\n\nReturn _the **maximum** number of **consecutive** robots you can run such that the total cost **does not** exceed_ `budget`.\n\n**Example 1:**\n\n**Input:** chargeTimes = \\[3,6,1,3,4\\], runningCosts = \\[2,1,3,4,5\\], budget = 25\n**Output:** 3\n**Explanation:** \nIt is possible to run all individual and consecutive pairs of robots within budget.\nTo obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 \\* sum(2,1,3) = 6 + 3 \\* 6 = 24 which is less than 25.\nIt can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.\n\n**Example 2:**\n\n**Input:** chargeTimes = \\[11,12,19\\], runningCosts = \\[10,8,7\\], budget = 19\n**Output:** 0\n**Explanation:** No robot can be run that does not exceed the budget, so we return 0.\n\n**Constraints:**\n\n*   `chargeTimes.length == runningCosts.length == n`\n*   `1 <= n <= 5 * 104`\n*   `1 <= chargeTimes[i], runningCosts[i] <= 105`\n*   `1 <= budget <= 1015`\"\"\"\n\n    n = len(charge_times)\n    max_robots = 0\n    for i in range(n):\n        max_charge = 0\n        running_sum = 0\n        for j in range(i, n):\n            max_charge = max(max_charge, charge_times[j])\n            running_sum += running_costs[j]\n            cost = max_charge + running_sum * (j - i + 1)\n            if cost <= budget:\n                max_robots = max(max_robots, j - i + 1)\n            else:\n                break\n    return max_robots"}}, "leetcode/leetcode_1751.txt": {"score": 0.9273765683174133, "content": {"text": "def slowestKey(releaseTimes, keysPressed):\n    \"\"\"You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn _the **maximum sum** of values that you can receive by attending events._\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,1\\]\\], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,10\\]\\], k = 2\n**Output:** 10\n**Explanation:** Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,1,1\\],\\[2,2,2\\],\\[3,3,3\\],\\[4,4,4\\]\\], k = 3\n**Output:** 9\n**Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n**Constraints:**\n\n*   `1 <= k <= events.length`\n*   `1 <= k * events.length <= 106`\n*   `1 <= startDayi <= endDayi <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    max_key = keysPressed[0]\n    max_duration = releaseTimes[0]\n    for i in range(1, len(releaseTimes)):\n        duration = releaseTimes[i] - releaseTimes[i - 1]\n        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):\n            max_key = keysPressed[i]\n            max_duration = duration\n    return max_key"}}, "leetcode/leetcode_630.txt": {"score": 0.9283705949783325, "content": {"text": "import heapq\n    \"\"\"There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`.\n\nYou will start on the `1st` day and you cannot take two or more courses simultaneously.\n\nReturn _the maximum number of courses that you can take_.\n\n**Example 1:**\n\n**Input:** courses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]\n**Output:** 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n\n**Example 2:**\n\n**Input:** courses = \\[\\[1,2\\]\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** courses = \\[\\[3,2\\],\\[4,3\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= courses.length <= 104`\n*   `1 <= durationi, lastDayi <= 104`\"\"\"\n\n\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    curr_time, duration_sum = 0, []\n\n    for duration, deadline in courses:\n        curr_time += duration\n        heapq.heappush(duration_sum, -duration)\n\n        if curr_time > deadline:\n            curr_time += heapq.heappop(duration_sum)\n\n    return len(duration_sum)"}}, "leetcode/leetcode_2106.txt": {"score": 0.9291479587554932, "content": {"text": "from math import gcd\n    \"\"\"Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\nReturn _the **maximum total number** of fruits you can harvest_.\n\n**Example 1:**\n\n**Input:** fruits = \\[\\[2,8\\],\\[6,3\\],\\[8,6\\]\\], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n**Example 2:**\n\n**Input:** fruits = \\[\\[0,9\\],\\[4,1\\],\\[5,7\\],\\[6,2\\],\\[7,4\\],\\[10,9\\]\\], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n**Example 3:**\n\n**Input:** fruits = \\[\\[0,3\\],\\[6,4\\],\\[8,5\\]\\], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `fruits[i].length == 2`\n*   `0 <= startPos, positioni <= 2 * 105`\n*   `positioni-1 < positioni` for any `i > 0` (**0-indexed**)\n*   `1 <= amounti <= 104`\n*   `0 <= k <= 2 * 105`\"\"\"\n\n\ndef findGCD(nums):\n    return gcd(min(nums), max(nums))"}}, "leetcode/leetcode_2105.txt": {"score": 0.9346882700920105, "content": {"text": "def numberOfGoodSubsets(nums: list[int]) -> int:\n    \"\"\"Alice and Bob want to water `n` plants in their garden. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`.\n\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, **initially full**. They water the plants in the following way:\n\n*   Alice waters the plants in order from **left to right**, starting from the `0th` plant. Bob waters the plants in order from **right to left**, starting from the `(n - 1)th` plant. They begin watering the plants **simultaneously**.\n*   It takes the same amount of time to water each plant regardless of how much water it needs.\n*   Alice/Bob **must** water the plant if they have enough in their can to **fully** water it. Otherwise, they **first** refill their can (instantaneously) then water the plant.\n*   In case both Alice and Bob reach the same plant, the one with **more** water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a **0-indexed** integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and two integers `capacityA` and `capacityB` representing the capacities of Alice's and Bob's watering cans respectively, return _the **number of times** they have to refill to water all the plants_.\n\n**Example 1:**\n\n**Input:** plants = \\[2,2,3,3\\], capacityA = 5, capacityB = 5\n**Output:** 1\n**Explanation:**\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.\n\n**Example 2:**\n\n**Input:** plants = \\[2,2,3,3\\], capacityA = 3, capacityB = 4\n**Output:** 2\n**Explanation:**\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.\n\n**Example 3:**\n\n**Input:** plants = \\[5\\], capacityA = 10, capacityB = 8\n**Output:** 0\n**Explanation:**\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0.\n\n**Constraints:**\n\n*   `n == plants.length`\n*   `1 <= n <= 105`\n*   `1 <= plants[i] <= 106`\n*   `max(plants[i]) <= capacityA, capacityB <= 109`\"\"\"\n\n    MOD = 10**9 + 7\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, 91) if is_prime(i)]\n    cnt = [0] * 100\n    for n in nums:\n        cnt[n] += 1\n\n    dp = [0] * (1 << 20)\n    dp[0] = 1\n    \n    for i in range(30, 0, -1):\n        if cnt[i] == 0:\n            continue\n        mask = [j for j in primes if i % j == 0]\n        i = i // j\n        if i > 1:\n            continue\n\n        m = 0\n        for j in mask:\n            m |= 1 << (j - 2)\n\n        for j in range(len(dp)-1, -1, -1):\n            if dp[j] == 0:\n                continue\n            cur = 1\n            for k in range(cnt[m]):\n                cur = (cur * 2) % MOD\n                dp[j | m] = (dp[j | m] + dp[j] * cur) % MOD\n\n    ans = sum(dp) % MOD\n    ans = (ans - dp[0] + MOD) % MOD\n    return (ans * (1 << (cnt[1] - 1))) % MOD"}}, "leetcode/leetcode_1642.txt": {"score": 0.9276142716407776, "content": {"text": "def maxWaterBottles(numBottles: int, numExchange: int) -> int:\n    \"\"\"You are given an integer array `heights` representing the heights of buildings, some `bricks`, and some `ladders`.\n\nYou start your journey from building `0` and move to the next building by possibly using bricks or ladders.\n\nWhile moving from building `i` to building `i+1` (**0-indexed**),\n\n*   If the current building's height is **greater than or equal** to the next building's height, you do **not** need a ladder or bricks.\n*   If the current building's height is **less than** the next building's height, you can either use **one ladder** or `(h[i+1] - h[i])` **bricks**.\n\n_Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally._\n\n**Example 1:**\n\n**Input:** heights = \\[4,2,7,6,9,14,12\\], bricks = 5, ladders = 1\n**Output:** 4\n**Explanation:** Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n**Example 2:**\n\n**Input:** heights = \\[4,12,2,7,3,18,20,3,19\\], bricks = 10, ladders = 2\n**Output:** 7\n\n**Example 3:**\n\n**Input:** heights = \\[14,3,19,3\\], bricks = 17, ladders = 0\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `1 <= heights[i] <= 106`\n*   `0 <= bricks <= 109`\n*   `0 <= ladders <= heights.length`\"\"\"\n\n    total = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        total += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return total"}}, "leetcode/leetcode_1705.txt": {"score": 0.9360844492912292, "content": {"text": "def unhappyFriends(n, preferences, pairs):\n    \"\"\"There is a special kind of apple tree that grows apples every day for `n` days. On the `ith` day, the tree grows `apples[i]` apples that will rot after `days[i]` days, that is on day `i + days[i]` the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by `apples[i] == 0` and `days[i] == 0`.\n\nYou decided to eat **at most** one apple a day (to keep the doctors away). Note that you can keep eating after the first `n` days.\n\nGiven two integer arrays `days` and `apples` of length `n`, return _the maximum number of apples you can eat._\n\n**Example 1:**\n\n**Input:** apples = \\[1,2,3,5,2\\], days = \\[3,2,1,4,2\\]\n**Output:** 7\n**Explanation:** You can eat 7 apples:\n- On the first day, you eat an apple that grew on the first day.\n- On the second day, you eat an apple that grew on the second day.\n- On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.\n- On the fourth to the seventh days, you eat apples that grew on the fourth day.\n\n**Example 2:**\n\n**Input:** apples = \\[3,0,0,0,0,2\\], days = \\[3,0,0,0,0,2\\]\n**Output:** 5\n**Explanation:** You can eat 5 apples:\n- On the first to the third day you eat apples that grew on the first day.\n- Do nothing on the fouth and fifth days.\n- On the sixth and seventh days you eat apples that grew on the sixth day.\n\n**Constraints:**\n\n*   `n == apples.length == days.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= apples[i], days[i] <= 2 * 104`\n*   `days[i] = 0` if and only if `apples[i] = 0`.\"\"\"\n\n    pair_mapping = [0] * n\n    for pair in pairs:\n        pair_mapping[pair[0]] = pair[1]\n        pair_mapping[pair[1]] = pair[0]\n\n    unhappy_count = 0\n    for x in range(n):\n        y = pair_mapping[x]\n        pref_x = preferences[x]\n        idx_y = pref_x.index(y)\n\n        for i in range(idx_y):\n            u = pref_x[i]\n            v = pair_mapping[u]\n            pref_u = preferences[u]\n            if x in pref_u[:pref_u.index(v)]:\n                unhappy_count += 1\n                break\n\n    return unhappy_count // 2"}}, "leetcode/leetcode_2279.txt": {"score": 0.9456788301467896, "content": {"text": "def max_unique_even_sum(final_sum):\n    \"\"\"You have `n` bags numbered from `0` to `n - 1`. You are given two **0-indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in **any** of the bags.\n\nReturn _the **maximum** number of bags that could have full capacity after placing the additional rocks in some bags._\n\n**Example 1:**\n\n**Input:** capacity = \\[2,3,4,5\\], rocks = \\[1,2,4,4\\], additionalRocks = 2\n**Output:** 3\n**Explanation:**\nPlace 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now \\[2,3,4,4\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3.\n\n**Example 2:**\n\n**Input:** capacity = \\[10,2,2\\], rocks = \\[2,2,0\\], additionalRocks = 100\n**Output:** 3\n**Explanation:**\nPlace 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now \\[10,2,2\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks.\n\n**Constraints:**\n\n*   `n == capacity.length == rocks.length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= capacity[i] <= 109`\n*   `0 <= rocks[i] <= capacity[i]`\n*   `1 <= additionalRocks <= 109`\"\"\"\n\n    result = []\n    current = 2\n    while final_sum > 0:\n        if final_sum >= current:\n            result.append(current)\n            final_sum -= current\n            current += 2\n        else:\n            break\n    return result"}}, "leetcode/leetcode_904.txt": {"score": 0.9652166962623596, "content": {"text": "def leafSimilar(root1, root2):\n    \"\"\"You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the **type** of fruit the `ith` tree produces.\n\nYou want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\n\n*   You only have **two** baskets, and each basket can only hold a **single type** of fruit. There is no limit on the amount of fruit each basket can hold.\n*   Starting from any tree of your choice, you must pick **exactly one fruit** from **every** tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\n*   Once you reach a tree with fruit that cannot fit in your baskets, you must stop.\n\nGiven the integer array `fruits`, return _the **maximum** number of fruits you can pick_.\n\n**Example 1:**\n\n**Input:** fruits = \\[1,2,1\\]\n**Output:** 3\n**Explanation:** We can pick from all 3 trees.\n\n**Example 2:**\n\n**Input:** fruits = \\[0,1,2,2\\]\n**Output:** 3\n**Explanation:** We can pick from trees \\[1,2,2\\].\nIf we had started at the first tree, we would only pick from trees \\[0,1\\].\n\n**Example 3:**\n\n**Input:** fruits = \\[1,2,3,2,2\\]\n**Output:** 4\n**Explanation:** We can pick from trees \\[2,3,2,2\\].\nIf we had started at the first tree, we would only pick from trees \\[1,2\\].\n\n**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `0 <= fruits[i] < fruits.length`\"\"\"\n\n    def getLeaves(node):\n        if not node:\n            return []\n        if not node.left and not node.right:\n            return [node.val]\n        return getLeaves(node.left) + getLeaves(node.right)\n\n    return getLeaves(root1) == getLeaves(root2)"}}}}, "48": {"gold": {"leetcode/leetcode_1728.txt": 1}, "retrieved": {"leetcode/leetcode_1559.txt": {"score": 0.9075347781181335, "content": {"text": "def cherry_pickup(grid):\n    \"\"\"Given a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the **same value** in `grid`.\n\nA cycle is a path of **length 4 or more** in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the **same value** of the current cell.\n\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.\n\nReturn `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[ \"a \", \"a \", \"a \", \"a \"\\],\\[ \"a \", \"b \", \"b \", \"a \"\\],\\[ \"a \", \"b \", \"b \", \"a \"\\],\\[ \"a \", \"a \", \"a \", \"a \"\\]\\]\n**Output:** true\n**Explanation:** There are two valid cycles shown in different colors in the image below:\n \n\n**Example 2:**\n\n**Input:** grid = \\[\\[ \"c \", \"c \", \"c \", \"a \"\\],\\[ \"c \", \"d \", \"c \", \"c \"\\],\\[ \"c \", \"c \", \"e \", \"c \"\\],\\[ \"f \", \"c \", \"c \", \"c \"\\]\\]\n**Output:** true\n**Explanation:** There is only one valid cycle highlighted in the image below:\n \n\n**Example 3:**\n\n**Input:** grid = \\[\\[ \"a \", \"b \", \"b \"\\],\\[ \"b \", \"z \", \"b \"\\],\\[ \"b \", \"b \", \"a \"\\]\\]\n**Output:** false\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid` consists only of lowercase English letters.\"\"\"\n\n    rows, cols = len(grid), len(grid[0])\n    dp = [[[0] * cols for _ in range(cols)] for _ in range(rows)]\n\n    for row in reversed(range(rows)):\n        for col1 in range(cols):\n            for col2 in range(cols):\n                current_cell = dp[row + 1][col1][col2] if row < rows - 1 else 0\n                current_cell += grid[row][col1] + (grid[row][col2] if col1 != col2 else 0)\n\n                max_val = 0\n                for move1 in range(-1, 2):\n                    for move2 in range(-1, 2):\n                        new_col1, new_col2 = col1 + move1, col2 + move2\n                        if 0 <= new_col1 < cols and 0 <= new_col2 < cols:\n                            max_val = max(max_val, dp[row][new_col1][new_col2])\n\n                dp[row][col1][col2] = current_cell + max_val\n\n    return dp[0][0][cols - 1]"}}, "leetcode/leetcode_1568.txt": {"score": 0.9082546234130859, "content": {"text": "def pseudoPalindromicPaths(root, cnt = 0):\n    \"\"\"You are given an `m x n` binary grid `grid` where `1` represents land and `0` represents water. An **island** is a maximal **4-directionally** (horizontal or vertical) connected group of `1`'s.\n\nThe grid is said to be **connected** if we have **exactly one island**, otherwise is said **disconnected**.\n\nIn one day, we are allowed to change **any** single land cell `(1)` into a water cell `(0)`.\n\nReturn _the minimum number of days to disconnect the grid_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n\n**Output:** 2\n**Explanation:** We need at least 2 days to get a disconnected grid.\nChange land grid\\[1\\]\\[1\\] and grid\\[0\\]\\[2\\] to water and get 2 disconnected island.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\]\\]\n**Output:** 2\n**Explanation:** Grid of full water is also disconnected (\\[\\[1,1\\]\\] -> \\[\\[0,0\\]\\]), 0 islands.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    if not root:\n        return 0\n    cnt ^= 1 << (root.val - 1)\n    if not root.left and not root.right:\n        return (cnt & (cnt - 1)) == 0\n    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt)"}}, "leetcode/csn_python_train_223858.txt": {"score": 0.9084402322769165, "content": {"text": "def islive(self, state):\n\t\t'''A state is \"live\" if a final state can be reached from it.'''\n\t\treachable = [state]\n\t\ti = 0\n\t\twhile i < len(reachable):\n\t\t\tcurrent = reachable[i]\n\t\t\tif current in self.finals:\n\t\t\t\treturn True\n\t\t\tif current in self.map:\n\t\t\t\tfor symbol in self.map[current]:\n\t\t\t\t\tnext = self.map[current][symbol]\n\t\t\t\t\tif next not in reachable:\n\t\t\t\t\t\treachable.append(next)\n\t\t\ti += 1\n\t\treturn False"}}, "leetcode/leetcode_802.txt": {"score": 0.9111688137054443, "content": {"text": "import heapq\n    \"\"\"There is a directed graph of `n` nodes with each node labeled from `0` to `n - 1`. The graph is represented by a **0-indexed** 2D integer array `graph` where `graph[i]` is an integer array of nodes adjacent to node `i`, meaning there is an edge from node `i` to each node in `graph[i]`.\n\nA node is a **terminal node** if there are no outgoing edges. A node is a **safe node** if every possible path starting from that node leads to a **terminal node** (or another safe node).\n\nReturn _an array containing all the **safe nodes** of the graph_. The answer should be sorted in **ascending** order.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[1,2\\],\\[2,3\\],\\[5\\],\\[0\\],\\[5\\],\\[\\],\\[\\]\\]\n**Output:** \\[2,4,5,6\\]\n**Explanation:** The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,2,3,4\\],\\[1,2\\],\\[3,4\\],\\[0,4\\],\\[\\]\\]\n**Output:** \\[4\\]\n**Explanation:**\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n\n**Constraints:**\n\n*   `n == graph.length`\n*   `1 <= n <= 104`\n*   `0 <= graph[i].length <= n`\n*   `0 <= graph[i][j] <= n - 1`\n*   `graph[i]` is sorted in a strictly increasing order.\n*   The graph may contain self-loops.\n*   The number of edges in the graph will be in the range `[1, 4 * 104]`.\"\"\"\n\n\ndef kthSmallestPrimeFraction(arr, k):\n    pq = [(-arr[i] / arr[-1], i, len(arr) - 1) for i in range(len(arr) - 1)]\n\n    heapq.heapify(pq)\n\n    for _ in range(k - 1):\n        frac, i, j = heapq.heappop(pq)\n        j -= 1\n        if i < j:\n            heapq.heappush(pq, (-arr[i] / arr[j], i, j))\n\n    frac, i, j = heapq.heappop(pq)\n    return [arr[i], arr[j]]"}}, "leetcode/leetcode_1020.txt": {"score": 0.9122061729431152, "content": {"text": "def maxTurbulenceSize(arr):\n    \"\"\"You are given an `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell.\n\nA **move** consists of walking from one land cell to another adjacent (**4-directionally**) land cell or walking off the boundary of the `grid`.\n\nReturn _the number of land cells in_ `grid` _for which we cannot walk off the boundary of the grid in any number of **moves**_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[1,0,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 0\n**Explanation:** All 1s are either on the boundary or can reach the boundary.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\n\nFor i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is odd, and arr\\[k\\] < arr\\[k + 1\\] when k is even. OR For i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is even, and arr\\[k\\] < arr\\[k + 1\\] when k is odd.\"\"\"\n\n    n = len(arr)\n    result = 1\n    i = 0\n\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 1\n            continue\n\n        j = i + 1\n        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):\n            j += 1\n        \n        result = max(result, j - i + 1)\n        i = j\n\n    return result"}}, "leetcode/leetcode_1728.txt": {"score": 0.9309066534042358, "content": {"text": "class Fancy:\n    \"\"\"A game is played by a cat and a mouse named Cat and Mouse.\n\nThe environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.\n\n*   Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).\n*   Floors are represented by the character `'.'` and can be walked on.\n*   Walls are represented by the character `'#'` and cannot be walked on.\n*   Food is represented by the character `'F'` and can be walked on.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n\nMouse and Cat play according to the following rules:\n\n*   Mouse **moves first**, then they take turns to move.\n*   During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.\n*   `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n*   Staying in the same position is allowed.\n*   Mouse can jump over Cat.\n\nThe game can end in 4 ways:\n\n*   If Cat occupies the same position as Mouse, Cat wins.\n*   If Cat reaches the food first, Cat wins.\n*   If Mouse reaches the food first, Mouse wins.\n*   If Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` _if Mouse can win the game if both Cat and Mouse play optimally, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \"####F \", \"#C... \", \"M.... \"\\], catJump = 1, mouseJump = 2\n**Output:** true\n**Explanation:** Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\n**Example 2:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 4\n**Output:** true\n\n**Example 3:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 3\n**Output:** false\n\n**Constraints:**\n\n*   `rows == grid.length`\n*   `cols = grid[i].length`\n*   `1 <= rows, cols <= 8`\n*   `grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n*   `1 <= catJump, mouseJump <= 8`\"\"\"\n\n    def __init__(self):\n        self.sequence = []\n\n    def append(self, val):\n        self.sequence.append(val)\n\n    def addAll(self, inc):\n        self.sequence = [num + inc for num in self.sequence]\n\n    def multAll(self, m):\n        self.sequence = [num * m for num in self.sequence]\n\n    def getIndex(self, idx):\n        if idx >= len(self.sequence):\n            return -1\n        return self.sequence[idx]"}}, "leetcode/leetcode_789.txt": {"score": 0.9107385277748108, "content": {"text": "import heapq\n    \"\"\"You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point `[0, 0]`, and you are given a destination point `target = [xtarget, ytarget]` that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array `ghosts`, where `ghosts[i] = [xi, yi]` represents the starting position of the `ith` ghost. All inputs are **integral coordinates**.\n\nEach turn, you and all the ghosts may independently choose to either **move 1 unit** in any of the four cardinal directions: north, east, south, or west, or **stay still**. All actions happen **simultaneously**.\n\nYou escape if and only if you can reach the target **before** any ghost reaches you. If you reach any square (including the target) at the **same time** as a ghost, it **does not** count as an escape.\n\nReturn `true` _if it is possible to escape regardless of how the ghosts move, otherwise return_ `false`_._\n\n**Example 1:**\n\n**Input:** ghosts = \\[\\[1,0\\],\\[0,3\\]\\], target = \\[0,1\\]\n**Output:** true\n**Explanation:** You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you.\n\n**Example 2:**\n\n**Input:** ghosts = \\[\\[1,0\\]\\], target = \\[2,0\\]\n**Output:** false\n**Explanation:** You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.\n\n**Example 3:**\n\n**Input:** ghosts = \\[\\[2,0\\]\\], target = \\[1,0\\]\n**Output:** false\n**Explanation:** The ghost can reach the target at the same time as you.\n\n**Constraints:**\n\n*   `1 <= ghosts.length <= 100`\n*   `ghosts[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   There can be **multiple ghosts** in the same location.\n*   `target.length == 2`\n*   `-104 <= xtarget, ytarget <= 104`\"\"\"\n\n\nclass KthLargest:\n\n    def __init__(self, k, nums):\n        self.heap = []\n        self.k = k\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.heap, val)\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        return self.heap[0]"}}, "leetcode/leetcode_913.txt": {"score": 0.9989938139915466, "content": {"text": "import random\n    \"\"\"A game on an **undirected** graph is played by two players, Mouse and Cat, who alternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that `ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first, the cat starts at node `2` and goes second, and there is a hole at node `0`.\n\nDuring each player's turn, they **must** travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it **must** travel to any node in `graph[1]`.\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n\nThen, the game can end in three ways:\n\n*   If ever the Cat occupies the same node as the Mouse, the Cat wins.\n*   If ever the Mouse reaches the Hole, the Mouse wins.\n*   If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a `graph`, and assuming both players play optimally, return\n\n*   `1` if the mouse wins the game,\n*   `2` if the cat wins the game, or\n*   `0` if the game is a draw.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[2,5\\],\\[3\\],\\[0,4,5\\],\\[1,4,5\\],\\[2,3\\],\\[0,2,3\\]\\]\n**Output:** 0\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,3\\],\\[0\\],\\[3\\],\\[0,2\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `3 <= graph.length <= 50`\n*   `1 <= graph[i].length < graph.length`\n*   `0 <= graph[i][j] < graph.length`\n*   `graph[i][j] != i`\n*   `graph[i]` is unique.\n*   The mouse and the cat can always move.\"\"\"\n\n\nclass Solution:\n    def __init__(self, m, n):\n        self.grid = [[0] * n for _ in range(m)]\n        self.zero_count = m * n\n\n    def pick(self):\n        index = random.randrange(self.zero_count)\n\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                if cell == 0:\n                    if index == 0:\n                        self.grid[i][j] = 1\n                        self.zero_count -= 1\n                        return (i, j)\n                    index -= 1\n        return (-1, -1)  # Should not happen"}}, "leetcode/leetcode_1436.txt": {"score": 0.9117962121963501, "content": {"text": "from collections import deque\n    \"\"\"You are given the array `paths`, where `paths[i] = [cityAi, cityBi]` means there exists a direct path going from `cityAi` to `cityBi`. _Return the destination city, that is, the city without any path outgoing to another city._\n\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n\n**Example 1:**\n\n**Input:** paths = \\[\\[ \"London \", \"New York \"\\],\\[ \"New York \", \"Lima \"\\],\\[ \"Lima \", \"Sao Paulo \"\\]\\]\n**Output:**  \"Sao Paulo \" \n**Explanation:** Starting at  \"London \" city you will reach  \"Sao Paulo \" city which is the destination city. Your trip consist of:  \"London \" ->  \"New York \" ->  \"Lima \" ->  \"Sao Paulo \".\n\n**Example 2:**\n\n**Input:** paths = \\[\\[ \"B \", \"C \"\\],\\[ \"D \", \"B \"\\],\\[ \"C \", \"A \"\\]\\]\n**Output:**  \"A \"\n**Explanation:** All possible trips are: \n \"D \" ->  \"B \" ->  \"C \" ->  \"A \". \n \"B \" ->  \"C \" ->  \"A \". \n \"C \" ->  \"A \". \n \"A \". \nClearly the destination city is  \"A \".\n\n**Example 3:**\n\n**Input:** paths = \\[\\[ \"A \", \"Z \"\\]\\]\n**Output:**  \"Z \"\n\n**Constraints:**\n\n*   `1 <= paths.length <= 100`\n*   `paths[i].length == 2`\n*   `1 <= cityAi.length, cityBi.length <= 10`\n*   `cityAi != cityBi`\n*   All strings consist of lowercase and uppercase English letters and the space character.\"\"\"\n\nfrom collections import defaultdict\n\ndef watched_videos_by_friends(watched_videos, friends, id, level):\n    visited = set()\n    q = deque([(id, 0)])\n    video_freq = defaultdict(int)\n\n    while q:\n        current_id, current_level = q.popleft()\n\n        if current_level == level:\n            for video in watched_videos[current_id]:\n                video_freq[video] += 1\n        elif current_level < level:\n            for friend_id in friends[current_id]:\n                if friend_id not in visited:\n                    visited.add(friend_id)\n                    q.append((friend_id, current_level + 1))\n\n    result = sorted(video_freq.keys(), key=lambda x: (video_freq[x], x))\n\n    return result"}}, "leetcode/leetcode_2258.txt": {"score": 0.9231865406036377, "content": {"text": "from collections import deque\n    \"\"\"You are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:\n\n*   `0` represents grass,\n*   `1` represents fire,\n*   `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls.\n\nReturn _the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\nA cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2,0,0,0,0,0\\],\\[0,0,0,2,2,1,0\\],\\[0,2,0,0,1,2,0\\],\\[0,0,2,2,2,0,2\\],\\[0,0,0,0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[0,1,2,0\\],\\[0,2,0,0\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[2,2,0\\],\\[1,2,0\\]\\]\n**Output:** 1000000000\n**Explanation:** The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 300`\n*   `4 <= m * n <= 2 * 104`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`\"\"\"\n\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef getMaxSafeMinutes(grid):\n    m, n = len(grid), len(grid[0])\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n    q = deque()\n\n    if grid[m - 1][n - 1] != 1:\n        dist[m - 1][n - 1] = 0\n        q.append((m - 1, n - 1))\n\n    while q:\n        x, y = q.popleft()\n        for d in range(4):\n            nx, ny = x + dx[d], y + dy[d]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\n    if dist[0][0] == -1:\n        return -1\n\n    res = 0\n    for test in range(dist[0][0], int(1e9)):\n        ok = True\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    for d in range(4):\n                        nx, ny = x + dx[d], y + dy[d]\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:\n                            break\n                    else:\n                        ok = False\n                        break\n        if ok:\n            res = test\n        else:\n            break\n    return res"}}}}, "49": {"gold": {"leetcode/leetcode_2157.txt": 1, "leetcode/leetcode_2521.txt": 1}, "retrieved": {"leetcode/leetcode_1719.txt": {"score": 0.8982838988304138, "content": {"text": "def check_ways(pairs):\n    \"\"\"You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and:\n\n*   There are no duplicates.\n*   `xi < yi`\n\nLet `ways` be the number of rooted trees that satisfy the following conditions:\n\n*   The tree consists of nodes whose values appeared in `pairs`.\n*   A pair `[xi, yi]` exists in `pairs` **if and only if** `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.\n*   **Note:** the tree does not have to be a binary tree.\n\nTwo ways are considered to be different if there is at least one node that has different parents in both ways.\n\nReturn:\n\n*   `0` if `ways == 0`\n*   `1` if `ways == 1`\n*   `2` if `ways > 1`\n\nA **rooted tree** is a tree that has a single root node, and all edges are oriented to be outgoing from the root.\n\nAn **ancestor** of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.\n\n**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:** There is exactly one valid rooted tree, which is shown in the above figure.\n\n**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[1,3\\]\\]\n**Output:** 2\n**Explanation:** There are multiple valid rooted trees. Three of them are shown in the above figures.\n\n**Example 3:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\],\\[1,5\\]\\]\n**Output:** 0\n**Explanation:** There are no valid rooted trees.\n\n**Constraints:**\n\n*   `1 <= pairs.length <= 105`\n*   `1 <= xi < yi <= 500`\n*   The elements in `pairs` are unique.\"\"\"\n\n    candidates = {}\n    for x, y in pairs:\n        candidates[x] = candidates.get(x, 0) + 1\n        candidates[y] = candidates.get(y, 0) + 1\n\n    root_count = sum(1 for v in candidates.values() if v == 1)\n    return min(root_count, 2)"}}, "leetcode/leetcode_2316.txt": {"score": 0.9030909538269043, "content": {"text": "def count_hills_valleys(nums):\n    \"\"\"You are given an integer `n`. There is an **undirected** graph with `n` nodes, numbered from `0` to `n - 1`. You are given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nReturn _the **number of pairs** of different nodes that are **unreachable** from each other_.\n\n**Example 1:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,2\\]\\]\n**Output:** 0\n**Explanation:** There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[0,2\\],\\[0,5\\],\\[2,4\\],\\[1,6\\],\\[5,4\\]\\]\n**Output:** 14\n**Explanation:** There are 14 pairs of nodes that are unreachable from each other:\n\\[\\[0,1\\],\\[0,3\\],\\[0,6\\],\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[1,5\\],\\[2,3\\],\\[2,6\\],\\[3,4\\],\\[3,5\\],\\[3,6\\],\\[4,6\\],\\[5,6\\]\\].\nTherefore, we return 14.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `0 <= edges.length <= 2 * 105`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   There are no repeated edges.\"\"\"\n\n    count = 0\n    for i in range(1, len(nums) - 1):\n        if (nums[i] > nums[i - 1] and nums[i] > nums[i + 1]) or (nums[i] < nums[i - 1] and nums[i] < nums[i + 1]):\n            count += 1\n    return count"}}, "leetcode/leetcode_1579.txt": {"score": 0.9035141468048096, "content": {"text": "class UnionFind:\n    \"\"\"Alice and Bob have an undirected graph of `n` nodes and three types of edges:\n\n*   Type 1: Can be traversed by Alice only.\n*   Type 2: Can be traversed by Bob only.\n*   Type 3: Can be traversed by both Alice and Bob.\n\nGiven an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.\n\nReturn _the maximum number of edges you can remove, or return_ `-1` _if Alice and Bob cannot fully traverse the graph._\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[3,1,2\\],\\[3,2,3\\],\\[1,1,3\\],\\[1,2,4\\],\\[1,1,2\\],\\[2,3,4\\]\\]\n**Output:** 2\n**Explanation:** If we remove the 2 edges \\[1,1,2\\] and \\[1,1,3\\]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n\n**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[3,1,2\\],\\[3,2,3\\],\\[1,1,4\\],\\[2,1,4\\]\\]\n**Output:** 0\n**Explanation:** Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n\n**Example 3:**\n\n**Input:** n = 4, edges = \\[\\[3,2,3\\],\\[1,1,2\\],\\[2,3,4\\]\\]\n**Output:** -1\n**Explanation:** In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= edges.length <= min(105, 3 * n * (n - 1) / 2)`\n*   `edges[i].length == 3`\n*   `1 <= typei <= 3`\n*   `1 <= ui < vi <= n`\n*   All tuples `(typei, ui, vi)` are distinct.\"\"\"\n\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.components = size\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def unite(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x != root_y:\n            self.parent[root_x] = root_y\n            self.components -= 1\n            return True\n        return False\n\ndef max_num_edges_to_remove(n, edges):\n    ufA, ufB = UnionFind(n + 1), UnionFind(n + 1)\n    common_edges = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if ufA.unite(u, v):\n                ufB.unite(u, v)\n                common_edges += 1\n\n    removed_edges = 0\n    for t, u, v in edges:\n        uf = ufA if t == 1 else ufB if t == 2 else None\n        if uf and not uf.unite(u, v):\n            removed_edges += 1\n\n    return -1 if ufA.components != 2 or ufB.components != 2 else removed_edges - common_edges"}}, "leetcode/leetcode_2421.txt": {"score": 0.9115844964981079, "content": {"text": "from collections import defaultdict\n    \"\"\"There is a tree (i.e. a connected, undirected graph with no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges.\n\nYou are given a **0-indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nA **good path** is a simple path that satisfies the following conditions:\n\n1.  The starting node and the ending node have the **same** value.\n2.  All nodes between the starting node and the ending node have values **less than or equal to** the starting node (i.e. the starting node's value should be the maximum value along the path).\n\nReturn _the number of distinct good paths_.\n\nNote that a path and its reverse are counted as the **same** path. For example, `0 -> 1` is considered to be the same as `1 -> 0`. A single node is also considered as a valid path.\n\n**Example 1:**\n\n**Input:** vals = \\[1,3,2,1,3\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 6\n**Explanation:** There are 5 good paths consisting of a single node.\nThere is 1 additional good path: 1 -> 0 -> 2 -> 4.\n(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\nNote that 0 -> 2 -> 3 is not a good path because vals\\[2\\] > vals\\[0\\].\n\n**Example 2:**\n\n**Input:** vals = \\[1,1,2,2,3\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 7\n**Explanation:** There are 5 good paths consisting of a single node.\nThere are 2 additional good paths: 0 -> 1 and 2 -> 3.\n\n**Example 3:**\n\n**Input:** vals = \\[1\\], edges = \\[\\]\n**Output:** 1\n**Explanation:** The tree consists of only one node, so there is one good path.\n\n**Constraints:**\n\n*   `n == vals.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= vals[i] <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef dfs(node, parent, adj, vals, cur_max, count):\n    if vals[node] >= cur_max:\n        if vals[node] > cur_max:\n            count[0] += 1\n            cur_max = vals[node]\n        for next in adj[node]:\n            if next != parent:\n                dfs(next, node, adj, vals, cur_max, count)\n\ndef number_of_good_paths(vals, edges):\n    n = len(vals)\n    adj = defaultdict(list)\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    count = [0]\n    for i in range(n):\n        dfs(i, -1, adj, vals, -1, count)\n    return count[0]"}}, "leetcode/leetcode_2368.txt": {"score": 0.9053980112075806, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an undirected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an integer array `restricted` which represents **restricted** nodes.\n\nReturn _the **maximum** number of nodes you can reach from node_ `0` _without visiting a restricted node._\n\nNote that node `0` will **not** be a restricted node.\n\n**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,1\\],\\[4,0\\],\\[0,5\\],\\[5,6\\]\\], restricted = \\[4,5\\]\n**Output:** 4\n**Explanation:** The diagram above shows the tree.\nWe have that \\[0,1,2,3\\] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[0,2\\],\\[0,5\\],\\[0,4\\],\\[3,2\\],\\[6,5\\]\\], restricted = \\[4,2,1\\]\n**Output:** 3\n**Explanation:** The diagram above shows the tree.\nWe have that \\[0,5,6\\] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\n*   `1 <= restricted.length < n`\n*   `1 <= restricted[i] < n`\n*   All the values of `restricted` are **unique**.\"\"\"\n\n\ndef max_nodes_without_restricted(n, edges, restricted):\n    tree = defaultdict(list)\n    blocked_nodes = set(restricted)\n\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    max_nodes = [0]\n\n    def dfs(node, depth, parent):\n        if node in blocked_nodes:\n            return\n        max_nodes[0] = max(max_nodes[0], depth)\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, depth + 1, node)\n\n    dfs(0, 1, -1)\n    return max_nodes[0]"}}, "leetcode/leetcode_1766.txt": {"score": 0.9240016341209412, "content": {"text": "from bisect import bisect_left\n    \"\"\"There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges. Each node has a value associated with it, and the **root** of the tree is node `0`.\n\nTo represent this tree, you are given an integer array `nums` and a 2D array `edges`. Each `nums[i]` represents the `ith` node's value, and each `edges[j] = [uj, vj]` represents an edge between nodes `uj` and `vj` in the tree.\n\nTwo values `x` and `y` are **coprime** if `gcd(x, y) == 1` where `gcd(x, y)` is the **greatest common divisor** of `x` and `y`.\n\nAn ancestor of a node `i` is any other node on the shortest path from node `i` to the **root**. A node is **not** considered an ancestor of itself.\n\nReturn _an array_ `ans` _of size_ `n`, _where_ `ans[i]` _is the closest ancestor to node_ `i` _such that_ `nums[i]` _and_ `nums[ans[i]]` are **coprime**, or `-1` _if there is no such ancestor_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,3,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[-1,0,0,1\\]\n**Explanation:** In the above figure, each node's value is in parentheses.\n- Node 0 has no coprime ancestors.\n- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).\n- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's\n  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.\n- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its\n  closest valid ancestor.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,10,2,3,6,15\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[2,6\\]\\]\n**Output:** \\[-1,0,-1,0,0,0,-1\\]\n\n**Constraints:**\n\n*   `nums.length == n`\n*   `1 <= nums[i] <= 50`\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[j].length == 2`\n*   `0 <= uj, vj < n`\n*   `uj != vj`\"\"\"\n\n\ndef minimum_mountain_removals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(n):\n        left[i] = bisect_left(left[:i], nums[i])\n        right[n - 1 - i] = bisect_left(right[n - i:], nums[n - 1 - i])\n\n    return n - max(left[i] + right[i] for i in range(1, n - 1)) - 1"}}, "leetcode/leetcode_2157.txt": {"score": 0.9104010462760925, "content": {"text": "from heapq import heappop, heappush\n    \"\"\"You are given a **0-indexed** array of strings `words`. Each string consists of **lowercase English letters** only. No letter occurs more than once in any string of `words`.\n\nTwo strings `s1` and `s2` are said to be **connected** if the set of letters of `s2` can be obtained from the set of letters of `s1` by any **one** of the following operations:\n\n*   Adding exactly one letter to the set of the letters of `s1`.\n*   Deleting exactly one letter from the set of the letters of `s1`.\n*   Replacing exactly one letter from the set of the letters of `s1` with any letter, **including** itself.\n\nThe array `words` can be divided into one or more non-intersecting **groups**. A string belongs to a group if any **one** of the following is true:\n\n*   It is connected to **at least one** other string of the group.\n*   It is the **only** string present in the group.\n\nNote that the strings in `words` should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.\n\nReturn _an array_ `ans` _of size_ `2` _where:_\n\n*   `ans[0]` _is the **maximum number** of groups_ `words` _can be divided into, and_\n*   `ans[1]` _is the **size of the largest** group_.\n\n**Example 1:**\n\n**Input:** words = \\[ \"a \", \"b \", \"ab \", \"cde \"\\]\n**Output:** \\[2,3\\]\n**Explanation:**\n- words\\[0\\] can be used to obtain words\\[1\\] (by replacing 'a' with 'b'), and words\\[2\\] (by adding 'b'). So words\\[0\\] is connected to words\\[1\\] and words\\[2\\].\n- words\\[1\\] can be used to obtain words\\[0\\] (by replacing 'b' with 'a'), and words\\[2\\] (by adding 'a'). So words\\[1\\] is connected to words\\[0\\] and words\\[2\\].\n- words\\[2\\] can be used to obtain words\\[0\\] (by deleting 'b'), and words\\[1\\] (by deleting 'a'). So words\\[2\\] is connected to words\\[0\\] and words\\[1\\].\n- words\\[3\\] is not connected to any string in words.\nThus, words can be divided into 2 groups \\[ \"a \", \"b \", \"ab \"\\] and \\[ \"cde \"\\]. The size of the largest group is 3.  \n\n**Example 2:**\n\n**Input:** words = \\[ \"a \", \"ab \", \"abc \"\\]\n**Output:** \\[1,3\\]\n**Explanation:**\n- words\\[0\\] is connected to words\\[1\\].\n- words\\[1\\] is connected to words\\[0\\] and words\\[2\\].\n- words\\[2\\] is connected to words\\[1\\].\nSince all strings are connected to each other, they should be grouped together.\nThus, the size of the largest group is 3.\n\n**Constraints:**\n\n*   `1 <= words.length <= 2 * 104`\n*   `1 <= words[i].length <= 26`\n*   `words[i]` consists of lowercase English letters only.\n*   No letter occurs more than once in `words[i]`.\"\"\"\n\n\ndef smallest_subsequence(s, k, letter, repetition):\n    result = []\n    letter_count = s.count(letter)\n\n    pq = []\n    for c in s:\n        if c <= letter or letter_count > repetition:\n            while pq and pq[0] > c:\n                if heappop(pq) == letter:\n                    letter_count -= 1\n            heappush(pq, c)\n            if len(pq) > k:\n                heappop(pq)\n        if k - len(pq) == repetition:\n            letter_count -= 1\n        repetition = max(0, repetition)\n\n    return \"\".join(pq)"}}, "leetcode/leetcode_1627.txt": {"score": 0.9329108595848083, "content": {"text": "def lastMoment(n, left, right):\n    \"\"\"We have `n` cities labeled from `1` to `n`. Two different cities with labels `x` and `y` are directly connected by a bidirectional road if and only if `x` and `y` share a common divisor **strictly greater** than some `threshold`. More formally, cities with labels `x` and `y` have a road between them if there exists an integer `z` such that all of the following are true:\n\n*   `x % z == 0`,\n*   `y % z == 0`, and\n*   `z > threshold`.\n\nGiven the two integers, `n` and `threshold`, and an array of `queries`, you must determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are connected directly or indirectly. (i.e. there is some path between them).\n\nReturn _an array_ `answer`_, where_ `answer.length == queries.length` _and_ `answer[i]` _is_ `true` _if for the_ `ith` _query, there is a path between_ `ai` _and_ `bi`_, or_ `answer[i]` _is_ `false` _if there is no path._\n\n**Example 1:**\n\n**Input:** n = 6, threshold = 2, queries = \\[\\[1,4\\],\\[2,5\\],\\[3,6\\]\\]\n**Output:** \\[false,false,true\\]\n**Explanation:** The divisors for each number:\n1:   1\n2:   1, 2\n3:   1, 3\n4:   1, 2, 4\n5:   1, 5\n6:   1, 2, 3, 6\nUsing the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the\nonly ones directly connected. The result of each query:\n\\[1,4\\]   1 is not connected to 4\n\\[2,5\\]   2 is not connected to 5\n\\[3,6\\]   3 is connected to 6 through path 3--6\n\n**Example 2:**\n\n**Input:** n = 6, threshold = 0, queries = \\[\\[4,5\\],\\[3,4\\],\\[3,2\\],\\[2,6\\],\\[1,3\\]\\]\n**Output:** \\[true,true,true,true,true\\]\n**Explanation:** The divisors for each number are the same as the previous example. However, since the threshold is 0,\nall divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.\n\n**Example 3:**\n\n**Input:** n = 5, threshold = 1, queries = \\[\\[4,5\\],\\[4,5\\],\\[3,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** \\[false,false,false,false,false\\]\n**Explanation:** Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.\nPlease notice that there can be multiple queries for the same pair of nodes \\[x, y\\], and that the query \\[x, y\\] is equivalent to the query \\[y, x\\].\n\n**Constraints:**\n\n*   `2 <= n <= 104`\n*   `0 <= threshold <= n`\n*   `1 <= queries.length <= 105`\n*   `queries[i].length == 2`\n*   `1 <= ai, bi <= cities`\n*   `ai != bi`\"\"\"\n\n    max_left = max(left, default=0)\n    min_right = min(right, default=n)\n\n    return max(max_left, n - min_right)"}}, "leetcode/leetcode_952.txt": {"score": 0.9725062847137451, "content": {"text": "from collections import Counter\n    \"\"\"You are given an integer array of unique positive integers `nums`. Consider the following graph:\n\n*   There are `nums.length` nodes, labeled `nums[0]` to `nums[nums.length - 1]`,\n*   There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`.\n\nReturn _the size of the largest connected component in the graph_.\n\n**Example 1:**\n\n**Input:** nums = \\[4,6,15,35\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** nums = \\[20,50,9,63\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** nums = \\[2,3,6,7,4,12,21,39\\]\n**Output:** 8\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 105`\n*   All the values of `nums` are **unique**.\"\"\"\n\n\ndef word_subsets(words1, words2):\n    max_chars = Counter()\n    for word in words2:\n        chars = Counter(word)\n        for c, count in chars.items():\n            max_chars[c] = max(max_chars[c], count)\n    \n    result = []\n    for word in words1:\n        word_chars = Counter(word)\n        universal = all(word_chars[c] >= max_chars[c] for c in max_chars)\n        if universal:\n            result.append(word)\n    \n    return result"}}, "leetcode/leetcode_2581.txt": {"score": 0.9155495166778564, "content": {"text": "def possibleRoots(edges, guesses, k):\n    \"\"\"Alice has an undirected tree with `n` nodes labeled from `0` to `n - 1`. The tree is represented as a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nAlice wants Bob to find the root of the tree. She allows Bob to make several **guesses** about her tree. In one guess, he does the following:\n\n*   Chooses two **distinct** integers `u` and `v` such that there exists an edge `[u, v]` in the tree.\n*   He tells Alice that `u` is the **parent** of `v` in the tree.\n\nBob's guesses are represented by a 2D integer array `guesses` where `guesses[j] = [uj, vj]` indicates Bob guessed `uj` to be the parent of `vj`.\n\nAlice being lazy, does not reply to each of Bob's guesses, but just says that **at least** `k` of his guesses are `true`.\n\nGiven the 2D integer arrays `edges`, `guesses` and the integer `k`, return _the **number of possible nodes** that can be the root of Alice's tree_. If there is no such tree, return `0`.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[4,2\\]\\], guesses = \\[\\[1,3\\],\\[0,1\\],\\[1,0\\],\\[2,4\\]\\], k = 3\n**Output:** 3\n**Explanation:** \nRoot = 0, correct guesses = \\[1,3\\], \\[0,1\\], \\[2,4\\]\nRoot = 1, correct guesses = \\[1,3\\], \\[1,0\\], \\[2,4\\]\nRoot = 2, correct guesses = \\[1,3\\], \\[1,0\\], \\[2,4\\]\nRoot = 3, correct guesses = \\[1,0\\], \\[2,4\\]\nRoot = 4, correct guesses = \\[1,3\\], \\[1,0\\]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\], guesses = \\[\\[1,0\\],\\[3,4\\],\\[2,1\\],\\[3,2\\]\\], k = 1\n**Output:** 5\n**Explanation:** \nRoot = 0, correct guesses = \\[3,4\\]\nRoot = 1, correct guesses = \\[1,0\\], \\[3,4\\]\nRoot = 2, correct guesses = \\[1,0\\], \\[2,1\\], \\[3,4\\]\nRoot = 3, correct guesses = \\[1,0\\], \\[2,1\\], \\[3,2\\], \\[3,4\\]\nRoot = 4, correct guesses = \\[1,0\\], \\[2,1\\], \\[3,2\\]\nConsidering any node as root will give at least 1 correct guess. \n\n**Constraints:**\n\n*   `edges.length == n - 1`\n*   `2 <= n <= 105`\n*   `1 <= guesses.length <= 105`\n*   `0 <= ai, bi, uj, vj <= n - 1`\n*   `ai != bi`\n*   `uj != vj`\n*   `edges` represents a valid tree.\n*   `guesses[j]` is an edge of the tree.\n*   `guesses` is unique.\n*   `0 <= k <= guesses.length`\"\"\"\n\n    n = len(edges) + 1\n    in_degree = [0] * n\n    guess_parents = set()\n    \n    for guess in guesses:\n        guess_parents.add(guess[0])\n    \n    for edge in edges:\n        in_degree[edge[1]] += 1\n    \n    possible_roots = 0\n    for i in range(n):\n        if in_degree[i] == 0:\n            if k == 0 or i in guess_parents:\n                possible_roots += 1\n        elif in_degree[i] == 1 and len(guesses) - k < in_degree[i]:\n            possible_roots += 1\n    \n    return possible_roots"}}}}, "50": {"gold": {"leetcode/leetcode_215.txt": 1, "leetcode/leetcode_347.txt": 1, "leetcode/leetcode_692.txt": 1, "leetcode/leetcode_1779.txt": 1}, "retrieved": {"leetcode/csn_python_train_239274.txt": {"score": 0.8906508684158325, "content": {"text": "def find_closest_neighbours(cell, all_cells, k, max_dist):\n        \"\"\"\n        Find k closest neighbours of the given cell.\n        :param CellFeatures cell: cell of interest\n        :param all_cells: cell to consider as neighbours\n        :param int k: number of neighbours to be returned\n        :param int max_dist: maximal distance in pixels to consider neighbours\n        :return: k closest neighbours\n        \"\"\"\n        all_cells = [c for c in all_cells if c != cell]\n\n        sorted_cells = sorted([(cell.distance(c), c) for c in all_cells])\n\n        return [sc[1] for sc in sorted_cells[:k] if sc[0] <= max_dist]"}}, "leetcode/csn_python_train_177648.txt": {"score": 0.8949911594390869, "content": {"text": "def sorted_by_distance_to(self, position: Union[Unit, Point2], reverse: bool = False) -> \"Units\":\n        \"\"\" This function should be a bit faster than using units.sorted(keyfn=lambda u: u.distance_to(position)) \"\"\"\n        if len(self) in [0, 1]:\n            return self\n        position = position.position\n        return self.sorted(keyfn=lambda unit: unit.position._distance_squared(position), reverse=reverse)"}}, "leetcode/csn_python_train_177677.txt": {"score": 0.8930994868278503, "content": {"text": "def sort_by_distance(self, ps: Union[\"Units\", List[\"Point2\"]]) -> List[\"Point2\"]:\n        \"\"\" This returns the target points sorted as list. You should not pass a set or dict since those are not sortable.\n        If you want to sort your units towards a point, use 'units.sorted_by_distance_to(point)' instead. \"\"\"\n        if len(ps) == 1:\n            return ps[0]\n        # if ps and all(isinstance(p, Point2) for p in ps):\n        #     return sorted(ps, key=lambda p: self._distance_squared(p))\n        return sorted(ps, key=lambda p: self._distance_squared(p.position))"}}, "leetcode/csn_python_train_320962.txt": {"score": 0.8950648903846741, "content": {"text": "def closest_points(S):\n    \"\"\"Closest pair of points\n\n    :param S: list of points\n    :requires: size of S at least 2\n    :modifies: changes the order in S\n    :returns: pair of points p,q from S with minimum Euclidean distance\n    :complexity: expected linear time\n    \"\"\"\n    shuffle(S)\n    assert len(S) >= 2\n    p = S[0]\n    q = S[1]\n    d = dist(p, q)\n    while d > 0:\n        r = improve(S, d)\n        if r:\n            d, p, q = r\n        else:\n            break\n    return p, q"}}, "leetcode/csn_python_train_177676.txt": {"score": 0.9110530614852905, "content": {"text": "def _distance_squared(self, p2: \"Point2\") -> Union[int, float]:\n        \"\"\" Function used to not take the square root as the distances will stay proportionally the same. This is to speed up the sorting process. \"\"\"\n        return (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2"}}, "leetcode/csn_python_train_320450.txt": {"score": 0.9157092571258545, "content": {"text": "def index_of_nearest(p, hot_points, distance_f=distance):\n    \"\"\"Given a point and a set of hot points it found the hot point\n    nearest to the given point. An arbitrary distance function can\n    be specified\n    :return the index of the nearest hot points, or None if the list of hot\n            points is empty\n    \"\"\"\n    min_dist = None\n    nearest_hp_i = None\n    for i, hp in enumerate(hot_points):\n        dist = distance_f(p, hp)\n        if min_dist is None or dist < min_dist:\n            min_dist = dist\n            nearest_hp_i = i\n    return nearest_hp_i"}}, "leetcode/csn_python_train_177679.txt": {"score": 0.8961111307144165, "content": {"text": "def distance_to_closest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[int, float]:\n        \"\"\" This function assumes the 2d distance is meant \"\"\"\n        assert ps\n        closest_distance_squared = math.inf\n        for p2 in ps:\n            if not isinstance(p2, Point2):\n                p2 = p2.position\n            distance = (self[0] - p2[0]) ** 2 + (self[1] - p2[1]) ** 2\n            if distance < closest_distance_squared:\n                closest_distance_squared = distance\n        return closest_distance_squared ** 0.5"}}, "leetcode/leetcode_973.txt": {"score": 0.9944499731063843, "content": {"text": "def moves_to_stamp(stamp: str, target: str) -> list:\n    \"\"\"Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.\n\nThe distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `\u221a(x1 - x2)2 + (y1 - y2)2`).\n\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,3\\],\\[-2,2\\]\\], k = 1\n**Output:** \\[\\[-2,2\\]\\]\n**Explanation:**\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just \\[\\[-2,2\\]\\].\n\n**Example 2:**\n\n**Input:** points = \\[\\[3,3\\],\\[5,-1\\],\\[-2,4\\]\\], k = 2\n**Output:** \\[\\[3,3\\],\\[-2,4\\]\\]\n**Explanation:** The answer \\[\\[-2,4\\],\\[3,3\\]\\] would also be accepted.\n\n**Constraints:**\n\n*   `1 <= k <= points.length <= 104`\n*   `-104 < xi, yi < 104`\"\"\"\n\n    result = []\n    is_stamped = [False] * len(target)\n    stamp_count = 0\n    target = list(target)\n\n    while stamp_count < 10 * len(target):\n        found_stamp = False\n        for i in range(len(target) - len(stamp) + 1):\n            if is_stamped[i]:\n                continue\n            j = 0\n            overlap = 0\n            while j < len(stamp) and (target[i + j] == '?' or target[i + j] == stamp[j]):\n                if target[i + j] == stamp[j]:\n                    overlap += 1\n                j += 1\n            if j == len(stamp) and overlap > 0:\n                for j in range(len(stamp)):\n                    target[i + j] = '?'\n                result.append(i)\n                is_stamped[i] = True\n                found_stamp = True\n        if not found_stamp:\n            break\n        \n        stamp_count += 1\n\n    for c in target:\n        if c != '?':\n            return []\n\n    return result[::-1]"}}, "leetcode/csn_python_train_177678.txt": {"score": 0.9014489054679871, "content": {"text": "def closest(self, ps: Union[\"Units\", List[\"Point2\"], Set[\"Point2\"]]) -> Union[\"Unit\", \"Point2\"]:\n        \"\"\" This function assumes the 2d distance is meant \"\"\"\n        assert ps\n        if len(ps) == 1:\n            return ps[0]\n        closest_distance_squared = math.inf\n        for p2 in ps:\n            p2pos = p2\n            if not isinstance(p2pos, Point2):\n                p2pos = p2.position\n            distance = (self[0] - p2pos[0]) ** 2 + (self[1] - p2pos[1]) ** 2\n            if distance < closest_distance_squared:\n                closest_distance_squared = distance\n                closest_element = p2\n        return closest_element"}}, "leetcode/leetcode_1779.txt": {"score": 0.9172890186309814, "content": {"text": "def nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:\n    \"\"\"You are given two integers, `x` and `y`, which represent your current location on a Cartesian grid: `(x, y)`. You are also given an array `points` where each `points[i] = [ai, bi]` represents that a point exists at `(ai, bi)`. A point is **valid** if it shares the same x-coordinate or the same y-coordinate as your location.\n\nReturn _the index **(0-indexed)** of the **valid** point with the smallest **Manhattan distance** from your current location_. If there are multiple, return _the valid point with the **smallest** index_. If there are no valid points, return `-1`.\n\nThe **Manhattan distance** between two points `(x1, y1)` and `(x2, y2)` is `abs(x1 - x2) + abs(y1 - y2)`.\n\n**Example 1:**\n\n**Input:** x = 3, y = 4, points = \\[\\[1,2\\],\\[3,1\\],\\[2,4\\],\\[2,3\\],\\[4,4\\]\\]\n**Output:** 2\n**Explanation:** Of all the points, only \\[3,1\\], \\[2,4\\] and \\[4,4\\] are valid. Of the valid points, \\[2,4\\] and \\[4,4\\] have the smallest Manhattan distance from your current location, with a distance of 1. \\[2,4\\] has the smallest index, so return 2.\n\n**Example 2:**\n\n**Input:** x = 3, y = 4, points = \\[\\[3,4\\]\\]\n**Output:** 0\n**Explanation:** The answer is allowed to be on the same location as your current location.\n\n**Example 3:**\n\n**Input:** x = 3, y = 4, points = \\[\\[2,3\\]\\]\n**Output:** -1\n**Explanation:** There are no valid points.\n\n**Constraints:**\n\n*   `1 <= points.length <= 104`\n*   `points[i].length == 2`\n*   `1 <= x, y, ai, bi <= 104`\"\"\"\n\n    min_distance = float(\"inf\")\n    index = -1\n    for i, point in enumerate(points):\n        if x == point[0] or y == point[1]:\n            distance = abs(x - point[0]) + abs(y - point[1])\n            if distance < min_distance:\n                min_distance = distance\n                index = i\n    return index"}}}}, "51": {"gold": {"leetcode/leetcode_812.txt": 1}, "retrieved": {"leetcode/leetcode_1534.txt": {"score": 0.86543208360672, "content": {"text": "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    \"\"\"Given an array of integers `arr`, and three integers `a`, `b` and `c`. You need to find the number of good triplets.\n\nA triplet `(arr[i], arr[j], arr[k])` is **good** if the following conditions are true:\n\n*   `0 <= i < j < k < arr.length`\n*   `|arr[i] - arr[j]| <= a`\n*   `|arr[j] - arr[k]| <= b`\n*   `|arr[i] - arr[k]| <= c`\n\nWhere `|x|` denotes the absolute value of `x`.\n\nReturn _the number of good triplets_.\n\n**Example 1:**\n\n**Input:** arr = \\[3,0,1,1,9,7\\], a = 7, b = 2, c = 3\n**Output:** 4\n**Explanation:** There are 4 good triplets: \\[(3,0,1), (3,0,1), (3,1,1), (0,1,1)\\].\n\n**Example 2:**\n\n**Input:** arr = \\[1,1,2,2,3\\], a = 0, b = 0, c = 1\n**Output:** 0\n**Explanation:** No triplet satisfies all conditions.\n\n**Constraints:**\n\n*   `3 <= arr.length <= 100`\n*   `0 <= arr[i] <= 1000`\n*   `0 <= a, b, c <= 1000`\"\"\"\n\n    counts = [0] * 5\n    max_frogs = 0\n\n    for c in croakOfFrogs:\n        index = \"croak\".find(c)\n        if index == 0:\n            counts[0] += 1\n            max_frogs = max(max_frogs, counts[0])\n        elif counts[index - 1] > 0:\n            counts[index - 1] -= 1\n            counts[index] += 1\n        else:\n            return -1\n\n    if counts[0] == counts[4]:\n        return max_frogs\n    else:\n        return -1"}}, "leetcode/csn_python_train_320957.txt": {"score": 0.8671785593032837, "content": {"text": "def rectangles_from_points(S):\n    \"\"\"How many rectangles can be formed from a set of points\n\n    :param S: list of points, as coordinate pairs\n    :returns: the number of rectangles\n    :complexity: :math:`O(n^2)`\n    \"\"\"\n    answ = 0\n    pairs = {}\n    for j in range(len(S)):\n        for i in range(j):\n            px, py = S[i]\n            qx, qy = S[j]\n            center = (px + qx, py + qy)\n            dist = (px - qx) ** 2 + (py - qy) ** 2\n            sign = (center, dist)\n            if sign in pairs:\n                answ += len(pairs[sign])\n                pairs[sign].append((i, j))\n            else:\n                pairs[sign] = [(i, j)]\n    return answ"}}, "leetcode/leetcode_593.txt": {"score": 0.8689332008361816, "content": {"text": "def validSquare(p1, p2, p3, p4):\n    \"\"\"Given the coordinates of four points in 2D space `p1`, `p2`, `p3` and `p4`, return `true` _if the four points construct a square_.\n\nThe coordinate of a point `pi` is represented as `[xi, yi]`. The input is **not** given in any order.\n\nA **valid square** has four equal sides with positive length and four equal angles (90-degree angles).\n\n**Example 1:**\n\n**Input:** p1 = \\[0,0\\], p2 = \\[1,1\\], p3 = \\[1,0\\], p4 = \\[0,1\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** p1 = \\[0,0\\], p2 = \\[1,1\\], p3 = \\[1,0\\], p4 = \\[0,12\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** p1 = \\[1,0\\], p2 = \\[-1,0\\], p3 = \\[0,1\\], p4 = \\[0,-1\\]\n**Output:** true\n\n**Constraints:**\n\n*   `p1.length == p2.length == p3.length == p4.length == 2`\n*   `-104 <= xi, yi <= 104`\"\"\"\n\n    def dist_sq(p, q):\n        return (p[0] - q[0])**2 + (p[1] - q[1])**2\n\n    points = [p1, p2, p3, p4]\n    dists = set()\n\n    for i in range(4):\n        for j in range(i + 1, 4):\n            dists.add(dist_sq(points[i], points[j]))\n\n    return len(dists) == 2 and 0 not in dists"}}, "leetcode/leetcode_1039.txt": {"score": 0.8701868057250977, "content": {"text": "def find_judge(n, trust):\n    \"\"\"You have a convex `n`\\-sided polygon where each vertex has an integer value. You are given an integer array `values` where `values[i]` is the value of the `ith` vertex (i.e., **clockwise order**).\n\nYou will **triangulate** the polygon into `n - 2` triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all `n - 2` triangles in the triangulation.\n\nReturn _the smallest possible total score that you can achieve with some triangulation of the polygon_.\n\n**Example 1:**\n\n**Input:** values = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The polygon is already triangulated, and the score of the only triangle is 6.\n\n**Example 2:**\n\n**Input:** values = \\[3,7,4,5\\]\n**Output:** 144\n**Explanation:** There are two triangulations, with possible scores: 3\\*7\\*5 + 4\\*5\\*7 = 245, or 3\\*4\\*5 + 3\\*4\\*7 = 144.\nThe minimum score is 144.\n\n**Example 3:**\n\n**Input:** values = \\[1,3,1,4,1,5\\]\n**Output:** 13\n**Explanation:** The minimum score triangulation has score 1\\*1\\*3 + 1\\*1\\*4 + 1\\*1\\*5 + 1\\*1\\*1 = 13.\n\n**Constraints:**\n\n*   `n == values.length`\n*   `3 <= n <= 50`\n*   `1 <= values[i] <= 100`\"\"\"\n\n    trustCounts = [0] * (n + 1)\n    for a, b in trust:\n        trustCounts[a] -= 1\n        trustCounts[b] += 1\n\n    for i in range(1, n + 1):\n        if trustCounts[i] == n - 1:\n            return i\n    return -1"}}, "leetcode/leetcode_963.txt": {"score": 0.8989583253860474, "content": {"text": "def find_same_binary_value_parts(arr):\n    \"\"\"You are given an array of points in the **X-Y** plane `points` where `points[i] = [xi, yi]`.\n\nReturn _the minimum area of any rectangle formed from these points, with sides **not necessarily parallel** to the X and Y axes_. If there is not any such rectangle, return `0`.\n\nAnswers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,2\\],\\[2,1\\],\\[1,0\\],\\[0,1\\]\\]\n**Output:** 2.00000\n**Explanation:** The minimum area rectangle occurs at \\[1,2\\],\\[2,1\\],\\[1,0\\],\\[0,1\\], with an area of 2.\n\n**Example 2:**\n\n**Input:** points = \\[\\[0,1\\],\\[2,1\\],\\[1,1\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:** 1.00000\n**Explanation:** The minimum area rectangle occurs at \\[1,0\\],\\[1,1\\],\\[2,1\\],\\[2,0\\], with an area of 1.\n\n**Example 3:**\n\n**Input:** points = \\[\\[0,3\\],\\[1,2\\],\\[3,1\\],\\[1,3\\],\\[2,1\\]\\]\n**Output:** 0\n**Explanation:** There is no possible rectangle to form from these points.\n\n**Constraints:**\n\n*   `1 <= points.length <= 50`\n*   `points[i].length == 2`\n*   `0 <= xi, yi <= 4 * 104`\n*   All the given points are **unique**.\"\"\"\n\n    ones = sum(arr)\n\n    if ones % 3 != 0:\n        return [-1, -1]\n\n    target = ones // 3\n    if target == 0:\n        return [0, len(arr) - 2]\n\n    count = 0\n    i = j = -1\n    ones = 0\n    for idx, n in enumerate(arr):\n        if n == 1:\n            ones += 1\n            if ones == target + 1:\n                count += 1\n            if count == 1 and i == -1:\n                i = idx\n            if count == 2 and j == -1:\n                j = idx\n            if count == 3:\n                break\n\n    return [i, j]"}}, "leetcode/csn_python_train_340365.txt": {"score": 0.8775298595428467, "content": {"text": "def isIsosceles(self):\n        '''\n        True iff two side lengths are equal, boolean.\n        '''\n        return (self.a == self.b) or (self.a == self.c) or (self.b == self.c)"}}, "leetcode/leetcode_812.txt": {"score": 0.9232019782066345, "content": {"text": "def is_shifted(s, goal):\n    \"\"\"Given an array of points on the **X-Y** plane `points` where `points[i] = [xi, yi]`, return _the area of the largest triangle that can be formed by any three different points_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[0,1\\],\\[1,0\\],\\[0,2\\],\\[2,0\\]\\]\n**Output:** 2.00000\n**Explanation:** The five points are shown in the above figure. The red triangle is the largest.\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,0\\],\\[0,0\\],\\[0,1\\]\\]\n**Output:** 0.50000\n\n**Constraints:**\n\n*   `3 <= points.length <= 50`\n*   `-50 <= xi, yi <= 50`\n*   All the given points are **unique**.\"\"\"\n\n    if len(s) != len(goal): return False\n\n    s = s + s\n    return goal in s"}}, "leetcode/leetcode_976.txt": {"score": 0.9856931567192078, "content": {"text": "def min_area_rect(points):\n    \"\"\"Given an integer array `nums`, return _the largest perimeter of a triangle with a non-zero area, formed from three of these lengths_. If it is impossible to form any triangle of a non-zero area, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,1,2\\]\n**Output:** 5\n**Explanation:** You can form a triangle with three side lengths: 1, 2, and 2.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,10\\]\n**Output:** 0\n**Explanation:** \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `1 <= nums[i] <= 106`\"\"\"\n\n    point_set = {(x, y) for x, y in points}\n    min_area = float('inf')\n\n    for p1 in point_set:\n        for p2 in point_set:\n            if p1[0] != p2[0] and p1[1] != p2[1]:\n                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n\n    return min_area if min_area != float('inf') else 0"}}, "leetcode/leetcode_1395.txt": {"score": 0.8863460421562195, "content": {"text": "def minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    \"\"\"There are `n` soldiers standing in a line. Each soldier is assigned a **unique** `rating` value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\n*   Choose 3 soldiers with index (`i`, `j`, `k`) with rating (`rating[i]`, `rating[j]`, `rating[k]`).\n*   A team is valid if: (`rating[i] < rating[j] < rating[k]`) or (`rating[i] > rating[j] > rating[k]`) where (`0 <= i < j < k < n`).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\n**Example 1:**\n\n**Input:** rating = \\[2,5,3,4,1\\]\n**Output:** 3\n**Explanation:** We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\n**Example 2:**\n\n**Input:** rating = \\[2,1,3\\]\n**Output:** 0\n**Explanation:** We can't form any team given the conditions.\n\n**Example 3:**\n\n**Input:** rating = \\[1,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `n == rating.length`\n*   `3 <= n <= 1000`\n*   `1 <= rating[i] <= 105`\n*   All the integers in `rating` are **unique**.\n\nIn one second, you can either: - Move vertically by one unit, - Move horizontally by one unit, or - Move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in one second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points, but they do not count as visited unless you stop on them.\"\"\"\n\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        time += max(dx, dy)\n    return time"}}, "leetcode/leetcode_611.txt": {"score": 0.9220112562179565, "content": {"text": "def triangleNumber(nums: list) -> int:\n    \"\"\"Given an integer array `nums`, return _the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,2,3,4\\]\n**Output:** 3\n**Explanation:** Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n\n**Example 2:**\n\n**Input:** nums = \\[4,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\"\"\"\n\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] > nums[k]:\n                    count += 1\n                else:\n                    break\n    return count"}}}}, "52": {"gold": {"leetcode/leetcode_834.txt": 1}, "retrieved": {"leetcode/leetcode_1466.txt": {"score": 0.8829911947250366, "content": {"text": "def maxJumps(arr, d):\n    \"\"\"There are `n` cities numbered from `0` to `n - 1` and `n - 1` roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n\nRoads are represented by `connections` where `connections[i] = [ai, bi]` represents a road from city `ai` to city `bi`.\n\nThis year, there will be a big event in the capital (city `0`), and many people want to travel to this city.\n\nYour task consists of reorienting some roads such that each city can visit the city `0`. Return the **minimum** number of edges changed.\n\nIt's **guaranteed** that each city can reach city `0` after reorder.\n\n**Example 1:**\n\n**Input:** n = 6, connections = \\[\\[0,1\\],\\[1,3\\],\\[2,3\\],\\[4,0\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\n**Example 2:**\n\n**Input:** n = 5, connections = \\[\\[1,0\\],\\[1,2\\],\\[3,2\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\n**Example 3:**\n\n**Input:** n = 3, connections = \\[\\[1,0\\],\\[2,0\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `2 <= n <= 5 * 104`\n*   `connections.length == n - 1`\n*   `connections[i].length == 2`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\"\"\"\n\n    n = len(arr)\n    dp = [1] * n\n\n    def helper(idx):\n        if dp[idx] > 1:\n            return dp[idx]\n        maximum = 1\n        for i in range(1, d + 1):\n            if idx + i < n and arr[idx] <= arr[idx + i]:\n                break\n            if idx + i < n:\n                maximum = max(maximum, 1 + helper(idx + i))\n\n            if idx - i >= 0 and arr[idx] <= arr[idx - i]:\n                break\n            if idx - i >= 0:\n                maximum = max(maximum, 1 + helper(idx - i))\n        \n        dp[idx] = maximum\n        return maximum\n\n    for i in range(n):\n        helper(i)\n\n    return max(dp)"}}, "leetcode/leetcode_517.txt": {"score": 0.8833943605422974, "content": {"text": "def find_min_moves(machines):\n    \"\"\"You have `n` super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n\nFor each move, you could choose any `m` (`1 <= m <= n`) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n\nGiven an integer array `machines` representing the number of dresses in each washing machine from left to right on the line, return _the minimum number of moves to make all the washing machines have the same number of dresses_. If it is not possible to do it, return `-1`.\n\n**Example 1:**\n\n**Input:** machines = \\[1,0,5\\]\n**Output:** 3\n**Explanation:**\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\n**Example 2:**\n\n**Input:** machines = \\[0,3,0\\]\n**Output:** 2\n**Explanation:**\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\n**Example 3:**\n\n**Input:** machines = \\[0,2,0\\]\n**Output:** -1\n**Explanation:**\nIt's impossible to make all three washing machines have the same number of dresses.\n\n**Constraints:**\n\n*   `n == machines.length`\n*   `1 <= n <= 104`\n*   `0 <= machines[i] <= 105`\"\"\"\n\n    n = len(machines)\n    total_dresses = sum(machines)\n    if total_dresses % n != 0:\n        return -1\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n    \n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n        \n    return moves"}}, "leetcode/leetcode_1963.txt": {"score": 0.8843616843223572, "content": {"text": "def get_xor_sum(arr1, arr2):\n    \"\"\"You are given a **0-indexed** string `s` of **even** length `n`. The string consists of **exactly** `n / 2` opening brackets `'['` and `n / 2` closing brackets `']'`.\n\nA string is called **balanced** if and only if:\n\n*   It is the empty string, or\n*   It can be written as `AB`, where both `A` and `B` are **balanced** strings, or\n*   It can be written as `[C]`, where `C` is a **balanced** string.\n\nYou may swap the brackets at **any** two indices **any** number of times.\n\nReturn _the **minimum** number of swaps to make_ `s` _**balanced**_.\n\n**Example 1:**\n\n**Input:** s =  \"\\]\\[\\]\\[ \"\n**Output:** 1\n**Explanation:** You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is  \"\\[\\[\\]\\] \".\n\n**Example 2:**\n\n**Input:** s =  \"\\]\\]\\]\\[\\[\\[ \"\n**Output:** 2\n**Explanation:** You can do the following to make the string balanced:\n- Swap index 0 with index 4. s =  \"\\[\\]\\]\\[\\]\\[ \".\n- Swap index 1 with index 5. s =  \"\\[\\[\\]\\[\\]\\] \".\nThe resulting string is  \"\\[\\[\\]\\[\\]\\] \".\n\n**Example 3:**\n\n**Input:** s =  \"\\[\\] \"\n**Output:** 0\n**Explanation:** The string is already balanced.\n\n**Constraints:**\n\n*   `n == s.length`\n*   `2 <= n <= 106`\n*   `n` is even.\n*   `s[i]` is either `'['` or `']'`.\n*   The number of opening brackets `'['` equals `n / 2`, and the number of closing brackets `']'` equals `n / 2`.\"\"\"\n\n    xor_arr1 = xor_arr2 = 0\n    for i in arr1:\n        xor_arr1 ^= i\n    for j in arr2:\n        xor_arr2 ^= j\n    return xor_arr1 & xor_arr2"}}, "leetcode/leetcode_1653.txt": {"score": 0.9063320159912109, "content": {"text": "def dfs(root, distance, depths):\n    \"\"\"You are given a string `s` consisting only of characters `'a'` and `'b'`\u200b\u200b\u200b\u200b.\n\nYou can delete any number of characters in `s` to make `s` **balanced**. `s` is **balanced** if there is no pair of indices `(i,j)` such that `i < j` and `s[i] = 'b'` and `s[j]= 'a'`.\n\nReturn _the **minimum** number of deletions needed to make_ `s` _**balanced**_.\n\n**Example 1:**\n\n**Input:** s =  \"aababbab \"\n**Output:** 2\n**Explanation:** You can either:\nDelete the characters at 0-indexed positions 2 and 6 ( \"aababbab \" ->  \"aaabbb \"), or\nDelete the characters at 0-indexed positions 3 and 6 ( \"aababbab \" ->  \"aabbbb \").\n\n**Example 2:**\n\n**Input:** s =  \"bbaaaaabb \"\n**Output:** 2\n**Explanation:** The only solution is to delete the first two characters.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is `'a'` or `'b'`\u200b\u200b.\"\"\"\n\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        depths.append(0)\n        return 1\n    left, right = [], []\n    count = dfs(root.left, distance, left) + dfs(root.right, distance, right)\n    for l in left:\n        for r in right:\n            if l + r + 2 <= distance:\n                count += 1\n    depths.extend(l + 1 for l in left)\n    depths.extend(r + 1 for r in right)\n    return count\n\ndef countPairs(root, distance):\n    depths = []\n    return dfs(root, distance, depths)"}}, "leetcode/leetcode_310.txt": {"score": 0.8837898373603821, "content": {"text": "from collections import deque\n    \"\"\"A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\n\nReturn _a list of all **MHTs'** root labels_. You can return the answer in **any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[1\\]\n**Explanation:** As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n**Example 2:**\n\n**Input:** n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]\n**Output:** \\[3,4\\]\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs `(ai, bi)` are distinct.\n*   The given input is **guaranteed** to be a tree and there will be **no repeated** edges.\"\"\"\n\nfrom typing import List\n\ndef find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1:\n        return [0]\n\n    adj_list = [set() for _ in range(n)]\n    for a, b in edges:\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)\n\n    while n > 2:\n        leaves_size = len(leaves)\n        n -= leaves_size\n        for _ in range(leaves_size):\n            leaf = leaves.popleft()\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)"}}, "leetcode/leetcode_2171.txt": {"score": 0.8930515646934509, "content": {"text": "import heapq\n    \"\"\"You are given an array of **positive** integers `beans`, where each integer represents the number of magic beans found in a particular magic bag.\n\n**Remove** any number of beans (**possibly none**) from each bag such that the number of beans in each remaining **non-empty** bag (still containing **at least one** bean) is **equal**. Once a bean has been removed from a bag, you are **not** allowed to return it to any of the bags.\n\nReturn _the **minimum** number of magic beans that you have to remove_.\n\n**Example 1:**\n\n**Input:** beans = \\[4,**1**,6,5\\]\n**Output:** 4\n**Explanation:** \n- We remove 1 bean from the bag with only 1 bean.\n  This results in the remaining bags: \\[4,**0**,6,5\\]\n- Then we remove 2 beans from the bag with 6 beans.\n  This results in the remaining bags: \\[4,0,**4**,5\\]\n- Then we remove 1 bean from the bag with 5 beans.\n  This results in the remaining bags: \\[4,0,4,**4**\\]\nWe removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that remove 4 beans or fewer.\n\n**Example 2:**\n\n**Input:** beans = \\[**2**,10,**3**,**2**\\]\n**Output:** 7\n**Explanation:**\n- We remove 2 beans from one of the bags with 2 beans.\n  This results in the remaining bags: \\[**0**,10,3,2\\]\n- Then we remove 2 beans from the other bag with 2 beans.\n  This results in the remaining bags: \\[0,10,3,**0**\\]\n- Then we remove 3 beans from the bag with 3 beans. \n  This results in the remaining bags: \\[0,10,**0**,0\\]\nWe removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that removes 7 beans or fewer.\n\n**Constraints:**\n\n*   `1 <= beans.length <= 105`\n*   `1 <= beans[i] <= 105`\"\"\"\n\n\ndef second_minimum(n: int, edges: List[List[int]], time: int, change: int) -> int:\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    dist = [-1] * (n + 1)\n    queue = [(0, 1)]\n    dist[1] = 0\n\n    while queue:\n        t1, v1 = heapq.heappop(queue)\n\n        if v1 == n:\n            return t1\n\n        for v2 in adj[v1]:\n            t2 = t1 + time\n            waiting = change - (t2 % change) if (t2 // change) % 2 == 1 else 0\n\n            if dist[v2] == -1 or dist[v2] > t2 + waiting:\n                if dist[v2] != -1:\n                    heapq.heappush(queue, (dist[v2], v2))\n                dist[v2] = t2 + waiting\n                heapq.heappush(queue, (dist[v2], v2))\n\n    return -1"}}, "leetcode/leetcode_1658.txt": {"score": 0.8926316499710083, "content": {"text": "def min_swaps(grid):\n    \"\"\"You are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn _the **minimum number** of operations to reduce_ `x` _to **exactly**_ `0` _if it is possible__, otherwise, return_ `-1`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,4,2,3\\], x = 5\n**Output:** 2\n**Explanation:** The optimal solution is to remove the last two elements to reduce x to zero.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,7,8,9\\], x = 4\n**Output:** -1\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,20,1,1,3\\], x = 10\n**Output:** 5\n**Explanation:** The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`\n*   `1 <= x <= 109`\"\"\"\n\n    n = len(grid)\n    row_zeros = [0] * n\n    \n    for i in range(n):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j] == 0:\n                row_zeros[i] += 1\n            else:\n                break\n    \n    steps = 0\n    for i in range(n):\n        target = n - i - 1\n        current_row = i\n        while current_row < n and row_zeros[current_row] < target:\n            current_row += 1\n        if current_row == n:\n            return -1\n        steps += current_row - i\n        row_zeros.pop(current_row)\n        row_zeros.insert(i, target)\n    \n    return steps"}}, "leetcode/leetcode_971.txt": {"score": 0.9106749892234802, "content": {"text": "from collections import deque\n    \"\"\"You are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired** [**pre-order traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order) of the binary tree.\n\nAny node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\nFlip the **smallest** number of nodes so that the **pre-order traversal** of the tree **matches** `voyage`.\n\nReturn _a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the pre-order traversal match_ `voyage`_, return the list_ `[-1]`.\n\n**Example 1:**\n\n**Input:** root = \\[1,2\\], voyage = \\[2,1\\]\n**Output:** \\[-1\\]\n**Explanation:** It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\], voyage = \\[1,3,2\\]\n**Output:** \\[1\\]\n**Explanation:** Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n\n**Example 3:**\n\n**Input:** root = \\[1,2,3\\], voyage = \\[1,2,3\\]\n**Output:** \\[\\]\n**Explanation:** The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `n == voyage.length`\n*   `1 <= n <= 100`\n*   `1 <= Node.val, voyage[i] <= n`\n*   All the values in the tree are **unique**.\n*   All the values in `voyage` are **unique**.\"\"\"\n\n\ndef shortestBridge(grid):\n    n = len(grid)\n    q = deque()\n\n    # Find the first island and mark it\n    for i in range(n):\n        if any(grid[i]):\n            first_row = i\n            first_col = grid[first_row].index(1)\n            break\n\n    dfs(grid, q, first_row, first_col)\n\n    steps = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    while q:\n        for _ in range(len(q)):\n            x, y = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n:\n                    if grid[nx][ny] == 1:\n                        return steps\n                    elif grid[nx][ny] == 0:\n                        grid[nx][ny] = -1\n                        q.append((nx, ny))\n        steps += 1\n    return -1\n\ndef dfs(grid, q, i, j):\n    n = len(grid)\n    if not (0 <= i < n and 0 <= j < n and grid[i][j] == 1):\n        return\n    grid[i][j] = -1\n    q.append((i, j))\n    \n    dfs(grid, q, i - 1, j)\n    dfs(grid, q, i + 1, j)\n    dfs(grid, q, i, j - 1)\n    dfs(grid, q, i, j + 1)"}}, "leetcode/leetcode_1040.txt": {"score": 0.9082220196723938, "content": {"text": "def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n    \"\"\"There are some stones in different positions on the X-axis. You are given an integer array `stones`, the positions of the stones.\n\nCall a stone an **endpoint stone** if it has the smallest or largest position. In one move, you pick up an **endpoint stone** and move it to an unoccupied position so that it is no longer an **endpoint stone**.\n\n*   In particular, if the stones are at say, `stones = [1,2,5]`, you cannot move the endpoint stone at position `5`, since moving it to any position (such as `0`, or `3`) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n\nReturn _an integer array_ `answer` _of length_ `2` _where_:\n\n*   `answer[0]` _is the minimum number of moves you can play, and_\n*   `answer[1]` _is the maximum number of moves you can play_.\n\n**Example 1:**\n\n**Input:** stones = \\[7,4,9\\]\n**Output:** \\[1,2\\]\n**Explanation:** We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.\n\n**Example 2:**\n\n**Input:** stones = \\[6,5,4,3,10\\]\n**Output:** \\[2,3\\]\n**Explanation:** We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.\n\n**Constraints:**\n\n*   `3 <= stones.length <= 104`\n*   `1 <= stones[i] <= 109`\n*   All the values of `stones` are **unique**.\"\"\"\n\n    if root is None or val > root.val:\n        newNode = TreeNode(val)\n        newNode.left = root\n        return newNode\n    root.right = self.insertIntoMaxTree(root.right, val)\n    return root"}}, "leetcode/leetcode_979.txt": {"score": 0.9642162919044495, "content": {"text": "def decode_permutation(s: str):\n    \"\"\"You are given the `root` of a binary tree with `n` nodes where each `node` in the tree has `node.val` coins. There are `n` coins in total throughout the whole tree.\n\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\n\nReturn _the **minimum** number of moves required to make every node have **exactly** one coin_.\n\n**Example 1:**\n\n**Input:** root = \\[3,0,0\\]\n**Output:** 2\n**Explanation:** From the root of the tree, we move one coin to its left child, and one coin to its right child.\n\n**Example 2:**\n\n**Input:** root = \\[0,3,0\\]\n**Output:** 3\n**Explanation:** From the left child of the root, we move two coins to the root \\[taking two moves\\]. Then, we move one coin from the root of the tree to the right child.\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= n <= 100`\n*   `0 <= Node.val <= n`\n*   The sum of all `Node.val` is `n`.\"\"\"\n\n    n = len(s)\n    perm = [0] * (n + 1)\n    next_zero, next_one = 0, n\n\n    for c in s:\n        if c == '0':\n            perm[next_zero] = next_one\n            next_zero += 1\n            next_one -= 1\n        else:\n            perm[next_one] = next_zero\n            next_one -= 1\n            next_zero += 1\n\n    perm[next_zero] = next_one\n    return perm"}}}}, "53": {"gold": {"leetcode/leetcode_37.txt": 1, "leetcode/leetcode_63.txt": 1, "leetcode/leetcode_212.txt": 1}, "retrieved": {"leetcode/csn_python_train_339919.txt": {"score": 0.9016572833061218, "content": {"text": "def check_valid_solution(solution, graph):\n    \"\"\"Check that the solution is valid: every path is visited exactly once.\"\"\"\n    expected = Counter(\n        i for (i, _) in graph.iter_starts_with_index()\n        if i < graph.get_disjoint(i)\n    )\n    actual = Counter(\n        min(i, graph.get_disjoint(i))\n        for i in solution\n    )\n\n    difference = Counter(expected)\n    difference.subtract(actual)\n    difference = {k: v for k, v in difference.items() if v != 0}\n    if difference:\n        print('Solution is not valid!'\n              'Difference in node counts (expected - actual): {}'.format(difference))\n        return False\n    return True"}}, "leetcode/leetcode_1568.txt": {"score": 0.9020464420318604, "content": {"text": "def pseudoPalindromicPaths(root, cnt = 0):\n    \"\"\"You are given an `m x n` binary grid `grid` where `1` represents land and `0` represents water. An **island** is a maximal **4-directionally** (horizontal or vertical) connected group of `1`'s.\n\nThe grid is said to be **connected** if we have **exactly one island**, otherwise is said **disconnected**.\n\nIn one day, we are allowed to change **any** single land cell `(1)` into a water cell `(0)`.\n\nReturn _the minimum number of days to disconnect the grid_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n\n**Output:** 2\n**Explanation:** We need at least 2 days to get a disconnected grid.\nChange land grid\\[1\\]\\[1\\] and grid\\[0\\]\\[2\\] to water and get 2 disconnected island.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\]\\]\n**Output:** 2\n**Explanation:** Grid of full water is also disconnected (\\[\\[1,1\\]\\] -> \\[\\[0,0\\]\\]), 0 islands.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    if not root:\n        return 0\n    cnt ^= 1 << (root.val - 1)\n    if not root.left and not root.right:\n        return (cnt & (cnt - 1)) == 0\n    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt)"}}, "leetcode/leetcode_2258.txt": {"score": 0.9018051028251648, "content": {"text": "from collections import deque\n    \"\"\"You are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:\n\n*   `0` represents grass,\n*   `1` represents fire,\n*   `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls.\n\nReturn _the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\nA cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2,0,0,0,0,0\\],\\[0,0,0,2,2,1,0\\],\\[0,2,0,0,1,2,0\\],\\[0,0,2,2,2,0,2\\],\\[0,0,0,0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[0,1,2,0\\],\\[0,2,0,0\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[2,2,0\\],\\[1,2,0\\]\\]\n**Output:** 1000000000\n**Explanation:** The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 300`\n*   `4 <= m * n <= 2 * 104`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`\"\"\"\n\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef getMaxSafeMinutes(grid):\n    m, n = len(grid), len(grid[0])\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n    q = deque()\n\n    if grid[m - 1][n - 1] != 1:\n        dist[m - 1][n - 1] = 0\n        q.append((m - 1, n - 1))\n\n    while q:\n        x, y = q.popleft()\n        for d in range(4):\n            nx, ny = x + dx[d], y + dy[d]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\n    if dist[0][0] == -1:\n        return -1\n\n    res = 0\n    for test in range(dist[0][0], int(1e9)):\n        ok = True\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    for d in range(4):\n                        nx, ny = x + dx[d], y + dy[d]\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:\n                            break\n                    else:\n                        ok = False\n                        break\n        if ok:\n            res = test\n        else:\n            break\n    return res"}}, "leetcode/leetcode_1036.txt": {"score": 0.9077989459037781, "content": {"text": "from collections import deque\n    \"\"\"There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are `(x, y)`.\n\nWe start at the `source = [sx, sy]` square and want to reach the `target = [tx, ty]` square. There is also an array of `blocked` squares, where each `blocked[i] = [xi, yi]` represents a blocked square with coordinates `(xi, yi)`.\n\nEach move, we can walk one square north, east, south, or west if the square is **not** in the array of `blocked` squares. We are also not allowed to walk outside of the grid.\n\nReturn `true` _if and only if it is possible to reach the_ `target` _square from the_ `source` _square through a sequence of valid moves_.\n\n**Example 1:**\n\n**Input:** blocked = \\[\\[0,1\\],\\[1,0\\]\\], source = \\[0,0\\], target = \\[0,2\\]\n**Output:** false\n**Explanation:** The target square is inaccessible starting from the source square because we cannot move.\nWe cannot move north or east because those squares are blocked.\nWe cannot move south or west because we cannot go outside of the grid.\n\n**Example 2:**\n\n**Input:** blocked = \\[\\], source = \\[0,0\\], target = \\[999999,999999\\]\n**Output:** true\n**Explanation:** Because there are no blocked cells, it is possible to reach the target square.\n\n**Constraints:**\n\n*   `0 <= blocked.length <= 200`\n*   `blocked[i].length == 2`\n*   `0 <= xi, yi < 106`\n*   `source.length == target.length == 2`\n*   `0 <= sx, sy, tx, ty < 106`\n*   `source != target`\n*   It is guaranteed that `source` and `target` are not blocked.\"\"\"\n\n\ndef orangesRotting(grid):\n    m, n = len(grid), len(grid[0])\n    fresh_oranges = sum(row.count(1) for row in grid)\n    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])\n    \n    minutes = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while rotten and fresh_oranges:\n        for _ in range(len(rotten)):\n            x, y = rotten.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh_oranges -= 1\n                    rotten.append((nx, ny))\n        minutes += 1\n\n    return minutes if fresh_oranges == 0 else -1"}}, "leetcode/leetcode_1391.txt": {"score": 0.9163944125175476, "content": {"text": "def hasValidPath(grid):\n    \"\"\"You are given an `m x n` `grid`. Each cell of `grid` represents a street. The street of `grid[i][j]` can be:\n\n*   `1` which means a street connecting the left cell and the right cell.\n*   `2` which means a street connecting the upper cell and the lower cell.\n*   `3` which means a street connecting the left cell and the lower cell.\n*   `4` which means a street connecting the right cell and the lower cell.\n*   `5` which means a street connecting the left cell and the upper cell.\n*   `6` which means a street connecting the right cell and the upper cell.\n\nYou will initially start at the street of the upper-left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)`. **The path should only follow the streets**.\n\n**Notice** that you are **not allowed** to change any street.\n\nReturn `true` _if there is a valid path in the grid or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[2,4,3\\],\\[6,5,2\\]\\]\n**Output:** true\n**Explanation:** As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,1\\],\\[1,2,1\\]\\]\n**Output:** false\n**Explanation:** As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,2\\]\\]\n**Output:** false\n**Explanation:** You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `1 <= grid[i][j] <= 6`\"\"\"\n\n    m, n = len(grid), len(grid[0])\n\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    allowed = [[], [0, 2], [1, 3], [0, 1], [0, 3], [1, 2], [1, 0]]\n\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        visited[i][j] = True\n        for dir in allowed[grid[i][j]]:\n            x, y = i + directions[dir][0], j + directions[dir][1]\n            if 0 <= x < m and 0 <= y < n and not visited[x][y] and (dir + 2) % 4 in allowed[grid[x][y]]:\n                if dfs(x, y):\n                    return True\n        return False\n\n    return dfs(0, 0)"}}, "leetcode/leetcode_1368.txt": {"score": 0.9181179404258728, "content": {"text": "from collections import deque\n    \"\"\"Given an `m x n` grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:\n\n*   `1` which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)\n*   `2` which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)\n*   `3` which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)\n*   `4` which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\n\nYou will initially start at the upper left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path does not have to be the shortest.\n\nYou can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell **one time only**.\n\nReturn _the minimum cost to make the grid have at least one valid path_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1,1\\],\\[2,2,2,2\\],\\[1,1,1,1\\],\\[2,2,2,2\\]\\]\n**Output:** 3\n**Explanation:** You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,3\\],\\[3,2,2\\],\\[1,1,4\\]\\]\n**Output:** 0\n**Explanation:** You can follow the path from (0, 0) to (2, 2).\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,2\\],\\[4,3\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `1 <= grid[i][j] <= 4`\"\"\"\n\n\ndef minCost(grid):\n    m, n = len(grid), len(grid[0])\n    cost = 0\n\n    visited = [[1000000] * n for _ in range(m)]\n    q = deque([(0, 0)])\n    visited[0][0] = 0\n\n    while q:\n        y, x = q.popleft()\n        if y == m - 1 and x == n - 1:\n            cost = visited[y][x]\n            break\n\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n\n        for dir in range(4):\n            newY, newX = y + dy[dir], x + dx[dir]\n            if 0 <= newY < m and 0 <= newX < n:\n                newCost = visited[y][x] + (1 if dir + 1 != grid[y][x] else 0)\n                if newCost < visited[newY][newX]:\n                    visited[newY][newX] = newCost\n                    q.append((newY, newX))\n\n    return cost"}}, "leetcode/leetcode_1970.txt": {"score": 0.9048877954483032, "content": {"text": "def sort_sentence(s: str) -> str:\n    \"\"\"There is a **1-based** binary matrix where `0` represents land and `1` represents water. You are given integers `row` and `col` representing the number of rows and columns in the matrix, respectively.\n\nInitially on day `0`, the **entire** matrix is **land**. However, each day a new cell becomes flooded with **water**. You are given a **1-based** 2D array `cells`, where `cells[i] = [ri, ci]` represents that on the `ith` day, the cell on the `rith` row and `cith` column (**1-based** coordinates) will be covered with **water** (i.e., changed to `1`).\n\nYou want to find the **last** day that it is possible to walk from the **top** to the **bottom** by only walking on land cells. You can start from **any** cell in the top row and end at **any** cell in the bottom row. You can only travel in the **four** cardinal directions (left, right, up, and down).\n\nReturn _the **last** day where it is possible to walk from the **top** to the **bottom** by only walking on land cells_.\n\n**Example 1:**\n\n**Input:** row = 2, col = 2, cells = \\[\\[1,1\\],\\[2,1\\],\\[1,2\\],\\[2,2\\]\\]\n**Output:** 2\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n**Example 2:**\n\n**Input:** row = 2, col = 2, cells = \\[\\[1,1\\],\\[1,2\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:** 1\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n**Example 3:**\n\n**Input:** row = 3, col = 3, cells = \\[\\[1,2\\],\\[2,1\\],\\[3,3\\],\\[2,2\\],\\[1,1\\],\\[1,3\\],\\[2,3\\],\\[3,2\\],\\[3,1\\]\\]\n**Output:** 3\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3.\n\n**Constraints:**\n\n*   `2 <= row, col <= 2 * 104`\n*   `4 <= row * col <= 2 * 104`\n*   `cells.length == row * col`\n*   `1 <= ri <= row`\n*   `1 <= ci <= col`\n*   All the values of `cells` are **unique**.\"\"\"\n\n    tokens = s.split()\n    words = [''] * len(tokens)\n    \n    for token in tokens:\n        pos = int(token[-1]) - 1\n        words[pos] = token[:-1]\n    \n    return ' '.join(words)"}}, "leetcode/leetcode_980.txt": {"score": 0.9956471920013428, "content": {"text": "from itertools import permutations\n    \"\"\"You are given an `m x n` integer array `grid` where `grid[i][j]` could be:\n\n*   `1` representing the starting square. There is exactly one starting square.\n*   `2` representing the ending square. There is exactly one ending square.\n*   `0` representing empty squares we can walk over.\n*   `-1` representing obstacles that we cannot walk over.\n\nReturn _the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,0,0,0\\],\\[0,0,2,-1\\]\\]\n**Output:** 2\n**Explanation:** We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,0,0,0\\],\\[0,0,0,2\\]\\]\n**Output:** 4\n**Explanation:** We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,1\\],\\[2,0\\]\\]\n**Output:** 0\n**Explanation:** There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 20`\n*   `1 <= m * n <= 20`\n*   `-1 <= grid[i][j] <= 2`\n*   There is exactly one starting cell and one ending cell.\"\"\"\n\n\ndef smallestSuperstring(words):\n    def get_shared_length(a, b):\n        for shared_length in range(min(len(a), len(b)), 0, -1):\n            if a[-shared_length:] == b[:shared_length]:\n                return shared_length\n        return 0\n\n    def merge(a, b, shared_length):\n        return a + b[shared_length:]\n\n    def get_total_length(merged_words):\n        return sum(len(word) for word in merged_words)\n\n    best = None\n    for perm in permutations(words):\n        merged_words = list(perm)\n        for i in range(len(words) - 1):\n            shared_length = get_shared_length(merged_words[i], merged_words[i + 1])\n            merged_words[i + 1] = merge(merged_words[i], merged_words[i + 1], shared_length)\n        if best is None or get_total_length(merged_words) < len(best):\n            best = \"\".join(merged_words)\n\n    return best"}}, "leetcode/leetcode_1020.txt": {"score": 0.914363443851471, "content": {"text": "def maxTurbulenceSize(arr):\n    \"\"\"You are given an `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell.\n\nA **move** consists of walking from one land cell to another adjacent (**4-directionally**) land cell or walking off the boundary of the `grid`.\n\nReturn _the number of land cells in_ `grid` _for which we cannot walk off the boundary of the grid in any number of **moves**_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[1,0,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 0\n**Explanation:** All 1s are either on the boundary or can reach the boundary.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\n\nFor i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is odd, and arr\\[k\\] < arr\\[k + 1\\] when k is even. OR For i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is even, and arr\\[k\\] < arr\\[k + 1\\] when k is odd.\"\"\"\n\n    n = len(arr)\n    result = 1\n    i = 0\n\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 1\n            continue\n\n        j = i + 1\n        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):\n            j += 1\n        \n        result = max(result, j - i + 1)\n        i = j\n\n    return result"}}, "leetcode/leetcode_1091.txt": {"score": 0.9220102429389954, "content": {"text": "from collections import deque\n    \"\"\"Given an `n x n` binary matrix `grid`, return _the length of the shortest **clear path** in the matrix_. If there is no clear path, return `-1`.\n\nA **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell (i.e., `(n - 1, n - 1)`) such that:\n\n*   All the visited cells of the path are `0`.\n*   All the adjacent cells of the path are **8-directionally** connected (i.e., they are different and they share an edge or a corner).\n\nThe **length of a clear path** is the number of visited cells of this path.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0,0\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** -1\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 100`\n*   `grid[i][j] is 0 or 1`\"\"\"\n\n\ndef shortestPathBinaryMatrix(grid):\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]: return -1\n\n    dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    q = deque([(0, 0)])\n    grid[0][0] = 1\n\n    pathLength = 1\n\n    while q:\n        qlen = len(q)\n        for _ in range(qlen):\n            x, y = q.popleft()\n\n            if x == n - 1 and y == n - 1: return pathLength\n\n            for d in dir:\n                newX, newY = x + d[0], y + d[1]\n\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    q.append((newX, newY))\n                    grid[newX][newY] = 1\n        pathLength += 1\n\n    return -1"}}}}, "54": {"gold": {"leetcode/leetcode_2101.txt": 1, "leetcode/leetcode_2258.txt": 1}, "retrieved": {"leetcode/leetcode_542.txt": {"score": 0.9175243377685547, "content": {"text": "from collections import deque\n    \"\"\"Given an `m x n` binary matrix `mat`, return _the distance of the nearest_ `0` _for each cell_.\n\nThe distance between two adjacent cells is `1`.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n\n**Example 2:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,2,1\\]\\]\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 104`\n*   `1 <= m * n <= 104`\n*   `mat[i][j]` is either `0` or `1`.\n*   There is at least one `0` in `mat`.\"\"\"\n\n\ndef updateMatrix(mat):\n    m, n = len(mat), len(mat[0])\n    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]\n    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            newX, newY = x + dx, y + dy\n            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:\n                distance[newX][newY] = distance[x][y] + 1\n                queue.append((newX, newY))\n\n    return distance"}}, "leetcode/leetcode_1162.txt": {"score": 0.9203377366065979, "content": {"text": "from collections import deque\n    \"\"\"Given an `n x n` `grid` containing only values `0` and `1`, where `0` represents water and `1` represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return `-1`.\n\nThe distance used in this problem is the Manhattan distance: the distance between two cells `(x0, y0)` and `(x1, y1)` is `|x0 - x1| + |y0 - y1|`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,1\\],\\[0,0,0\\],\\[1,0,1\\]\\]\n**Output:** 2\n**Explanation:** The cell (1, 1) is as far as possible from all the land with distance 2.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Output:** 4\n**Explanation:** The cell (2, 2) is as far as possible from all the land with distance 4.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 100`\n*   `grid[i][j]` is `0` or `1`\"\"\"\n\n\ndef maxDistance(grid):\n    distance = -1\n    water_cells = deque()\n    n = len(grid)\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                water_cells.append((i, j))\n\n    if not water_cells or len(water_cells) == n * n:\n        return distance\n\n    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while water_cells:\n        size = len(water_cells)\n        for _ in range(size):\n            x, y = water_cells.popleft()\n            for dx, dy in directions:\n                newX, newY = x + dx, y + dy\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    grid[newX][newY] = 1\n                    water_cells.append((newX, newY))\n        distance += 1\n        \n    return distance - 1"}}, "leetcode/leetcode_2257.txt": {"score": 0.920194149017334, "content": {"text": "def earliest_blooming_day(plant_time, grow_time):\n    \"\"\"You are given two integers `m` and `n` representing a **0-indexed** `m x n` grid. You are also given two 2D integer arrays `guards` and `walls` where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `ith` guard and `jth` wall respectively.\n\nA guard can see **every** cell in the four cardinal directions (north, east, south, or west) starting from their position unless **obstructed** by a wall or another guard. A cell is **guarded** if there is **at least** one guard that can see it.\n\nReturn _the number of unoccupied cells that are **not** **guarded**._\n\n**Example 1:**\n\n**Input:** m = 4, n = 6, guards = \\[\\[0,0\\],\\[1,1\\],\\[2,3\\]\\], walls = \\[\\[0,1\\],\\[2,2\\],\\[1,4\\]\\]\n**Output:** 7\n**Explanation:** The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\n**Example 2:**\n\n**Input:** m = 3, n = 3, guards = \\[\\[1,1\\]\\], walls = \\[\\[0,1\\],\\[1,0\\],\\[2,1\\],\\[1,2\\]\\]\n**Output:** 4\n**Explanation:** The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\n**Constraints:**\n\n*   `1 <= m, n <= 105`\n*   `2 <= m * n <= 105`\n*   `1 <= guards.length, walls.length <= 5 * 104`\n*   `2 <= guards.length + walls.length <= m * n`\n*   `guards[i].length == walls[j].length == 2`\n*   `0 <= rowi, rowj < m`\n*   `0 <= coli, colj < n`\n*   All the positions in `guards` and `walls` are **unique**.\"\"\"\n\n    bloom_time = [plant_time[i] + grow_time[i] for i in range(len(plant_time))]\n    bloom_time.sort()\n    earliest_day = 0\n    for i in bloom_time:\n        earliest_day = max(earliest_day, i)\n        earliest_day += 1\n    return earliest_day"}}, "leetcode/leetcode_1091.txt": {"score": 0.9222530722618103, "content": {"text": "from collections import deque\n    \"\"\"Given an `n x n` binary matrix `grid`, return _the length of the shortest **clear path** in the matrix_. If there is no clear path, return `-1`.\n\nA **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell (i.e., `(n - 1, n - 1)`) such that:\n\n*   All the visited cells of the path are `0`.\n*   All the adjacent cells of the path are **8-directionally** connected (i.e., they are different and they share an edge or a corner).\n\nThe **length of a clear path** is the number of visited cells of this path.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0,0\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** -1\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 100`\n*   `grid[i][j] is 0 or 1`\"\"\"\n\n\ndef shortestPathBinaryMatrix(grid):\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]: return -1\n\n    dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    q = deque([(0, 0)])\n    grid[0][0] = 1\n\n    pathLength = 1\n\n    while q:\n        qlen = len(q)\n        for _ in range(qlen):\n            x, y = q.popleft()\n\n            if x == n - 1 and y == n - 1: return pathLength\n\n            for d in dir:\n                newX, newY = x + d[0], y + d[1]\n\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    q.append((newX, newY))\n                    grid[newX][newY] = 1\n        pathLength += 1\n\n    return -1"}}, "leetcode/leetcode_1926.txt": {"score": 0.9296427369117737, "content": {"text": "from collections import deque\n    \"\"\"You are given an `m x n` matrix `maze` (**0-indexed**) with empty cells (represented as `'.'`) and walls (represented as `'+'`). You are also given the `entrance` of the maze, where `entrance = [entrancerow, entrancecol]` denotes the row and column of the cell you are initially standing at.\n\nIn one step, you can move one cell **up**, **down**, **left**, or **right**. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the **nearest exit** from the `entrance`. An **exit** is defined as an **empty cell** that is at the **border** of the `maze`. The `entrance` **does not count** as an exit.\n\nReturn _the **number of steps** in the shortest path from the_ `entrance` _to the nearest exit, or_ `-1` _if no such path exists_.\n\n**Example 1:**\n\n**Input:** maze = \\[\\[ \"+ \", \"+ \", \". \", \"+ \"\\],\\[ \". \", \". \", \". \", \"+ \"\\],\\[ \"+ \", \"+ \", \"+ \", \". \"\\]\\], entrance = \\[1,2\\]\n**Output:** 1\n**Explanation:** There are 3 exits in this maze at \\[1,0\\], \\[0,2\\], and \\[2,3\\].\nInitially, you are at the entrance cell \\[1,2\\].\n- You can reach \\[1,0\\] by moving 2 steps left.\n- You can reach \\[0,2\\] by moving 1 step up.\nIt is impossible to reach \\[2,3\\] from the entrance.\nThus, the nearest exit is \\[0,2\\], which is 1 step away.\n\n**Example 2:**\n\n**Input:** maze = \\[\\[ \"+ \", \"+ \", \"+ \"\\],\\[ \". \", \". \", \". \"\\],\\[ \"+ \", \"+ \", \"+ \"\\]\\], entrance = \\[1,0\\]\n**Output:** 2\n**Explanation:** There is 1 exit in this maze at \\[1,2\\].\n\\[1,0\\] does not count as an exit since it is the entrance cell.\nInitially, you are at the entrance cell \\[1,0\\].\n- You can reach \\[1,2\\] by moving 2 steps right.\nThus, the nearest exit is \\[1,2\\], which is 2 steps away.\n\n**Example 3:**\n\n**Input:** maze = \\[\\[ \". \", \"+ \"\\]\\], entrance = \\[0,0\\]\n**Output:** -1\n**Explanation:** There are no exits in this maze.\n\n**Constraints:**\n\n*   `maze.length == m`\n*   `maze[i].length == n`\n*   `1 <= m, n <= 100`\n*   `maze[i][j]` is either `'.'` or `'+'`.\n*   `entrance.length == 2`\n*   `0 <= entrancerow < m`\n*   `0 <= entrancecol < n`\n*   `entrance` will always be an empty cell.\"\"\"\n\n\ndef nearest_exit(maze, entrance):\n    m, n = len(maze), len(maze[0])\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    q = deque([tuple(entrance)])\n    \n    steps = -1\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            if maze[r][c] == '+': continue\n            if r == 0 or r == m-1 or c == 0 or c == n-1:\n                if r != entrance[0] or c != entrance[1]: return steps\n            maze[r][c] = '+'\n            for dr, dc in moves:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n:\n                    q.append((nr, nc))\n    return -1"}}, "leetcode/leetcode_675.txt": {"score": 0.9303058981895447, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:\n\n*   `0` means the cell cannot be walked through.\n*   `1` represents an empty cell that can be walked through.\n*   A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).\n\nStarting from the point `(0, 0)`, return _the minimum steps you need to walk to cut off all the trees_. If you cannot cut off all the trees, return `-1`.\n\n**Note:** The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n**Example 1:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,4\\],\\[7,6,5\\]\\]\n**Output:** 6\n**Explanation:** Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n**Example 2:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,0\\],\\[7,6,5\\]\\]\n**Output:** -1\n**Explanation:** The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n**Example 3:**\n\n**Input:** forest = \\[\\[2,3,4\\],\\[0,0,5\\],\\[8,7,6\\]\\]\n**Output:** 6\n**Explanation:** You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n\n**Constraints:**\n\n*   `m == forest.length`\n*   `n == forest[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= forest[i][j] <= 109`\n*   Heights of all trees are **distinct**.\"\"\"\n\nfrom collections import deque\n\ndef cutOffTree(forest: List[List[int]]) -> int:\n    if not forest or not forest[0]: return 0\n    m, n = len(forest), len(forest[0])\n    trees = []\n    \n    for i in range(m):\n        for j in range(n):\n            if forest[i][j] > 1:\n                heappush(trees, (forest[i][j], i, j))\n    \n    startX, startY = 0, 0\n    totalSteps = 0\n    while trees:\n        tree, endX, endY = heappop(trees)\n        steps = bfs(forest, startX, startY, endX, endY)\n        if steps == -1:\n            return -1\n        totalSteps += steps\n        startX, startY = endX, endY\n    \n    return totalSteps\n\ndef bfs(forest, startX, startY, endX, endY):\n    if startX == endX and startY == endY:\n        return 0\n        \n    m, n = len(forest), len(forest[0])\n    visited = [[False] * n for _ in range(m)]\n    q = deque([(startX, startY, 0)])\n    visited[startX][startY] = True\n    dirs = [-1, 0, 1, 0, -1]\n    \n    while q:\n        x, y, steps = q.popleft()\n        for k in range(4):\n            newX, newY = x + dirs[k], y + dirs[k+1]\n            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:\n                if newX == endX and newY == endY:\n                    return steps + 1\n                q.append((newX, newY, steps + 1))\n                visited[newX][newY] = True\n    \n    return -1"}}, "leetcode/leetcode_749.txt": {"score": 0.9202401638031006, "content": {"text": "def shortest_completing_word(license_plate, words):\n    \"\"\"A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as an `m x n` binary grid `isInfected`, where `isInfected[i][j] == 0` represents uninfected cells, and `isInfected[i][j] == 1` represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two **4-directionally** adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There **will never be a tie**.\n\nReturn _the number of walls used to quarantine all the infected regions_. If the world will become fully infected, return the number of walls used.\n\n**Example 1:**\n\n**Input:** isInfected = \\[\\[0,1,0,0,0,0,0,1\\],\\[0,1,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 10\n**Explanation:** There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n \nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n \n\n**Example 2:**\n\n**Input:** isInfected = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 4\n**Explanation:** Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n**Example 3:**\n\n**Input:** isInfected = \\[\\[1,1,1,0,0,0,0,0,0\\],\\[1,0,1,0,1,1,1,1,1\\],\\[1,1,1,0,0,0,0,0,0\\]\\]\n**Output:** 13\n**Explanation:** The region on the left only builds two new walls.\n\n**Constraints:**\n\n*   `m == isInfected.length`\n*   `n == isInfected[i].length`\n*   `1 <= m, n <= 50`\n*   `isInfected[i][j]` is either `0` or `1`.\n*   There is always a contiguous viral region throughout the described process that will **infect strictly more uncontaminated squares** in the next round.\"\"\"\n\n    target = [0] * 26\n    for c in license_plate:\n        if c.isalpha():\n            target[ord(c.lower()) - ord('a')] += 1\n\n    result = \"\"\n    for word in words:\n        current = [0] * 26\n        for c in word:\n            if c.isalpha():\n                current[ord(c.lower()) - ord('a')] += 1\n\n        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):\n            result = word\n\n    return result"}}, "leetcode/leetcode_2258.txt": {"score": 0.9466050267219543, "content": {"text": "from collections import deque\n    \"\"\"You are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:\n\n*   `0` represents grass,\n*   `1` represents fire,\n*   `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls.\n\nReturn _the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\nA cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2,0,0,0,0,0\\],\\[0,0,0,2,2,1,0\\],\\[0,2,0,0,1,2,0\\],\\[0,0,2,2,2,0,2\\],\\[0,0,0,0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[0,1,2,0\\],\\[0,2,0,0\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[2,2,0\\],\\[1,2,0\\]\\]\n**Output:** 1000000000\n**Explanation:** The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 300`\n*   `4 <= m * n <= 2 * 104`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`\"\"\"\n\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef getMaxSafeMinutes(grid):\n    m, n = len(grid), len(grid[0])\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n    q = deque()\n\n    if grid[m - 1][n - 1] != 1:\n        dist[m - 1][n - 1] = 0\n        q.append((m - 1, n - 1))\n\n    while q:\n        x, y = q.popleft()\n        for d in range(4):\n            nx, ny = x + dx[d], y + dy[d]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\n    if dist[0][0] == -1:\n        return -1\n\n    res = 0\n    for test in range(dist[0][0], int(1e9)):\n        ok = True\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    for d in range(4):\n                        nx, ny = x + dx[d], y + dy[d]\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:\n                            break\n                    else:\n                        ok = False\n                        break\n        if ok:\n            res = test\n        else:\n            break\n    return res"}}, "leetcode/leetcode_2577.txt": {"score": 0.9227539896965027, "content": {"text": "from collections import deque\n    \"\"\"You are given a `m x n` matrix `grid` consisting of **non-negative** integers where `grid[row][col]` represents the **minimum** time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.\n\nYou are standing in the **top-left** cell of the matrix in the `0th` second, and you must move to **any** adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\nReturn _the **minimum** time required in which you can visit the bottom-right cell of the matrix_. If you cannot visit the bottom-right cell, then return `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,3,2\\],\\[5,1,2,5\\],\\[4,3,8,6\\]\\]\n**Output:** 7\n**Explanation:** One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid\\[0\\]\\[1\\] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid\\[1\\]\\[3\\] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid\\[2\\]\\[3\\] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,2,4\\],\\[3,2,1\\],\\[1,0,4\\]\\]\n**Output:** -1\n**Explanation:** There is no path from the top left to the bottom-right cell.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 1000`\n*   `4 <= m * n <= 105`\n*   `0 <= grid[i][j] <= 105`\n*   `grid[0][0] == 0`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n\ndef minTime(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    visited = [[1000000] * n for _ in range(m)]\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    visited[0][0] = 0\n\n    q = deque([(0, 0)])\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n\n            if 0 <= nx < m and 0 <= ny < n:\n                t = max(grid[nx][ny], visited[x][y] + 1)\n                if visited[nx][ny] > t:\n                    visited[nx][ny] = t\n                    q.append((nx, ny))\n\n    return visited[m - 1][n - 1] if visited[m - 1][n - 1] != 1000000 else -1"}}, "leetcode/leetcode_994.txt": {"score": 0.9806207418441772, "content": {"text": "def prisonAfterNDays(cells, n):\n    \"\"\"You are given an `m x n` `grid` where each cell can have one of three values:\n\n*   `0` representing an empty cell,\n*   `1` representing a fresh orange, or\n*   `2` representing a rotten orange.\n\nEvery minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.\n\nReturn _the minimum number of minutes that must elapse until no cell has a fresh orange_. If _this is impossible, return_ `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[2,1,1\\],\\[1,1,0\\],\\[0,1,1\\]\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** grid = \\[\\[2,1,1\\],\\[0,1,1\\],\\[1,0,1\\]\\]\n**Output:** -1\n**Explanation:** The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,2\\]\\]\n**Output:** 0\n**Explanation:** Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 10`\n*   `grid[i][j]` is `0`, `1`, or `2`.\"\"\"\n\n    n = n % 14 if n % 14 != 0 else 14 # Pattern repeats every 14 days\n\n    for _ in range(n):\n        temp = [0] * 8\n        for i in range(1, 7):\n            temp[i] = int(cells[i - 1] == cells[i + 1])\n        cells = temp\n\n    return cells"}}}}, "55": {"gold": {"leetcode/leetcode_312.txt": 1}, "retrieved": {"leetcode/leetcode_2335.txt": {"score": 0.9172028303146362, "content": {"text": "def min_seconds(amount: List[int]) -> int:\n    \"\"\"You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up `2` cups with **different** types of water, or `1` cup of any type of water.\n\nYou are given a **0-indexed** integer array `amount` of length `3` where `amount[0]`, `amount[1]`, and `amount[2]` denote the number of cold, warm, and hot water cups you need to fill respectively. Return _the **minimum** number of seconds needed to fill up all the cups_.\n\n**Example 1:**\n\n**Input:** amount = \\[1,4,2\\]\n**Output:** 4\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.\n\n**Example 2:**\n\n**Input:** amount = \\[5,4,4\\]\n**Output:** 7\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.\n\n**Example 3:**\n\n**Input:** amount = \\[5,0,0\\]\n**Output:** 5\n**Explanation:** Every second, we fill up a cold cup.\n\n**Constraints:**\n\n*   `amount.length == 3`\n*   `0 <= amount[i] <= 100`\"\"\"\n\n    total = sum(amount)\n    largest_two = max(amount[0] + amount[1], amount[1] + amount[2], amount[0] + amount[2])\n    return (total + 1) // 2 - (largest_two + 1) // 2 + largest_two"}}, "leetcode/leetcode_2244.txt": {"score": 0.9210624098777771, "content": {"text": "def numOfBeams(bank):\n    \"\"\"You are given a **0-indexed** integer array `tasks`, where `tasks[i]` represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the **same difficulty level**.\n\nReturn _the **minimum** rounds required to complete all the tasks, or_ `-1` _if it is not possible to complete all the tasks._\n\n**Example 1:**\n\n**Input:** tasks = \\[2,2,3,3,2,4,4,4,4,4\\]\n**Output:** 4\n**Explanation:** To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2. \n- In the second round, you complete 2 tasks of difficulty level 3. \n- In the third round, you complete 3 tasks of difficulty level 4. \n- In the fourth round, you complete 2 tasks of difficulty level 4.  \nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n\n**Example 2:**\n\n**Input:** tasks = \\[2,3,3\\]\n**Output:** -1\n**Explanation:** There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= tasks[i] <= 109`\"\"\"\n\n    m = len(bank)\n    n = len(bank[0])\n    beams = 0\n\n    for i in range(m):\n        for j in range(n):\n            if bank[i][j] == '1':\n                k = j + 1\n                while k < n and bank[i][k] != '1':\n                    beams += bank[i][k] == '0'\n                    k += 1\n                k = i + 1\n                while k < m and bank[k][j] != '1':\n                    beams += bank[k][j] == '0'\n                    k += 1\n\n    return beams"}}, "leetcode/leetcode_1217.txt": {"score": 0.9187689423561096, "content": {"text": "def sort_array(arr1, arr2):\n    \"\"\"We have `n` chips, where the position of the `ith` chip is `position[i]`.\n\nWe need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:\n\n*   `position[i] + 2` or `position[i] - 2` with `cost = 0`.\n*   `position[i] + 1` or `position[i] - 1` with `cost = 1`.\n\nReturn _the minimum cost_ needed to move all the chips to the same position.\n\n**Example 1:**\n\n**Input:** position = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n**Example 2:**\n\n**Input:** position = \\[2,2,2,3,3\\]\n**Output:** 2\n**Explanation:** We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n**Example 3:**\n\n**Input:** position = \\[1,1000000000\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= position.length <= 100`\n*   `1 <= position[i] <= 10^9`\"\"\"\n\n    counts = {}\n    result = []\n\n    for num in arr1:\n        counts[num] = counts.get(num, 0) + 1\n\n    for num in arr2:\n        if num in counts:\n            result.extend([num] * counts[num])\n            del counts[num]\n\n    for num in sorted(counts.keys()):\n        result.extend([num] * counts[num])\n\n    return result"}}, "leetcode/leetcode_2547.txt": {"score": 0.9215370416641235, "content": {"text": "def minCost(nums: List[int], k: int) -> int:\n    \"\"\"You are given an integer array `nums` and an integer `k`.\n\nSplit the array into some number of non-empty subarrays. The **cost** of a split is the sum of the **importance value** of each subarray in the split.\n\nLet `trimmed(subarray)` be the version of the subarray where all numbers which appear only once are removed.\n\n*   For example, `trimmed([3,1,2,4,3,4]) = [3,4,3,4].`\n\nThe **importance value** of a subarray is `k + trimmed(subarray).length`.\n\n*   For example, if a subarray is `[1,2,3,3,3,4,4]`, then trimmed(`[1,2,3,3,3,4,4]) = [3,3,3,4,4].`The importance value of this subarray will be `k + 5`.\n\nReturn _the minimum possible cost of a split of_ `nums`.\n\nA **subarray** is a contiguous **non-empty** sequence of elements within an array.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,1,3,3\\], k = 2\n**Output:** 8\n**Explanation:** We split nums to have two subarrays: \\[1,2\\], \\[1,2,1,3,3\\].\nThe importance value of \\[1,2\\] is 2 + (0) = 2.\nThe importance value of \\[1,2,1,3,3\\] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1\\], k = 2\n**Output:** 6\n**Explanation:** We split nums to have two subarrays: \\[1,2\\], \\[1,2,1\\].\nThe importance value of \\[1,2\\] is 2 + (0) = 2.\nThe importance value of \\[1,2,1\\] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,1,2,1\\], k = 5\n**Output:** 10\n**Explanation:** We split nums to have one subarray: \\[1,2,1,2,1\\].\nThe importance value of \\[1,2,1,2,1\\] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < nums.length`\n*   `1 <= k <= 109`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;\u00a0 } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n    n = len(nums)\n    count = [0] * 1001\n    dp = [0] * (n + 1)\n\n    i = 0\n    for j in range(n):\n        count[nums[j]] += 1\n        \n        if count[nums[j]] == 2:\n            dp[j + 1] = dp[i] + k + (j - i + 1)\n        elif count[nums[j]] > 2:\n            dp[j + 1] = min(dp[j], dp[j - 1] + 1)\n        else:\n            dp[j + 1] = dp[j] + 1\n\n        while i <= j and count[nums[i]] >= 2:\n            count[nums[i]] -= 1\n            i += 1\n\n    return dp[n] + n * k"}}, "leetcode/leetcode_1547.txt": {"score": 0.9336656928062439, "content": {"text": "def destCity(paths):\n    \"\"\"Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows:\n\nGiven an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn _the minimum total cost_ of the cuts.\n\n**Example 1:**\n\n**Input:** n = 7, cuts = \\[1,3,4,5\\]\n**Output:** 16\n**Explanation:** Using cuts order = \\[1, 3, 4, 5\\] as in the input leads to the following scenario:\n \nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be \\[3, 5, 1, 4\\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n**Example 2:**\n\n**Input:** n = 9, cuts = \\[5,6,1,4,2\\]\n**Output:** 22\n**Explanation:** If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order \\[4, 6, 5, 2, 1\\] has total cost = 22 which is the minimum possible.\n\n**Constraints:**\n\n*   `2 <= n <= 106`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   All the integers in `cuts` array are **distinct**.\"\"\"\n\n    starting_cities = set()\n    \n    for path in paths:\n        starting_cities.add(path[0])\n\n    for path in paths:\n        if path[1] not in starting_cities:\n            return path[1]\n\n    return \"\""}}, "leetcode/leetcode_1986.txt": {"score": 0.937580406665802, "content": {"text": "from collections import defaultdict\n    \"\"\"There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break.\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n*   If you start a task in a work session, you must complete it in the **same** work session.\n*   You can start a new task **immediately** after finishing the previous one.\n*   You may complete the tasks in **any order**.\n\nGiven `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._\n\nThe tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,3\\], sessionTime = 3\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n**Example 2:**\n\n**Input:** tasks = \\[3,1,3,1,1\\], sessionTime = 8\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n**Example 3:**\n\n**Input:** tasks = \\[1,2,3,4,5\\], sessionTime = 15\n**Output:** 1\n**Explanation:** You can finish all the tasks in one work session.\n\n**Constraints:**\n\n*   `n == tasks.length`\n*   `1 <= n <= 14`\n*   `1 <= tasks[i] <= 10`\n*   `max(tasks[i]) <= sessionTime <= 15`\"\"\"\n\n\n\ndef largestPathValue(colors, edges):\n    def dfs(node):\n        if not cache[node][ord(colors[node]) - ord('a')]:\n            cache[node][ord(colors[node]) - ord('a')] = 1\n            for neighbor in graph[node]:\n                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],\n                                                               1 + dfs(neighbor))\n        return cache[node][ord(colors[node]) - ord('a')]\n\n    n = len(colors)\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n\n    cache = [[0] * 26 for _ in range(n)]\n    in_degree = [0] * n\n    for a, b in edges:\n        in_degree[b] += 1\n    res = -1\n    for i in range(n):\n        if in_degree[i] == 0:\n            res = max(res, dfs(i))\n    return res"}}, "leetcode/leetcode_1760.txt": {"score": 0.9212073683738708, "content": {"text": "def can_form_array(arr, pieces):\n    \"\"\"You are given an integer array `nums` where the `ith` bag contains `nums[i]` balls. You are also given an integer `maxOperations`.\n\nYou can perform the following operation at most `maxOperations` times:\n\n*   Take any bag of balls and divide it into two new bags with a **positive** number of balls.\n    *   For example, a bag of `5` balls can become two new bags of `1` and `4` balls, or two new bags of `2` and `3` balls.\n\nYour penalty is the **maximum** number of balls in a bag. You want to **minimize** your penalty after the operations.\n\nReturn _the minimum possible penalty after performing the operations_.\n\n**Example 1:**\n\n**Input:** nums = \\[9\\], maxOperations = 2\n**Output:** 3\n**Explanation:** \n- Divide the bag with 9 balls into two bags of sizes 6 and 3. \\[**9**\\] -> \\[6,3\\].\n- Divide the bag with 6 balls into two bags of sizes 3 and 3. \\[**6**,3\\] -> \\[3,3,3\\].\nThe bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,8,2\\], maxOperations = 4\n**Output:** 2\n**Explanation:**\n- Divide the bag with 8 balls into two bags of sizes 4 and 4. \\[2,4,**8**,2\\] -> \\[2,4,4,4,2\\].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. \\[2,**4**,4,4,2\\] -> \\[2,2,2,4,4,2\\].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. \\[2,2,2,**4**,4,2\\] -> \\[2,2,2,2,2,4,2\\].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. \\[2,2,2,2,2,**4**,2\\] -> \\[2,2,2,2,2,2,2,2\\].\nThe bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= maxOperations, nums[i] <= 109`\"\"\"\n\n    piece_map = {piece[0]: piece for piece in pieces}\n    \n    i = 0\n    while i < len(arr):\n        if arr[i] not in piece_map:\n            return False\n        \n        for num in piece_map[arr[i]]:\n            if arr[i] != num:\n                return False\n            i += 1\n            \n    return True"}}, "leetcode/leetcode_1665.txt": {"score": 0.9473332762718201, "content": {"text": "def minimumEffort(tasks):\n    \"\"\"You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n\n*   `actuali` is the actual amount of energy you **spend to finish** the `ith` task.\n*   `minimumi` is the minimum amount of energy you **require to begin** the `ith` task.\n\nFor example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n\nYou can finish the tasks in **any order** you like.\n\nReturn _the **minimum** initial amount of energy you will need_ _to finish all the tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[4,8\\]\\]\n**Output:** 8\n**Explanation:**\nStarting with 8 energy, we finish the tasks in the following order:\n    - 3rd task. Now energy = 8 - 4 = 4.\n    - 2nd task. Now energy = 4 - 2 = 2.\n    - 1st task. Now energy = 2 - 1 = 1.\nNotice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3\\],\\[2,4\\],\\[10,11\\],\\[10,12\\],\\[8,9\\]\\]\n**Output:** 32\n**Explanation:**\nStarting with 32 energy, we finish the tasks in the following order:\n    - 1st task. Now energy = 32 - 1 = 31.\n    - 2nd task. Now energy = 31 - 2 = 29.\n    - 3rd task. Now energy = 29 - 10 = 19.\n    - 4th task. Now energy = 19 - 10 = 9.\n    - 5th task. Now energy = 9 - 8 = 1.\n\n**Example 3:**\n\n**Input:** tasks = \\[\\[1,7\\],\\[2,8\\],\\[3,9\\],\\[4,10\\],\\[5,11\\],\\[6,12\\]\\]\n**Output:** 27\n**Explanation:**\nStarting with 27 energy, we finish the tasks in the following order:\n    - 5th task. Now energy = 27 - 5 = 22.\n    - 2nd task. Now energy = 22 - 2 = 20.\n    - 3rd task. Now energy = 20 - 3 = 17.\n    - 1st task. Now energy = 17 - 1 = 16.\n    - 4th task. Now energy = 16 - 4 = 12.\n    - 6th task. Now energy = 12 - 6 = 6.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= actual\u200bi <= minimumi <= 104`\"\"\"\n\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n    ans, sum_energy = 0, 0\n    for task in tasks:\n        ans = max(ans, sum_energy + task[1])\n        sum_energy += task[0]\n    return ans"}}, "leetcode/leetcode_1049.txt": {"score": 0.9436067938804626, "content": {"text": "def min_rotations(tops, bottoms):\n    \"\"\"You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.\n\nWe are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n\n*   If `x == y`, both stones are destroyed, and\n*   If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is **at most one** stone left.\n\nReturn _the smallest possible weight of the left stone_. If there are no stones left, return `0`.\n\n**Example 1:**\n\n**Input:** stones = \\[2,7,4,1,8,1\\]\n**Output:** 1\n**Explanation:**\nWe can combine 2 and 4 to get 2, so the array converts to \\[2,7,1,8,1\\] then,\nwe can combine 7 and 8 to get 1, so the array converts to \\[2,1,1,1\\] then,\nwe can combine 2 and 1 to get 1, so the array converts to \\[1,1,1\\] then,\nwe can combine 1 and 1 to get 0, so the array converts to \\[1\\], then that's the optimal value.\n\n**Example 2:**\n\n**Input:** stones = \\[31,26,33,21,40\\]\n**Output:** 5\n\n**Constraints:**\n\n*   `1 <= stones.length <= 30`\n*   `1 <= stones[i] <= 100`\"\"\"\n\n    res = float('inf')\n\n    for target in (tops[0], bottoms[0]):\n        top_rot, bot_rot = 0, 0\n        for ti, bi in zip(tops, bottoms):\n            if ti != target and bi != target:\n                top_rot = bot_rot = float('inf')\n                break\n            top_rot += ti != target\n            bot_rot += bi != target\n\n        res = min(res, top_rot, bot_rot)\n\n    return -1 if res == float('inf') else res"}}, "leetcode/leetcode_1000.txt": {"score": 0.9941602945327759, "content": {"text": "def min_deletion_size(strs):\n    \"\"\"There are `n` piles of `stones` arranged in a row. The `ith` pile has `stones[i]` stones.\n\nA move consists of merging exactly `k` **consecutive** piles into one pile, and the cost of this move is equal to the total number of stones in these `k` piles.\n\nReturn _the minimum cost to merge all piles of stones into one pile_. If it is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 2\n**Output:** 20\n**Explanation:** We start with \\[3, 2, 4, 1\\].\nWe merge \\[3, 2\\] for a cost of 5, and we are left with \\[5, 4, 1\\].\nWe merge \\[4, 1\\] for a cost of 5, and we are left with \\[5, 5\\].\nWe merge \\[5, 5\\] for a cost of 10, and we are left with \\[10\\].\nThe total cost was 20, and this is the minimum possible.\n\n**Example 2:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 3\n**Output:** -1\n**Explanation:** After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n\n**Example 3:**\n\n**Input:** stones = \\[3,5,1,2,6\\], k = 3\n**Output:** 25\n**Explanation:** We start with \\[3, 5, 1, 2, 6\\].\nWe merge \\[5, 1, 2\\] for a cost of 8, and we are left with \\[3, 8, 6\\].\nWe merge \\[3, 8, 6\\] for a cost of 17, and we are left with \\[17\\].\nThe total cost was 25, and this is the minimum possible.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `1 <= n <= 30`\n*   `1 <= stones[i] <= 100`\n*   `2 <= k <= 30`\"\"\"\n\n    rows, cols = len(strs), len(strs[0])\n    count = 0\n    for c in range(cols):\n        for r in range(1, rows):\n            if strs[r - 1][c] > strs[r][c]:\n                count += 1\n                break\n    return count"}}}}, "56": {"gold": {"leetcode/leetcode_2009.txt": 1}, "retrieved": {"leetcode/leetcode_1900.txt": {"score": 0.9216642379760742, "content": {"text": "def closest_cost(base_costs, topping_costs, target):\n    \"\"\"There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their **initial** standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.).\n\nThe tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n\n*   For example, if the row consists of players `1, 2, 4, 6, 7`\n    *   Player `1` competes against player `7`.\n    *   Player `2` competes against player `6`.\n    *   Player `4` automatically advances to the next round.\n\nAfter each round is over, the winners are lined back up in the row based on the **original ordering** assigned to them initially (ascending order).\n\nThe players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may **choose** the outcome of this round.\n\nGiven the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the **earliest** possible round number and the **latest** possible round number in which these two players will compete against each other, respectively_.\n\n**Example 1:**\n\n**Input:** n = 11, firstPlayer = 2, secondPlayer = 4\n**Output:** \\[3,4\\]\n**Explanation:**\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n\n**Example 2:**\n\n**Input:** n = 5, firstPlayer = 1, secondPlayer = 5\n**Output:** \\[1,1\\]\n**Explanation:** The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.\n\n**Constraints:**\n\n*   `2 <= n <= 28`\n*   `1 <= firstPlayer < secondPlayer <= n`\"\"\"\n\n    closest = base_costs[0]\n    \n    for base in base_costs:\n        cost = base\n        \n        for i in range(1 << (len(topping_costs) * 2)):\n            bit_mask = i\n            \n            for j, topping_cost in enumerate(topping_costs):\n                cost += (bit_mask & 3) * topping_cost\n                bit_mask >>= 2\n                \n            if abs(target - cost) < abs(target - closest):\n                closest = cost\n            elif abs(target - cost) == abs(target - closest) and cost < closest:\n                closest = cost\n                \n            cost = base\n            \n    return closest"}}, "leetcode/leetcode_1509.txt": {"score": 0.9235262274742126, "content": {"text": "def minDifference(nums):\n    \"\"\"You are given an integer array `nums`.\n\nIn one move, you can choose one element of `nums` and change it to **any value**.\n\nReturn _the minimum difference between the largest and smallest value of `nums` **after performing at most three moves**_.\n\n**Example 1:**\n\n**Input:** nums = \\[5,3,2,4\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 2 to 3. nums becomes \\[5,3,3,4\\].\nIn the second move, change 4 to 3. nums becomes \\[5,3,3,3\\].\nIn the third move, change 5 to 3. nums becomes \\[3,3,3,3\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,0,10,14\\]\n**Output:** 1\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 5 to 0. nums becomes \\[1,0,0,10,14\\].\nIn the second move, change 10 to 0. nums becomes \\[1,0,0,0,14\\].\nIn the third move, change 14 to 1. nums becomes \\[1,0,0,0,1\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 0.\nIt can be shown that there is no way to make the difference 0 in 3 moves.\n\n**Example 3:**\n\n**Input:** nums = \\[3,100,20\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 100 to 7. nums becomes \\[4,7,20\\].\nIn the second move, change 20 to 7. nums becomes \\[4,7,7\\].\nIn the third move, change 4 to 3. nums becomes \\[7,7,7\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\"\"\"\n\n    n = len(nums)\n    if n <= 4: return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res"}}, "leetcode/leetcode_1551.txt": {"score": 0.9219518303871155, "content": {"text": "def min_operations(n):\n    \"\"\"You have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e., `0 <= i < n`).\n\nIn one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e., perform `arr[x] -=1` and `arr[y] += 1`). The goal is to make all the elements of the array **equal**. It is **guaranteed** that all the elements of the array can be made equal using some operations.\n\nGiven an integer `n`, the length of the array, return _the minimum number of operations_ needed to make all the elements of arr equal.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** arr = \\[1, 3, 5\\]\nFirst operation choose x = 2 and y = 0, this leads arr to be \\[2, 3, 4\\]\nIn the second operation choose x = 2 and y = 0 again, thus arr = \\[3, 3, 3\\].\n\n**Example 2:**\n\n**Input:** n = 6\n**Output:** 9\n\n**Constraints:**\n\n*   `1 <= n <= 104`\"\"\"\n\n    return n * n // 4"}}, "leetcode/leetcode_2037.txt": {"score": 0.9395436644554138, "content": {"text": "def count_square_triples(n):\n    \"\"\"There are `n` seats and `n` students in a room. You are given an array `seats` of length `n`, where `seats[i]` is the position of the `ith` seat. You are also given the array `students` of length `n`, where `students[j]` is the position of the `jth` student.\n\nYou may perform the following move any number of times:\n\n*   Increase or decrease the position of the `ith` student by `1` (i.e., moving the `ith` student from position `x` to `x + 1` or `x - 1`)\n\nReturn _the **minimum number of moves** required to move each student to a seat_ _such that no two students are in the same seat._\n\nNote that there may be **multiple** seats or students in the **same** position at the beginning.\n\n**Example 1:**\n\n**Input:** seats = \\[3,1,5\\], students = \\[2,7,4\\]\n**Output:** 4\n**Explanation:** The students are moved as follows:\n- The first student is moved from from position 2 to position 1 using 1 move.\n- The second student is moved from from position 7 to position 5 using 2 moves.\n- The third student is moved from from position 4 to position 3 using 1 move.\nIn total, 1 + 2 + 1 = 4 moves were used.\n\n**Example 2:**\n\n**Input:** seats = \\[4,1,5,9\\], students = \\[1,3,2,6\\]\n**Output:** 7\n**Explanation:** The students are moved as follows:\n- The first student is not moved.\n- The second student is moved from from position 3 to position 4 using 1 move.\n- The third student is moved from from position 2 to position 5 using 3 moves.\n- The fourth student is moved from from position 6 to position 9 using 3 moves.\nIn total, 0 + 1 + 3 + 3 = 7 moves were used.\n\n**Example 3:**\n\n**Input:** seats = \\[2,2,6,6\\], students = \\[1,3,2,6\\]\n**Output:** 4\n**Explanation:** Note that there are two seats at position 2 and two seats at position 6.\nThe students are moved as follows:\n- The first student is moved from from position 1 to position 2 using 1 move.\n- The second student is moved from from position 3 to position 6 using 3 moves.\n- The third student is not moved.\n- The fourth student is not moved.\nIn total, 1 + 3 + 0 + 0 = 4 moves were used.\n\n**Constraints:**\n\n*   `n == seats.length == students.length`\n*   `1 <= n <= 100`\n*   `1 <= seats[i], students[j] <= 100`\"\"\"\n\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = int((a * a + b * b)**0.5)\n            if c * c == a * a + b * b and c <= n:\n                count += 1\n    return count"}}, "leetcode/leetcode_1658.txt": {"score": 0.9242231249809265, "content": {"text": "def min_swaps(grid):\n    \"\"\"You are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn _the **minimum number** of operations to reduce_ `x` _to **exactly**_ `0` _if it is possible__, otherwise, return_ `-1`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,4,2,3\\], x = 5\n**Output:** 2\n**Explanation:** The optimal solution is to remove the last two elements to reduce x to zero.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,7,8,9\\], x = 4\n**Output:** -1\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,20,1,1,3\\], x = 10\n**Output:** 5\n**Explanation:** The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`\n*   `1 <= x <= 109`\"\"\"\n\n    n = len(grid)\n    row_zeros = [0] * n\n    \n    for i in range(n):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j] == 0:\n                row_zeros[i] += 1\n            else:\n                break\n    \n    steps = 0\n    for i in range(n):\n        target = n - i - 1\n        current_row = i\n        while current_row < n and row_zeros[current_row] < target:\n            current_row += 1\n        if current_row == n:\n            return -1\n        steps += current_row - i\n        row_zeros.pop(current_row)\n        row_zeros.insert(i, target)\n    \n    return steps"}}, "leetcode/leetcode_1040.txt": {"score": 0.9262949228286743, "content": {"text": "def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n    \"\"\"There are some stones in different positions on the X-axis. You are given an integer array `stones`, the positions of the stones.\n\nCall a stone an **endpoint stone** if it has the smallest or largest position. In one move, you pick up an **endpoint stone** and move it to an unoccupied position so that it is no longer an **endpoint stone**.\n\n*   In particular, if the stones are at say, `stones = [1,2,5]`, you cannot move the endpoint stone at position `5`, since moving it to any position (such as `0`, or `3`) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n\nReturn _an integer array_ `answer` _of length_ `2` _where_:\n\n*   `answer[0]` _is the minimum number of moves you can play, and_\n*   `answer[1]` _is the maximum number of moves you can play_.\n\n**Example 1:**\n\n**Input:** stones = \\[7,4,9\\]\n**Output:** \\[1,2\\]\n**Explanation:** We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.\n\n**Example 2:**\n\n**Input:** stones = \\[6,5,4,3,10\\]\n**Output:** \\[2,3\\]\n**Explanation:** We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.\n\n**Constraints:**\n\n*   `3 <= stones.length <= 104`\n*   `1 <= stones[i] <= 109`\n*   All the values of `stones` are **unique**.\"\"\"\n\n    if root is None or val > root.val:\n        newNode = TreeNode(val)\n        newNode.left = root\n        return newNode\n    root.right = self.insertIntoMaxTree(root.right, val)\n    return root"}}, "leetcode/leetcode_1769.txt": {"score": 0.9333831071853638, "content": {"text": "def maximum_generated(n: int) -> int:\n    \"\"\"You have `n` boxes. You are given a binary string `boxes` of length `n`, where `boxes[i]` is `'0'` if the `ith` box is **empty**, and `'1'` if it contains **one** ball.\n\nIn one operation, you can move **one** ball from a box to an adjacent box. Box `i` is adjacent to box `j` if `abs(i - j) == 1`. Note that after doing so, there may be more than one ball in some boxes.\n\nReturn an array `answer` of size `n`, where `answer[i]` is the **minimum** number of operations needed to move all the balls to the `ith` box.\n\nEach `answer[i]` is calculated considering the **initial** state of the boxes.\n\n**Example 1:**\n\n**Input:** boxes =  \"110 \"\n**Output:** \\[1,1,3\\]\n**Explanation:** The answer for each box is as follows:\n1) First box: you will have to move one ball from the second box to the first box in one operation.\n2) Second box: you will have to move one ball from the first box to the second box in one operation.\n3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.\n\n**Example 2:**\n\n**Input:** boxes =  \"001011 \"\n**Output:** \\[11,8,5,4,3,4\\]\n\n**Constraints:**\n\n*   `n == boxes.length`\n*   `1 <= n <= 2000`\n*   `boxes[i]` is either `'0'` or `'1'`.\"\"\"\n\n    if n == 0:\n        return 0\n    nums = [0] * (n + 1)\n    nums[1] = 1\n    for i in range(2, n + 1):\n        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]\n    return max(nums)"}}, "leetcode/leetcode_1217.txt": {"score": 0.9456602931022644, "content": {"text": "def sort_array(arr1, arr2):\n    \"\"\"We have `n` chips, where the position of the `ith` chip is `position[i]`.\n\nWe need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:\n\n*   `position[i] + 2` or `position[i] - 2` with `cost = 0`.\n*   `position[i] + 1` or `position[i] - 1` with `cost = 1`.\n\nReturn _the minimum cost_ needed to move all the chips to the same position.\n\n**Example 1:**\n\n**Input:** position = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n**Example 2:**\n\n**Input:** position = \\[2,2,2,3,3\\]\n**Output:** 2\n**Explanation:** We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n**Example 3:**\n\n**Input:** position = \\[1,1000000000\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= position.length <= 100`\n*   `1 <= position[i] <= 10^9`\"\"\"\n\n    counts = {}\n    result = []\n\n    for num in arr1:\n        counts[num] = counts.get(num, 0) + 1\n\n    for num in arr2:\n        if num in counts:\n            result.extend([num] * counts[num])\n            del counts[num]\n\n    for num in sorted(counts.keys()):\n        result.extend([num] * counts[num])\n\n    return result"}}, "leetcode/leetcode_517.txt": {"score": 0.9489192962646484, "content": {"text": "def find_min_moves(machines):\n    \"\"\"You have `n` super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n\nFor each move, you could choose any `m` (`1 <= m <= n`) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n\nGiven an integer array `machines` representing the number of dresses in each washing machine from left to right on the line, return _the minimum number of moves to make all the washing machines have the same number of dresses_. If it is not possible to do it, return `-1`.\n\n**Example 1:**\n\n**Input:** machines = \\[1,0,5\\]\n**Output:** 3\n**Explanation:**\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\n**Example 2:**\n\n**Input:** machines = \\[0,3,0\\]\n**Output:** 2\n**Explanation:**\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\n**Example 3:**\n\n**Input:** machines = \\[0,2,0\\]\n**Output:** -1\n**Explanation:**\nIt's impossible to make all three washing machines have the same number of dresses.\n\n**Constraints:**\n\n*   `n == machines.length`\n*   `1 <= n <= 104`\n*   `0 <= machines[i] <= 105`\"\"\"\n\n    n = len(machines)\n    total_dresses = sum(machines)\n    if total_dresses % n != 0:\n        return -1\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n    \n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n        \n    return moves"}}, "leetcode/leetcode_1033.txt": {"score": 0.9818459153175354, "content": {"text": "def broken_calc(startValue: int, target: int) -> int:\n    \"\"\"There are three stones in different positions on the X-axis. You are given three integers `a`, `b`, and `c`, the positions of the stones.\n\nIn one move, you pick up a stone at an endpoint (i.e., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. Formally, let's say the stones are currently at positions `x`, `y`, and `z` with `x < y < z`. You pick up the stone at either position `x` or position `z`, and move that stone to an integer position `k`, with `x < k < z` and `k != y`.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n\nReturn _an integer array_ `answer` _of length_ `2` _where_:\n\n*   `answer[0]` _is the minimum number of moves you can play, and_\n*   `answer[1]` _is the maximum number of moves you can play_.\n\n**Example 1:**\n\n**Input:** a = 1, b = 2, c = 5\n**Output:** \\[1,2\\]\n**Explanation:** Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.\n\n**Example 2:**\n\n**Input:** a = 4, b = 3, c = 2\n**Output:** \\[0,0\\]\n**Explanation:** We cannot make any moves.\n\n**Example 3:**\n\n**Input:** a = 3, b = 5, c = 1\n**Output:** \\[1,2\\]\n**Explanation:** Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 100`\n*   `a`, `b`, and `c` have different values.\"\"\"\n\n    operations = 0\n    while target > startValue:\n        target = target // 2 if target % 2 == 0 else target + 1\n        operations += 1\n    return operations + startValue - target"}}}}, "57": {"gold": {"leetcode/leetcode_2509.txt": 1}, "retrieved": {"leetcode/leetcode_975.txt": {"score": 0.8889593482017517, "content": {"text": "def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\n    \"\"\"You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called **odd-numbered jumps**, and the (2nd, 4th, 6th, ...) jumps in the series are called **even-numbered jumps**. Note that the **jumps** are numbered, not the indices.\n\nYou may jump forward from index `i` to index `j` (with `i < j`) in the following way:\n\n*   During **odd-numbered jumps** (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   During **even-numbered jumps** (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   It may be the case that for some index `i`, there are no legal jumps.\n\nA starting index is **good** if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).\n\nReturn _the number of **good** starting indices_.\n\n**Example 1:**\n\n**Input:** arr = \\[10,13,12,14,15\\]\n**Output:** 2\n**Explanation:** \nFrom starting index i = 0, we can make our 1st jump to i = 2 (since arr\\[2\\] is the smallest among arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\] that is greater or equal to arr\\[0\\]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\njumps.\n\n**Example 2:**\n\n**Input:** arr = \\[2,3,1,1,4\\]\n**Output:** 3\n**Explanation:** \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr\\[1\\] is the smallest value in \\[arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[0\\].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr\\[2\\] is the largest value in \\[arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is less than or equal to arr\\[1\\]. arr\\[3\\] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr\\[3\\] is the smallest value in \\[arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[2\\].\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\nnumber of jumps.\n\n**Example 3:**\n\n**Input:** arr = \\[5,1,3,4,2\\]\n**Output:** 3\n**Explanation:** We can reach the end from starting indices 1, 2, and 4.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 2 * 104`\n*   `0 <= arr[i] < 105`\"\"\"\n\n    if not root:\n        return 0\n    if root.val < low:\n        return self.rangeSumBST(root.right, low, high)\n    if root.val > high:\n        return self.rangeSumBST(root.left, low, high)\n    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)"}}, "leetcode/csn_python_train_39285.txt": {"score": 0.896053671836853, "content": {"text": "def binaryTree_depthFirstNumbers(binaryTree, labelTree=True, dontStopAtID=True):\n    \"\"\"\n    get mid-order depth first tree numbers\n    \"\"\"\n    traversalIDs = {}\n    def traverse(binaryTree, mid=0, leafNo=0):\n        if binaryTree.internal and (dontStopAtID or binaryTree.iD is None):\n            midStart = mid\n            j, leafNo = traverse(binaryTree.left, mid, leafNo)\n            mid = j\n            j, leafNo = traverse(binaryTree.right, j+1, leafNo)\n            traversalIDs[binaryTree] = TraversalID(midStart, mid, j)\n            return j, leafNo\n        traversalID = TraversalID(mid, mid, mid+1)\n        traversalID.leafNo = leafNo\n        #thus nodes must be unique\n        traversalIDs[binaryTree] = traversalID\n        return mid+1, leafNo+1\n    traverse(binaryTree)\n    if labelTree:\n        for binaryTree in traversalIDs.keys():\n            binaryTree.traversalID = traversalIDs[binaryTree]\n    return traversalIDs"}}, "leetcode/csn_python_train_339926.txt": {"score": 0.8909088969230652, "content": {"text": "def get_path(self, i):\n        \"\"\"Returns the path corresponding to the node i.\"\"\"\n        index = (i - 1) // 2\n        reverse = (i - 1) % 2\n        path = self.paths[index]\n        if reverse:\n            return path.reversed()\n        else:\n            return path"}}, "leetcode/csn_python_train_317001.txt": {"score": 0.9058631062507629, "content": {"text": "def values(self):\n        \"\"\"Return the `list representation`_ of the binary tree.\n\n        .. _list representation:\n            https://en.wikipedia.org/wiki/Binary_tree#Arrays\n\n        :return: List representation of the binary tree, which is a list of\n            node values in breadth-first order starting from the root (current\n            node). If a node is at index i, its left child is always at 2i + 1,\n            right child at 2i + 2, and parent at index floor((i - 1) / 2). None\n            indicates absence of a node at that index. See example below for an\n            illustration.\n        :rtype: [int | float | None]\n\n        **Example**:\n\n        .. doctest::\n\n            >>> from binarytree import Node\n            >>>\n            >>> root = Node(1)\n            >>> root.left = Node(2)\n            >>> root.right = Node(3)\n            >>> root.left.right = Node(4)\n            >>>\n            >>> root.values\n            [1, 2, 3, None, 4]\n        \"\"\"\n        current_nodes = [self]\n        has_more_nodes = True\n        values = []\n\n        while has_more_nodes:\n            has_more_nodes = False\n            next_nodes = []\n            for node in current_nodes:\n                if node is None:\n                    values.append(None)\n                    next_nodes.extend((None, None))\n                    continue\n\n                if node.left is not None or node.right is not None:\n                    has_more_nodes = True\n\n                values.append(node.value)\n                next_nodes.extend((node.left, node.right))\n\n            current_nodes = next_nodes\n\n        # Get rid of trailing None's\n        while values and values[-1] is None:\n            values.pop()\n\n        return values"}}, "leetcode/leetcode_222.txt": {"score": 0.9107995629310608, "content": {"text": "class TreeNode:\n    \"\"\"Given the `root` of a **complete** binary tree, return the number of the nodes in the tree.\n\nAccording to **[Wikipedia](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.\n\nDesign an algorithm that runs in less than `O(n)` time complexity.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5,6\\]\n**Output:** 6\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5 * 104]`.\n*   `0 <= Node.val <= 5 * 104`\n*   The tree is guaranteed to be **complete**.\"\"\"\n\n    def __init__(self, left=None, right=None):\n        self.left = left\n        self.right = right\n\ndef count_nodes(root):\n    if not root:\n        return 0\n    ld = rd = 0\n    l = r = root\n\n    while l:\n        l = l.left\n        ld += 1\n\n    while r:\n        r = r.right\n        rd += 1\n\n    if ld == rd:\n        return (1 << ld) - 1\n    return 1 + count_nodes(root.left) + count_nodes(root.right)"}}, "leetcode/leetcode_2415.txt": {"score": 0.8919691443443298, "content": {"text": "class TreeNode:\n    \"\"\"Given the `root` of a **perfect** binary tree, reverse the node values at each **odd** level of the tree.\n\n*   For example, suppose the node values at level 3 are `[2,1,3,4,7,11,29,18]`, then it should become `[18,29,11,7,4,3,1,2]`.\n\nReturn _the root of the reversed tree_.\n\nA binary tree is **perfect** if all parent nodes have two children and all leaves are on the same level.\n\nThe **level** of a node is the number of edges along the path between it and the root node.\n\n**Example 1:**\n\n**Input:** root = \\[2,3,5,8,13,21,34\\]\n**Output:** \\[2,5,3,8,13,21,34\\]\n**Explanation:** \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.\n\n**Example 2:**\n\n**Input:** root = \\[7,13,11\\]\n**Output:** \\[7,11,13\\]\n**Explanation:** \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.\n\n**Example 3:**\n\n**Input:** root = \\[0,1,2,0,0,0,0,1,1,1,1,2,2,2,2\\]\n**Output:** \\[0,2,1,0,0,0,0,2,2,2,2,1,1,1,1\\]\n**Explanation:** \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 214]`.\n*   `0 <= Node.val <= 105`\n*   `root` is a **perfect** binary tree.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef reverse_odd_levels(node, level):\n    if node is None: return\n    if level % 2 == 1:\n        node.left, node.right = node.right, node.left\n    reverse_odd_levels(node.left, level + 1)\n    reverse_odd_levels(node.right, level + 1)\n\ndef reverse_odd_level_nodes(root):\n    reverse_odd_levels(root, 0)\n    return root"}}, "leetcode/csn_python_train_316995.txt": {"score": 0.9014262557029724, "content": {"text": "def build(values):\n    \"\"\"Build a tree from `list representation`_ and return its root node.\n\n    .. _list representation:\n        https://en.wikipedia.org/wiki/Binary_tree#Arrays\n\n    :param values: List representation of the binary tree, which is a list of\n        node values in breadth-first order starting from the root (current\n        node). If a node is at index i, its left child is always at 2i + 1,\n        right child at 2i + 2, and parent at floor((i - 1) / 2). None indicates\n        absence of a node at that index. See example below for an illustration.\n    :type values: [int | float | None]\n    :return: Root node of the binary tree.\n    :rtype: binarytree.Node\n    :raise binarytree.exceptions.NodeNotFoundError: If the list representation\n        is malformed (e.g. a parent node is missing).\n\n    **Example**:\n\n    .. doctest::\n\n        >>> from binarytree import build\n        >>>\n        >>> root = build([1, 2, 3, None, 4])\n        >>>\n        >>> print(root)\n        <BLANKLINE>\n          __1\n         /   \\\\\n        2     3\n         \\\\\n          4\n        <BLANKLINE>\n\n    .. doctest::\n\n        >>> from binarytree import build\n        >>>\n        >>> root = build([None, 2, 3])  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n         ...\n        NodeNotFoundError: parent node missing at index 0\n    \"\"\"\n    nodes = [None if v is None else Node(v) for v in values]\n\n    for index in range(1, len(nodes)):\n        node = nodes[index]\n        if node is not None:\n            parent_index = (index - 1) // 2\n            parent = nodes[parent_index]\n            if parent is None:\n                raise NodeNotFoundError(\n                    'parent node missing at index {}'.format(parent_index))\n            setattr(parent, 'left' if index % 2 else 'right', node)\n\n    return nodes[0] if nodes else None"}}, "leetcode/leetcode_971.txt": {"score": 0.9070058465003967, "content": {"text": "from collections import deque\n    \"\"\"You are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired** [**pre-order traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order) of the binary tree.\n\nAny node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\nFlip the **smallest** number of nodes so that the **pre-order traversal** of the tree **matches** `voyage`.\n\nReturn _a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the pre-order traversal match_ `voyage`_, return the list_ `[-1]`.\n\n**Example 1:**\n\n**Input:** root = \\[1,2\\], voyage = \\[2,1\\]\n**Output:** \\[-1\\]\n**Explanation:** It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\], voyage = \\[1,3,2\\]\n**Output:** \\[1\\]\n**Explanation:** Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n\n**Example 3:**\n\n**Input:** root = \\[1,2,3\\], voyage = \\[1,2,3\\]\n**Output:** \\[\\]\n**Explanation:** The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `n == voyage.length`\n*   `1 <= n <= 100`\n*   `1 <= Node.val, voyage[i] <= n`\n*   All the values in the tree are **unique**.\n*   All the values in `voyage` are **unique**.\"\"\"\n\n\ndef shortestBridge(grid):\n    n = len(grid)\n    q = deque()\n\n    # Find the first island and mark it\n    for i in range(n):\n        if any(grid[i]):\n            first_row = i\n            first_col = grid[first_row].index(1)\n            break\n\n    dfs(grid, q, first_row, first_col)\n\n    steps = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    while q:\n        for _ in range(len(q)):\n            x, y = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n:\n                    if grid[nx][ny] == 1:\n                        return steps\n                    elif grid[nx][ny] == 0:\n                        grid[nx][ny] = -1\n                        q.append((nx, ny))\n        steps += 1\n    return -1\n\ndef dfs(grid, q, i, j):\n    n = len(grid)\n    if not (0 <= i < n and 0 <= j < n and grid[i][j] == 1):\n        return\n    grid[i][j] = -1\n    q.append((i, j))\n    \n    dfs(grid, q, i - 1, j)\n    dfs(grid, q, i + 1, j)\n    dfs(grid, q, i, j - 1)\n    dfs(grid, q, i, j + 1)"}}, "leetcode/leetcode_1022.txt": {"score": 0.928296685218811, "content": {"text": "def uniquePathsIII(grid):\n    \"\"\"You are given the `root` of a binary tree where each node has a value `0` or `1`. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\n*   For example, if the path is `0 -> 1 -> 1 -> 0 -> 1`, then this could represent `01101` in binary, which is `13`.\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return _the sum of these numbers_.\n\nThe test cases are generated so that the answer fits in a **32-bits** integer.\n\n**Example 1:**\n\n**Input:** root = \\[1,0,1,0,1,0,1\\]\n**Output:** 22\n**Explanation:** (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\n**Example 2:**\n\n**Input:** root = \\[0\\]\n**Output:** 0\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `Node.val` is `0` or `1`.\"\"\"\n\n    x, y, empty = 0, 0, 1\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                x, y = i, j\n            elif grid[i][j] == 0:\n                empty += 1\n    return dfs(grid, x, y, empty)\n\ndef dfs(grid, x, y, empty):\n    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == -1:\n        return 0\n    if grid[x][y] == 2:\n        return 1 if empty == -1 else 0\n    grid[x][y] = -1\n    paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1)\n    grid[x][y] = 0\n    return paths"}}, "leetcode/leetcode_1104.txt": {"score": 0.9447590112686157, "content": {"text": "def colorBorder(grid, row, col, color):\n    \"\"\"In an infinite binary tree where every node has two children, the nodes are labelled in row order.\n\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\nGiven the `label` of a node in this tree, return the labels in the path from the root of the tree to the node with that `label`.\n\n**Example 1:**\n\n**Input:** label = 14\n**Output:** \\[1,3,4,14\\]\n\n**Example 2:**\n\n**Input:** label = 26\n**Output:** \\[1,2,6,10,26\\]\n\n**Constraints:**\n\n*   `1 <= label <= 10^6`\"\"\"\n\n    def dfs(grid, row, col, current, color):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != current:\n            return\n\n        grid[row][col] = color\n        dfs(grid, row - 1, col, current, color)\n        dfs(grid, row + 1, col, current, color)\n        dfs(grid, row, col - 1, current, color)\n        dfs(grid, row, col + 1, current, color)\n\n    current = grid[row][col]\n    if current == color:\n        return grid\n\n    dfs(grid, row, col, current, color + 1000)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] > 1000:\n                grid[i][j] -= 1000\n\n    return grid"}}}}, "58": {"gold": {"leetcode/leetcode_1563.txt": 1, "leetcode/leetcode_1686.txt": 1, "leetcode/leetcode_1690.txt": 1, "leetcode/leetcode_1872.txt": 1, "leetcode/leetcode_2029.txt": 1}, "retrieved": {"leetcode/leetcode_1563.txt": {"score": 0.9311373829841614, "content": {"text": "from math import acos, cos, sin, sqrt\n    \"\"\"There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially **zero**.\n\nReturn _the maximum score that Alice can obtain_.\n\n**Example 1:**\n\n**Input:** stoneValue = \\[6,2,3,4,5,5\\]\n**Output:** 18\n**Explanation:** In the first round, Alice divides the row to \\[6,2,3\\], \\[4,5,5\\]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to \\[6\\], \\[2,3\\]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is \\[2\\], \\[3\\]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\n**Example 2:**\n\n**Input:** stoneValue = \\[7,7,7,7,7,7,7\\]\n**Output:** 28\n\n**Example 3:**\n\n**Input:** stoneValue = \\[4\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 500`\n*   `1 <= stoneValue[i] <= 106`\"\"\"\n\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts"}}, "leetcode/leetcode_1753.txt": {"score": 0.9454101324081421, "content": {"text": "import heapq\n    \"\"\"You are playing a solitaire game with **three piles** of stones of sizes `a`\u200b\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two **different non-empty** piles, take one stone from each, and add `1` point to your score. The game stops when there are **fewer than two non-empty** piles (meaning there are no more available moves).\n\nGiven three integers `a`\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b, return _the_ **_maximum_** _**score** you can get._\n\n**Example 1:**\n\n**Input:** a = 2, b = 4, c = 6\n**Output:** 6\n**Explanation:** The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points.\n\n**Example 2:**\n\n**Input:** a = 4, b = 4, c = 6\n**Output:** 7\n**Explanation:** The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points.\n\n**Example 3:**\n\n**Input:** a = 1, b = 8, c = 8\n**Output:** 8\n**Explanation:** One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 105`\"\"\"\n\nfrom typing import List\n\ndef minimumEffortPath(heights: List[List[int]]) -> int:\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    rows = len(heights)\n    cols = len(heights[0])\n    efforts = [[float('inf')] * cols for _ in range(rows)]\n\n    q = [(0, 0, 0)]\n    efforts[0][0] = 0\n    \n    while q:\n        effort, x, y = heapq.heappop(q)\n        \n        if x == rows - 1 and y == cols - 1:\n            return effort\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_effort = max(effort, abs(heights[nx][ny] - heights[x][y]))\n                if new_effort < efforts[nx][ny]:\n                    efforts[nx][ny] = new_effort\n                    heapq.heappush(q, (new_effort, nx, ny))\n    \n    return -1"}}, "leetcode/leetcode_2029.txt": {"score": 0.9363881945610046, "content": {"text": "def stoneGameIX(stones: List[int]) -> bool:\n    \"\"\"Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array `stones`, where `stones[i]` is the **value** of the `ith` stone.\n\nAlice and Bob take turns, with **Alice** starting first. On each turn, the player may remove any stone from `stones`. The player who removes a stone **loses** if the **sum** of the values of **all removed stones** is divisible by `3`. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\n\nAssuming both players play **optimally**, return `true` _if Alice wins and_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** stones = \\[2,1\\]\n**Output:** true\n**Explanation:** The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\n\n**Example 2:**\n\n**Input:** stones = \\[2\\]\n**Output:** false\n**Explanation:** Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\n\n**Example 3:**\n\n**Input:** stones = \\[5,1,2,4,3\\]\n**Output:** false\n**Explanation:** Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n\n**Constraints:**\n\n*   `1 <= stones.length <= 105`\n*   `1 <= stones[i] <= 104`\"\"\"\n\n    cnt = [0, 0, 0]\n    for s in stones:\n        cnt[s % 3] += 1\n    return (cnt[1] and cnt[2]) or (cnt[1] > cnt[2] if cnt[1] > cnt[2] + 2 else cnt[2] > cnt[1] + 1)"}}, "leetcode/leetcode_1690.txt": {"score": 0.9557539224624634, "content": {"text": "def getMaxLen(nums):\n    \"\"\"Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, they can **remove** either the leftmost stone or the rightmost stone from the row and receive points equal to the **sum** of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.\n\nBob found that he will always lose this game (poor Bob, he always loses), so he decided to **minimize the score's difference**. Alice's goal is to **maximize the difference** in the score.\n\nGiven an array of integers `stones` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **difference** in Alice and Bob's score if they both play **optimally**._\n\n**Example 1:**\n\n**Input:** stones = \\[5,3,1,4,2\\]\n**Output:** 6\n**Explanation:** \n- Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = \\[5,3,1,4\\].\n- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = \\[3,1,4\\].\n- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = \\[1,4\\].\n- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = \\[4\\].\n- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = \\[\\].\nThe score difference is 18 - 12 = 6.\n\n**Example 2:**\n\n**Input:** stones = \\[7,90,5,1,100,10,10,2\\]\n**Output:** 122\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 1000`\n*   `1 <= stones[i] <= 1000`\"\"\"\n\n    maxLength = currentLen = currentNegLen = 0\n    \n    for num in nums:\n        if num > 0:\n            currentLen += 1\n            if currentNegLen > 0:\n                currentNegLen += 1\n        elif num < 0:\n            currentLen, currentNegLen = currentNegLen, currentLen + 1\n        else:\n            currentLen = currentNegLen = 0\n        maxLength = max(maxLength, currentLen)\n    \n    return maxLength"}}, "leetcode/leetcode_1406.txt": {"score": 0.956724226474762, "content": {"text": "def stoneGameIII(stoneValue):\n    \"\"\"Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\n\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n\nAssume Alice and Bob **play optimally**.\n\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n\n**Example 1:**\n\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n\n**Example 2:**\n\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n\n**Example 3:**\n\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`\"\"\"\n\n    n = len(stoneValue)\n    dp = [float(\"-inf\")] * (n + 1)\n    dp[n] = 0\n    \n    for i in range(n - 1, -1, -1):\n        curr = 0\n        for j in range(3):\n            if i + j < n:\n                curr += stoneValue[i + j]\n                dp[i] = max(dp[i], curr - dp[i + j + 1])\n                \n    return \"Tie \" if dp[0] == 0 else \"Alice \" if dp[0] > 0 else \"Bob \""}}, "leetcode/leetcode_877.txt": {"score": 0.9586158394813538, "content": {"text": "from collections import deque, defaultdict\n    \"\"\"Alice and Bob play a game with piles of stones. There are an **even** number of piles arranged in a row, and each pile has a **positive** integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones. The **total** number of stones across all the piles is **odd**, so there are no ties.\n\nAlice and Bob take turns, with **Alice starting first**. Each turn, a player takes the entire pile of stones either from the **beginning** or from the **end** of the row. This continues until there are no more piles left, at which point the person with the **most stones wins**.\n\nAssuming Alice and Bob play optimally, return `true` _if Alice wins the game, or_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** piles = \\[5,3,4,5\\]\n**Output:** true\n**Explanation:** \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes \\[3, 4, 5\\].\nIf Bob takes 3, then the board is \\[4, 5\\], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is \\[3, 4\\], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\n**Example 2:**\n\n**Input:** piles = \\[3,7,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `2 <= piles.length <= 500`\n*   `piles.length` is **even**.\n*   `1 <= piles[i] <= 500`\n*   `sum(piles[i])` is **odd**.\"\"\"\n\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    q = deque()\n    \n    for i in range(n):\n        q.append((i, 1 << i))\n    steps = -1\n    visited = {i: set() for i in range(n)}\n    \n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            currNode, currVisits = q.popleft()\n            \n            if bin(currVisits).count('1') == n:\n                return steps\n\n            for nextNode in graph[currNode]:\n                nextVisits = currVisits | (1 << nextNode)\n\n                if nextVisits not in visited[nextNode]:\n                    visited[nextNode].add(nextVisits)\n                    q.append((nextNode, nextVisits))\n\n    return -1"}}, "leetcode/leetcode_1686.txt": {"score": 0.9428112506866455, "content": {"text": "def stoneGameVI(aliceValues, bobValues):\n    \"\"\"Alice and Bob take turns playing a game, with Alice starting first.\n\nThere are `n` stones in a pile. On each player's turn, they can **remove** a stone from the pile and receive points based on the stone's value. Alice and Bob may **value the stones differently**.\n\nYou are given two integer arrays of length `n`, `aliceValues` and `bobValues`. Each `aliceValues[i]` and `bobValues[i]` represents how Alice and Bob, respectively, value the `ith` stone.\n\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play **optimally**. Both players know the other's values.\n\nDetermine the result of the game, and:\n\n*   If Alice wins, return `1`.\n*   If Bob wins, return `-1`.\n*   If the game results in a draw, return `0`.\n\n**Example 1:**\n\n**Input:** aliceValues = \\[1,3\\], bobValues = \\[2,1\\]\n**Output:** 1\n**Explanation:**\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.\n\n**Example 2:**\n\n**Input:** aliceValues = \\[1,2\\], bobValues = \\[3,1\\]\n**Output:** 0\n**Explanation:**\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.\n\n**Example 3:**\n\n**Input:** aliceValues = \\[2,4,3\\], bobValues = \\[1,6,7\\]\n**Output:** -1\n**Explanation:**\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins.\n\n**Constraints:**\n\n*   `n == aliceValues.length == bobValues.length`\n*   `1 <= n <= 105`\n*   `1 <= aliceValues[i], bobValues[i] <= 100`\"\"\"\n\n    n = len(aliceValues)\n    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceSum, bobSum = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            aliceSum += aliceValues[diff[i][1]]\n        else:\n            bobSum += bobValues[diff[i][1]]\n            \n    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)"}}, "leetcode/leetcode_1872.txt": {"score": 0.9596508741378784, "content": {"text": "def can_eat(candiesCount, queries):\n    \"\"\"Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, while the number of stones is **more than one**, they will do the following:\n\n1.  Choose an integer `x > 1`, and **remove** the leftmost `x` stones from the row.\n2.  Add the **sum** of the **removed** stones' values to the player's score.\n3.  Place a **new stone**, whose value is equal to that sum, on the left side of the row.\n\nThe game stops when **only** **one** stone is left in the row.\n\nThe **score difference** between Alice and Bob is `(Alice's score - Bob's score)`. Alice's goal is to **maximize** the score difference, and Bob's goal is the **minimize** the score difference.\n\nGiven an integer array `stones` of length `n` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **score difference** between Alice and Bob if they both play **optimally**._\n\n**Example 1:**\n\n**Input:** stones = \\[-1,2,-3,4,-5\\]\n**Output:** 5\n**Explanation:**\n- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of\n  value 2 on the left. stones = \\[2,-5\\].\n- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on\n  the left. stones = \\[-3\\].\nThe difference between their scores is 2 - (-3) = 5.\n\n**Example 2:**\n\n**Input:** stones = \\[7,-6,5,10,5,-2,-6\\]\n**Output:** 13\n**Explanation:**\n- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a\n  stone of value 13 on the left. stones = \\[13\\].\nThe difference between their scores is 13 - 0 = 13.\n\n**Example 3:**\n\n**Input:** stones = \\[-10,-12\\]\n**Output:** -22\n**Explanation:**\n- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her\n  score and places a stone of value -22 on the left. stones = \\[-22\\].\nThe difference between their scores is (-22) - 0 = -22.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 105`\n*   `-104 <= stones[i] <= 104`\"\"\"\n\n    prefix_sum = [0] * (len(candiesCount) + 1)\n    for i in range(len(candiesCount)):\n        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]\n\n    result = [False] * len(queries)\n    for i in range(len(queries)):\n        favoriteType, favoriteDay, dailyCap = queries[i]\n        x1 = favoriteDay + 1\n        y1 = (favoriteDay + 1) * dailyCap\n\n        x2 = prefix_sum[favoriteType] + 1\n        y2 = prefix_sum[favoriteType + 1]\n\n        result[i] = not (x1 > y2 or y1 < x2)\n\n    return result"}}, "leetcode/leetcode_486.txt": {"score": 0.9619666337966919, "content": {"text": "def can_win(nums):\n    \"\"\"You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,2\\]\n**Output:** false\n**Explanation:** Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,233,7\\]\n**Output:** true\n**Explanation:** Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 107`\"\"\"\n\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = nums[i]\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n    return dp[0][n - 1] >= 0"}}, "leetcode/leetcode_1140.txt": {"score": 0.9834412336349487, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`\"\"\"\n\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes"}}}}, "59": {"gold": {"leetcode/leetcode_2525.txt": 1}, "retrieved": {"leetcode/csn_python_train_341195.txt": {"score": 0.8889367580413818, "content": {"text": "def tictactoe(w, i, player, opponent, grid=None):\n    \"Put two strategies to a classic battle of wits.\"\n    grid = grid or empty_grid\n    while True:\n        w.render_to_terminal(w.array_from_text(view(grid)))\n        if is_won(grid):\n            print(whose_move(grid), \"wins.\")\n            break\n        if not successors(grid):\n            print(\"A draw.\")\n            break\n        grid = player(w, i, grid)\n        player, opponent = opponent, player"}}, "leetcode/csn_python_train_132130.txt": {"score": 0.9120721817016602, "content": {"text": "def complete(self):\n        \"\"\"is the game over?\"\"\"\n        if None not in [v for v in self.squares]:\n            return True\n        if self.winner() is not None:\n            return True\n        return False"}}, "leetcode/csn_python_train_341271.txt": {"score": 0.8911583423614502, "content": {"text": "def value(board, who='x'):\n    \"\"\"Returns the value of a board\n    >>> b = Board(); b._rows = [['x', 'x', 'x'], ['x', 'x', 'x'], ['x', 'x', 'x']]\n    >>> value(b)\n    1\n    >>> b = Board(); b._rows = [['o', 'o', 'o'], ['o', 'o', 'o'], ['o', 'o', 'o']]\n    >>> value(b)\n    -1\n    >>> b = Board(); b._rows = [['x', 'o', ' '], ['x', 'o', ' '], [' ', ' ', ' ']]\n    >>> value(b)\n    1\n    >>> b._rows[0][2] = 'x'\n    >>> value(b)\n    -1\n    \"\"\"\n    w = board.winner()\n    if w == who:\n        return 1\n    if w == opp(who):\n        return -1\n    if board.turn == 9:\n        return 0\n\n    if who == board.whose_turn:\n        return max([value(b, who) for b in board.possible()])\n    else:\n        return min([value(b, who) for b in board.possible()])"}}, "leetcode/csn_python_train_5751.txt": {"score": 0.9335336685180664, "content": {"text": "def get_reward_and_done(board):\n  \"\"\"Given a representation of the board, returns reward and done.\"\"\"\n  # Returns (reward, done) where:\n  # reward: -1 means lost, +1 means win, 0 means draw or continuing.\n  # done: True if the game is over, i.e. someone won or it is a draw.\n\n  # Sum all rows ...\n  all_sums = [np.sum(board[i, :]) for i in range(3)]\n  # ... all columns\n  all_sums.extend([np.sum(board[:, i]) for i in range(3)])\n  # and both diagonals.\n  all_sums.append(np.sum([board[i, i] for i in range(3)]))\n  all_sums.append(np.sum([board[i, 2 - i] for i in range(3)]))\n\n  if -3 in all_sums:\n    return -1, True\n\n  if 3 in all_sums:\n    return 1, True\n\n  done = True\n  if get_open_spaces(board):\n    done = False\n\n  return 0, done"}}, "leetcode/leetcode_794.txt": {"score": 0.9286779165267944, "content": {"text": "import heapq\n    \"\"\"Given a Tic-Tac-Toe board as a string array `board`, return `true` if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\n\nThe board is a `3 x 3` array that consists of characters `' '`, `'X'`, and `'O'`. The `' '` character represents an empty square.\n\nHere are the rules of Tic-Tac-Toe:\n\n*   Players take turns placing characters into empty squares `' '`.\n*   The first player always places `'X'` characters, while the second player always places `'O'` characters.\n*   `'X'` and `'O'` characters are always placed into empty squares, never filled ones.\n*   The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n*   The game also ends if all squares are non-empty.\n*   No more moves can be played if the game is over.\n\n**Example 1:**\n\n**Input:** board = \\[ \"O   \", \"    \", \"    \"\\]\n**Output:** false\n**Explanation:** The first player always plays  \"X \".\n\n**Example 2:**\n\n**Input:** board = \\[ \"XOX \", \" X  \", \"    \"\\]\n**Output:** false\n**Explanation:** Players take turns making moves.\n\n**Example 3:**\n\n**Input:** board = \\[ \"XOX \", \"O O \", \"XOX \"\\]\n**Output:** true\n\n**Constraints:**\n\n*   `board.length == 3`\n*   `board[i].length == 3`\n*   `board[i][j]` is either `'X'`, `'O'`, or `' '`.\"\"\"\n\n\ndef swim(n, grid):\n    pq = [(grid[0][0], 0, 0)]\n    visited = [[False] * n for _ in range(n)]\n\n    dr = [-1, 0, 1, 0]\n    dc = [0, 1, 0, -1]\n\n    while pq:\n        curT, curR, curC = heapq.heappop(pq)\n\n        if curR == n - 1 and curC == n - 1:\n            return curT\n\n        for d in range(4):\n            newRow, newCol = curR + dr[d], curC + dc[d]\n            if 0 <= newRow < n and 0 <= newCol < n and not visited[newRow][newCol]:\n                visited[newRow][newCol] = True\n                heapq.heappush(pq, (max(curT, grid[newRow][newCol]), newRow, newCol))\n\n    return -1"}}, "leetcode/leetcode_1958.txt": {"score": 0.9018919467926025, "content": {"text": "def checkMove(board, rMove, cMove, color):\n    \"\"\"You are given a **0-indexed** `8 x 8` grid `board`, where `board[r][c]` represents the cell `(r, c)` on a game board. On the board, free cells are represented by `'.'`, white cells are represented by `'W'`, and black cells are represented by `'B'`.\n\nEach move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only **legal** if, after changing it, the cell becomes the **endpoint of a good line** (horizontal, vertical, or diagonal).\n\nA **good line** is a line of **three or more cells (including the endpoints)** where the endpoints of the line are **one color**, and the remaining cells in the middle are the **opposite color** (no cells in the line are free). You can find examples for good lines in the figure below:\n\nGiven two integers `rMove` and `cMove` and a character `color` representing the color you are playing as (white or black), return `true` _if changing cell_ `(rMove, cMove)` _to color_ `color` _is a **legal** move, or_ `false` _if it is not legal_.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"W \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"W \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"W \", \". \", \". \", \". \", \". \"\\],\\[ \"W \", \"B \", \"B \", \". \", \"W \", \"W \", \"W \", \"B \"\\],\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"W \", \". \", \". \", \". \", \". \"\\]\\], rMove = 4, cMove = 3, color =  \"B \"\n**Output:** true\n**Explanation:** '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'.\nThe two good lines with the chosen cell as an endpoint are annotated above with the red rectangles.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \"B \", \". \", \". \", \"W \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \"W \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"W \", \"B \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \"B \", \"W \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \"W \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \"B \"\\]\\], rMove = 4, cMove = 4, color =  \"W \"\n**Output:** false\n**Explanation:** While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint.\n\n**Constraints:**\n\n*   `board.length == board[r].length == 8`\n*   `0 <= rMove, cMove < 8`\n*   `board[rMove][cMove] == '.'`\n*   `color` is either `'B'` or `'W'`.\"\"\"\n\n    directions = ((-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1))\n    opposite_color = 'B' if color == 'W' else 'W'\n\n    for d in directions:\n        x, y = rMove + d[0], cMove + d[1]\n        count = 0\n        while 0 <= x < 8 and 0 <= y < 8 and board[x][y] == opposite_color:\n            x += d[0]\n            y += d[1]\n            count += 1\n\n        if count > 0 and 0 <= x < 8 and 0 <= y < 8 and board[x][y] == color:\n            return True\n\n    return False"}}, "leetcode/csn_python_train_5750.txt": {"score": 0.900467574596405, "content": {"text": "def get_open_spaces(board):\n  \"\"\"Given a representation of the board, returns a list of open spaces.\"\"\"\n  open_spaces = []\n  for i in range(3):\n    for j in range(3):\n      if board[i][j] == 0:\n        open_spaces.append(encode_pos(i, j))\n  return open_spaces"}}, "leetcode/leetcode_1275.txt": {"score": 0.9886855483055115, "content": {"text": "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    \"\"\"**Tic-tac-toe** is played by two players `A` and `B` on a `3 x 3` grid. The rules of Tic-Tac-Toe are:\n\n*   Players take turns placing characters into empty squares `' '`.\n*   The first player `A` always places `'X'` characters, while the second player `B` always places `'O'` characters.\n*   `'X'` and `'O'` characters are always placed into empty squares, never on filled ones.\n*   The game ends when there are **three** of the same (non-empty) character filling any row, column, or diagonal.\n*   The game also ends if all squares are non-empty.\n*   No more moves can be played if the game is over.\n\nGiven a 2D integer array `moves` where `moves[i] = [rowi, coli]` indicates that the `ith` move will be played on `grid[rowi][coli]`. return _the winner of the game if it exists_ (`A` or `B`). In case the game ends in a draw return `\"Draw \"`. If there are still movements to play return `\"Pending \"`.\n\nYou can assume that `moves` is valid (i.e., it follows the rules of **Tic-Tac-Toe**), the grid is initially empty, and `A` will play first.\n\n**Example 1:**\n\n**Input:** moves = \\[\\[0,0\\],\\[2,0\\],\\[1,1\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:**  \"A \"\n**Explanation:** A wins, they always play first.\n\n**Example 2:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[0,1\\],\\[0,2\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:**  \"B \"\n**Explanation:** B wins.\n\n**Example 3:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\],\\[1,0\\],\\[1,2\\],\\[2,1\\],\\[0,1\\],\\[0,2\\],\\[2,2\\]\\]\n**Output:**  \"Draw \"\n**Explanation:** The game ends in a draw since there are no moves to make.\n\n**Constraints:**\n\n*   `1 <= moves.length <= 9`\n*   `moves[i].length == 2`\n*   `0 <= rowi, coli <= 2`\n*   There are no repeated elements on `moves`.\n*   `moves` follow the rules of tic tac toe.\"\"\"\n\n    parent = [-1] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            if parent[leftChild[i]] != -1:\n                return False\n            parent[leftChild[i]] = i\n        if rightChild[i] != -1:\n            if parent[rightChild[i]] != -1:\n                return False\n            parent[rightChild[i]] = i\n    \n    root = -1\n    for i in range(n):\n        if parent[i] == -1:\n            if root != -1:\n                return False\n            root = i\n\n    return root != -1"}}, "leetcode/csn_python_train_341273.txt": {"score": 0.9491469860076904, "content": {"text": "def winner(self):\n        \"\"\"Returns either x or o if one of them won, otherwise None\"\"\"\n        for c in 'xo':\n            for comb in [(0,3,6), (1,4,7), (2,5,8), (0,1,2), (3,4,5), (6,7,8), (0,4,8), (2,4,6)]:\n                if all(self.spots[p] == c for p in comb):\n                    return c\n        return None"}}, "leetcode/csn_python_train_304035.txt": {"score": 0.9387131333351135, "content": {"text": "def isWon(state, who):\n    \"\"\"Test if a tic-tac-toe game has been won.\n    \n    Assumes that the board is in a legal state.\n    Will test if the value 1 is in any winning combination.\n    \n    \"\"\"\n    for w in WINS:\n        S = sum(1 if (w[k] == 1 and state[k] == who) else 0\n                for k in range(ACTIONS))\n        if S == 3:\n            # We have a win\n            return True\n    # There were no wins so return False\n    return False"}}}}, "60": {"gold": {"leetcode/leetcode_2045.txt": 1}, "retrieved": {"leetcode/leetcode_1514.txt": {"score": 0.9036553502082825, "content": {"text": "def min_start_value(nums):\n    \"\"\"You are given an undirected weighted graph of `n` nodes (0-indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes `a` and `b` with a probability of success of traversing that edge `succProb[i]`.\n\nGiven two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability.\n\nIf there is no path from `start` to `end`, **return 0**. Your answer will be accepted if it differs from the correct answer by at most **1e-5**.\n\n**Example 1:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,2\\]\\], succProb = \\[0.5,0.5,0.2\\], start = 0, end = 2\n**Output:** 0.25000\n**Explanation:** There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 \\* 0.5 = 0.25.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,2\\]\\], succProb = \\[0.5,0.5,0.3\\], start = 0, end = 2\n**Output:** 0.30000\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\]\\], succProb = \\[0.5\\], start = 0, end = 2\n**Output:** 0.00000\n**Explanation:** There is no path between 0 and 2.\n\n**Constraints:**\n\n*   `2 <= n <= 10^4`\n*   `0 <= start, end < n`\n*   `start != end`\n*   `0 <= a, b < n`\n*   `a != b`\n*   `0 <= succProb.length == edges.length <= 2*10^4`\n*   `0 <= succProb[i] <= 1`\n*   There is at most one edge between every two nodes.\"\"\"\n\n    min_sum, sum = 0, 0\n    for num in nums:\n        sum += num\n        min_sum = min(min_sum, sum)\n    return 1 - min_sum"}}, "leetcode/leetcode_881.txt": {"score": 0.9081114530563354, "content": {"text": "from collections import defaultdict\n    \"\"\"You are given an array `people` where `people[i]` is the weight of the `ith` person, and an **infinite number of boats** where each boat can carry a maximum weight of `limit`. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most `limit`.\n\nReturn _the minimum number of boats to carry every given person_.\n\n**Example 1:**\n\n**Input:** people = \\[1,2\\], limit = 3\n**Output:** 1\n**Explanation:** 1 boat (1, 2)\n\n**Example 2:**\n\n**Input:** people = \\[3,2,2,1\\], limit = 3\n**Output:** 3\n**Explanation:** 3 boats (1, 2), (2) and (3)\n\n**Example 3:**\n\n**Input:** people = \\[3,5,3,4\\], limit = 5\n**Output:** 4\n**Explanation:** 4 boats (3), (3), (4), (5)\n\n**Constraints:**\n\n*   `1 <= people.length <= 5 * 104`\n*   `1 <= people[i] <= limit <= 3 * 104`\"\"\"\n\n\ndef loudAndRich(richer, quiet):\n    n = len(quiet)\n    graph = defaultdict(list)\n    for r in richer:\n        graph[r[1]].append(r[0])\n\n    answer = [-1] * n\n\n    def dfs(x):\n        if answer[x] != -1:\n            return answer[x]\n        answer[x] = x\n        for y in graph[x]:\n            cand = dfs(y)\n            if quiet[cand] < quiet[answer[x]]:\n                answer[x] = cand\n        return answer[x]\n\n    for i in range(n):\n        dfs(i)\n\n    return answer"}}, "leetcode/csn_python_train_403018.txt": {"score": 0.911620557308197, "content": {"text": "def dijkstra_single_path_length(G, start, end):\n    \"\"\"\n    Compute shortest path length between satrt\n    and end for a weight graph. return -> (length, [path])\n    \"\"\"\n    if start not in G.vertices:\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (start,))\n    if end not in G.vertices:\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (end,))\n    dijkstra_data = dijkstra(G, start)\n    length = dijkstra_data[0][end]\n    path = [end]\n    current = end\n    while current is not start:\n        for vertex in dijkstra_data[1]:\n            if vertex is current:\n                path.append(dijkstra_data[1][vertex])\n                current = dijkstra_data[1][vertex]\n                break\n    return length, path"}}, "leetcode/leetcode_1976.txt": {"score": 0.9143666625022888, "content": {"text": "def can_split_string(s: str) -> bool:\n    \"\"\"You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with **bi-directional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the **shortest amount of time**.\n\nReturn _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 7, roads = \\[\\[0,6,7\\],\\[0,1,2\\],\\[1,2,3\\],\\[1,3,3\\],\\[6,3,3\\],\\[3,5,1\\],\\[6,5,1\\],\\[2,5,1\\],\\[0,4,5\\],\\[4,6,2\\]\\]\n**Output:** 4\n**Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u279d 6\n- 0 \u279d 4 \u279d 6\n- 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6\n- 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6\n\n**Example 2:**\n\n**Input:** n = 2, roads = \\[\\[1,0,10\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\n*   `n - 1 <= roads.length <= n * (n - 1) / 2`\n*   `roads[i].length == 3`\n*   `0 <= ui, vi <= n - 1`\n*   `1 <= timei <= 109`\n*   `ui != vi`\n*   There is at most one road connecting any two intersections.\n*   You can reach any intersection from any other intersection.\"\"\"\n\n    count = [0] * 10\n\n    for c in s:\n        count[int(c)] += 1\n\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n\n    return False"}}, "leetcode/leetcode_743.txt": {"score": 0.9262122511863708, "content": {"text": "import heapq\n    \"\"\"You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return _the **minimum** time it takes for all the_ `n` _nodes to receive the signal_. If it is impossible for all the `n` nodes to receive the signal, return `-1`.\n\n**Example 1:**\n\n**Input:** times = \\[\\[2,1,1\\],\\[2,3,1\\],\\[3,4,1\\]\\], n = 4, k = 2\n**Output:** 2\n\n**Example 2:**\n\n**Input:** times = \\[\\[1,2,1\\]\\], n = 2, k = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** times = \\[\\[1,2,1\\]\\], n = 2, k = 2\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= k <= n <= 100`\n*   `1 <= times.length <= 6000`\n*   `times[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `0 <= wi <= 100`\n*   All the pairs `(ui, vi)` are **unique**. (i.e., no multiple edges.)\"\"\"\n\n\ndef networkDelayTime(times, n, k):\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {u: float('inf') for u in range(1, n+1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n\n        for v, weight in graph[u]:\n            new_dist = curr_dist + weight\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n\n    max_time = max(dist.values())\n    return max_time if max_time < float('inf') else -1"}}, "leetcode/leetcode_1928.txt": {"score": 0.9465402960777283, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"There is a country of `n` cities numbered from `0` to `n - 1` where **all the cities are connected** by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is represented as a **0-indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime` **minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or_ `-1` _if you cannot complete it within_ `maxTime` _minutes_.\n\n**Example 1:**\n\n**Input:** maxTime = 30, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 11\n**Explanation:** The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n\n**Example 2:**\n\n**Input:** maxTime = 29, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 48\n**Explanation:** The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n\n**Example 3:**\n\n**Input:** maxTime = 25, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** -1\n**Explanation:** There is no way to reach city 5 from city 0 within 25 minutes.\n\n**Constraints:**\n\n*   `1 <= maxTime <= 1000`\n*   `n == passingFees.length`\n*   `2 <= n <= 1000`\n*   `n - 1 <= edges.length <= 1000`\n*   `0 <= xi, yi <= n - 1`\n*   `1 <= timei <= 1000`\n*   `1 <= passingFees[j] <= 1000`\n*   The graph may contain multiple edges between two nodes.\n*   The graph does not contain self loops.\"\"\"\n\n\ndef getNumberOfBacklogOrders(orders):\n    buy, sell = [], []\n\n    for price, amount, orderType in orders:\n        if orderType == 0:\n            while amount > 0 and sell and -sell[0][0] <= price:\n                executedAmount = min(amount, sell[0][1])\n                amount -= executedAmount\n                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]\n                if sell[0][1] == 0:\n                    heappop(sell)\n            if amount:\n                heappush(buy, [-price, amount])\n        else:\n            while amount > 0 and buy and buy[0][0] >= price:\n                executedAmount = min(amount, buy[0][1])\n                amount -= executedAmount\n                buy[0] = [buy[0][0], buy[0][1] - executedAmount]\n                if buy[0][1] == 0:\n                    heappop(buy)\n            if amount:\n                heappush(sell, [-price, amount])\n\n    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)\n    return res % 1000000007"}}, "leetcode/leetcode_787.txt": {"score": 0.9328771233558655, "content": {"text": "from collections import deque\n    \"\"\"There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return `-1`.\n\n**Example 1:**\n\n**Input:** n = 4, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[2,0,100\\],\\[1,3,600\\],\\[2,3,200\\]\\], src = 0, dst = 3, k = 1\n**Output:** 700\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities \\[0,1,2,3\\] is cheaper but is invalid because it uses 2 stops.\n\n**Example 2:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 1\n**Output:** 200\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\n**Example 3:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 0\n**Output:** 500\n**Explanation:**\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= flights.length <= (n * (n - 1) / 2)`\n*   `flights[i].length == 3`\n*   `0 <= fromi, toi < n`\n*   `fromi != toi`\n*   `1 <= pricei <= 104`\n*   There will not be any multiple flights between two cities.\n*   `0 <= src, dst, k < n`\n*   `src != dst`\"\"\"\n\n\ndef slidingPuzzle(board):\n    m, n = 2, 3\n    target = \"123450\"\n    start = \"\".join(str(num) for row in board for num in row)\n    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]\n    q = deque([start])\n    res = 0\n    visited = {start}\n    while q:\n        for _ in range(len(q)):\n            cur = q.popleft()\n            if cur == target:\n                return res\n            zero_idx = cur.index(\"0\")\n            for dir in dirs[zero_idx]:\n                neighbor = list(cur)\n                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]\n                neighbor = \"\".join(neighbor)\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        res += 1\n    return -1"}}, "leetcode/leetcode_1334.txt": {"score": 0.9926489591598511, "content": {"text": "def findTheCity(n, edges, distanceThreshold):\n    \"\"\"There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[0,1,3\\],\\[1,2,1\\],\\[1,3,4\\],\\[2,3,1\\]\\], distanceThreshold = 4\n**Output:** 3\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> \\[City 1, City 2\\] \nCity 1 -> \\[City 0, City 2, City 3\\] \nCity 2 -> \\[City 0, City 1, City 3\\] \nCity 3 -> \\[City 1, City 2\\] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1,2\\],\\[0,4,8\\],\\[1,2,3\\],\\[1,4,2\\],\\[2,3,1\\],\\[3,4,1\\]\\], distanceThreshold = 2\n**Output:** 0\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> \\[City 1\\] \nCity 1 -> \\[City 0, City 4\\] \nCity 2 -> \\[City 3, City 4\\] \nCity 3 -> \\[City 2, City 4\\]\nCity 4 -> \\[City 1, City 2, City 3\\] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= edges.length <= n * (n - 1) / 2`\n*   `edges[i].length == 3`\n*   `0 <= fromi < toi < n`\n*   `1 <= weighti, distanceThreshold <= 10^4`\n*   All pairs `(fromi, toi)` are distinct.\"\"\"\n\n    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res"}}, "leetcode/leetcode_1786.txt": {"score": 0.9422495365142822, "content": {"text": "def count_consistent_strings(allowed, words):\n    \"\"\"There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[1,2,3\\],\\[1,3,3\\],\\[2,3,1\\],\\[1,4,2\\],\\[5,2,2\\],\\[3,5,1\\],\\[5,4,10\\]\\]\n**Output:** 3\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,3,1\\],\\[4,1,2\\],\\[7,3,4\\],\\[2,5,3\\],\\[5,6,1\\],\\[6,7,2\\],\\[7,5,3\\],\\[2,6,4\\]\\]\n**Output:** 1\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The only restricted path is 1 --> 3 --> 7.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `n - 1 <= edges.length <= 4 * 104`\n*   `edges[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= weighti <= 105`\n*   There is at most one edge between any two nodes.\n*   There is at least one path between any two nodes.\"\"\"\n\n    allowed_set = set(allowed)\n    count = 0\n    for word in words:\n        is_valid = True\n        for c in word:\n            if c not in allowed_set:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n    return count"}}, "leetcode/leetcode_2492.txt": {"score": 0.9428750872612, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are given a positive integer `n` representing `n` cities numbered from `1` to `n`. You are also given a **2D** array `roads` where `roads[i] = [ai, bi, distancei]` indicates that there is a **bidirectional** road between cities `ai` and `bi` with a distance equal to `distancei`. The cities graph is not necessarily connected.\n\nThe **score** of a path between two cities is defined as the **minimum** distance of a road in this path.\n\nReturn _the **minimum** possible score of a path between cities_ `1` _and_ `n`.\n\n**Note**:\n\n*   A path is a sequence of roads between two cities.\n*   It is allowed for a path to contain the same road **multiple** times, and you can visit cities `1` and `n` multiple times along the path.\n*   The test cases are generated such that there is **at least** one path between `1` and `n`.\n\n**Example 1:**\n\n**Input:** n = 4, roads = \\[\\[1,2,9\\],\\[2,3,6\\],\\[2,4,5\\],\\[1,4,7\\]\\]\n**Output:** 5\n**Explanation:** The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n\n**Example 2:**\n\n**Input:** n = 4, roads = \\[\\[1,2,2\\],\\[1,3,4\\],\\[3,4,7\\]\\]\n**Output:** 2\n**Explanation:** The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `1 <= roads.length <= 105`\n*   `roads[i].length == 3`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   `1 <= distancei <= 104`\n*   There are no repeated edges.\n*   There is at least one path between `1` and `n`.\"\"\"\n\nfrom collections import defaultdict\n\ndef minimumScore(n, roads):\n    adj = defaultdict(list)\n    for road in roads:\n        adj[road[0]].append((road[1], road[2]))\n        adj[road[1]].append((road[0], road[2]))\n\n    INF = int(1e9)\n    pq = [(0, 1)]\n\n    minDist = [INF] * (n + 1)\n    while pq:\n        curDist, curCity = heappop(pq)\n\n        if curCity == n:\n            return curDist\n\n        if curDist < minDist[curCity]:\n            minDist[curCity] = curDist\n            for nextCity, nextDist in adj[curCity]:\n                candidate_dist = max(curDist, nextDist)\n                if candidate_dist < minDist[nextCity]:\n                    heappush(pq, (candidate_dist, nextCity))\n\n    return -1"}}}}, "61": {"gold": {"leetcode/leetcode_2267.txt": 1}, "retrieved": {"leetcode/csn_python_train_390945.txt": {"score": 0.9186926484107971, "content": {"text": "def traverse_core(core_area, world_size=(60, 60),\n                  neighbor_func=get_moore_neighbors_toroidal):\n    \"\"\"\n    Treat cells in core_area like a graph and traverse it to\n    see how many connected components there are.\n    \"\"\"\n\n    if not core_area:\n        return []\n    core_area = [tuple(i) for i in core_area]\n    curr = core_area[0]\n    core_area = set(core_area[1:])\n    to_explore = []\n    cores = [[curr]]\n\n    while core_area:\n        neighbors = neighbor_func(curr, world_size)\n\n        for n in neighbors:\n            if n in core_area:\n                core_area.remove(n)\n                to_explore.append(n)\n                cores[-1].append(n)\n\n        if to_explore:\n            curr = to_explore.pop()\n        else:\n            curr = core_area.pop()\n            cores.append([curr])\n\n    return cores"}}, "leetcode/leetcode_1559.txt": {"score": 0.924018144607544, "content": {"text": "def cherry_pickup(grid):\n    \"\"\"Given a 2D array of characters `grid` of size `m x n`, you need to find if there exists any cycle consisting of the **same value** in `grid`.\n\nA cycle is a path of **length 4 or more** in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the **same value** of the current cell.\n\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle `(1, 1) -> (1, 2) -> (1, 1)` is invalid because from `(1, 2)` we visited `(1, 1)` which was the last visited cell.\n\nReturn `true` if any cycle of the same value exists in `grid`, otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[ \"a \", \"a \", \"a \", \"a \"\\],\\[ \"a \", \"b \", \"b \", \"a \"\\],\\[ \"a \", \"b \", \"b \", \"a \"\\],\\[ \"a \", \"a \", \"a \", \"a \"\\]\\]\n**Output:** true\n**Explanation:** There are two valid cycles shown in different colors in the image below:\n \n\n**Example 2:**\n\n**Input:** grid = \\[\\[ \"c \", \"c \", \"c \", \"a \"\\],\\[ \"c \", \"d \", \"c \", \"c \"\\],\\[ \"c \", \"c \", \"e \", \"c \"\\],\\[ \"f \", \"c \", \"c \", \"c \"\\]\\]\n**Output:** true\n**Explanation:** There is only one valid cycle highlighted in the image below:\n \n\n**Example 3:**\n\n**Input:** grid = \\[\\[ \"a \", \"b \", \"b \"\\],\\[ \"b \", \"z \", \"b \"\\],\\[ \"b \", \"b \", \"a \"\\]\\]\n**Output:** false\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid` consists only of lowercase English letters.\"\"\"\n\n    rows, cols = len(grid), len(grid[0])\n    dp = [[[0] * cols for _ in range(cols)] for _ in range(rows)]\n\n    for row in reversed(range(rows)):\n        for col1 in range(cols):\n            for col2 in range(cols):\n                current_cell = dp[row + 1][col1][col2] if row < rows - 1 else 0\n                current_cell += grid[row][col1] + (grid[row][col2] if col1 != col2 else 0)\n\n                max_val = 0\n                for move1 in range(-1, 2):\n                    for move2 in range(-1, 2):\n                        new_col1, new_col2 = col1 + move1, col2 + move2\n                        if 0 <= new_col1 < cols and 0 <= new_col2 < cols:\n                            max_val = max(max_val, dp[row][new_col1][new_col2])\n\n                dp[row][col1][col2] = current_cell + max_val\n\n    return dp[0][0][cols - 1]"}}, "leetcode/leetcode_463.txt": {"score": 0.922494113445282, "content": {"text": "def islandPerimeter(grid):\n    \"\"\"You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.\"\"\"\n\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter"}}, "leetcode/leetcode_1034.txt": {"score": 0.9286568760871887, "content": {"text": "def good_subarrays(nums, k):\n    \"\"\"You are given an `m x n` integer matrix `grid`, and three integers `row`, `col`, and `color`. Each value in the grid represents the color of the grid square at that location.\n\nTwo squares belong to the same **connected component** if they have the same color and are next to each other in any of the 4 directions.\n\nThe **border of a connected component** is all the squares in the connected component that are either **4-directionally** adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\n\nYou should color the **border** of the **connected component** that contains the square `grid[row][col]` with `color`.\n\nReturn _the final grid_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,2\\]\\], row = 0, col = 0, color = 3\n**Output:** \\[\\[3,3\\],\\[3,2\\]\\]\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,2\\],\\[2,3,2\\]\\], row = 0, col = 1, color = 3\n**Output:** \\[\\[1,3,3\\],\\[2,3,3\\]\\]\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], row = 1, col = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j], color <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        frequency = {}\n        for j in range(i, len(nums)):\n            frequency[nums[j]] = frequency.get(nums[j], 0) + 1\n            if len(frequency) > k:\n                break\n            if len(frequency) == k:\n                count += 1\n    return count"}}, "leetcode/csn_python_train_320967.txt": {"score": 0.9368321895599365, "content": {"text": "def dfs_grid_recursive(grid, i, j, mark='X', free='.'):\n    \"\"\"DFS on a grid, mark connected component, iterative version\n\n    :param grid: matrix, 4-neighborhood\n    :param i,j: cell in this matrix, start of DFS exploration\n    :param free: symbol for walkable cells\n    :param mark: symbol to overwrite visited vertices\n    :complexity: linear\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    grid[i][j] = mark              # mark path\n    for ni, nj in [(i + 1, j), (i, j + 1),\n                   (i - 1, j), (i, j - 1)]:\n        if 0 <= ni < height and 0 <= nj < width:\n            if grid[ni][nj] == free:\n                dfs_grid(grid, ni, nj)"}}, "leetcode/leetcode_1992.txt": {"score": 0.9377925395965576, "content": {"text": "def findFarmland(land):\n    \"\"\"You are given a **0-indexed** `m x n` binary matrix `land` where a `0` represents a hectare of forested land and a `1` represents a hectare of farmland.\n\nTo keep the land organized, there are designated rectangular areas of hectares that consist **entirely** of farmland. These rectangular areas are called **groups**. No two groups are adjacent, meaning farmland in one group is **not** four-directionally adjacent to another farmland in a different group.\n\n`land` can be represented by a coordinate system where the top left corner of `land` is `(0, 0)` and the bottom right corner of `land` is `(m-1, n-1)`. Find the coordinates of the top left and bottom right corner of each **group** of farmland. A **group** of farmland with a top left corner at `(r1, c1)` and a bottom right corner at `(r2, c2)` is represented by the 4-length array `[r1, c1, r2, c2].`\n\nReturn _a 2D array containing the 4-length arrays described above for each **group** of farmland in_ `land`_. If there are no groups of farmland, return an empty array. You may return the answer in **any order**_.\n\n**Example 1:**\n\n**Input:** land = \\[\\[1,0,0\\],\\[0,1,1\\],\\[0,1,1\\]\\]\n**Output:** \\[\\[0,0,0,0\\],\\[1,1,2,2\\]\\]\n**Explanation:**\nThe first group has a top left corner at land\\[0\\]\\[0\\] and a bottom right corner at land\\[0\\]\\[0\\].\nThe second group has a top left corner at land\\[1\\]\\[1\\] and a bottom right corner at land\\[2\\]\\[2\\].\n\n**Example 2:**\n\n**Input:** land = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** \\[\\[0,0,1,1\\]\\]\n**Explanation:**\nThe first group has a top left corner at land\\[0\\]\\[0\\] and a bottom right corner at land\\[1\\]\\[1\\].\n\n**Example 3:**\n\n**Input:** land = \\[\\[0\\]\\]\n**Output:** \\[\\]\n**Explanation:**\nThere are no groups of farmland.\n\n**Constraints:**\n\n*   `m == land.length`\n*   `n == land[i].length`\n*   `1 <= m, n <= 300`\n*   `land` consists of only `0`'s and `1`'s.\n*   Groups of farmland are **rectangular** in shape.\"\"\"\n\n    m, n = len(land), len(land[0])\n    groups = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r1, c1 = i, j\n                while j + 1 < n and land[i][j + 1] == 1:\n                    j += 1\n                r2, c2 = i, j\n                while r2 + 1 < m and land[r2 + 1][j] == 1:\n                    r2 += 1\n                for r in range(r1, r2 + 1):\n                    for c in range(c1, c2 + 1):\n                        land[r][c] = 0\n                groups.append([r1, c1, r2, c2])\n\n    return groups"}}, "leetcode/csn_python_train_320968.txt": {"score": 0.9408931732177734, "content": {"text": "def dfs_grid(grid, i, j, mark='X', free='.'):\n    \"\"\"DFS on a grid, mark connected component, iterative version\n\n    :param grid: matrix, 4-neighborhood\n    :param i,j: cell in this matrix, start of DFS exploration\n    :param free: symbol for walkable cells\n    :param mark: symbol to overwrite visited vertices\n    :complexity: linear\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    to_visit = [(i, j)]\n    grid[i][j] = mark\n    while to_visit:\n        i1, j1 = to_visit.pop()\n        for i2, j2 in [(i1 + 1, j1), (i1, j1 + 1),\n                       (i1 - 1, j1), (i1, j1 - 1)]:\n            if (0 <= i2 < height and 0 <= j2 < width and\n                    grid[i2][j2] == free):\n                grid[i2][j2] = mark  # mark path\n                to_visit.append((i2, j2))"}}, "leetcode/leetcode_1391.txt": {"score": 0.9970245957374573, "content": {"text": "def hasValidPath(grid):\n    \"\"\"You are given an `m x n` `grid`. Each cell of `grid` represents a street. The street of `grid[i][j]` can be:\n\n*   `1` which means a street connecting the left cell and the right cell.\n*   `2` which means a street connecting the upper cell and the lower cell.\n*   `3` which means a street connecting the left cell and the lower cell.\n*   `4` which means a street connecting the right cell and the lower cell.\n*   `5` which means a street connecting the left cell and the upper cell.\n*   `6` which means a street connecting the right cell and the upper cell.\n\nYou will initially start at the street of the upper-left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)`. **The path should only follow the streets**.\n\n**Notice** that you are **not allowed** to change any street.\n\nReturn `true` _if there is a valid path in the grid or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[2,4,3\\],\\[6,5,2\\]\\]\n**Output:** true\n**Explanation:** As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,1\\],\\[1,2,1\\]\\]\n**Output:** false\n**Explanation:** As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,2\\]\\]\n**Output:** false\n**Explanation:** You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `1 <= grid[i][j] <= 6`\"\"\"\n\n    m, n = len(grid), len(grid[0])\n\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n    allowed = [[], [0, 2], [1, 3], [0, 1], [0, 3], [1, 2], [1, 0]]\n\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        visited[i][j] = True\n        for dir in allowed[grid[i][j]]:\n            x, y = i + directions[dir][0], j + directions[dir][1]\n            if 0 <= x < m and 0 <= y < n and not visited[x][y] and (dir + 2) % 4 in allowed[grid[x][y]]:\n                if dfs(x, y):\n                    return True\n        return False\n\n    return dfs(0, 0)"}}, "leetcode/leetcode_130.txt": {"score": 0.9320213794708252, "content": {"text": "class Solution:\n    \"\"\"Given an `m x n` matrix `board` containing `'X'` and `'O'`, _capture all regions that are 4-directionally surrounded by_ `'X'`.\n\nA region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"O \", \"X \"\\],\\[ \"X \", \"X \", \"O \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"X \"\\]\\]\n**Output:** \\[\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"X \"\\]\\]\n**Explanation:** Notice that an 'O' should not be flipped if:\n- It is on the border, or\n- It is adjacent to an 'O' that should not be flipped.\nThe bottom 'O' is on the border, so it is not flipped.\nThe other three 'O' form a surrounded region, so they are flipped.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \"X \"\\]\\]\n**Output:** \\[\\[ \"X \"\\]\\]\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 200`\n*   `board[i][j]` is `'X'` or `'O'`.\"\"\"\n\n    def solve(self, board: List[List[str]]) -> None:\n        if not board:\n            return\n        m, n = len(board), len(board[0])\n\n        def dfs(x, y):\n            if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != 'O':\n                return\n            board[x][y] = '#'\n            dfs(x - 1, y)\n            dfs(x + 1, y)\n            dfs(x, y - 1)\n            dfs(x, y + 1)\n\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for i in range(n):\n            dfs(0, i)\n            dfs(m - 1, i)\n\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '#':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"}}, "leetcode/leetcode_2556.txt": {"score": 0.9388471245765686, "content": {"text": "def canReach(grid, row, col):\n    \"\"\"You are given a **0-indexed** `m x n` **binary** matrix `grid`. You can move from a cell `(row, col)` to any of the cells `(row + 1, col)` or `(row, col + 1)` that has the value `1`. The matrix is **disconnected** if there is no path from `(0, 0)` to `(m - 1, n - 1)`.\n\nYou can flip the value of **at most one** (possibly none) cell. You **cannot flip** the cells `(0, 0)` and `(m - 1, n - 1)`.\n\nReturn `true` _if it is possible to make the matrix disconnect or_ `false` _otherwise_.\n\n**Note** that flipping a cell changes its value from `0` to `1` or from `1` to `0`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,0,0\\],\\[1,1,1\\]\\]\n**Output:** true\n**Explanation:** We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** false\n**Explanation:** It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `grid[i][j]` is either `0` or `1`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 1`\"\"\"\n\n    if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 0:\n        return False\n\n    if row == len(grid) - 1 and col == len(grid[0]) - 1:\n        return True\n\n    grid[row][col] = 0\n\n    return canReach(grid, row + 1, col) or canReach(grid, row, col + 1)\n\ndef canDisconnect(grid):\n    reachableCount = 0\n\n    for row in range(1, len(grid)):\n        for col in range(1, len(grid[0])):\n            if grid[row][col] == 1 and (canReach(grid, row - 1, col) or canReach(grid, row, col - 1)):\n                reachableCount += 1\n                if reachableCount > 1:\n                    return True\n\n    return reachableCount <= 1"}}}}, "62": {"gold": {"leetcode/leetcode_1563.txt": 1, "leetcode/leetcode_1686.txt": 1, "leetcode/leetcode_1690.txt": 1, "leetcode/leetcode_1872.txt": 1, "leetcode/leetcode_2029.txt": 1}, "retrieved": {"leetcode/leetcode_1753.txt": {"score": 0.9113205671310425, "content": {"text": "import heapq\n    \"\"\"You are playing a solitaire game with **three piles** of stones of sizes `a`\u200b\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two **different non-empty** piles, take one stone from each, and add `1` point to your score. The game stops when there are **fewer than two non-empty** piles (meaning there are no more available moves).\n\nGiven three integers `a`\u200b\u200b\u200b\u200b\u200b, `b`,\u200b\u200b\u200b\u200b\u200b and `c`\u200b\u200b\u200b\u200b\u200b, return _the_ **_maximum_** _**score** you can get._\n\n**Example 1:**\n\n**Input:** a = 2, b = 4, c = 6\n**Output:** 6\n**Explanation:** The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points.\n\n**Example 2:**\n\n**Input:** a = 4, b = 4, c = 6\n**Output:** 7\n**Explanation:** The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points.\n\n**Example 3:**\n\n**Input:** a = 1, b = 8, c = 8\n**Output:** 8\n**Explanation:** One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 105`\"\"\"\n\nfrom typing import List\n\ndef minimumEffortPath(heights: List[List[int]]) -> int:\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    rows = len(heights)\n    cols = len(heights[0])\n    efforts = [[float('inf')] * cols for _ in range(rows)]\n\n    q = [(0, 0, 0)]\n    efforts[0][0] = 0\n    \n    while q:\n        effort, x, y = heapq.heappop(q)\n        \n        if x == rows - 1 and y == cols - 1:\n            return effort\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                new_effort = max(effort, abs(heights[nx][ny] - heights[x][y]))\n                if new_effort < efforts[nx][ny]:\n                    efforts[nx][ny] = new_effort\n                    heapq.heappush(q, (new_effort, nx, ny))\n    \n    return -1"}}, "leetcode/leetcode_1690.txt": {"score": 0.9308086037635803, "content": {"text": "def getMaxLen(nums):\n    \"\"\"Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, they can **remove** either the leftmost stone or the rightmost stone from the row and receive points equal to the **sum** of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.\n\nBob found that he will always lose this game (poor Bob, he always loses), so he decided to **minimize the score's difference**. Alice's goal is to **maximize the difference** in the score.\n\nGiven an array of integers `stones` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **difference** in Alice and Bob's score if they both play **optimally**._\n\n**Example 1:**\n\n**Input:** stones = \\[5,3,1,4,2\\]\n**Output:** 6\n**Explanation:** \n- Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = \\[5,3,1,4\\].\n- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = \\[3,1,4\\].\n- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = \\[1,4\\].\n- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = \\[4\\].\n- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = \\[\\].\nThe score difference is 18 - 12 = 6.\n\n**Example 2:**\n\n**Input:** stones = \\[7,90,5,1,100,10,10,2\\]\n**Output:** 122\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 1000`\n*   `1 <= stones[i] <= 1000`\"\"\"\n\n    maxLength = currentLen = currentNegLen = 0\n    \n    for num in nums:\n        if num > 0:\n            currentLen += 1\n            if currentNegLen > 0:\n                currentNegLen += 1\n        elif num < 0:\n            currentLen, currentNegLen = currentNegLen, currentLen + 1\n        else:\n            currentLen = currentNegLen = 0\n        maxLength = max(maxLength, currentLen)\n    \n    return maxLength"}}, "leetcode/leetcode_2029.txt": {"score": 0.9287883639335632, "content": {"text": "def stoneGameIX(stones: List[int]) -> bool:\n    \"\"\"Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array `stones`, where `stones[i]` is the **value** of the `ith` stone.\n\nAlice and Bob take turns, with **Alice** starting first. On each turn, the player may remove any stone from `stones`. The player who removes a stone **loses** if the **sum** of the values of **all removed stones** is divisible by `3`. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\n\nAssuming both players play **optimally**, return `true` _if Alice wins and_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** stones = \\[2,1\\]\n**Output:** true\n**Explanation:** The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\n\n**Example 2:**\n\n**Input:** stones = \\[2\\]\n**Output:** false\n**Explanation:** Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\n\n**Example 3:**\n\n**Input:** stones = \\[5,1,2,4,3\\]\n**Output:** false\n**Explanation:** Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n\n**Constraints:**\n\n*   `1 <= stones.length <= 105`\n*   `1 <= stones[i] <= 104`\"\"\"\n\n    cnt = [0, 0, 0]\n    for s in stones:\n        cnt[s % 3] += 1\n    return (cnt[1] and cnt[2]) or (cnt[1] > cnt[2] if cnt[1] > cnt[2] + 2 else cnt[2] > cnt[1] + 1)"}}, "leetcode/leetcode_464.txt": {"score": 0.933037281036377, "content": {"text": "def canIWin(maxChoosableInteger, desiredTotal):\n    \"\"\"In the \"100 game \" two players take turns adding, to a running total, any integer from `1` to `10`. The player who first causes the running total to **reach or exceed** 100 wins.\n\nWhat if we change the game so that players **cannot** re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers `maxChoosableInteger` and `desiredTotal`, return `true` if the first player to move can force a win, otherwise, return `false`. Assume both players play **optimally**.\n\n**Example 1:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 11\n**Output:** false\n**Explanation:**\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n\n**Example 2:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 0\n**Output:** true\n\n**Example 3:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= maxChoosableInteger <= 20`\n*   `0 <= desiredTotal <= 300`\"\"\"\n\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)"}}, "leetcode/leetcode_486.txt": {"score": 0.9509930610656738, "content": {"text": "def can_win(nums):\n    \"\"\"You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,2\\]\n**Output:** false\n**Explanation:** Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,233,7\\]\n**Output:** true\n**Explanation:** Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 107`\"\"\"\n\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = nums[i]\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n    return dp[0][n - 1] >= 0"}}, "leetcode/leetcode_1686.txt": {"score": 0.9659286737442017, "content": {"text": "def stoneGameVI(aliceValues, bobValues):\n    \"\"\"Alice and Bob take turns playing a game, with Alice starting first.\n\nThere are `n` stones in a pile. On each player's turn, they can **remove** a stone from the pile and receive points based on the stone's value. Alice and Bob may **value the stones differently**.\n\nYou are given two integer arrays of length `n`, `aliceValues` and `bobValues`. Each `aliceValues[i]` and `bobValues[i]` represents how Alice and Bob, respectively, value the `ith` stone.\n\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play **optimally**. Both players know the other's values.\n\nDetermine the result of the game, and:\n\n*   If Alice wins, return `1`.\n*   If Bob wins, return `-1`.\n*   If the game results in a draw, return `0`.\n\n**Example 1:**\n\n**Input:** aliceValues = \\[1,3\\], bobValues = \\[2,1\\]\n**Output:** 1\n**Explanation:**\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.\n\n**Example 2:**\n\n**Input:** aliceValues = \\[1,2\\], bobValues = \\[3,1\\]\n**Output:** 0\n**Explanation:**\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.\n\n**Example 3:**\n\n**Input:** aliceValues = \\[2,4,3\\], bobValues = \\[1,6,7\\]\n**Output:** -1\n**Explanation:**\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins.\n\n**Constraints:**\n\n*   `n == aliceValues.length == bobValues.length`\n*   `1 <= n <= 105`\n*   `1 <= aliceValues[i], bobValues[i] <= 100`\"\"\"\n\n    n = len(aliceValues)\n    diff = sorted([(aliceValues[i] + bobValues[i], i) for i in range(n)], reverse=True)\n\n    aliceSum, bobSum = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            aliceSum += aliceValues[diff[i][1]]\n        else:\n            bobSum += bobValues[diff[i][1]]\n            \n    return 0 if aliceSum == bobSum else (1 if aliceSum > bobSum else -1)"}}, "leetcode/leetcode_1872.txt": {"score": 0.9324526190757751, "content": {"text": "def can_eat(candiesCount, queries):\n    \"\"\"Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, while the number of stones is **more than one**, they will do the following:\n\n1.  Choose an integer `x > 1`, and **remove** the leftmost `x` stones from the row.\n2.  Add the **sum** of the **removed** stones' values to the player's score.\n3.  Place a **new stone**, whose value is equal to that sum, on the left side of the row.\n\nThe game stops when **only** **one** stone is left in the row.\n\nThe **score difference** between Alice and Bob is `(Alice's score - Bob's score)`. Alice's goal is to **maximize** the score difference, and Bob's goal is the **minimize** the score difference.\n\nGiven an integer array `stones` of length `n` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **score difference** between Alice and Bob if they both play **optimally**._\n\n**Example 1:**\n\n**Input:** stones = \\[-1,2,-3,4,-5\\]\n**Output:** 5\n**Explanation:**\n- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of\n  value 2 on the left. stones = \\[2,-5\\].\n- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on\n  the left. stones = \\[-3\\].\nThe difference between their scores is 2 - (-3) = 5.\n\n**Example 2:**\n\n**Input:** stones = \\[7,-6,5,10,5,-2,-6\\]\n**Output:** 13\n**Explanation:**\n- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a\n  stone of value 13 on the left. stones = \\[13\\].\nThe difference between their scores is 13 - 0 = 13.\n\n**Example 3:**\n\n**Input:** stones = \\[-10,-12\\]\n**Output:** -22\n**Explanation:**\n- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her\n  score and places a stone of value -22 on the left. stones = \\[-22\\].\nThe difference between their scores is (-22) - 0 = -22.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 105`\n*   `-104 <= stones[i] <= 104`\"\"\"\n\n    prefix_sum = [0] * (len(candiesCount) + 1)\n    for i in range(len(candiesCount)):\n        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]\n\n    result = [False] * len(queries)\n    for i in range(len(queries)):\n        favoriteType, favoriteDay, dailyCap = queries[i]\n        x1 = favoriteDay + 1\n        y1 = (favoriteDay + 1) * dailyCap\n\n        x2 = prefix_sum[favoriteType] + 1\n        y2 = prefix_sum[favoriteType + 1]\n\n        result[i] = not (x1 > y2 or y1 < x2)\n\n    return result"}}, "leetcode/leetcode_1406.txt": {"score": 0.9941467642784119, "content": {"text": "def stoneGameIII(stoneValue):\n    \"\"\"Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\n\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n\nAssume Alice and Bob **play optimally**.\n\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n\n**Example 1:**\n\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n\n**Example 2:**\n\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n\n**Example 3:**\n\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`\"\"\"\n\n    n = len(stoneValue)\n    dp = [float(\"-inf\")] * (n + 1)\n    dp[n] = 0\n    \n    for i in range(n - 1, -1, -1):\n        curr = 0\n        for j in range(3):\n            if i + j < n:\n                curr += stoneValue[i + j]\n                dp[i] = max(dp[i], curr - dp[i + j + 1])\n                \n    return \"Tie \" if dp[0] == 0 else \"Alice \" if dp[0] > 0 else \"Bob \""}}, "leetcode/leetcode_1140.txt": {"score": 0.9410380721092224, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`\"\"\"\n\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes"}}, "leetcode/leetcode_877.txt": {"score": 0.9567310214042664, "content": {"text": "from collections import deque, defaultdict\n    \"\"\"Alice and Bob play a game with piles of stones. There are an **even** number of piles arranged in a row, and each pile has a **positive** integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones. The **total** number of stones across all the piles is **odd**, so there are no ties.\n\nAlice and Bob take turns, with **Alice starting first**. Each turn, a player takes the entire pile of stones either from the **beginning** or from the **end** of the row. This continues until there are no more piles left, at which point the person with the **most stones wins**.\n\nAssuming Alice and Bob play optimally, return `true` _if Alice wins the game, or_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** piles = \\[5,3,4,5\\]\n**Output:** true\n**Explanation:** \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes \\[3, 4, 5\\].\nIf Bob takes 3, then the board is \\[4, 5\\], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is \\[3, 4\\], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\n**Example 2:**\n\n**Input:** piles = \\[3,7,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `2 <= piles.length <= 500`\n*   `piles.length` is **even**.\n*   `1 <= piles[i] <= 500`\n*   `sum(piles[i])` is **odd**.\"\"\"\n\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    q = deque()\n    \n    for i in range(n):\n        q.append((i, 1 << i))\n    steps = -1\n    visited = {i: set() for i in range(n)}\n    \n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            currNode, currVisits = q.popleft()\n            \n            if bin(currVisits).count('1') == n:\n                return steps\n\n            for nextNode in graph[currNode]:\n                nextVisits = currVisits | (1 << nextNode)\n\n                if nextVisits not in visited[nextNode]:\n                    visited[nextNode].add(nextVisits)\n                    q.append((nextNode, nextVisits))\n\n    return -1"}}}}, "63": {"gold": {"leetcode/leetcode_2406.txt": 1}, "retrieved": {"leetcode/leetcode_2287.txt": {"score": 0.9191044569015503, "content": {"text": "def maxNumberOfCopies(s, target):\n    \"\"\"You are given two **0-indexed** strings `s` and `target`. You can take some letters from `s` and rearrange them to form new strings.\n\nReturn _the **maximum** number of copies of_ `target` _that can be formed by taking letters from_ `s` _and rearranging them._\n\n**Example 1:**\n\n**Input:** s =  \"ilovecodingonleetcode \", target =  \"code \"\n**Output:** 2\n**Explanation:**\nFor the first copy of  \"code \", take the letters at indices 4, 5, 6, and 7.\nFor the second copy of  \"code \", take the letters at indices 17, 18, 19, and 20.\nThe strings that are formed are  \"ecod \" and  \"code \" which can both be rearranged into  \"code \".\nWe can make at most two copies of  \"code \", so we return 2.\n\n**Example 2:**\n\n**Input:** s =  \"abcba \", target =  \"abc \"\n**Output:** 1\n**Explanation:**\nWe can make one copy of  \"abc \" by taking the letters at indices 0, 1, and 2.\nWe can make at most one copy of  \"abc \", so we return 1.\nNote that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of  \"abc \".\n\n**Example 3:**\n\n**Input:** s =  \"abbaccaddaeea \", target =  \"aaaaa \"\n**Output:** 1\n**Explanation:**\nWe can make one copy of  \"aaaaa \" by taking the letters at indices 0, 3, 6, 9, and 12.\nWe can make at most one copy of  \"aaaaa \", so we return 1.\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `1 <= target.length <= 10`\n*   `s` and `target` consist of lowercase English letters.\"\"\"\n\n    s_counts = [0] * 26\n    target_counts = [0] * 26\n\n    for c in s:\n        s_counts[ord(c) - ord('a')] += 1\n\n    for c in target:\n        target_counts[ord(c) - ord('a')] += 1\n\n    max_copies = float('inf')\n    for i in range(26):\n        if target_counts[i] > 0:\n            max_copies = min(max_copies, s_counts[i] // target_counts[i])\n    return max_copies"}}, "leetcode/leetcode_1764.txt": {"score": 0.9203544855117798, "content": {"text": "def max_k_repeating(sequence, word):\n    \"\"\"You are given a 2D integer array `groups` of length `n`. You are also given an integer array `nums`.\n\nYou are asked if you can choose `n` **disjoint** subarrays from the array `nums` such that the `ith` subarray is equal to `groups[i]` (**0-indexed**), and if `i > 0`, the `(i-1)th` subarray appears **before** the `ith` subarray in `nums` (i.e. the subarrays must be in the same order as `groups`).\n\nReturn `true` _if you can do this task, and_ `false` _otherwise_.\n\nNote that the subarrays are **disjoint** if and only if there is no index `k` such that `nums[k]` belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.\n\n**Example 1:**\n\n**Input:** groups = \\[\\[1,-1,-1\\],\\[3,-2,0\\]\\], nums = \\[1,-1,0,1,-1,-1,3,-2,0\\]\n**Output:** true\n**Explanation:** You can choose the 0th subarray as \\[1,-1,0,**1,-1,-1**,3,-2,0\\] and the 1st one as \\[1,-1,0,1,-1,-1,**3,-2,0**\\].\nThese subarrays are disjoint as they share no common nums\\[k\\] element.\n\n**Example 2:**\n\n**Input:** groups = \\[\\[10,-2\\],\\[1,2,3,4\\]\\], nums = \\[1,2,3,4,10,-2\\]\n**Output:** false\n**Explanation:** Note that choosing the subarrays \\[**1,2,3,4**,10,-2\\] and \\[1,2,3,4,**10,-2**\\] is incorrect because they are not in the same order as in groups.\n\\[10,-2\\] must come before \\[1,2,3,4\\].\n\n**Example 3:**\n\n**Input:** groups = \\[\\[1,2,3\\],\\[3,4\\]\\], nums = \\[7,7,1,2,3,4,7,7\\]\n**Output:** false\n**Explanation:** Note that choosing the subarrays \\[7,7,**1,2,3**,4,7,7\\] and \\[7,7,1,2,**3,4**,7,7\\] is invalid because they are not disjoint.\nThey share a common elements nums\\[4\\] (0-indexed).\n\n**Constraints:**\n\n*   `groups.length == n`\n*   `1 <= n <= 103`\n*   `1 <= groups[i].length, sum(groups[i].length) <= 103`\n*   `1 <= nums.length <= 103`\n*   `-107 <= groups[i][j], nums[k] <= 107`\"\"\"\n\n    max_k = 0\n    seq_length = len(sequence)\n    word_length = len(word)\n    for i in range(seq_length - word_length + 1):\n        k = 0\n        while sequence[i:i + word_length * (k + 1)] == word * (k + 1):\n            k += 1\n        max_k = max(max_k, k)\n    return max_k"}}, "leetcode/leetcode_2516.txt": {"score": 0.9217758774757385, "content": {"text": "def min_minutes(s: str, k: int) -> int:\n    \"\"\"You are given a string `s` consisting of the characters `'a'`, `'b'`, and `'c'` and a non-negative integer `k`. Each minute, you may take either the **leftmost** character of `s`, or the **rightmost** character of `s`.\n\nReturn _the **minimum** number of minutes needed for you to take **at least**_ `k` _of each character, or return_ `-1` _if it is not possible to take_ `k` _of each character._\n\n**Example 1:**\n\n**Input:** s =  \"aabaaaacaabc \", k = 2\n**Output:** 8\n**Explanation:** \nTake three characters from the left of s. You now have two 'a' characters, and one 'b' character.\nTake five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.\nA total of 3 + 5 = 8 minutes is needed.\nIt can be proven that 8 is the minimum number of minutes needed.\n\n**Example 2:**\n\n**Input:** s =  \"a \", k = 1\n**Output:** -1\n**Explanation:** It is not possible to take one 'b' or 'c' so return -1.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only the letters `'a'`, `'b'`, and `'c'`.\n*   `0 <= k <= s.length`\"\"\"\n\n    n = len(s)\n    left_counts = [0] * 3\n    right_counts = [0] * 3\n    for c in s:\n        right_counts[ord(c) - ord('a')] += 1\n\n    ans, total = n, 0\n    l, r = 0, n - 1\n    while l < r:\n        while l < r and left_counts[ord(s[l]) - ord('a')] < k and right_counts[ord(s[r]) - ord('a')] < k:\n            need_left = max(0, k - left_counts[ord(s[l]) - ord('a')])\n            need_right = max(0, k - right_counts[ord(s[r]) - ord('a')])\n            if need_left <= need_right:\n                total += need_left\n                l += 1\n                left_counts[ord(s[l]) - ord('a')] += 1\n                right_counts[ord(s[l]) - ord('a')] -= 1\n            else:\n                total += need_right\n                r -= 1\n                right_counts[ord(s[r]) - ord('a')] -= 1\n                left_counts[ord(s[r]) - ord('a')] += 1\n        ans = min(ans, total)\n        if l + 1 < n:\n            total -= left_counts[ord(s[l]) - ord('a')]\n            left_counts[ord(s[l]) - ord('a')] -= 1\n            right_counts[ord(s[l + 1]) - ord('a')] += 1\n            l += 1\n        else:\n            break\n    if all(cnt >= k for cnt in left_counts): \n        return ans\n    return -1"}}, "leetcode/leetcode_691.txt": {"score": 0.9253526329994202, "content": {"text": "from collections import Counter\n    \"\"\"We are given `n` different types of `stickers`. Each sticker has a lowercase English word on it.\n\nYou would like to spell out the given string `target` by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.\n\nReturn _the minimum number of stickers that you need to spell out_ `target`. If the task is impossible, return `-1`.\n\n**Note:** In all test cases, all words were chosen randomly from the `1000` most common US English words, and `target` was chosen as a concatenation of two random words.\n\n**Example 1:**\n\n**Input:** stickers = \\[ \"with \", \"example \", \"science \"\\], target =  \"thehat \"\n**Output:** 3\n**Explanation:**\nWe can use 2  \"with \" stickers, and 1  \"example \" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target  \"thehat \".\nAlso, this is the minimum number of stickers necessary to form the target string.\n\n**Example 2:**\n\n**Input:** stickers = \\[ \"notice \", \"possible \"\\], target =  \"basicbasic \"\n**Output:** -1\nExplanation:\nWe cannot form the target  \"basicbasic \" from cutting letters from the given stickers.\n\n**Constraints:**\n\n*   `n == stickers.length`\n*   `1 <= n <= 50`\n*   `1 <= stickers[i].length <= 10`\n*   `1 <= target.length <= 15`\n*   `stickers[i]` and `target` consist of lowercase English letters.\"\"\"\n\nfrom functools import lru_cache\n\ndef minStickers(stickers, target):\n    target_count = Counter(target)\n    memo = {}\n    \n    for s in stickers:\n        sticker_count = Counter(s)\n        state = ''.join(sticker_count & target_count)\n        memo[state] = 1\n    \n    @lru_cache(None)\n    def dp(state):\n        counts = Counter(state)\n        ans = float('inf')\n        for key, value in memo.items():\n            if any(counts[ch] < key.count(ch) for ch in state): continue\n            ans = min(ans, dp(state.translate(str.maketrans('', '', key))) + value)\n        return -1 if ans == float('inf') else ans\n    \n    return dp(target)"}}, "leetcode/leetcode_1639.txt": {"score": 0.9214082956314087, "content": {"text": "def numWays(words, target):\n    \"\"\"You are given a list of strings of the **same length** `words` and a string `target`.\n\nYour task is to form `target` using the given `words` under the following rules:\n\n*   `target` should be formed from left to right.\n*   To form the `ith` character (**0-indexed**) of `target`, you can choose the `kth` character of the `jth` string in `words` if `target[i] = words[j][k]`.\n*   Once you use the `kth` character of the `jth` string of `words`, you **can no longer** use the `xth` character of any string in `words` where `x <= k`. In other words, all characters to the left of or at index `k` become unusuable for every string.\n*   Repeat the process until you form the string `target`.\n\n**Notice** that you can use **multiple characters** from the **same string** in `words` provided the conditions above are met.\n\nReturn _the number of ways to form `target` from `words`_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** words = \\[ \"acca \", \"bbbb \", \"caca \"\\], target =  \"aba \"\n**Output:** 6\n**Explanation:** There are 6 ways to form target.\n \"aba \" -> index 0 ( \"acca \"), index 1 ( \"bbbb \"), index 3 ( \"caca \")\n \"aba \" -> index 0 ( \"acca \"), index 2 ( \"bbbb \"), index 3 ( \"caca \")\n \"aba \" -> index 0 ( \"acca \"), index 1 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 0 ( \"acca \"), index 2 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 1 ( \"caca \"), index 2 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 1 ( \"caca \"), index 2 ( \"bbbb \"), index 3 ( \"caca \")\n\n**Example 2:**\n\n**Input:** words = \\[ \"abba \", \"baab \"\\], target =  \"bab \"\n**Output:** 4\n**Explanation:** There are 4 ways to form target.\n \"bab \" -> index 0 ( \"baab \"), index 1 ( \"baab \"), index 2 ( \"abba \")\n \"bab \" -> index 0 ( \"baab \"), index 1 ( \"baab \"), index 3 ( \"baab \")\n \"bab \" -> index 0 ( \"baab \"), index 2 ( \"baab \"), index 3 ( \"baab \")\n \"bab \" -> index 1 ( \"abba \"), index 2 ( \"baab \"), index 3 ( \"baab \")\n\n**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 1000`\n*   All strings in `words` have the same length.\n*   `1 <= target.length <= 1000`\n*   `words[i]` and `target` contain only lowercase English letters.\"\"\"\n\n    n = len(words)\n    m = len(target)\n    count = [[0] * 26 for _ in range(n)]\n    dp = [[0] * n for _ in range(m)]\n    mod = 1000000007\n\n    for i, word in enumerate(words):\n        for c in word:\n            count[i][ord(c) - ord('a')] += 1\n\n    for i in range(n):\n        dp[0][i] = count[i][ord(target[0]) - ord('a')]\n\n    for i in range(1, m):\n        for j in range(n):\n            for k in range(n):\n                dp[i][j] = (dp[i][j] + dp[i-1][k] * count[j][ord(target[i]) - ord('a')]) % mod\n\n    return sum(dp[m-1]) % mod"}}, "leetcode/leetcode_1160.txt": {"score": 0.9274617433547974, "content": {"text": "def num_tile_possibilities(tiles: str) -> int:\n    \"\"\"You are given an array of strings `words` and a string `chars`.\n\nA string is **good** if it can be formed by characters from chars (each character can only be used once).\n\nReturn _the sum of lengths of all good strings in words_.\n\n**Example 1:**\n\n**Input:** words = \\[ \"cat \", \"bt \", \"hat \", \"tree \"\\], chars =  \"atach \"\n**Output:** 6\n**Explanation:** The strings that can be formed are  \"cat \" and  \"hat \" so the answer is 3 + 3 = 6.\n\n**Example 2:**\n\n**Input:** words = \\[ \"hello \", \"world \", \"leetcode \"\\], chars =  \"welldonehoneyr \"\n**Output:** 10\n**Explanation:** The strings that can be formed are  \"hello \" and  \"world \" so the answer is 5 + 5 = 10.\n\n**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length, chars.length <= 100`\n*   `words[i]` and `chars` consist of lowercase English letters.\"\"\"\n\n    freq = [0] * 26\n    for c in tiles:\n        freq[ord(c) - ord('A')] += 1\n\n    def dfs(freq):\n        result = 0\n        for i in range(26):\n            if freq[i] > 0:\n                freq[i] -= 1\n                result += 1 + dfs(freq)\n                freq[i] += 1\n        return result\n\n    return dfs(freq)"}}, "leetcode/leetcode_1189.txt": {"score": 0.9420918226242065, "content": {"text": "def max_number_of_balloons(text: str) -> int:\n    \"\"\"Given a string `text`, you want to use the characters of `text` to form as many instances of the word **\"balloon \"** as possible.\n\nYou can use each character in `text` **at most once**. Return the maximum number of instances that can be formed.\n\n**Example 1:**\n\n**Input:** text =  \"nlaebolko \"\n**Output:** 1\n\n**Example 2:**\n\n**Input:** text =  \"loonbalxballpoon \"\n**Output:** 2\n\n**Example 3:**\n\n**Input:** text =  \"leetcode \"\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= text.length <= 104`\n*   `text` consists of lower case English letters only.\"\"\"\n\n    letter_count = [0] * 5\n    for c in text:\n        if c == 'b': letter_count[0] += 1\n        if c == 'a': letter_count[1] += 1\n        if c == 'l': letter_count[2] += 1\n        if c == 'o': letter_count[3] += 1\n        if c == 'n': letter_count[4] += 1\n    letter_count[2] //= 2\n    letter_count[3] //= 2\n    return min(letter_count)"}}, "leetcode/leetcode_664.txt": {"score": 0.9254465699195862, "content": {"text": "def strange_printer(s: str) -> int:\n    \"\"\"There is a strange printer with the following two special properties:\n\n*   The printer can only print a sequence of **the same character** each time.\n*   At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string `s`, return _the minimum number of turns the printer needed to print it_.\n\n**Example 1:**\n\n**Input:** s =  \"aaabbb \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"bbb \".\n\n**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"b \" from the second place of the string, which will cover the existing character 'a'.\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters.\"\"\"\n\n    n = len(s)\n    if n == 0: return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = dp[i+1][j] + 1\n            for k in range(i + 1, j + 1):\n                if s[i] == s[k]:\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n    return dp[0][n-1]"}}, "leetcode/leetcode_1839.txt": {"score": 0.9305151700973511, "content": {"text": "def decode(encoded, first):\n    \"\"\"A string is considered **beautiful** if it satisfies the following conditions:\n\n*   Each of the 5 English vowels (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`) must appear **at least once** in it.\n*   The letters must be sorted in **alphabetical order** (i.e. all `'a'`s before `'e'`s, all `'e'`s before `'i'`s, etc.).\n\nFor example, strings `\"aeiou \"` and `\"aaaaaaeiiiioou \"` are considered **beautiful**, but `\"uaeio \"`, `\"aeoiu \"`, and `\"aaaeeeooo \"` are **not beautiful**.\n\nGiven a string `word` consisting of English vowels, return _the **length of the longest beautiful substring** of_ `word`_. If no such substring exists, return_ `0`.\n\nA **substring** is a contiguous sequence of characters in a string.\n\n**Example 1:**\n\n**Input:** word =  \"aeiaaioaaaaeiiiiouuuooaauuaeiu \"\n**Output:** 13\n**Explanation:** The longest beautiful substring in word is  \"aaaaeiiiiouuu \" of length 13.\n\n**Example 2:**\n\n**Input:** word =  \"aeeeiiiioooauuuaeiou \"\n**Output:** 5\n**Explanation:** The longest beautiful substring in word is  \"aeiou \" of length 5.\n\n**Example 3:**\n\n**Input:** word =  \"a \"\n**Output:** 0\n**Explanation:** There is no beautiful substring, so return 0.\n\n**Constraints:**\n\n*   `1 <= word.length <= 5 * 105`\n*   `word` consists of characters `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`.\"\"\"\n\n    arr = [first]\n    for num in encoded:\n        arr.append(arr[-1] ^ num)\n    return arr"}}, "leetcode/leetcode_1419.txt": {"score": 0.9937384724617004, "content": {"text": "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    \"\"\"You are given the string `croakOfFrogs`, which represents a combination of the string `\"croak \"` from different frogs, that is, multiple frogs can croak at the same time, so multiple `\"croak \"` are mixed.\n\n_Return the minimum number of_ different _frogs to finish all the croaks in the given string._\n\nA valid `\"croak \"` means a frog is printing five letters `'c'`, `'r'`, `'o'`, `'a'`, and `'k'` **sequentially**. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid `\"croak \"` return `-1`.\n\n**Example 1:**\n\n**Input:** croakOfFrogs =  \"croakcroak \"\n**Output:** 1 \n**Explanation:** One frog yelling  \"croak **\"** twice.\n\n**Example 2:**\n\n**Input:** croakOfFrogs =  \"crcoakroak \"\n**Output:** 2 \n**Explanation:** The minimum number of frogs is two. \nThe first frog could yell  \"**cr**c**oak**roak \".\nThe second frog could yell later  \"cr**c**oak**roak** \".\n\n**Example 3:**\n\n**Input:** croakOfFrogs =  \"croakcrook \"\n**Output:** -1\n**Explanation:** The given string is an invalid combination of  \"croak **\"** from different frogs.\n\n**Constraints:**\n\n*   `1 <= croakOfFrogs.length <= 105`\n*   `croakOfFrogs` is either `'c'`, `'r'`, `'o'`, `'a'`, or `'k'`.\"\"\"\n\n    counter = [0] * 5\n    frogs = max_frogs = 0\n    for ch in croakOfFrogs:\n        idx = 'croak'.index(ch)\n        counter[idx] += 1\n        if idx == 0:\n            max_frogs = max(max_frogs, frogs + 1)\n            frogs += 1\n        else:\n            counter[idx - 1] -= 1\n            if counter[idx - 1] < 0:\n                return -1\n            if idx == 4:\n                frogs -= 1\n    return max_frogs if all(count == counter[0] for count in counter) else -1"}}}}, "64": {"gold": {"leetcode/leetcode_2312.txt": 1}, "retrieved": {"leetcode/leetcode_2147.txt": {"score": 0.8894808292388916, "content": {"text": "def sum_of_points(s, answers):\n    \"\"\"Along a long library corridor, there is a line of seats and decorative plants. You are given a **0-indexed** string `corridor` of length `n` consisting of letters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'` represents a plant.\n\nOne room divider has **already** been installed to the left of index `0`, and **another** to the right of index `n - 1`. Additional room dividers can be installed. For each position between indices `i - 1` and `i` (`1 <= i <= n - 1`), at most one divider can be installed.\n\nDivide the corridor into non-overlapping sections, where each section has **exactly two seats** with any number of plants. There may be multiple ways to perform the division. Two ways are **different** if there is a position with a room divider installed in the first way but not in the second way.\n\nReturn _the number of ways to divide the corridor_. Since the answer may be very large, return it **modulo** `109 + 7`. If there is no way, return `0`.\n\n**Example 1:**\n\n**Input:** corridor =  \"SSPPSPS \"\n**Output:** 3\n**Explanation:** There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, **each** section has exactly **two** seats.\n\n**Example 2:**\n\n**Input:** corridor =  \"PPSPSP \"\n**Output:** 1\n**Explanation:** There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.\n\n**Example 3:**\n\n**Input:** corridor =  \"S \"\n**Output:** 0\n**Explanation:** There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n\n**Constraints:**\n\n*   `n == corridor.length`\n*   `1 <= n <= 105`\n*   `corridor[i]` is either `'S'` or `'P'`.\"\"\"\n\n    total_points = 0\n    result = 0\n    term = 1\n    sign = \"+\"\n\n    for char in s:\n        if char.isdigit():\n            number = int(char)\n            if sign == \"+\":\n                result += term\n                term = number\n            elif sign == \"*\":\n                term *= number\n        else:\n            sign = char\n\n    result += term\n\n    for ans in answers:\n        total_points += (ans == result)\n\n    return total_points"}}, "leetcode/leetcode_813.txt": {"score": 0.8961174488067627, "content": {"text": "from typing import List\n    \"\"\"You are given an integer array `nums` and an integer `k`. You can partition the array into **at most** `k` non-empty adjacent subarrays. The **score** of a partition is the sum of the averages of each subarray.\n\nNote that the partition must use every integer in `nums`, and that the score is not necessarily an integer.\n\nReturn _the maximum **score** you can achieve of all the possible partitions_. Answers within `10-6` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** nums = \\[9,1,2,3,9\\], k = 3\n**Output:** 20.00000\n**Explanation:** \nThe best choice is to partition nums into \\[9\\], \\[1, 2, 3\\], \\[9\\]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could have also partitioned nums into \\[9, 1\\], \\[2\\], \\[3, 9\\], for example.\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7\\], k = 4\n**Output:** 20.50000\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 104`\n*   `1 <= k <= nums.length`\"\"\"\n\n\ndef allPathsSourceTarget(graph: List[List[int]]) -> List[List[int]]:\n    def DFS(currentNode, path):\n        path.append(currentNode)\n        if currentNode == len(graph) - 1:\n            result.append(path[:])\n        else:\n            for neighbor in graph[currentNode]:\n                DFS(neighbor, path)\n        path.pop()\n\n    result = []\n    DFS(0, [])\n    return result"}}, "leetcode/leetcode_2328.txt": {"score": 0.8942517042160034, "content": {"text": "def add_parentheses(expression: str) -> str:\n    \"\"\"You are given an `m x n` integer matrix `grid`, where you can move from a cell to any adjacent cell in all `4` directions.\n\nReturn _the number of **strictly** **increasing** paths in the grid such that you can start from **any** cell and end at **any** cell._ Since the answer may be very large, return it **modulo** `109 + 7`.\n\nTwo paths are considered different if they do not have exactly the same sequence of visited cells.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1\\],\\[3,4\\]\\]\n**Output:** 8\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[1\\], \\[3\\], \\[4\\].\n- Paths with length 2: \\[1 -> 3\\], \\[1 -> 4\\], \\[3 -> 4\\].\n- Paths with length 3: \\[1 -> 3 -> 4\\].\nThe total number of paths is 4 + 3 + 1 = 8.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1\\],\\[2\\]\\]\n**Output:** 3\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[2\\].\n- Paths with length 2: \\[1 -> 2\\].\nThe total number of paths is 2 + 1 = 3.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 105`\"\"\"\n\n    return f\"({expression})\""}}, "leetcode/leetcode_2580.txt": {"score": 0.8963214755058289, "content": {"text": "def total_ways_to_split_ranges(ranges):\n    \"\"\"You are given a 2D integer array `ranges` where `ranges[i] = [starti, endi]` denotes that all integers between `starti` and `endi` (both **inclusive**) are contained in the `ith` range.\n\nYou are to split `ranges` into **two** (possibly empty) groups such that:\n\n*   Each range belongs to exactly one group.\n*   Any two **overlapping** ranges must belong to the **same** group.\n\nTwo ranges are said to be **overlapping** if there exists at least **one** integer that is present in both ranges.\n\n*   For example, `[1, 3]` and `[2, 5]` are overlapping because `2` and `3` occur in both ranges.\n\nReturn _the **total number** of ways to split_ `ranges` _into two groups_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** ranges = \\[\\[6,10\\],\\[5,15\\]\\]\n**Output:** 2\n**Explanation:** \nThe two ranges are overlapping, so they must be in the same group.\nThus, there are two possible ways:\n- Put both the ranges together in group 1.\n- Put both the ranges together in group 2.\n\n**Example 2:**\n\n**Input:** ranges = \\[\\[1,3\\],\\[10,20\\],\\[2,5\\],\\[4,8\\]\\]\n**Output:** 4\n**Explanation:** \nRanges \\[1,3\\], and \\[2,5\\] are overlapping. So, they must be in the same group.\nAgain, ranges \\[2,5\\] and \\[4,8\\] are also overlapping. So, they must also be in the same group. \nThus, there are four possible ways to group them:\n- All the ranges in group 1.\n- All the ranges in group 2.\n- Ranges \\[1,3\\], \\[2,5\\], and \\[4,8\\] in group 1 and \\[10,20\\] in group 2.\n- Ranges \\[1,3\\], \\[2,5\\], and \\[4,8\\] in group 2 and \\[10,20\\] in group 1.\n\n**Constraints:**\n\n*   `1 <= ranges.length <= 105`\n*   `ranges[i].length == 2`\n*   `0 <= starti <= endi <= 109`\"\"\"\n\n    MOD = 10**9 + 7\n    ranges.sort(key=lambda x: x[1])\n    overlapping, non_overlapping, prev_end = 0, 1, -1\n\n    for start, end in ranges:\n        if start <= prev_end:\n            overlapping += 1\n        else:\n            non_overlapping += 1\n        prev_end = max(prev_end, end)\n\n    result = 1\n    for i in range(1, overlapping + 1):\n        result = (result * 2) % MOD\n\n    return result"}}, "leetcode/leetcode_2245.txt": {"score": 0.9064757227897644, "content": {"text": "def can_destroy_all_asteroids(mass, asteroids):\n    \"\"\"You are given a 2D integer array `grid` of size `m x n`, where each cell contains a positive integer.\n\nA **cornered path** is defined as a set of adjacent cells with **at most** one turn. More specifically, the path should exclusively move either **horizontally** or **vertically** up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the **alternate** direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\n\nThe **product** of a path is defined as the product of all the values in the path.\n\nReturn _the **maximum** number of **trailing zeros** in the product of a cornered path found in_ `grid`.\n\nNote:\n\n*   **Horizontal** movement means moving in either the left or right direction.\n*   **Vertical** movement means moving in either the up or down direction.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[23,17,15,3,20\\],\\[8,1,20,27,11\\],\\[9,4,6,2,21\\],\\[40,9,1,10,6\\],\\[22,7,4,5,3\\]\\]\n**Output:** 3\n**Explanation:** The grid on the left shows a valid cornered path.\nIt has a product of 15 \\* 20 \\* 6 \\* 1 \\* 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[4,3,2\\],\\[7,6,1\\],\\[8,8,8\\]\\]\n**Output:** 0\n**Explanation:** The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 1000`\"\"\"\n\n    asteroids.sort()\n    for asteroid in asteroids:\n        if mass >= asteroid:\n            mass += asteroid\n        else:\n            return False\n    return True"}}, "leetcode/leetcode_2312.txt": {"score": 0.915206253528595, "content": {"text": "def max_count_target(nums, key):\n    \"\"\"You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars.\n\nTo cut a piece of wood, you must make a vertical or horizontal cut across the **entire** height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you **cannot** rotate a piece to swap its height and width.\n\nReturn _the **maximum** money you can earn after cutting an_ `m x n` _piece of wood_.\n\nNote that you can cut the piece of wood as many times as you want.\n\n**Example 1:**\n\n**Input:** m = 3, n = 5, prices = \\[\\[1,4,2\\],\\[2,2,7\\],\\[2,1,3\\]\\]\n**Output:** 19\n**Explanation:** The diagram above shows a possible scenario. It consists of:\n- 2 pieces of wood shaped 2 x 2, selling for a price of 2 \\* 7 = 14.\n- 1 piece of wood shaped 2 x 1, selling for a price of 1 \\* 3 = 3.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 \\* 2 = 2.\nThis obtains a total of 14 + 3 + 2 = 19 money earned.\nIt can be shown that 19 is the maximum amount of money that can be earned.\n\n**Example 2:**\n\n**Input:** m = 4, n = 6, prices = \\[\\[3,2,10\\],\\[1,4,2\\],\\[4,1,3\\]\\]\n**Output:** 32\n**Explanation:** The diagram above shows a possible scenario. It consists of:\n- 3 pieces of wood shaped 3 x 2, selling for a price of 3 \\* 10 = 30.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 \\* 2 = 2.\nThis obtains a total of 30 + 2 = 32 money earned.\nIt can be shown that 32 is the maximum amount of money that can be earned.\nNotice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.\n\n**Constraints:**\n\n*   `1 <= m, n <= 200`\n*   `1 <= prices.length <= 2 * 104`\n*   `prices[i].length == 3`\n*   `1 <= hi <= m`\n*   `1 <= wi <= n`\n*   `1 <= pricei <= 106`\n*   All the shapes of wood `(hi, wi)` are pairwise **distinct**.\"\"\"\n\n    count = {}\n    max_count = 0\n    max_target = -1\n    for i in range(1, len(nums)):\n        if nums[i - 1] == key:\n            count[nums[i]] = count.get(nums[i], 0) + 1\n            if count[nums[i]] > max_count:\n                max_count = count[nums[i]]\n                max_target = nums[i]\n    return max_target"}}, "leetcode/leetcode_1361.txt": {"score": 0.8953062295913696, "content": {"text": "def tilingRectangle(n, m):\n    \"\"\"You have `n` binary tree nodes numbered from `0` to `n - 1` where node `i` has two children `leftChild[i]` and `rightChild[i]`, return `true` if and only if **all** the given nodes form **exactly one** valid binary tree.\n\nIf node `i` has no left child then `leftChild[i]` will equal `-1`, similarly for the right child.\n\nNote that the nodes have no values and that we only use the node numbers in this problem.\n\n**Example 1:**\n\n**Input:** n = 4, leftChild = \\[1,-1,3,-1\\], rightChild = \\[2,-1,-1,-1\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** n = 4, leftChild = \\[1,-1,3,-1\\], rightChild = \\[2,3,-1,-1\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** n = 2, leftChild = \\[1,0\\], rightChild = \\[-1,-1\\]\n**Output:** false\n\n**Constraints:**\n\n*   `n == leftChild.length == rightChild.length`\n*   `1 <= n <= 104`\n*   `-1 <= leftChild[i], rightChild[i] <= n - 1`\"\"\"\n\n    if n > m:\n        n, m = m, n\n    if n == 1:\n        return m\n    if n == m:\n        return 1\n\n    res = float('inf')\n    for a in range(1, n // 2 + 1):\n        res = min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m))\n\n    for b in range(1, m // 2 + 1):\n        res = min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b))\n\n    return res"}}, "leetcode/leetcode_1465.txt": {"score": 0.9207420945167542, "content": {"text": "class TreeNode:\n    \"\"\"You are given a rectangular cake of size `h x w` and two arrays of integers `horizontalCuts` and `verticalCuts` where:\n\n*   `horizontalCuts[i]` is the distance from the top of the rectangular cake to the `ith` horizontal cut and similarly, and\n*   `verticalCuts[j]` is the distance from the left of the rectangular cake to the `jth` vertical cut.\n\nReturn _the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays_ `horizontalCuts` _and_ `verticalCuts`. Since the answer can be a large number, return this **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[1,2,4\\], verticalCuts = \\[1,3\\]\n**Output:** 4 \n**Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.\n\n**Example 2:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[3,1\\], verticalCuts = \\[1\\]\n**Output:** 6\n**Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.\n\n**Example 3:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[3\\], verticalCuts = \\[3\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `2 <= h, w <= 109`\n*   `1 <= horizontalCuts.length <= min(h - 1, 105)`\n*   `1 <= verticalCuts.length <= min(w - 1, 105)`\n*   `1 <= horizontalCuts[i] < h`\n*   `1 <= verticalCuts[i] < w`\n*   All the elements in `horizontalCuts` are distinct.\n*   All the elements in `verticalCuts` are distinct.\"\"\"\n\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxProduct(self, root: TreeNode) -> int:\n        def dfs(node):\n            if not node:\n                return 0\n            return node.val + dfs(node.left) + dfs(node.right)\n\n        def dfs2(node, half):\n            nonlocal result\n\n            if not node:\n                return 0\n            cur_sum = node.val + dfs2(node.left, half) + dfs2(node.right, half)\n            result = max(result, (total - cur_sum) * cur_sum)\n            return cur_sum\n\n        total = dfs(root)\n        result = 0\n        dfs2(root, total / 2)\n        return result % (10**9 + 7)"}}, "leetcode/leetcode_959.txt": {"score": 0.9119386076927185, "content": {"text": "def threeSumMulti(arr, target):\n    \"\"\"An `n x n` grid is composed of `1 x 1` squares where each `1 x 1` square consists of a `'/'`, `'\\'`, or blank space `' '`. These characters divide the square into contiguous regions.\n\nGiven the grid `grid` represented as a string array, return _the number of regions_.\n\nNote that backslash characters are escaped, so a `'\\'` is represented as `'\\\\'`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \" / \", \"/  \"\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** grid = \\[ \" / \", \"   \"\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** grid = \\[ \"/\\\\\\\\ \", \"\\\\/ \"\\]\n**Output:** 5\n**Explanation:** Recall that because \\\\ characters are escaped,  \"\\\\/ \" refers to /, and  \"/\\\\\\\\ \" refers to /\\\\.\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 30`\n*   `grid[i][j]` is either `'/'`, `'\\'`, or `' '`.\"\"\"\n\n    MOD = 1000000007\n    ans = 0\n\n    arr.sort()\n    n = len(arr)\n\n    for i in range(n - 2):\n        j, k = i + 1, n - 1\n        while j < k:\n            s = arr[i] + arr[j] + arr[k]\n            if s > target:\n                k -= 1\n            elif s < target:\n                j += 1\n            else:\n                if arr[j] != arr[k]:\n                    left_count = right_count = 1\n\n                    while j < n - 1 and arr[j] == arr[j + 1]:\n                        left_count += 1\n                        j += 1\n\n                    while k > 0 and arr[k] == arr[k - 1]:\n                        right_count += 1\n                        k -= 1\n\n                    ans += left_count * right_count\n                    ans %= MOD\n                    j += 1\n                    k -= 1\n                else:\n                    ans += (k - j + 1) * (k - j) // 2\n                    ans %= MOD\n                    break\n\n    return ans"}}, "leetcode/leetcode_1444.txt": {"score": 0.9905913472175598, "content": {"text": "def number_of_steps(num):\n    \"\"\"Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.\n\n**Example 1:**\n\n**Input:** pizza = \\[ \"A.. \", \"AAA \", \"... \"\\], k = 3\n**Output:** 3 \n**Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n**Example 2:**\n\n**Input:** pizza = \\[ \"A.. \", \"AA. \", \"... \"\\], k = 3\n**Output:** 1\n\n**Example 3:**\n\n**Input:** pizza = \\[ \"A.. \", \"A.. \", \"... \"\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 50`\n*   `rows == pizza.length`\n*   `cols == pizza[i].length`\n*   `1 <= k <= 10`\n*   `pizza` consists of characters `'A'` and `'.'` only.\"\"\"\n\n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    return steps - 1"}}}}, "65": {"gold": {"leetcode/leetcode_2024.txt": 1, "leetcode/leetcode_2136.txt": 1}, "retrieved": {"leetcode/leetcode_2274.txt": {"score": 0.9266429543495178, "content": {"text": "def final_value(nums, original):\n    \"\"\"Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.\n\nYou are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.\n\nReturn _the **maximum** number of consecutive floors without a special floor_.\n\n**Example 1:**\n\n**Input:** bottom = 2, top = 9, special = \\[4,6\\]\n**Output:** 3\n**Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors.\n\n**Example 2:**\n\n**Input:** bottom = 6, top = 8, special = \\[7,6,8\\]\n**Output:** 0\n**Explanation:** Every floor rented is a special floor, so we return 0.\n\n**Constraints:**\n\n*   `1 <= special.length <= 105`\n*   `1 <= bottom <= special[i] <= top <= 109`\n*   All the values of `special` are **unique**.\"\"\"\n\n    while original in nums:\n        original += 1\n    return original"}}, "leetcode/leetcode_1438.txt": {"score": 0.9307429790496826, "content": {"text": "from collections import deque\n    \"\"\"Given an array of integers `nums` and an integer `limit`, return the size of the longest **non-empty** subarray such that the absolute difference between any two elements of this subarray is less than or equal to `limit`_._\n\n**Example 1:**\n\n**Input:** nums = \\[8,2,4,7\\], limit = 4\n**Output:** 2 \n**Explanation:** All subarrays are: \n\\[8\\] with maximum absolute diff |8-8| = 0 <= 4.\n\\[8,2\\] with maximum absolute diff |8-2| = 6 > 4. \n\\[8,2,4\\] with maximum absolute diff |8-2| = 6 > 4.\n\\[8,2,4,7\\] with maximum absolute diff |8-2| = 6 > 4.\n\\[2\\] with maximum absolute diff |2-2| = 0 <= 4.\n\\[2,4\\] with maximum absolute diff |2-4| = 2 <= 4.\n\\[2,4,7\\] with maximum absolute diff |2-7| = 5 > 4.\n\\[4\\] with maximum absolute diff |4-4| = 0 <= 4.\n\\[4,7\\] with maximum absolute diff |4-7| = 3 <= 4.\n\\[7\\] with maximum absolute diff |7-7| = 0 <= 4. \nTherefore, the size of the longest subarray is 2.\n\n**Example 2:**\n\n**Input:** nums = \\[10,1,2,4,7,2\\], limit = 5\n**Output:** 4 \n**Explanation:** The subarray \\[2,4,7,2\\] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\n\n**Example 3:**\n\n**Input:** nums = \\[4,2,2,2,4,4,2,2\\], limit = 0\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `0 <= limit <= 109`\"\"\"\n\ndef longestSubarray(nums, limit):\n    max_deque = deque()\n    min_deque = deque()\n    left, right, longest = 0, 0, 0\n    \n    while right < len(nums):\n        while max_deque and nums[right] > max_deque[-1]: max_deque.pop()\n        while min_deque and nums[right] < min_deque[-1]: min_deque.pop()\n        \n        max_deque.append(nums[right])\n        min_deque.append(nums[right])\n        \n        while max_deque[0] - min_deque[0] > limit:\n            if max_deque[0] == nums[left]: max_deque.popleft()\n            if min_deque[0] == nums[left]: min_deque.popleft()\n            left += 1\n        \n        longest = max(longest, right - left + 1)\n        right += 1\n    \n    return longest"}}, "leetcode/leetcode_2136.txt": {"score": 0.9292874932289124, "content": {"text": "def earliestBlooms(plantTime, growTime):\n    \"\"\"You have `n` flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two **0-indexed** integer arrays `plantTime` and `growTime`, of length `n` each:\n\n*   `plantTime[i]` is the number of **full days** it takes you to **plant** the `ith` seed. Every day, you can work on planting exactly one seed. You **do not** have to work on planting the same seed on consecutive days, but the planting of a seed is not complete **until** you have worked `plantTime[i]` days on planting it in total.\n*   `growTime[i]` is the number of **full days** it takes the `ith` seed to grow after being completely planted. **After** the last day of its growth, the flower **blooms** and stays bloomed forever.\n\nFrom the beginning of day `0`, you can plant the seeds in **any** order.\n\nReturn _the **earliest** possible day where **all** seeds are blooming_.\n\n**Example 1:**\n\n**Input:** plantTime = \\[1,4,3\\], growTime = \\[2,3,1\\]\n**Output:** 9\n**Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n**Example 2:**\n\n**Input:** plantTime = \\[1,2,3,2\\], growTime = \\[2,1,2,1\\]\n**Output:** 9\n**Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n**Example 3:**\n\n**Input:** plantTime = \\[1\\], growTime = \\[1\\]\n**Output:** 2\n**Explanation:** On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming.\n\n**Constraints:**\n\n*   `n == plantTime.length == growTime.length`\n*   `1 <= n <= 105`\n*   `1 <= plantTime[i], growTime[i] <= 104`\"\"\"\n\n    n = len(plantTime)\n    processTime = list(zip(plantTime, growTime))\n    processTime.sort()\n\n    day = 0\n    blooms = 0\n    for p in processTime:\n        day += p[0]\n        blooms = max(blooms, day + p[1])\n    return blooms"}}, "leetcode/leetcode_2086.txt": {"score": 0.9312356114387512, "content": {"text": "def num_special_subsequences(nums):\n    \"\"\"You are given a **0-indexed** string `hamsters` where `hamsters[i]` is either:\n\n*   `'H'` indicating that there is a hamster at index `i`, or\n*   `'.'` indicating that index `i` is empty.\n\nYou will add some number of food buckets at the empty indices in order to feed the hamsters. A hamster can be fed if there is at least one food bucket to its left or to its right. More formally, a hamster at index `i` can be fed if you place a food bucket at index `i - 1` **and/or** at index `i + 1`.\n\nReturn _the minimum number of food buckets you should **place at empty indices** to feed all the hamsters or_ `-1` _if it is impossible to feed all of them_.\n\n**Example 1:**\n\n**Input:** hamsters =  \"H..H \"\n**Output:** 2\n**Explanation:** We place two food buckets at indices 1 and 2.\nIt can be shown that if we place only one food bucket, one of the hamsters will not be fed.\n\n**Example 2:**\n\n**Input:** hamsters =  \".H.H. \"\n**Output:** 1\n**Explanation:** We place one food bucket at index 2.\n\n**Example 3:**\n\n**Input:** hamsters =  \".HHH. \"\n**Output:** -1\n**Explanation:** If we place a food bucket at every empty index as shown, the hamster at index 2 will not be able to eat.\n\n**Constraints:**\n\n*   `1 <= hamsters.length <= 105`\n*   `hamsters[i]` is either`'H'` or `'.'`.\"\"\"\n\n    zeros, ones, twos = 0, 0, 0\n    mod = 1000000007\n    for num in nums:\n        if num == 0:\n            zeros = (zeros + 1) % mod\n        elif num == 1:\n            ones = (ones + zeros) % mod\n        else:\n            twos = (twos + ones) % mod\n    return twos"}}, "leetcode/leetcode_1578.txt": {"score": 0.9362496137619019, "content": {"text": "def minTime(colors: str, neededTime: List[int]) -> int:\n    \"\"\"Alice has `n` balloons arranged on a rope. You are given a **0-indexed** string `colors` where `colors[i]` is the color of the `ith` balloon.\n\nAlice wants the rope to be **colorful**. She does not want **two consecutive balloons** to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it **colorful**. You are given a **0-indexed** integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `ith` balloon from the rope.\n\nReturn _the **minimum time** Bob needs to make the rope **colorful**_.\n\n**Example 1:**\n\n**Input:** colors =  \"abaac \", neededTime = \\[1,2,3,4,5\\]\n**Output:** 3\n**Explanation:** In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.\n\n**Example 2:**\n\n**Input:** colors =  \"abc \", neededTime = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** The rope is already colorful. Bob does not need to remove any balloons from the rope.\n\n**Example 3:**\n\n**Input:** colors =  \"aabaa \", neededTime = \\[1,2,3,4,1\\]\n**Output:** 2\n**Explanation:** Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n\n**Constraints:**\n\n*   `n == colors.length == neededTime.length`\n*   `1 <= n <= 105`\n*   `1 <= neededTime[i] <= 104`\n*   `colors` contains only lowercase English letters.\"\"\"\n\n    res, prev = 0, -1\n    for i in range(len(colors) - 1):\n        if colors[i] == colors[i + 1]:\n            if prev == -1 or neededTime[i] < neededTime[prev]:\n                prev = i\n            if neededTime[i + 1] < neededTime[prev]:\n                prev = i + 1\n            res += neededTime[prev]\n            neededTime[prev] = 1000000\n            prev = -1\n    return res"}}, "leetcode/leetcode_2560.txt": {"score": 0.9444365501403809, "content": {"text": "def minimumCapability(nums, k):\n    \"\"\"There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he **refuses to steal from adjacent homes**.\n\nThe **capability** of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\n\nYou are given an integer array `nums` representing how much money is stashed in each house. More formally, the `ith` house from the left has `nums[i]` dollars.\n\nYou are also given an integer `k`, representing the **minimum** number of houses the robber will steal from. It is always possible to steal at least `k` houses.\n\nReturn _the **minimum** capability of the robber out of all the possible ways to steal at least_ `k` _houses_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,5,9\\], k = 2\n**Output:** 5\n**Explanation:** \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums\\[0\\], nums\\[2\\]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums\\[0\\], nums\\[3\\]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums\\[1\\], nums\\[3\\]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\], k = 2\n**Output:** 2\n**Explanation:** There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums\\[0\\], nums\\[4\\]) = 2.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `1 <= k <= (nums.length + 1)/2`\"\"\"\n\n    n, l, r = len(nums), 1, 10**9\n    while l < r:\n        mid = l + (r - l) // 2\n        i, cnt = 0, 0\n        for j in range(n):\n            if nums[j] <= mid:\n                cnt += 1\n                i = j + 2\n                while i + 1 < n and (i == j + 1 or nums[i] > mid):\n                    i += 1\n        if cnt < k:\n            l = mid + 1\n        else:\n            r = mid\n    return l"}}, "leetcode/leetcode_2187.txt": {"score": 0.9309710264205933, "content": {"text": "def sum_of_vowels_in_the_substrings(word: str) -> int:\n    \"\"\"You are given an array `time` where `time[i]` denotes the time taken by the `ith` bus to complete **one trip**.\n\nEach bus can make multiple trips **successively**; that is, the next trip can start **immediately after** completing the current trip. Also, each bus operates **independently**; that is, the trips of one bus do not influence the trips of any other bus.\n\nYou are also given an integer `totalTrips`, which denotes the number of trips all buses should make **in total**. Return _the **minimum time** required for all buses to complete **at least**_ `totalTrips` _trips_.\n\n**Example 1:**\n\n**Input:** time = \\[1,2,3\\], totalTrips = 5\n**Output:** 3\n**Explanation:**\n- At time t = 1, the number of trips completed by each bus are \\[1,0,0\\]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are \\[2,1,0\\]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are \\[3,1,1\\]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.\n\n**Example 2:**\n\n**Input:** time = \\[2\\], totalTrips = 1\n**Output:** 2\n**Explanation:**\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2.\n\n**Constraints:**\n\n*   `1 <= time.length <= 105`\n*   `1 <= time[i], totalTrips <= 107`\"\"\"\n\n    total_sum = 0\n    n = len(word)\n\n    for i, char in enumerate(word):\n        if char in {'a', 'e', 'i', 'o', 'u'}:\n            total_sum += (i + 1) * (n - i)\n\n    return total_sum"}}, "leetcode/leetcode_1482.txt": {"score": 0.9875836968421936, "content": {"text": "def smallerNumbersThanCurrent(nums):\n    \"\"\"You are given an integer array `bloomDay`, an integer `m` and an integer `k`.\n\nYou want to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden.\n\nThe garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet.\n\nReturn _the minimum number of days you need to wait to be able to make_ `m` _bouquets from the garden_. If it is impossible to make m bouquets return `-1`.\n\n**Example 1:**\n\n**Input:** bloomDay = \\[1,10,3,10,2\\], m = 3, k = 1\n**Output:** 3\n**Explanation:** Let us see what happened in the first three days. x means flower bloomed and \\_ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: \\[x, \\_, \\_, \\_, \\_\\]   // we can only make one bouquet.\nAfter day 2: \\[x, \\_, \\_, \\_, x\\]   // we can only make two bouquets.\nAfter day 3: \\[x, \\_, x, \\_, x\\]   // we can make 3 bouquets. The answer is 3.\n\n**Example 2:**\n\n**Input:** bloomDay = \\[1,10,3,10,2\\], m = 3, k = 2\n**Output:** -1\n**Explanation:** We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n\n**Example 3:**\n\n**Input:** bloomDay = \\[7,7,7,7,12,7,7\\], m = 2, k = 3\n**Output:** 12\n**Explanation:** We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: \\[x, x, x, x, \\_, x, x\\]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: \\[x, x, x, x, x, x, x\\]\nIt is obvious that we can make two bouquets in different ways.\n\n**Constraints:**\n\n*   `bloomDay.length == n`\n*   `1 <= n <= 105`\n*   `1 <= bloomDay[i] <= 109`\n*   `1 <= m <= 106`\n*   `1 <= k <= n`\"\"\"\n\n    result = [0] * len(nums)\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if nums[j] < nums[i]:\n                result[i] += 1\n    return result"}}, "leetcode/leetcode_2365.txt": {"score": 0.9427332282066345, "content": {"text": "def min_days_to_complete_tasks(tasks, space):\n    \"\"\"You are given a **0-indexed** array of positive integers `tasks`, representing tasks that need to be completed **in order**, where `tasks[i]` represents the **type** of the `ith` task.\n\nYou are also given a positive integer `space`, which represents the **minimum** number of days that must pass **after** the completion of a task before another task of the **same** type can be performed.\n\nEach day, until all tasks have been completed, you must either:\n\n*   Complete the next task from `tasks`, or\n*   Take a break.\n\nReturn _the **minimum** number of days needed to complete all tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,1,2,3,1\\], space = 3\n**Output:** 9\n**Explanation:**\nOne way to complete all tasks in 9 days is as follows:\nDay 1: Complete the 0th task.\nDay 2: Complete the 1st task.\nDay 3: Take a break.\nDay 4: Take a break.\nDay 5: Complete the 2nd task.\nDay 6: Complete the 3rd task.\nDay 7: Take a break.\nDay 8: Complete the 4th task.\nDay 9: Complete the 5th task.\nIt can be shown that the tasks cannot be completed in less than 9 days.\n\n**Example 2:**\n\n**Input:** tasks = \\[5,8,8,5\\], space = 2\n**Output:** 6\n**Explanation:**\nOne way to complete all tasks in 6 days is as follows:\nDay 1: Complete the 0th task.\nDay 2: Complete the 1st task.\nDay 3: Take a break.\nDay 4: Take a break.\nDay 5: Complete the 2nd task.\nDay 6: Complete the 3rd task.\nIt can be shown that the tasks cannot be completed in less than 6 days.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= tasks[i] <= 109`\n*   `1 <= space <= tasks.length`\"\"\"\n\n    task_last_complete = {}\n    days = 0\n\n    for task in tasks:\n        if task in task_last_complete:\n            passed_days = days - task_last_complete[task]\n            if passed_days < space:\n                days += space - passed_days\n        days += 1\n        task_last_complete[task] = days\n\n    return days"}}, "leetcode/leetcode_2260.txt": {"score": 0.9483914375305176, "content": {"text": "def partition_string(s, k, fill):\n    \"\"\"You are given an integer array `cards` where `cards[i]` represents the **value** of the `ith` card. A pair of cards are **matching** if the cards have the **same** value.\n\nReturn _the **minimum** number of **consecutive** cards you have to pick up to have a pair of **matching** cards among the picked cards._ If it is impossible to have matching cards, return `-1`.\n\n**Example 1:**\n\n**Input:** cards = \\[3,4,2,3,4,7\\]\n**Output:** 4\n**Explanation:** We can pick up the cards \\[3,4,2,3\\] which contain a matching pair of cards with value 3. Note that picking up the cards \\[4,2,3,4\\] is also optimal.\n\n**Example 2:**\n\n**Input:** cards = \\[1,0,5,3\\]\n**Output:** -1\n**Explanation:** There is no way to pick up a set of consecutive cards that contain a pair of matching cards.\n\n**Constraints:**\n\n*   `1 <= cards.length <= 105`\n*   `0 <= cards[i] <= 106`\"\"\"\n\n    partitions = []\n    current_partition = ''\n    for c in s:\n        current_partition += c\n        if len(current_partition) == k:\n            partitions.append(current_partition)\n            current_partition = ''\n    if current_partition:\n        current_partition += fill * (k - len(current_partition))\n        partitions.append(current_partition)\n    return partitions"}}}}, "66": {"gold": {"leetcode/leetcode_2211.txt": 1}, "retrieved": {"leetcode/leetcode_2239.txt": {"score": 0.8837598562240601, "content": {"text": "def robot_instructions(n: int, start_pos: list, s: str) -> list:\n    \"\"\"Given an integer array `nums` of size `n`, return _the number with the value **closest** to_ `0` _in_ `nums`. If there are multiple answers, return _the number with the **largest** value_.\n\n**Example 1:**\n\n**Input:** nums = \\[-4,-2,1,4,8\\]\n**Output:** 1\n**Explanation:**\nThe distance from -4 to 0 is |-4| = 4.\nThe distance from -2 to 0 is |-2| = 2.\nThe distance from 1 to 0 is |1| = 1.\nThe distance from 4 to 0 is |4| = 4.\nThe distance from 8 to 0 is |8| = 8.\nThus, the closest number to 0 in the array is 1.\n\n**Example 2:**\n\n**Input:** nums = \\[2,-1,1\\]\n**Output:** 1\n**Explanation:** 1 and -1 are both the closest numbers to 0, so 1 being larger is returned.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `-105 <= nums[i] <= 105`\"\"\"\n\n    answer = [0] * len(s)\n\n    for idx in range(len(s)):\n        row, col = start_pos\n\n        for i in range(idx, len(s)):\n            move = s[i]\n            if move == 'L':\n                col -= 1\n            elif move == 'R':\n                col += 1\n            elif move == 'U':\n                row -= 1\n            elif move == 'D':\n                row += 1\n\n            if row < 0 or row >= n or col < 0 or col >= n:\n                break\n\n            answer[idx] += 1\n\n    return answer"}}, "leetcode/leetcode_2332.txt": {"score": 0.888351559638977, "content": {"text": "def last_passenger_time(buses, passengers, capacity):\n    \"\"\"You are given a **0-indexed** integer array `buses` of length `n`, where `buses[i]` represents the departure time of the `ith` bus. You are also given a **0-indexed** integer array `passengers` of length `m`, where `passengers[j]` represents the arrival time of the `jth` passenger. All bus departure times are unique. All passenger arrival times are unique.\n\nYou are given an integer `capacity`, which represents the **maximum** number of passengers that can get on each bus.\n\nWhen a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at `x` minutes if you arrive at `y` minutes where `y <= x`, and the bus is not full. Passengers with the **earliest** arrival times get on the bus first.\n\nMore formally when a bus arrives, either:\n\n*   If `capacity` or fewer passengers are waiting for a bus, they will **all** get on the bus, or\n*   The `capacity` passengers with the **earliest** arrival times will get on the bus.\n\nReturn _the latest time you may arrive at the bus station to catch a bus_. You **cannot** arrive at the same time as another passenger.\n\n**Note:** The arrays `buses` and `passengers` are not necessarily sorted.\n\n**Example 1:**\n\n**Input:** buses = \\[10,20\\], passengers = \\[2,17,18,19\\], capacity = 2\n**Output:** 16\n**Explanation:** Suppose you arrive at time 16.\nAt time 10, the first bus departs with the 0th passenger. \nAt time 20, the second bus departs with you and the 1st passenger.\nNote that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus.\n\n**Example 2:**\n\n**Input:** buses = \\[20,30,10\\], passengers = \\[19,13,26,4,25,11,21\\], capacity = 2\n**Output:** 20\n**Explanation:** Suppose you arrive at time 20.\nAt time 10, the first bus departs with the 3rd passenger. \nAt time 20, the second bus departs with the 5th and 1st passengers.\nAt time 30, the third bus departs with the 0th passenger and you.\nNotice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus.\n\n**Constraints:**\n\n*   `n == buses.length`\n*   `m == passengers.length`\n*   `1 <= n, m, capacity <= 105`\n*   `2 <= buses[i], passengers[i] <= 109`\n*   Each element in `buses` is **unique**.\n*   Each element in `passengers` is **unique**.\"\"\"\n\n    buses.sort()\n    passengers.sort()\n\n    last_index = 0\n    for bus in buses:\n        cnt = 0\n        while last_index < len(passengers) and passengers[last_index] <= bus and cnt < capacity:\n            cnt += 1\n            last_index += 1\n\n    return buses[0] - 1 if last_index == 0 else passengers[last_index - 1] - 1"}}, "leetcode/leetcode_853.txt": {"score": 0.9026840925216675, "content": {"text": "def max_profit_assignment(difficulty, profit, worker):\n    \"\"\"There are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\n\nYou are given two integer array `position` and `speed`, both of length `n`, where `position[i]` is the position of the `ith` car and `speed[i]` is the speed of the `ith` car (in miles per hour).\n\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper **at the same speed**. The faster car will **slow down** to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n\nA **car fleet** is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\n\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\n\nReturn _the **number of car fleets** that will arrive at the destination_.\n\n**Example 1:**\n\n**Input:** target = 12, position = \\[10,8,0,5,3\\], speed = \\[2,4,1,1,3\\]\n**Output:** 3\n**Explanation:**\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\nNote that no other cars meet these fleets before the destination, so the answer is 3.\n\n**Example 2:**\n\n**Input:** target = 10, position = \\[3\\], speed = \\[3\\]\n**Output:** 1\n**Explanation:** There is only one car, hence there is only one fleet.\n\n**Example 3:**\n\n**Input:** target = 100, position = \\[0,2,4\\], speed = \\[4,2,1\\]\n**Output:** 1\n**Explanation:**\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n\n**Constraints:**\n\n*   `n == position.length == speed.length`\n*   `1 <= n <= 105`\n*   `0 < target <= 106`\n*   `0 <= position[i] < target`\n*   All the values of `position` are **unique**.\n*   `0 < speed[i] <= 106`\"\"\"\n\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    i, max_profit, total_profit = 0, 0, 0\n    for ability in worker:\n        while i < len(difficulty) and ability >= jobs[i][0]:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        total_profit += max_profit\n    return total_profit"}}, "leetcode/leetcode_2211.txt": {"score": 0.89556485414505, "content": {"text": "def k_radius_average(nums, k):\n    \"\"\"There are `n` cars on an infinitely long road. The cars are numbered from `0` to `n - 1` from left to right and each car is present at a **unique** point.\n\nYou are given a **0-indexed** string `directions` of length `n`. `directions[i]` can be either `'L'`, `'R'`, or `'S'` denoting whether the `ith` car is moving towards the **left**, towards the **right**, or **staying** at its current point respectively. Each moving car has the **same speed**.\n\nThe number of collisions can be calculated as follows:\n\n*   When two cars moving in **opposite** directions collide with each other, the number of collisions increases by `2`.\n*   When a moving car collides with a stationary car, the number of collisions increases by `1`.\n\nAfter a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\n\nReturn _the **total number of collisions** that will happen on the road_.\n\n**Example 1:**\n\n**Input:** directions =  \"RLRSLL \"\n**Output:** 5\n**Explanation:**\nThe collisions that will happen on the road are:\n- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\nThus, the total number of collisions that will happen on the road is 5. \n\n**Example 2:**\n\n**Input:** directions =  \"LLRR \"\n**Output:** 0\n**Explanation:**\nNo cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.\n\n**Constraints:**\n\n*   `1 <= directions.length <= 105`\n*   `directions[i]` is either `'L'`, `'R'`, or `'S'`.\"\"\"\n\n    n = len(nums)\n    avgs = [-1] * n\n    for i in range(k, n - k):\n        sum = 0\n        for j in range(i - k, i + k + 1):\n            sum += nums[j]\n        avgs[i] = sum // (2 * k + 1)\n    return avgs"}}, "leetcode/leetcode_735.txt": {"score": 0.9067985415458679, "content": {"text": "def asteroidCollision(asteroids):\n    \"\"\"We are given an array `asteroids` of integers representing asteroids in a row.\n\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\n\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\n\n**Example 1:**\n\n**Input:** asteroids = \\[5,10,-5\\]\n**Output:** \\[5,10\\]\n**Explanation:** The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\n\n**Example 2:**\n\n**Input:** asteroids = \\[8,-8\\]\n**Output:** \\[\\]\n**Explanation:** The 8 and -8 collide exploding each other.\n\n**Example 3:**\n\n**Input:** asteroids = \\[10,2,-5\\]\n**Output:** \\[10\\]\n**Explanation:** The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\n\n**Constraints:**\n\n*   `2 <= asteroids.length <= 104`\n*   `-1000 <= asteroids[i] <= 1000`\n*   `asteroids[i] != 0`\"\"\"\n\n    s = []\n    for num in asteroids:\n        if num > 0 or not s or s[-1] < 0:\n            s.append(num)\n        elif s[-1] <= -num:\n            if s[-1] < -num:\n                s.pop()\n                s.append(num)\n            else:\n                s.pop()\n    return s"}}, "leetcode/leetcode_1776.txt": {"score": 0.9436136484146118, "content": {"text": "def minOperations(nums, x):\n    \"\"\"There are `n` cars traveling at different speeds in the same direction along a one-lane road. You are given an array `cars` of length `n`, where `cars[i] = [positioni, speedi]` represents:\n\n*   `positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`.\n*   `speedi` is the initial speed of the `ith` car in meters per second.\n\nFor simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the **slowest** car in the fleet.\n\nReturn an array `answer`, where `answer[i]` is the time, in seconds, at which the `ith` car collides with the next car, or `-1` if the car does not collide with the next car. Answers within `10-5` of the actual answers are accepted.\n\n**Example 1:**\n\n**Input:** cars = \\[\\[1,2\\],\\[2,1\\],\\[4,3\\],\\[7,2\\]\\]\n**Output:** \\[1.00000,-1.00000,3.00000,-1.00000\\]\n**Explanation:** After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.\n\n**Example 2:**\n\n**Input:** cars = \\[\\[3,4\\],\\[5,4\\],\\[6,3\\],\\[9,1\\]\\]\n**Output:** \\[2.00000,1.00000,1.50000,-1.00000\\]\n\n**Constraints:**\n\n*   `1 <= cars.length <= 105`\n*   `1 <= positioni, speedi <= 106`\n*   `positioni < positioni+1`\"\"\"\n\n    total = sum(nums)\n    target = total - x\n    if target < 0:\n        return -1\n\n    maxLength = -1\n    left = 0\n    current_sum = 0\n\n    for right in range(len(nums)):\n        current_sum += nums[right]\n\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n\n        if current_sum == target:\n            maxLength = max(maxLength, right - left + 1)\n\n    return -1 if maxLength == -1 else len(nums) - maxLength"}}, "leetcode/leetcode_1921.txt": {"score": 0.9102659821510315, "content": {"text": "def eliminate_maximum(dist, speed):\n    \"\"\"You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0-indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city.\n\nThe monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute.\n\nYou have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge.The weapon is fully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon.\n\nReturn _the **maximum** number of monsters that you can eliminate before you lose, or_ `n` _if you can eliminate all the monsters before they reach the city._\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,4\\], speed = \\[1,1,1\\]\n**Output:** 3\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,3,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,2,3\\]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are \\[X,X,2\\]. You eliminate the thrid monster.\nAll 3 monsters can be eliminated.\n\n**Example 2:**\n\n**Input:** dist = \\[1,1,2,3\\], speed = \\[1,1,1,1\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,1,2,3\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,1,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Example 3:**\n\n**Input:** dist = \\[3,2,4\\], speed = \\[5,3,2\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[3,2,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Constraints:**\n\n*   `n == dist.length == speed.length`\n*   `1 <= n <= 105`\n*   `1 <= dist[i], speed[i] <= 105`\"\"\"\n\n    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated"}}, "leetcode/leetcode_1503.txt": {"score": 0.9946020245552063, "content": {"text": "def max_satisfaction(satisfaction):\n    \"\"\"We have a wooden plank of the length `n` **units**. Some ants are walking on the plank, each ant moves with a speed of **1 unit per second**. Some of the ants move to the **left**, the other move to the **right**.\n\nWhen two ants moving in two **different** directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\n\nWhen an ant reaches **one end** of the plank at a time `t`, it falls out of the plank immediately.\n\nGiven an integer `n` and two integer arrays `left` and `right`, the positions of the ants moving to the left and the right, return _the moment when the last ant(s) fall out of the plank_.\n\n**Example 1:**\n\n**Input:** n = 4, left = \\[4,3\\], right = \\[0,1\\]\n**Output:** 4\n**Explanation:** In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n\n**Example 2:**\n\n**Input:** n = 7, left = \\[\\], right = \\[0,1,2,3,4,5,6,7\\]\n**Output:** 7\n**Explanation:** All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n\n**Example 3:**\n\n**Input:** n = 7, left = \\[0,1,2,3,4,5,6,7\\], right = \\[\\]\n**Output:** 7\n**Explanation:** All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `0 <= left.length <= n + 1`\n*   `0 <= left[i] <= n`\n*   `0 <= right.length <= n + 1`\n*   `0 <= right[i] <= n`\n*   `1 <= left.length + right.length <= n + 1`\n*   All values of `left` and `right` are unique, and each value can appear **only in one** of the two arrays.\"\"\"\n\n    satisfaction.sort(reverse=True)\n    ans = total = sum = 0\n    for i in satisfaction:\n        total += i\n        if total > 0:\n            sum += total\n            ans = max(ans, sum)\n    return ans"}}, "leetcode/leetcode_1900.txt": {"score": 0.9155892729759216, "content": {"text": "def closest_cost(base_costs, topping_costs, target):\n    \"\"\"There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their **initial** standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.).\n\nThe tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n\n*   For example, if the row consists of players `1, 2, 4, 6, 7`\n    *   Player `1` competes against player `7`.\n    *   Player `2` competes against player `6`.\n    *   Player `4` automatically advances to the next round.\n\nAfter each round is over, the winners are lined back up in the row based on the **original ordering** assigned to them initially (ascending order).\n\nThe players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may **choose** the outcome of this round.\n\nGiven the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the **earliest** possible round number and the **latest** possible round number in which these two players will compete against each other, respectively_.\n\n**Example 1:**\n\n**Input:** n = 11, firstPlayer = 2, secondPlayer = 4\n**Output:** \\[3,4\\]\n**Explanation:**\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n\n**Example 2:**\n\n**Input:** n = 5, firstPlayer = 1, secondPlayer = 5\n**Output:** \\[1,1\\]\n**Explanation:** The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.\n\n**Constraints:**\n\n*   `2 <= n <= 28`\n*   `1 <= firstPlayer < secondPlayer <= n`\"\"\"\n\n    closest = base_costs[0]\n    \n    for base in base_costs:\n        cost = base\n        \n        for i in range(1 << (len(topping_costs) * 2)):\n            bit_mask = i\n            \n            for j, topping_cost in enumerate(topping_costs):\n                cost += (bit_mask & 3) * topping_cost\n                bit_mask >>= 2\n                \n            if abs(target - cost) < abs(target - closest):\n                closest = cost\n            elif abs(target - cost) == abs(target - closest) and cost < closest:\n                closest = cost\n                \n            cost = base\n            \n    return closest"}}, "leetcode/leetcode_2463.txt": {"score": 0.9210842847824097, "content": {"text": "def min_total_distance(robot: List[int], factory: List[List[int]]) -> int:\n    \"\"\"There are some robots and factories on the X-axis. You are given an integer array `robot` where `robot[i]` is the position of the `ith` robot. You are also given a 2D integer array `factory` where `factory[j] = [positionj, limitj]` indicates that `positionj` is the position of the `jth` factory and that the `jth` factory can repair at most `limitj` robots.\n\nThe positions of each robot are **unique**. The positions of each factory are also **unique**. Note that a robot can be **in the same position** as a factory initially.\n\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\n\n**At any moment**, you can set the initial direction of moving for **some** robot. Your target is to minimize the total distance traveled by all the robots.\n\nReturn _the minimum total distance traveled by all the robots_. The test cases are generated such that all the robots can be repaired.\n\n**Note that**\n\n*   All robots move at the same speed.\n*   If two robots move in the same direction, they will never collide.\n*   If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\n*   If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\n*   If the robot moved from a position `x` to a position `y`, the distance it moved is `|y - x|`.\n\n**Example 1:**\n\n**Input:** robot = \\[0,4,6\\], factory = \\[\\[2,2\\],\\[6,2\\]\\]\n**Output:** 4\n**Explanation:** As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n\n**Example 2:**\n\n**Input:** robot = \\[1,-1\\], factory = \\[\\[-2,1\\],\\[2,1\\]\\]\n**Output:** 2\n**Explanation:** As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.\n\n**Constraints:**\n\n*   `1 <= robot.length, factory.length <= 100`\n*   `factory[j].length == 2`\n*   `-109 <= robot[i], positionj <= 109`\n*   `0 <= limitj <= robot.length`\n*   The input will be generated such that it is always possible to repair every robot.\"\"\"\n\n    robot.sort()\n    factory.sort()\n\n    res = 0\n    idx = 0\n    for f_pos, f_limit in factory:\n        while f_limit > 0 and idx < len(robot):\n            res += abs(f_pos - robot[idx])\n            idx += 1\n            f_limit -= 1\n    \n    return res"}}}}, "67": {"gold": {"leetcode/leetcode_1563.txt": 1, "leetcode/leetcode_1686.txt": 1, "leetcode/leetcode_1690.txt": 1, "leetcode/leetcode_1872.txt": 1, "leetcode/leetcode_2029.txt": 1}, "retrieved": {"leetcode/leetcode_2558.txt": {"score": 0.8845559358596802, "content": {"text": "import math\n    \"\"\"You are given an integer array `gifts` denoting the number of gifts in various piles. Every second, you do the following:\n\n*   Choose the pile with the maximum number of gifts.\n*   If there is more than one pile with the maximum number of gifts, choose any.\n*   Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.\n\nReturn _the number of gifts remaining after_ `k` _seconds._\n\n**Example 1:**\n\n**Input:** gifts = \\[25,64,9,4,100\\], k = 4\n**Output:** 29\n**Explanation:** \nThe gifts are taken in the following way:\n- In the first second, the last pile is chosen and 10 gifts are left behind.\n- Then the second pile is chosen and 8 gifts are left behind.\n- After that the first pile is chosen and 5 gifts are left behind.\n- Finally, the last pile is chosen again and 3 gifts are left behind.\nThe final remaining gifts are \\[5,8,9,4,3\\], so the total number of gifts remaining is 29.\n\n**Example 2:**\n\n**Input:** gifts = \\[1,1,1,1\\], k = 4\n**Output:** 4\n**Explanation:** \nIn this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. \nThat is, you can't take any pile with you. \nSo, the total gifts remaining are 4.\n\n**Constraints:**\n\n*   `1 <= gifts.length <= 103`\n*   `1 <= gifts[i] <= 109`\n*   `1 <= k <= 103`\"\"\"\n\n\ndef giftsRemaining(gifts, k):\n    for i in range(k):\n        gifts.sort()\n        max_index = len(gifts) - 1\n        gifts[max_index] -= int(math.sqrt(gifts[max_index]))\n    return sum(gifts)"}}, "leetcode/leetcode_1553.txt": {"score": 0.8928386569023132, "content": {"text": "def countTriplets(arr):\n    \"\"\"There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:\n\n*   Eat one orange.\n*   If the number of remaining oranges `n` is divisible by `2` then you can eat `n / 2` oranges.\n*   If the number of remaining oranges `n` is divisible by `3` then you can eat `2 * (n / 3)` oranges.\n\nYou can only choose one of the actions per day.\n\nGiven the integer `n`, return _the minimum number of days to eat_ `n` _oranges_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation:** You have 10 oranges.\nDay 1: Eat 1 orange,  10 - 1 = 9.  \nDay 2: Eat 6 oranges, 9 - 2\\*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\nDay 3: Eat 2 oranges, 3 - 2\\*(3/3) = 3 - 2 = 1. \nDay 4: Eat the last orange  1 - 1  = 0.\nYou need at least 4 days to eat the 10 oranges.\n\n**Example 2:**\n\n**Input:** n = 6\n**Output:** 3\n**Explanation:** You have 6 oranges.\nDay 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\nDay 2: Eat 2 oranges, 3 - 2\\*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\nDay 3: Eat the last orange  1 - 1  = 0.\nYou need at least 3 days to eat the 6 oranges.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 109`\"\"\"\n\n    n = len(arr)\n    XOR = [0] * (n + 1)\n    \n    for i in range(n):\n        XOR[i+1] = XOR[i] ^ arr[i]\n    \n    count = 0\n    for i in range(n):\n        for k in range(i+1, n):\n            if XOR[i] == XOR[k+1]:\n                count += k-i\n    return count"}}, "leetcode/leetcode_367.txt": {"score": 0.8929992914199829, "content": {"text": "def is_perfect_square(num: int) -> bool:\n    \"\"\"Given a positive integer num, return `true` _if_ `num` _is a perfect square or_ `false` _otherwise_.\n\nA **perfect square** is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\n\nYou must not use any built-in library function, such as `sqrt`.\n\n**Example 1:**\n\n**Input:** num = 16\n**Output:** true\n**Explanation:** We return true because 4 \\* 4 = 16 and 4 is an integer.\n\n**Example 2:**\n\n**Input:** num = 14\n**Output:** false\n**Explanation:** We return false because 3.742 \\* 3.742 = 14 and 3.742 is not an integer.\n\n**Constraints:**\n\n*   `1 <= num <= 231 - 1`\"\"\"\n\n    if num < 2:\n        return True\n    left, right = 2, num // 2\n    while left <= right:\n        mid = left + (right - left) // 2\n        square = mid * mid\n        if square == num:\n            return True\n        if square > num:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False"}}, "leetcode/leetcode_1688.txt": {"score": 0.9020618200302124, "content": {"text": "def numberOfMatches(n: int) -> int:\n    \"\"\"You are given an integer `n`, the number of teams in a tournament that has strange rules:\n\n*   If the current number of teams is **even**, each team gets paired with another team. A total of `n / 2` matches are played, and `n / 2` teams advance to the next round.\n*   If the current number of teams is **odd**, one team randomly advances in the tournament, and the rest gets paired. A total of `(n - 1) / 2` matches are played, and `(n - 1) / 2 + 1` teams advance to the next round.\n\nReturn _the number of matches played in the tournament until a winner is decided._\n\n**Example 1:**\n\n**Input:** n = 7\n**Output:** 6\n**Explanation:** Details of the tournament: \n- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 3 + 2 + 1 = 6.\n\n**Example 2:**\n\n**Input:** n = 14\n**Output:** 13\n**Explanation:** Details of the tournament:\n- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 7 + 3 + 2 + 1 = 13.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\"\"\"\n\n    matches = 0\n    while n > 1:\n        matches += n // 2\n        n = (n + 1) // 2\n    return matches"}}, "leetcode/leetcode_1342.txt": {"score": 0.9217991232872009, "content": {"text": "def queensAttacktheKing(queens, king):\n    \"\"\"Given an integer `num`, return _the number of steps to reduce it to zero_.\n\nIn one step, if the current number is even, you have to divide it by `2`, otherwise, you have to subtract `1` from it.\n\n**Example 1:**\n\n**Input:** num = 14\n**Output:** 6\n**Explanation:** \nStep 1) 14 is even; divide by 2 and obtain 7. \nStep 2) 7 is odd; subtract 1 and obtain 6.\nStep 3) 6 is even; divide by 2 and obtain 3. \nStep 4) 3 is odd; subtract 1 and obtain 2. \nStep 5) 2 is even; divide by 2 and obtain 1. \nStep 6) 1 is odd; subtract 1 and obtain 0.\n\n**Example 2:**\n\n**Input:** num = 8\n**Output:** 4\n**Explanation:** \nStep 1) 8 is even; divide by 2 and obtain 4. \nStep 2) 4 is even; divide by 2 and obtain 2. \nStep 3) 2 is even; divide by 2 and obtain 1. \nStep 4) 1 is odd; subtract 1 and obtain 0.\n\n**Example 3:**\n\n**Input:** num = 123\n**Output:** 12\n\n**Constraints:**\n\n*   `0 <= num <= 106`\"\"\"\n\n    result = []\n    for x in range(-1, 2):\n        for y in range(-1, 2):\n            if x == 0 and y == 0:\n                continue\n            posX, posY = king[0] + x, king[1] + y\n            while 0 <= posX < 8 and 0 <= posY < 8:\n                for queen in queens:\n                    if posX == queen[0] and posY == queen[1]:\n                        result.append([queen[0], queen[1]])\n                        break\n                posX += x\n                posY += y\n    return result"}}, "leetcode/leetcode_464.txt": {"score": 0.8940843343734741, "content": {"text": "def canIWin(maxChoosableInteger, desiredTotal):\n    \"\"\"In the \"100 game \" two players take turns adding, to a running total, any integer from `1` to `10`. The player who first causes the running total to **reach or exceed** 100 wins.\n\nWhat if we change the game so that players **cannot** re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers `maxChoosableInteger` and `desiredTotal`, return `true` if the first player to move can force a win, otherwise, return `false`. Assume both players play **optimally**.\n\n**Example 1:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 11\n**Output:** false\n**Explanation:**\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n\n**Example 2:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 0\n**Output:** true\n\n**Example 3:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= maxChoosableInteger <= 20`\n*   `0 <= desiredTotal <= 300`\"\"\"\n\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)"}}, "leetcode/leetcode_397.txt": {"score": 0.8974313139915466, "content": {"text": "def min_operations(n):\n    \"\"\"Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.\n\n**Example 1:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** 8 -> 4 -> 2 -> 1\n\n**Example 2:**\n\n**Input:** n = 7\n**Output:** 4\n**Explanation:** 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`\"\"\"\n\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps"}}, "leetcode/leetcode_2029.txt": {"score": 0.9154056906700134, "content": {"text": "def stoneGameIX(stones: List[int]) -> bool:\n    \"\"\"Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array `stones`, where `stones[i]` is the **value** of the `ith` stone.\n\nAlice and Bob take turns, with **Alice** starting first. On each turn, the player may remove any stone from `stones`. The player who removes a stone **loses** if the **sum** of the values of **all removed stones** is divisible by `3`. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).\n\nAssuming both players play **optimally**, return `true` _if Alice wins and_ `false` _if Bob wins_.\n\n**Example 1:**\n\n**Input:** stones = \\[2,1\\]\n**Output:** true\n**Explanation:** The game will be played as follows:\n- Turn 1: Alice can remove either stone.\n- Turn 2: Bob removes the remaining stone. \nThe sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.\n\n**Example 2:**\n\n**Input:** stones = \\[2\\]\n**Output:** false\n**Explanation:** Alice will remove the only stone, and the sum of the values on the removed stones is 2. \nSince all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.\n\n**Example 3:**\n\n**Input:** stones = \\[5,1,2,4,3\\]\n**Output:** false\n**Explanation:** Bob will always win. One possible way for Bob to win is shown below:\n- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\nAlice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n\n**Constraints:**\n\n*   `1 <= stones.length <= 105`\n*   `1 <= stones[i] <= 104`\"\"\"\n\n    cnt = [0, 0, 0]\n    for s in stones:\n        cnt[s % 3] += 1\n    return (cnt[1] and cnt[2]) or (cnt[1] > cnt[2] if cnt[1] > cnt[2] + 2 else cnt[2] > cnt[1] + 1)"}}, "leetcode/leetcode_1025.txt": {"score": 0.9435136914253235, "content": {"text": "def mincostTickets(days, costs):\n    \"\"\"Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there is a number `n` on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n*   Choosing any `x` with `0 < x < n` and `n % x == 0`.\n*   Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso, if a player cannot make a move, they lose the game.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** true\n**Explanation:** Alice chooses 1, and Bob has no more moves.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** false\n**Explanation:** Alice chooses 1, Bob chooses 1, and Alice has no more moves.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\"\"\"\n\n  travel_days = set(days)\n  dp = [0] * 366\n\n  for i in range(1, 366):\n    if i not in travel_days:\n      dp[i] = dp[i - 1]\n    else:\n      dp[i] = min(dp[i - 1] + costs[0],\n                  dp[max(0, i - 7)] + costs[1],\n                  dp[max(0, i - 30)] + costs[2])\n\n  return dp[365]"}}, "leetcode/leetcode_1510.txt": {"score": 0.9837806224822998, "content": {"text": "def find_lucky(arr):\n    \"\"\"Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there are `n` stones in a pile. On each player's turn, that player makes a _move_ consisting of removing **any** non-zero **square number** of stones in the pile.\n\nAlso, if a player cannot make a move, he/she loses the game.\n\nGiven a positive integer `n`, return `true` if and only if Alice wins the game otherwise return `false`, assuming both players play optimally.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** false\n**Explanation:** Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** true\n**Explanation:** n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n\n**Constraints:**\n\n*   `1 <= n <= 105`\"\"\"\n\n    freq = {}\n\n    for n in arr:\n        if n in freq:\n            freq[n] += 1\n        else:\n            freq[n] = 1\n\n    lucky = -1\n    for key, value in freq.items():\n        if key == value:\n            lucky = max(lucky, key)\n\n    return lucky"}}}}, "68": {"gold": {"leetcode/leetcode_2147.txt": 1}, "retrieved": {"leetcode/leetcode_1335.txt": {"score": 0.9069555997848511, "content": {"text": "def max_candies(candies, k):\n    \"\"\"You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `ith` job, you have to finish all the jobs `j` where `0 <= j < i`).\n\nYou have to finish **at least** one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done on that day.\n\nYou are given an integer array `jobDifficulty` and an integer `d`. The difficulty of the `ith` job is `jobDifficulty[i]`.\n\nReturn _the minimum difficulty of a job schedule_. If you cannot find a schedule for the jobs return `-1`.\n\n**Example 1:**\n\n**Input:** jobDifficulty = \\[6,5,4,3,2,1\\], d = 2\n**Output:** 7\n**Explanation:** First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n\n**Example 2:**\n\n**Input:** jobDifficulty = \\[9,9,9\\], d = 4\n**Output:** -1\n**Explanation:** If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n\n**Example 3:**\n\n**Input:** jobDifficulty = \\[1,1,1\\], d = 3\n**Output:** 3\n**Explanation:** The schedule is one job per day. total difficulty will be 3.\n\n**Constraints:**\n\n*   `1 <= jobDifficulty.length <= 300`\n*   `0 <= jobDifficulty[i] <= 1000`\n*   `1 <= d <= 10`\"\"\"\n\n    left, right = 1, max(candies)\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        count = sum(candy // mid for candy in candies)\n        if count >= k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right"}}, "leetcode/leetcode_1105.txt": {"score": 0.9105075001716614, "content": {"text": "def max_uncrossed_lines(nums1, nums2):\n    \"\"\"You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`.\n\nWe want to place these books in order onto bookcase shelves that have a total width `shelfWidth`.\n\nWe choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n\nNote that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n*   For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\nReturn _the minimum possible height that the total bookshelf can be after placing shelves in this manner_.\n\n**Example 1:**\n\n**Input:** books = \\[\\[1,1\\],\\[2,3\\],\\[2,3\\],\\[1,1\\],\\[1,1\\],\\[1,1\\],\\[1,2\\]\\], shelfWidth = 4\n**Output:** 6\n**Explanation:**\nThe sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n**Example 2:**\n\n**Input:** books = \\[\\[1,3\\],\\[2,4\\],\\[3,2\\]\\], shelfWidth = 6\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= books.length <= 1000`\n*   `1 <= thicknessi <= shelfWidth <= 1000`\n*   `1 <= heighti <= 1000`\"\"\"\n\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]"}}, "leetcode/leetcode_1563.txt": {"score": 0.9141780138015747, "content": {"text": "from math import acos, cos, sin, sqrt\n    \"\"\"There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially **zero**.\n\nReturn _the maximum score that Alice can obtain_.\n\n**Example 1:**\n\n**Input:** stoneValue = \\[6,2,3,4,5,5\\]\n**Output:** 18\n**Explanation:** In the first round, Alice divides the row to \\[6,2,3\\], \\[4,5,5\\]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to \\[6\\], \\[2,3\\]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is \\[2\\], \\[3\\]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\n**Example 2:**\n\n**Input:** stoneValue = \\[7,7,7,7,7,7,7\\]\n**Output:** 28\n\n**Example 3:**\n\n**Input:** stoneValue = \\[4\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 500`\n*   `1 <= stoneValue[i] <= 106`\"\"\"\n\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts"}}, "leetcode/leetcode_410.txt": {"score": 0.9113823771476746, "content": {"text": "def splitArray(nums, m):\n    \"\"\"Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array.\n\n**Example 1:**\n\n**Input:** nums = \\[7,2,5,10,8\\], k = 2\n**Output:** 18\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 9\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= min(50, nums.length)`\"\"\"\n\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left"}}, "leetcode/leetcode_1760.txt": {"score": 0.9177428483963013, "content": {"text": "def can_form_array(arr, pieces):\n    \"\"\"You are given an integer array `nums` where the `ith` bag contains `nums[i]` balls. You are also given an integer `maxOperations`.\n\nYou can perform the following operation at most `maxOperations` times:\n\n*   Take any bag of balls and divide it into two new bags with a **positive** number of balls.\n    *   For example, a bag of `5` balls can become two new bags of `1` and `4` balls, or two new bags of `2` and `3` balls.\n\nYour penalty is the **maximum** number of balls in a bag. You want to **minimize** your penalty after the operations.\n\nReturn _the minimum possible penalty after performing the operations_.\n\n**Example 1:**\n\n**Input:** nums = \\[9\\], maxOperations = 2\n**Output:** 3\n**Explanation:** \n- Divide the bag with 9 balls into two bags of sizes 6 and 3. \\[**9**\\] -> \\[6,3\\].\n- Divide the bag with 6 balls into two bags of sizes 3 and 3. \\[**6**,3\\] -> \\[3,3,3\\].\nThe bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,8,2\\], maxOperations = 4\n**Output:** 2\n**Explanation:**\n- Divide the bag with 8 balls into two bags of sizes 4 and 4. \\[2,4,**8**,2\\] -> \\[2,4,4,4,2\\].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. \\[2,**4**,4,4,2\\] -> \\[2,2,2,4,4,2\\].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. \\[2,2,2,**4**,4,2\\] -> \\[2,2,2,2,2,4,2\\].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. \\[2,2,2,2,2,**4**,2\\] -> \\[2,2,2,2,2,2,2,2\\].\nThe bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= maxOperations, nums[i] <= 109`\"\"\"\n\n    piece_map = {piece[0]: piece for piece in pieces}\n    \n    i = 0\n    while i < len(arr):\n        if arr[i] not in piece_map:\n            return False\n        \n        for num in piece_map[arr[i]]:\n            if arr[i] != num:\n                return False\n            i += 1\n            \n    return True"}}, "leetcode/leetcode_2547.txt": {"score": 0.9440767168998718, "content": {"text": "def minCost(nums: List[int], k: int) -> int:\n    \"\"\"You are given an integer array `nums` and an integer `k`.\n\nSplit the array into some number of non-empty subarrays. The **cost** of a split is the sum of the **importance value** of each subarray in the split.\n\nLet `trimmed(subarray)` be the version of the subarray where all numbers which appear only once are removed.\n\n*   For example, `trimmed([3,1,2,4,3,4]) = [3,4,3,4].`\n\nThe **importance value** of a subarray is `k + trimmed(subarray).length`.\n\n*   For example, if a subarray is `[1,2,3,3,3,4,4]`, then trimmed(`[1,2,3,3,3,4,4]) = [3,3,3,4,4].`The importance value of this subarray will be `k + 5`.\n\nReturn _the minimum possible cost of a split of_ `nums`.\n\nA **subarray** is a contiguous **non-empty** sequence of elements within an array.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,1,3,3\\], k = 2\n**Output:** 8\n**Explanation:** We split nums to have two subarrays: \\[1,2\\], \\[1,2,1,3,3\\].\nThe importance value of \\[1,2\\] is 2 + (0) = 2.\nThe importance value of \\[1,2,1,3,3\\] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1\\], k = 2\n**Output:** 6\n**Explanation:** We split nums to have two subarrays: \\[1,2\\], \\[1,2,1\\].\nThe importance value of \\[1,2\\] is 2 + (0) = 2.\nThe importance value of \\[1,2,1\\] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,1,2,1\\], k = 5\n**Output:** 10\n**Explanation:** We split nums to have one subarray: \\[1,2,1,2,1\\].\nThe importance value of \\[1,2,1,2,1\\] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < nums.length`\n*   `1 <= k <= 109`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;\u00a0 } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n    n = len(nums)\n    count = [0] * 1001\n    dp = [0] * (n + 1)\n\n    i = 0\n    for j in range(n):\n        count[nums[j]] += 1\n        \n        if count[nums[j]] == 2:\n            dp[j + 1] = dp[i] + k + (j - i + 1)\n        elif count[nums[j]] > 2:\n            dp[j + 1] = min(dp[j], dp[j - 1] + 1)\n        else:\n            dp[j + 1] = dp[j] + 1\n\n        while i <= j and count[nums[i]] >= 2:\n            count[nums[i]] -= 1\n            i += 1\n\n    return dp[n] + n * k"}}, "leetcode/leetcode_1986.txt": {"score": 0.9144854545593262, "content": {"text": "from collections import defaultdict\n    \"\"\"There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break.\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n*   If you start a task in a work session, you must complete it in the **same** work session.\n*   You can start a new task **immediately** after finishing the previous one.\n*   You may complete the tasks in **any order**.\n\nGiven `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._\n\nThe tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,3\\], sessionTime = 3\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n**Example 2:**\n\n**Input:** tasks = \\[3,1,3,1,1\\], sessionTime = 8\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n**Example 3:**\n\n**Input:** tasks = \\[1,2,3,4,5\\], sessionTime = 15\n**Output:** 1\n**Explanation:** You can finish all the tasks in one work session.\n\n**Constraints:**\n\n*   `n == tasks.length`\n*   `1 <= n <= 14`\n*   `1 <= tasks[i] <= 10`\n*   `max(tasks[i]) <= sessionTime <= 15`\"\"\"\n\n\n\ndef largestPathValue(colors, edges):\n    def dfs(node):\n        if not cache[node][ord(colors[node]) - ord('a')]:\n            cache[node][ord(colors[node]) - ord('a')] = 1\n            for neighbor in graph[node]:\n                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],\n                                                               1 + dfs(neighbor))\n        return cache[node][ord(colors[node]) - ord('a')]\n\n    n = len(colors)\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n\n    cache = [[0] * 26 for _ in range(n)]\n    in_degree = [0] * n\n    for a, b in edges:\n        in_degree[b] += 1\n    res = -1\n    for i in range(n):\n        if in_degree[i] == 0:\n            res = max(res, dfs(i))\n    return res"}}, "leetcode/leetcode_1547.txt": {"score": 0.9906080365180969, "content": {"text": "def destCity(paths):\n    \"\"\"Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows:\n\nGiven an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn _the minimum total cost_ of the cuts.\n\n**Example 1:**\n\n**Input:** n = 7, cuts = \\[1,3,4,5\\]\n**Output:** 16\n**Explanation:** Using cuts order = \\[1, 3, 4, 5\\] as in the input leads to the following scenario:\n \nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be \\[3, 5, 1, 4\\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n**Example 2:**\n\n**Input:** n = 9, cuts = \\[5,6,1,4,2\\]\n**Output:** 22\n**Explanation:** If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order \\[4, 6, 5, 2, 1\\] has total cost = 22 which is the minimum possible.\n\n**Constraints:**\n\n*   `2 <= n <= 106`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   All the integers in `cuts` array are **distinct**.\"\"\"\n\n    starting_cities = set()\n    \n    for path in paths:\n        starting_cities.add(path[0])\n\n    for path in paths:\n        if path[1] not in starting_cities:\n            return path[1]\n\n    return \"\""}}, "leetcode/leetcode_1665.txt": {"score": 0.9161994457244873, "content": {"text": "def minimumEffort(tasks):\n    \"\"\"You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n\n*   `actuali` is the actual amount of energy you **spend to finish** the `ith` task.\n*   `minimumi` is the minimum amount of energy you **require to begin** the `ith` task.\n\nFor example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n\nYou can finish the tasks in **any order** you like.\n\nReturn _the **minimum** initial amount of energy you will need_ _to finish all the tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[4,8\\]\\]\n**Output:** 8\n**Explanation:**\nStarting with 8 energy, we finish the tasks in the following order:\n    - 3rd task. Now energy = 8 - 4 = 4.\n    - 2nd task. Now energy = 4 - 2 = 2.\n    - 1st task. Now energy = 2 - 1 = 1.\nNotice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3\\],\\[2,4\\],\\[10,11\\],\\[10,12\\],\\[8,9\\]\\]\n**Output:** 32\n**Explanation:**\nStarting with 32 energy, we finish the tasks in the following order:\n    - 1st task. Now energy = 32 - 1 = 31.\n    - 2nd task. Now energy = 31 - 2 = 29.\n    - 3rd task. Now energy = 29 - 10 = 19.\n    - 4th task. Now energy = 19 - 10 = 9.\n    - 5th task. Now energy = 9 - 8 = 1.\n\n**Example 3:**\n\n**Input:** tasks = \\[\\[1,7\\],\\[2,8\\],\\[3,9\\],\\[4,10\\],\\[5,11\\],\\[6,12\\]\\]\n**Output:** 27\n**Explanation:**\nStarting with 27 energy, we finish the tasks in the following order:\n    - 5th task. Now energy = 27 - 5 = 22.\n    - 2nd task. Now energy = 22 - 2 = 20.\n    - 3rd task. Now energy = 20 - 3 = 17.\n    - 1st task. Now energy = 17 - 1 = 16.\n    - 4th task. Now energy = 16 - 4 = 12.\n    - 6th task. Now energy = 12 - 6 = 6.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= actual\u200bi <= minimumi <= 104`\"\"\"\n\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n    ans, sum_energy = 0, 0\n    for task in tasks:\n        ans = max(ans, sum_energy + task[1])\n        sum_energy += task[0]\n    return ans"}}, "leetcode/leetcode_1000.txt": {"score": 0.9353924989700317, "content": {"text": "def min_deletion_size(strs):\n    \"\"\"There are `n` piles of `stones` arranged in a row. The `ith` pile has `stones[i]` stones.\n\nA move consists of merging exactly `k` **consecutive** piles into one pile, and the cost of this move is equal to the total number of stones in these `k` piles.\n\nReturn _the minimum cost to merge all piles of stones into one pile_. If it is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 2\n**Output:** 20\n**Explanation:** We start with \\[3, 2, 4, 1\\].\nWe merge \\[3, 2\\] for a cost of 5, and we are left with \\[5, 4, 1\\].\nWe merge \\[4, 1\\] for a cost of 5, and we are left with \\[5, 5\\].\nWe merge \\[5, 5\\] for a cost of 10, and we are left with \\[10\\].\nThe total cost was 20, and this is the minimum possible.\n\n**Example 2:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 3\n**Output:** -1\n**Explanation:** After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n\n**Example 3:**\n\n**Input:** stones = \\[3,5,1,2,6\\], k = 3\n**Output:** 25\n**Explanation:** We start with \\[3, 5, 1, 2, 6\\].\nWe merge \\[5, 1, 2\\] for a cost of 8, and we are left with \\[3, 8, 6\\].\nWe merge \\[3, 8, 6\\] for a cost of 17, and we are left with \\[17\\].\nThe total cost was 25, and this is the minimum possible.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `1 <= n <= 30`\n*   `1 <= stones[i] <= 100`\n*   `2 <= k <= 30`\"\"\"\n\n    rows, cols = len(strs), len(strs[0])\n    count = 0\n    for c in range(cols):\n        for r in range(1, rows):\n            if strs[r - 1][c] > strs[r][c]:\n                count += 1\n                break\n    return count"}}}}, "69": {"gold": {"leetcode/leetcode_2064.txt": 1}, "retrieved": {"leetcode/leetcode_1499.txt": {"score": 0.9344871640205383, "content": {"text": "import heapq\n    \"\"\"You are given an array `points` containing the coordinates of points on a 2D plane, sorted by the x-values, where `points[i] = [xi, yi]` such that `xi < xj` for all `1 <= i < j <= points.length`. You are also given an integer `k`.\n\nReturn _the maximum value of the equation_ `yi + yj + |xi - xj|` where `|xi - xj| <= k` and `1 <= i < j <= points.length`.\n\nIt is guaranteed that there exists at least one pair of points that satisfy the constraint `|xi - xj| <= k`.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,3\\],\\[2,0\\],\\[5,10\\],\\[6,-10\\]\\], k = 1\n**Output:** 4\n**Explanation:** The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\nNo other pairs satisfy the condition, so we return the max of 4 and 1.\n\n**Example 2:**\n\n**Input:** points = \\[\\[0,0\\],\\[3,0\\],\\[9,2\\]\\], k = 3\n**Output:** 3\n**Explanation:** Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.\n\n**Constraints:**\n\n*   `2 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `-108 <= xi, yi <= 108`\n*   `0 <= k <= 2 * 108`\n*   `xi < xj` for all `1 <= i < j <= points.length`\n*   `xi` form a strictly increasing sequence.\"\"\"\n\n\ndef max_performance(n, k, speed, efficiency):\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n\n    result = 0\n    sum_speed = 0\n    min_heap = []\n    for e, s in engineers:\n        if len(min_heap) >= k:\n            sum_speed -= heapq.heappop(min_heap)\n\n        heapq.heappush(min_heap, s)\n        sum_speed += s\n        result = max(result, e * sum_speed)\n\n    return result % (10**9 + 7)"}}, "leetcode/leetcode_2064.txt": {"score": 0.9377191066741943, "content": {"text": "def minimum_maximum(n, quantities):\n    \"\"\"You are given an integer `n` indicating there are `n` specialty retail stores. There are `m` product types of varying amounts, which are given as a **0-indexed** integer array `quantities`, where `quantities[i]` represents the number of products of the `ith` product type.\n\nYou need to distribute **all products** to the retail stores following these rules:\n\n*   A store can only be given **at most one product type** but can be given **any** amount of it.\n*   After distribution, each store will have been given some number of products (possibly `0`). Let `x` represent the maximum number of products given to any store. You want `x` to be as small as possible, i.e., you want to **minimize** the **maximum** number of products that are given to any store.\n\nReturn _the minimum possible_ `x`.\n\n**Example 1:**\n\n**Input:** n = 6, quantities = \\[11,6\\]\n**Output:** 3\n**Explanation:** One optimal way is:\n- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3\n- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3\nThe maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.\n\n**Example 2:**\n\n**Input:** n = 7, quantities = \\[15,10,10\\]\n**Output:** 5\n**Explanation:** One optimal way is:\n- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5\n- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5\n- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5\nThe maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.\n\n**Example 3:**\n\n**Input:** n = 1, quantities = \\[100000\\]\n**Output:** 100000\n**Explanation:** The only optimal way is:\n- The 100000 products of type 0 are distributed to the only store.\nThe maximum number of products given to any store is max(100000) = 100000.\n\n**Constraints:**\n\n*   `m == quantities.length`\n*   `1 <= m <= n <= 105`\n*   `1 <= quantities[i] <= 105`\"\"\"\n\n    sum_products = sum(quantities)\n    x = (sum_products + n - 1) // n\n    remaining_stores = n\n    for q in quantities:\n        remaining_stores -= (q + x - 1) // x\n        if remaining_stores < 0:\n            x = (sum_products + remaining_stores) // (n + remaining_stores)\n            remaining_stores = n\n    return x"}}, "leetcode/leetcode_1723.txt": {"score": 0.9366878271102905, "content": {"text": "def max_achievable_requests(n, requests, idx=0, counts=None):\n    \"\"\"You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`\"\"\"\n\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)"}}, "leetcode/leetcode_2528.txt": {"score": 0.9387243390083313, "content": {"text": "def max_min_power(stations, r, k):\n    \"\"\"You are given a **0-indexed** integer array `stations` of length `n`, where `stations[i]` represents the number of power stations in the `ith` city.\n\nEach power station can provide power to every city in a fixed **range**. In other words, if the range is denoted by `r`, then a power station at city `i` can provide power to all cities `j` such that `|i - j| <= r` and `0 <= i, j <= n - 1`.\n\n*   Note that `|x|` denotes **absolute** value. For example, `|7 - 5| = 2` and `|3 - 10| = 7`.\n\nThe **power** of a city is the total number of power stations it is being provided power from.\n\nThe government has sanctioned building `k` more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\n\nGiven the two integers `r` and `k`, return _the **maximum possible minimum power** of a city, if the additional power stations are built optimally._\n\n**Note** that you can build the `k` power stations in multiple cities.\n\n**Example 1:**\n\n**Input:** stations = \\[1,2,4,5,0\\], r = 1, k = 2\n**Output:** 5\n**Explanation:** \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become \\[1,4,4,5,0\\].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.\n\n**Example 2:**\n\n**Input:** stations = \\[4,4,4,4\\], r = 0, k = 3\n**Output:** 4\n**Explanation:** \nIt can be proved that we cannot make the minimum power of a city greater than 4.\n\n**Constraints:**\n\n*   `n == stations.length`\n*   `1 <= n <= 105`\n*   `0 <= stations[i] <= 105`\n*   `0 <= r <= n - 1`\n*   `0 <= k <= 109`\"\"\"\n\n    n = len(stations)\n    total_power = [0] * n\n    for i in range(n):\n        for j in range(max(0, i - r), min(n, i + r + 1)):\n            total_power[j] += stations[i]\n\n    sumk = 0\n    min_power = float('inf')\n    for i in range(r, n - r):\n        sumk += stations[i]\n        min_power = min(min_power, total_power[i])\n\n    for j in range(2 * r):\n        i = n - 2 * r - 1 - j\n        sumk -= stations[i + r + 1]\n        min_power -= stations[j]\n        min_power += sumk\n        min_power += k\n        min_power = min(min_power, total_power[j])\n\n    return min_power"}}, "leetcode/leetcode_561.txt": {"score": 0.9450616240501404, "content": {"text": "def array_pair_sum(nums):\n    \"\"\"Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is **maximized**. Return _the maximized sum_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,4,3,2\\]\n**Output:** 4\n**Explanation:** All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\n\n**Example 2:**\n\n**Input:** nums = \\[6,2,6,5,1,2\\]\n**Output:** 9\n**Explanation:** The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `nums.length == 2 * n`\n*   `-104 <= nums[i] <= 104`\"\"\"\n\n    nums.sort()\n    return sum(nums[::2])"}}, "leetcode/leetcode_2560.txt": {"score": 0.9379931688308716, "content": {"text": "def minimumCapability(nums, k):\n    \"\"\"There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he **refuses to steal from adjacent homes**.\n\nThe **capability** of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\n\nYou are given an integer array `nums` representing how much money is stashed in each house. More formally, the `ith` house from the left has `nums[i]` dollars.\n\nYou are also given an integer `k`, representing the **minimum** number of houses the robber will steal from. It is always possible to steal at least `k` houses.\n\nReturn _the **minimum** capability of the robber out of all the possible ways to steal at least_ `k` _houses_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,5,9\\], k = 2\n**Output:** 5\n**Explanation:** \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums\\[0\\], nums\\[2\\]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums\\[0\\], nums\\[3\\]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums\\[1\\], nums\\[3\\]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\], k = 2\n**Output:** 2\n**Explanation:** There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums\\[0\\], nums\\[4\\]) = 2.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `1 <= k <= (nums.length + 1)/2`\"\"\"\n\n    n, l, r = len(nums), 1, 10**9\n    while l < r:\n        mid = l + (r - l) // 2\n        i, cnt = 0, 0\n        for j in range(n):\n            if nums[j] <= mid:\n                cnt += 1\n                i = j + 2\n                while i + 1 < n and (i == j + 1 or nums[i] > mid):\n                    i += 1\n        if cnt < k:\n            l = mid + 1\n        else:\n            r = mid\n    return l"}}, "leetcode/leetcode_1877.txt": {"score": 0.9396243691444397, "content": {"text": "def minPairSum(nums):\n    \"\"\"The **pair sum** of a pair `(a,b)` is equal to `a + b`. The **maximum pair sum** is the largest **pair sum** in a list of pairs.\n\n*   For example, if we have pairs `(1,5)`, `(2,3)`, and `(4,4)`, the **maximum pair sum** would be `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`.\n\nGiven an array `nums` of **even** length `n`, pair up the elements of `nums` into `n / 2` pairs such that:\n\n*   Each element of `nums` is in **exactly one** pair, and\n*   The **maximum pair sum** is **minimized**.\n\nReturn _the minimized **maximum pair sum** after optimally pairing up the elements_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,5,2,3\\]\n**Output:** 7\n**Explanation:** The elements can be paired up into pairs (3,3) and (5,2).\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\n\n**Example 2:**\n\n**Input:** nums = \\[3,5,4,2,4,6\\]\n**Output:** 8\n**Explanation:** The elements can be paired up into pairs (3,5), (4,4), and (6,2).\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 105`\n*   `n` is **even**.\n*   `1 <= nums[i] <= 105`\"\"\"\n\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums) // 2):\n        max_sum = max(max_sum, nums[i] + nums[-1 - i])\n    return max_sum"}}, "leetcode/leetcode_1984.txt": {"score": 0.9480199217796326, "content": {"text": "def max_distance(nums1, nums2):\n    \"\"\"You are given a **0-indexed** integer array `nums`, where `nums[i]` represents the score of the `ith` student. You are also given an integer `k`.\n\nPick the scores of any `k` students from the array so that the **difference** between the **highest** and the **lowest** of the `k` scores is **minimized**.\n\nReturn _the **minimum** possible difference_.\n\n**Example 1:**\n\n**Input:** nums = \\[90\\], k = 1\n**Output:** 0\n**Explanation:** There is one way to pick score(s) of one student:\n- \\[**90**\\]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\n\n**Example 2:**\n\n**Input:** nums = \\[9,4,1,7\\], k = 2\n**Output:** 2\n**Explanation:** There are six ways to pick score(s) of two students:\n- \\[**9**,**4**,1,7\\]. The difference between the highest and lowest score is 9 - 4 = 5.\n- \\[**9**,4,**1**,7\\]. The difference between the highest and lowest score is 9 - 1 = 8.\n- \\[**9**,4,1,**7**\\]. The difference between the highest and lowest score is 9 - 7 = 2.\n- \\[9,**4**,**1**,7\\]. The difference between the highest and lowest score is 4 - 1 = 3.\n- \\[9,**4**,1,**7**\\]. The difference between the highest and lowest score is 7 - 4 = 3.\n- \\[9,4,**1**,**7**\\]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 1000`\n*   `0 <= nums[i] <= 105`\"\"\"\n\n    i, j, max_dist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if i <= j and nums1[i] <= nums2[j]:\n            max_dist = max(max_dist, j - i)\n            j += 1\n        else:\n            i += 1\n    return max_dist"}}, "leetcode/leetcode_2517.txt": {"score": 0.956113874912262, "content": {"text": "def max_tastiness(price, k):\n    \"\"\"You are given an array of positive integers `price` where `price[i]` denotes the price of the `ith` candy and a positive integer `k`.\n\nThe store sells baskets of `k` **distinct** candies. The **tastiness** of a candy basket is the smallest absolute difference of the **prices** of any two candies in the basket.\n\nReturn _the **maximum** tastiness of a candy basket._\n\n**Example 1:**\n\n**Input:** price = \\[13,5,1,8,21,2\\], k = 3\n**Output:** 8\n**Explanation:** Choose the candies with the prices \\[13,5,21\\].\nThe tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\nIt can be proven that 8 is the maximum tastiness that can be achieved.\n\n**Example 2:**\n\n**Input:** price = \\[1,3,1\\], k = 2\n**Output:** 2\n**Explanation:** Choose the candies with the prices \\[1,3\\].\nThe tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\nIt can be proven that 2 is the maximum tastiness that can be achieved.\n\n**Example 3:**\n\n**Input:** price = \\[7,7,7,7\\], k = 2\n**Output:** 0\n**Explanation:** Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n\n**Constraints:**\n\n*   `2 <= k <= price.length <= 105`\n*   `1 <= price[i] <= 109`\"\"\"\n\n    price.sort()\n    max_tastiness = 0\n    for i in range(len(price) - k + 1):\n        min_diff = float('inf')\n        for j in range(i, i + k - 1):\n            min_diff = min(min_diff, price[j + 1] - price[j])\n        max_tastiness = max(max_tastiness, min_diff)\n\n    return max_tastiness"}}, "leetcode/leetcode_1552.txt": {"score": 0.9742651581764221, "content": {"text": "def build_array(target, n):\n    \"\"\"In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has `n` empty baskets, the `ith` basket is at `position[i]`, Morty has `m` balls and needs to distribute the balls into the baskets such that the **minimum magnetic force** between any two balls is **maximum**.\n\nRick stated that magnetic force between two different balls at positions `x` and `y` is `|x - y|`.\n\nGiven the integer array `position` and the integer `m`. Return _the required force_.\n\n**Example 1:**\n\n**Input:** position = \\[1,2,3,4,7\\], m = 3\n**Output:** 3\n**Explanation:** Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs \\[3, 3, 6\\]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n\n**Example 2:**\n\n**Input:** position = \\[5,4,3,2,1,1000000000\\], m = 2\n**Output:** 999999999\n**Explanation:** We can use baskets 1 and 1000000000.\n\n**Constraints:**\n\n*   `n == position.length`\n*   `2 <= n <= 105`\n*   `1 <= position[i] <= 109`\n*   All integers in `position` are **distinct**.\n*   `2 <= m <= position.length`\"\"\"\n\n    result = []\n    current = 1\n    for num in target:\n        while current < num:\n            result.append(\"Push\")\n            result.append(\"Pop\")\n            current += 1\n        result.append(\"Push\")\n        current += 1\n    return result"}}}}, "70": {"gold": {"leetcode/leetcode_2556.txt": 1}, "retrieved": {"leetcode/leetcode_1091.txt": {"score": 0.9179675579071045, "content": {"text": "from collections import deque\n    \"\"\"Given an `n x n` binary matrix `grid`, return _the length of the shortest **clear path** in the matrix_. If there is no clear path, return `-1`.\n\nA **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell (i.e., `(n - 1, n - 1)`) such that:\n\n*   All the visited cells of the path are `0`.\n*   All the adjacent cells of the path are **8-directionally** connected (i.e., they are different and they share an edge or a corner).\n\nThe **length of a clear path** is the number of visited cells of this path.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0,0\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** -1\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 100`\n*   `grid[i][j] is 0 or 1`\"\"\"\n\n\ndef shortestPathBinaryMatrix(grid):\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]: return -1\n\n    dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    q = deque([(0, 0)])\n    grid[0][0] = 1\n\n    pathLength = 1\n\n    while q:\n        qlen = len(q)\n        for _ in range(qlen):\n            x, y = q.popleft()\n\n            if x == n - 1 and y == n - 1: return pathLength\n\n            for d in dir:\n                newX, newY = x + d[0], y + d[1]\n\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    q.append((newX, newY))\n                    grid[newX][newY] = 1\n        pathLength += 1\n\n    return -1"}}, "leetcode/leetcode_2493.txt": {"score": 0.9204540252685547, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"You are given a positive integer `n` representing the number of nodes in an **undirected** graph. The nodes are labeled from `1` to `n`.\n\nYou are also given a 2D integer array `edges`, where `edges[i] = [ai, bi]` indicates that there is a **bidirectional** edge between nodes `ai` and `bi`. **Notice** that the given graph may be disconnected.\n\nDivide the nodes of the graph into `m` groups (**1-indexed**) such that:\n\n*   Each node in the graph belongs to exactly one group.\n*   For every pair of nodes in the graph that are connected by an edge `[ai, bi]`, if `ai` belongs to the group with index `x`, and `bi` belongs to the group with index `y`, then `|y - x| = 1`.\n\nReturn _the maximum number of groups (i.e., maximum_ `m`_) into which you can divide the nodes_. Return `-1` _if it is impossible to group the nodes with the given conditions_.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[1,2\\],\\[1,4\\],\\[1,5\\],\\[2,6\\],\\[2,3\\],\\[4,6\\]\\]\n**Output:** 4\n**Explanation:** As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1\n**Explanation:** If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible.\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n*   `1 <= edges.length <= 104`\n*   `edges[i].length == 2`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   There is at most one edge between any pair of vertices.\"\"\"\n\n\ndef maxGroups(n, edges):\n    graph = defaultdict(list)\n    color = [0] * (n + 1)\n\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    max_group = 0\n    for i in range(1, n + 1):\n        if color[i] == 0:\n            q = deque([i])\n            color[i] = 1\n            while q:\n                node = q.popleft()\n                max_group = max(max_group, color[node])\n                for neighbor in graph[node]:\n                    if color[neighbor] == 0:\n                        color[neighbor] = color[node] + 1\n                        q.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return -1\n                        \n    return max_group"}}, "leetcode/leetcode_695.txt": {"score": 0.9214721918106079, "content": {"text": "def maxAreaOfIsland(grid):\n    \"\"\"You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is the number of cells with a value `1` in the island.\n\nReturn _the maximum **area** of an island in_ `grid`. If there is no island, return `0`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,1,0,0,0,0,1,0,0,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,1,1,0,1,0,0,0,0,0,0,0,0\\],\\[0,1,0,0,1,1,0,0,1,0,1,0,0\\],\\[0,1,0,0,1,1,0,0,1,1,1,0,0\\],\\[0,0,0,0,0,0,0,0,0,0,1,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,0,0,0,0\\]\\]\n**Output:** 6\n**Explanation:** The answer is not 11, because the island must be connected 4-directionally.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            return 0\n        grid[i][j] = 0\n        return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                max_area = max(max_area, dfs(i, j))\n    return max_area"}}, "leetcode/leetcode_749.txt": {"score": 0.9277503490447998, "content": {"text": "def shortest_completing_word(license_plate, words):\n    \"\"\"A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as an `m x n` binary grid `isInfected`, where `isInfected[i][j] == 0` represents uninfected cells, and `isInfected[i][j] == 1` represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two **4-directionally** adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There **will never be a tie**.\n\nReturn _the number of walls used to quarantine all the infected regions_. If the world will become fully infected, return the number of walls used.\n\n**Example 1:**\n\n**Input:** isInfected = \\[\\[0,1,0,0,0,0,0,1\\],\\[0,1,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 10\n**Explanation:** There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n \nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n \n\n**Example 2:**\n\n**Input:** isInfected = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 4\n**Explanation:** Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n**Example 3:**\n\n**Input:** isInfected = \\[\\[1,1,1,0,0,0,0,0,0\\],\\[1,0,1,0,1,1,1,1,1\\],\\[1,1,1,0,0,0,0,0,0\\]\\]\n**Output:** 13\n**Explanation:** The region on the left only builds two new walls.\n\n**Constraints:**\n\n*   `m == isInfected.length`\n*   `n == isInfected[i].length`\n*   `1 <= m, n <= 50`\n*   `isInfected[i][j]` is either `0` or `1`.\n*   There is always a contiguous viral region throughout the described process that will **infect strictly more uncontaminated squares** in the next round.\"\"\"\n\n    target = [0] * 26\n    for c in license_plate:\n        if c.isalpha():\n            target[ord(c.lower()) - ord('a')] += 1\n\n    result = \"\"\n    for word in words:\n        current = [0] * 26\n        for c in word:\n            if c.isalpha():\n                current[ord(c.lower()) - ord('a')] += 1\n\n        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):\n            result = word\n\n    return result"}}, "leetcode/leetcode_934.txt": {"score": 0.9351921677589417, "content": {"text": "def subarrayBitwiseORs(arr: List[int]) -> int:\n    \"\"\"You are given an `n x n` binary matrix `grid` where `1` represents land and `0` represents water.\n\nAn **island** is a 4-directionally connected group of `1`'s not connected to any other `1`'s. There are **exactly two islands** in `grid`.\n\nYou may change `0`'s to `1`'s to connect the two islands to form **one island**.\n\nReturn _the smallest number of_ `0`_'s you must flip to connect the two islands_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 1\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,0\\],\\[0,0,0\\],\\[0,0,1\\]\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1,1\\],\\[1,0,0,0,1\\],\\[1,0,1,0,1\\],\\[1,0,0,0,1\\],\\[1,1,1,1,1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `2 <= n <= 100`\n*   `grid[i][j]` is either `0` or `1`.\n*   There are exactly two islands in `grid`.\"\"\"\n\n    result, current, temp = set(), set(), set()\n    for num in arr:\n        temp = {num}\n        for c in current:\n            temp.add(num | c)\n        current = temp\n        result |= current\n    return len(result)"}}, "leetcode/leetcode_1368.txt": {"score": 0.927562952041626, "content": {"text": "from collections import deque\n    \"\"\"Given an `m x n` grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:\n\n*   `1` which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)\n*   `2` which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)\n*   `3` which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)\n*   `4` which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\n\nYou will initially start at the upper left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path does not have to be the shortest.\n\nYou can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell **one time only**.\n\nReturn _the minimum cost to make the grid have at least one valid path_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1,1\\],\\[2,2,2,2\\],\\[1,1,1,1\\],\\[2,2,2,2\\]\\]\n**Output:** 3\n**Explanation:** You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,3\\],\\[3,2,2\\],\\[1,1,4\\]\\]\n**Output:** 0\n**Explanation:** You can follow the path from (0, 0) to (2, 2).\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,2\\],\\[4,3\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `1 <= grid[i][j] <= 4`\"\"\"\n\n\ndef minCost(grid):\n    m, n = len(grid), len(grid[0])\n    cost = 0\n\n    visited = [[1000000] * n for _ in range(m)]\n    q = deque([(0, 0)])\n    visited[0][0] = 0\n\n    while q:\n        y, x = q.popleft()\n        if y == m - 1 and x == n - 1:\n            cost = visited[y][x]\n            break\n\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n\n        for dir in range(4):\n            newY, newX = y + dy[dir], x + dx[dir]\n            if 0 <= newY < m and 0 <= newX < n:\n                newCost = visited[y][x] + (1 if dir + 1 != grid[y][x] else 0)\n                if newCost < visited[newY][newX]:\n                    visited[newY][newX] = newCost\n                    q.append((newY, newX))\n\n    return cost"}}, "leetcode/leetcode_1020.txt": {"score": 0.9299387335777283, "content": {"text": "def maxTurbulenceSize(arr):\n    \"\"\"You are given an `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell.\n\nA **move** consists of walking from one land cell to another adjacent (**4-directionally**) land cell or walking off the boundary of the `grid`.\n\nReturn _the number of land cells in_ `grid` _for which we cannot walk off the boundary of the grid in any number of **moves**_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[1,0,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 0\n**Explanation:** All 1s are either on the boundary or can reach the boundary.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\n\nFor i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is odd, and arr\\[k\\] < arr\\[k + 1\\] when k is even. OR For i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is even, and arr\\[k\\] < arr\\[k + 1\\] when k is odd.\"\"\"\n\n    n = len(arr)\n    result = 1\n    i = 0\n\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 1\n            continue\n\n        j = i + 1\n        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):\n            j += 1\n        \n        result = max(result, j - i + 1)\n        i = j\n\n    return result"}}, "leetcode/leetcode_827.txt": {"score": 0.933952808380127, "content": {"text": "def maxAreaOfIsland(grid):\n    \"\"\"You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`.\n\nReturn _the size of the largest **island** in_ `grid` _after applying this operation_.\n\nAn **island** is a 4-directionally connected group of `1`s.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** 3\n**Explanation:** Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** 4\n**Explanation:** Change the 0 to 1 and make the island bigger, only one island with area = 4.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** 4\n**Explanation:** Can't change any 0 to 1, only one island with area = 4.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    def dfs(x, y):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:\n            return 0\n        grid[x][y] = 0\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1\n\n    ans = 0\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 0:\n                grid[i][j] = 1\n                ans = max(ans, dfs(i, j))\n                grid[i][j] = 0\n    return ans"}}, "leetcode/leetcode_2556.txt": {"score": 0.954484224319458, "content": {"text": "def canReach(grid, row, col):\n    \"\"\"You are given a **0-indexed** `m x n` **binary** matrix `grid`. You can move from a cell `(row, col)` to any of the cells `(row + 1, col)` or `(row, col + 1)` that has the value `1`. The matrix is **disconnected** if there is no path from `(0, 0)` to `(m - 1, n - 1)`.\n\nYou can flip the value of **at most one** (possibly none) cell. You **cannot flip** the cells `(0, 0)` and `(m - 1, n - 1)`.\n\nReturn `true` _if it is possible to make the matrix disconnect or_ `false` _otherwise_.\n\n**Note** that flipping a cell changes its value from `0` to `1` or from `1` to `0`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,0,0\\],\\[1,1,1\\]\\]\n**Output:** true\n**Explanation:** We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** false\n**Explanation:** It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `grid[i][j]` is either `0` or `1`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 1`\"\"\"\n\n    if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] == 0:\n        return False\n\n    if row == len(grid) - 1 and col == len(grid[0]) - 1:\n        return True\n\n    grid[row][col] = 0\n\n    return canReach(grid, row + 1, col) or canReach(grid, row, col + 1)\n\ndef canDisconnect(grid):\n    reachableCount = 0\n\n    for row in range(1, len(grid)):\n        for col in range(1, len(grid[0])):\n            if grid[row][col] == 1 and (canReach(grid, row - 1, col) or canReach(grid, row, col - 1)):\n                reachableCount += 1\n                if reachableCount > 1:\n                    return True\n\n    return reachableCount <= 1"}}, "leetcode/leetcode_1568.txt": {"score": 0.9597071409225464, "content": {"text": "def pseudoPalindromicPaths(root, cnt = 0):\n    \"\"\"You are given an `m x n` binary grid `grid` where `1` represents land and `0` represents water. An **island** is a maximal **4-directionally** (horizontal or vertical) connected group of `1`'s.\n\nThe grid is said to be **connected** if we have **exactly one island**, otherwise is said **disconnected**.\n\nIn one day, we are allowed to change **any** single land cell `(1)` into a water cell `(0)`.\n\nReturn _the minimum number of days to disconnect the grid_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n\n**Output:** 2\n**Explanation:** We need at least 2 days to get a disconnected grid.\nChange land grid\\[1\\]\\[1\\] and grid\\[0\\]\\[2\\] to water and get 2 disconnected island.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\]\\]\n**Output:** 2\n**Explanation:** Grid of full water is also disconnected (\\[\\[1,1\\]\\] -> \\[\\[0,0\\]\\]), 0 islands.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    if not root:\n        return 0\n    cnt ^= 1 << (root.val - 1)\n    if not root.left and not root.right:\n        return (cnt & (cnt - 1)) == 0\n    return pseudoPalindromicPaths(root.left, cnt) + pseudoPalindromicPaths(root.right, cnt)"}}}}, "71": {"gold": {"leetcode/leetcode_664.txt": 1, "leetcode/leetcode_2360.txt": 1}, "retrieved": {"leetcode/leetcode_1496.txt": {"score": 0.9034095406532288, "content": {"text": "def lucky_numbers(matrix):\n    \"\"\"Given a string `path`, where `path[i] = 'N'`, `'S'`, `'E'` or `'W'`, each representing moving one unit north, south, east, or west, respectively. You start at the origin `(0, 0)` on a 2D plane and walk on the path specified by `path`.\n\nReturn `true` _if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited_. Return `false` otherwise.\n\n**Example 1:**\n\n**Input:** path =  \"NES \"\n**Output:** false \n**Explanation:** Notice that the path doesn't cross any point more than once.\n\n**Example 2:**\n\n**Input:** path =  \"NESWW \"\n**Output:** true\n**Explanation:** Notice that the path visits the origin twice.\n\n**Constraints:**\n\n*   `1 <= path.length <= 104`\n*   `path[i]` is either `'N'`, `'S'`, `'E'`, or `'W'`.\"\"\"\n\n    m, n = len(matrix), len(matrix[0])\n    lucky_numbers = []\n\n    for i in range(m):\n        min_row = min(matrix[i])\n        min_row_idx = matrix[i].index(min_row)\n        is_lucky = all(matrix[k][min_row_idx] <= min_row for k in range(m))\n\n        if is_lucky:\n            lucky_numbers.append(min_row)\n\n    return lucky_numbers"}}, "leetcode/leetcode_1970.txt": {"score": 0.9075517654418945, "content": {"text": "def sort_sentence(s: str) -> str:\n    \"\"\"There is a **1-based** binary matrix where `0` represents land and `1` represents water. You are given integers `row` and `col` representing the number of rows and columns in the matrix, respectively.\n\nInitially on day `0`, the **entire** matrix is **land**. However, each day a new cell becomes flooded with **water**. You are given a **1-based** 2D array `cells`, where `cells[i] = [ri, ci]` represents that on the `ith` day, the cell on the `rith` row and `cith` column (**1-based** coordinates) will be covered with **water** (i.e., changed to `1`).\n\nYou want to find the **last** day that it is possible to walk from the **top** to the **bottom** by only walking on land cells. You can start from **any** cell in the top row and end at **any** cell in the bottom row. You can only travel in the **four** cardinal directions (left, right, up, and down).\n\nReturn _the **last** day where it is possible to walk from the **top** to the **bottom** by only walking on land cells_.\n\n**Example 1:**\n\n**Input:** row = 2, col = 2, cells = \\[\\[1,1\\],\\[2,1\\],\\[1,2\\],\\[2,2\\]\\]\n**Output:** 2\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n**Example 2:**\n\n**Input:** row = 2, col = 2, cells = \\[\\[1,1\\],\\[1,2\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:** 1\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n**Example 3:**\n\n**Input:** row = 3, col = 3, cells = \\[\\[1,2\\],\\[2,1\\],\\[3,3\\],\\[2,2\\],\\[1,1\\],\\[1,3\\],\\[2,3\\],\\[3,2\\],\\[3,1\\]\\]\n**Output:** 3\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3.\n\n**Constraints:**\n\n*   `2 <= row, col <= 2 * 104`\n*   `4 <= row * col <= 2 * 104`\n*   `cells.length == row * col`\n*   `1 <= ri <= row`\n*   `1 <= ci <= col`\n*   All the values of `cells` are **unique**.\"\"\"\n\n    tokens = s.split()\n    words = [''] * len(tokens)\n    \n    for token in tokens:\n        pos = int(token[-1]) - 1\n        words[pos] = token[:-1]\n    \n    return ' '.join(words)"}}, "leetcode/leetcode_2257.txt": {"score": 0.9042590260505676, "content": {"text": "def earliest_blooming_day(plant_time, grow_time):\n    \"\"\"You are given two integers `m` and `n` representing a **0-indexed** `m x n` grid. You are also given two 2D integer arrays `guards` and `walls` where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `ith` guard and `jth` wall respectively.\n\nA guard can see **every** cell in the four cardinal directions (north, east, south, or west) starting from their position unless **obstructed** by a wall or another guard. A cell is **guarded** if there is **at least** one guard that can see it.\n\nReturn _the number of unoccupied cells that are **not** **guarded**._\n\n**Example 1:**\n\n**Input:** m = 4, n = 6, guards = \\[\\[0,0\\],\\[1,1\\],\\[2,3\\]\\], walls = \\[\\[0,1\\],\\[2,2\\],\\[1,4\\]\\]\n**Output:** 7\n**Explanation:** The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\n**Example 2:**\n\n**Input:** m = 3, n = 3, guards = \\[\\[1,1\\]\\], walls = \\[\\[0,1\\],\\[1,0\\],\\[2,1\\],\\[1,2\\]\\]\n**Output:** 4\n**Explanation:** The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\n**Constraints:**\n\n*   `1 <= m, n <= 105`\n*   `2 <= m * n <= 105`\n*   `1 <= guards.length, walls.length <= 5 * 104`\n*   `2 <= guards.length + walls.length <= m * n`\n*   `guards[i].length == walls[j].length == 2`\n*   `0 <= rowi, rowj < m`\n*   `0 <= coli, colj < n`\n*   All the positions in `guards` and `walls` are **unique**.\"\"\"\n\n    bloom_time = [plant_time[i] + grow_time[i] for i in range(len(plant_time))]\n    bloom_time.sort()\n    earliest_day = 0\n    for i in bloom_time:\n        earliest_day = max(earliest_day, i)\n        earliest_day += 1\n    return earliest_day"}}, "leetcode/leetcode_419.txt": {"score": 0.9077045917510986, "content": {"text": "def countBattleships(board):\n    \"\"\"Given an `m x n` matrix `board` where each cell is a battleship `'X'` or empty `'.'`, return _the number of the **battleships** on_ `board`.\n\n**Battleships** can only be placed horizontally or vertically on `board`. In other words, they can only be made of the shape `1 x k` (`1` row, `k` columns) or `k x 1` (`k` rows, `1` column), where `k` can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"X \", \". \", \". \", \"X \"\\],\\[ \". \", \". \", \". \", \"X \"\\],\\[ \". \", \". \", \". \", \"X \"\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \". \"\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 200`\n*   `board[i][j]` is either `'.'` or `'X'`.\n\n**Follow up:** Could you do it in one-pass, using only `O(1)` extra memory and without modifying the values `board`?\"\"\"\n\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count"}}, "leetcode/leetcode_864.txt": {"score": 0.9089667797088623, "content": {"text": "def largestOverlap(img1, img2):\n    \"\"\"You are given an `m x n` grid `grid` where:\n\n*   `'.'` is an empty cell.\n*   `'#'` is a wall.\n*   `'@'` is the starting point.\n*   Lowercase letters represent keys.\n*   Uppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n\nFor some `1 <= k <= 6`, there is exactly one lowercase and one uppercase letter of the first `k` letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n\nReturn _the lowest number of moves to acquire all keys_. If it is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \"@.a.. \", \"###.# \", \"b.A.B \"\\]\n**Output:** 8\n**Explanation:** Note that the goal is to obtain all the keys not to open all the locks.\n\n**Example 2:**\n\n**Input:** grid = \\[ \"@..aA \", \"..B#. \", \"....b \"\\]\n**Output:** 6\n\n**Example 3:**\n\n**Input:** grid = \\[ \"@Aa \"\\]\n**Output:** -1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either an English letter, `'.'`, `'#'`, or `'@'`.\n*   The number of keys in the grid is in the range `[1, 6]`.\n*   Each key in the grid is **unique**.\n*   Each key in the grid has a matching lock.\"\"\"\n\n    n = len(img1)\n    onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]\n    onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]\n\n    overlaps = {}\n    for pt1 in onesImg1:\n        for pt2 in onesImg2:\n            dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1]\n            key = (dx, dy)\n            if key not in overlaps:\n                overlaps[key] = 0\n            overlaps[key] += 1\n\n    return max(overlaps.values() or [0])"}}, "leetcode/leetcode_2201.txt": {"score": 0.9153805375099182, "content": {"text": "def arrange_pairs(pairs):\n    \"\"\"There is an `n x n` **0-indexed** grid with some artifacts buried in it. You are given the integer `n` and a **0-indexed** 2D integer array `artifacts` describing the positions of the rectangular artifacts where `artifacts[i] = [r1i, c1i, r2i, c2i]` denotes that the `ith` artifact is buried in the subgrid where:\n\n*   `(r1i, c1i)` is the coordinate of the **top-left** cell of the `ith` artifact and\n*   `(r2i, c2i)` is the coordinate of the **bottom-right** cell of the `ith` artifact.\n\nYou will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.\n\nGiven a **0-indexed** 2D integer array `dig` where `dig[i] = [ri, ci]` indicates that you will excavate the cell `(ri, ci)`, return _the number of artifacts that you can extract_.\n\nThe test cases are generated such that:\n\n*   No two artifacts overlap.\n*   Each artifact only covers at most `4` cells.\n*   The entries of `dig` are unique.\n\n**Example 1:**\n\n**Input:** n = 2, artifacts = \\[\\[0,0,0,0\\],\\[0,1,1,1\\]\\], dig = \\[\\[0,0\\],\\[0,1\\]\\]\n**Output:** 1\n**Explanation:** \nThe different colors represent different artifacts. Excavated cells are labeled with a 'D' in the grid.\nThere is 1 artifact that can be extracted, namely the red artifact.\nThe blue artifact has one part in cell (1,1) which remains uncovered, so we cannot extract it.\nThus, we return 1.\n\n**Example 2:**\n\n**Input:** n = 2, artifacts = \\[\\[0,0,0,0\\],\\[0,1,1,1\\]\\], dig = \\[\\[0,0\\],\\[0,1\\],\\[1,1\\]\\]\n**Output:** 2\n**Explanation:** Both the red and blue artifacts have all parts uncovered (labeled with a 'D') and can be extracted, so we return 2. \n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `1 <= artifacts.length, dig.length <= min(n2, 105)`\n*   `artifacts[i].length == 4`\n*   `dig[i].length == 2`\n*   `0 <= r1i, c1i, r2i, c2i, ri, ci <= n - 1`\n*   `r1i <= r2i`\n*   `c1i <= c2i`\n*   No two artifacts will overlap.\n*   The number of cells covered by an artifact is **at most** `4`.\n*   The entries of `dig` are unique.\"\"\"\n\n    adj = {pair[0]: pair for pair in pairs}\n    result = []\n    start = pairs[0][0]\n\n    while adj:\n        pair = adj.pop(start)\n        result.append(pair)\n        start = pair[1]\n\n    return result"}}, "leetcode/leetcode_782.txt": {"score": 0.908024251461029, "content": {"text": "def numJewelsInStones(jewels, stones):\n    \"\"\"You are given an `n x n` binary grid `board`. In each move, you can swap any two rows with each other, or any two columns with each other.\n\nReturn _the minimum number of moves to transform the board into a **chessboard board**_. If the task is impossible, return `-1`.\n\nA **chessboard board** is a board where no `0`'s and no `1`'s are 4-directionally adjacent.\n\n**Example 1:**\n\n**Input:** board = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[1,0,0,1\\],\\[1,0,0,1\\]\\]\n**Output:** 2\n**Explanation:** One potential sequence of moves is shown.\nThe first move swaps the first and second column.\nThe second move swaps the second and third row.\n\n**Example 2:**\n\n**Input:** board = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 0\n**Explanation:** Also note that the board with 0 in the top left corner, is also a valid chessboard.\n\n**Example 3:**\n\n**Input:** board = \\[\\[1,0\\],\\[1,0\\]\\]\n**Output:** -1\n**Explanation:** No matter what sequence of moves you make, you cannot end with a valid chessboard.\n\n**Constraints:**\n\n*   `n == board.length`\n*   `n == board[i].length`\n*   `2 <= n <= 30`\n*   `board[i][j]` is either `0` or `1`.\"\"\"\n\n    count = 0\n    for s in stones:\n        if s in jewels:\n            count += 1\n    return count"}}, "leetcode/leetcode_1591.txt": {"score": 0.9948551654815674, "content": {"text": "def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    \"\"\"There is a strange printer with the following two special requirements:\n\n*   On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n*   Once the printer has used a color for the above operation, **the same color cannot be used again**.\n\nYou are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid.\n\nReturn `true` _if it is possible to print the matrix_ `targetGrid`_,_ _otherwise, return_ `false`.\n\n**Example 1:**\n\n**Input:** targetGrid = \\[\\[1,1,1,1\\],\\[1,2,2,1\\],\\[1,2,2,1\\],\\[1,1,1,1\\]\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** targetGrid = \\[\\[1,1,1,1\\],\\[1,1,3,3\\],\\[1,1,3,4\\],\\[5,5,1,4\\]\\]\n**Output:** true\n\n**Example 3:**\n\n**Input:** targetGrid = \\[\\[1,2,1\\],\\[2,1,2\\],\\[1,2,1\\]\\]\n**Output:** false\n**Explanation:** It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n\n**Constraints:**\n\n*   `m == targetGrid.length`\n*   `n == targetGrid[i].length`\n*   `1 <= m, n <= 60`\n*   `1 <= targetGrid[row][col] <= 60`\"\"\"\n\n    color_bounds = {}\n    m, n = len(targetGrid), len(targetGrid[0])\n\n    for i in range(m):\n        for j in range(n):\n            color = targetGrid[i][j]\n            if color not in color_bounds:\n                color_bounds[color] = [i, j, i, j]\n            else:\n                color_bounds[color][0] = min(color_bounds[color][0], i)\n                color_bounds[color][1] = min(color_bounds[color][1], j)\n                color_bounds[color][2] = max(color_bounds[color][2], i)\n                color_bounds[color][3] = max(color_bounds[color][3], j)\n\n    remaining_colors = set(color_bounds.keys())\n    while remaining_colors:\n        progress = False\n        to_remove = set()\n        for color in remaining_colors:\n            bounds = color_bounds[color]\n            contained = all(targetGrid[i][j] == color or targetGrid[i][j] == -1\n                        for i in range(bounds[0], bounds[2] + 1)\n                        for j in range(bounds[1], bounds[3] + 1))\n            if contained:\n                for i in range(bounds[0], bounds[2] + 1):\n                    for j in range(bounds[1], bounds[3] + 1):\n                        targetGrid[i][j] = -1\n                to_remove.add(color)\n                progress = True\n\n        remaining_colors -= to_remove\n        if not progress:\n            return False\n\n    return True"}}, "leetcode/leetcode_1284.txt": {"score": 0.9096477627754211, "content": {"text": "def sum_of_divisors_with_four_divisors(nums):\n    \"\"\"Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing `1` to `0` and `0` to `1`). A pair of cells are called neighbors if they share one edge.\n\nReturn the _minimum number of steps_ required to convert `mat` to a zero matrix or `-1` if you cannot.\n\nA **binary matrix** is a matrix with all cells equal to `0` or `1` only.\n\nA **zero matrix** is a matrix with all cells equal to `0`.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[0,0\\],\\[0,1\\]\\]\n**Output:** 3\n**Explanation:** One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n\n**Example 2:**\n\n**Input:** mat = \\[\\[0\\]\\]\n**Output:** 0\n**Explanation:** Given matrix is a zero matrix. We do not need to change it.\n\n**Example 3:**\n\n**Input:** mat = \\[\\[1,0,0\\],\\[1,0,0\\]\\]\n**Output:** -1\n**Explanation:** Given matrix cannot be a zero matrix.\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 3`\n*   `mat[i][j]` is either `0` or `1`.\"\"\"\n\n    total_sum = 0\n\n    for num in nums:\n        div_count = 0\n        div_sum = 0\n\n        for i in range(1, int(num ** 0.5) + 1):\n            if num % i == 0:\n                div_sum += i\n                div_count += 1\n\n                if num // i != i:\n                    div_sum += num // i\n                    div_count += 1\n\n            if div_count > 4:\n                break\n\n        if div_count == 4:\n            total_sum += div_sum\n\n    return total_sum"}}, "leetcode/leetcode_2132.txt": {"score": 0.9426242113113403, "content": {"text": "def construct2DArray(original, m, n):\n    \"\"\"You are given an `m x n` binary matrix `grid` where each cell is either `0` (empty) or `1` (occupied).\n\nYou are then given stamps of size `stampHeight x stampWidth`. We want to fit the stamps such that they follow the given **restrictions** and **requirements**:\n\n1.  Cover all the **empty** cells.\n2.  Do not cover any of the **occupied** cells.\n3.  We can put as **many** stamps as we want.\n4.  Stamps can **overlap** with each other.\n5.  Stamps are not allowed to be **rotated**.\n6.  Stamps must stay completely **inside** the grid.\n\nReturn `true` _if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return_ `false`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[1,0,0,0\\],\\[1,0,0,0\\],\\[1,0,0,0\\],\\[1,0,0,0\\]\\], stampHeight = 4, stampWidth = 3\n**Output:** true\n**Explanation:** We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,1,0,0\\],\\[0,0,1,0\\],\\[0,0,0,1\\]\\], stampHeight = 2, stampWidth = 2 \n**Output:** false \n**Explanation:** There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[r].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 2 * 105`\n*   `grid[r][c]` is either `0` or `1`.\n*   `1 <= stampHeight, stampWidth <= 105`\"\"\"\n\n    if m * n != len(original): return []\n    res = [[0] * n for _ in range(m)]\n    for i in range(len(original)):\n        res[i // n][i % n] = original[i]\n    return res"}}}}, "72": {"gold": {"leetcode/leetcode_682.txt": 1, "leetcode/leetcode_844.txt": 1}, "retrieved": {"leetcode/leetcode_1233.txt": {"score": 0.8578363060951233, "content": {"text": "from typing import List\n    \"\"\"Given a list of folders `folder`, return _the folders after removing all **sub-folders** in those folders_. You may return the answer in **any order**.\n\nIf a `folder[i]` is located within another `folder[j]`, it is called a **sub-folder** of it.\n\nThe format of a path is one or more concatenated strings of the form: `'/'` followed by one or more lowercase English letters.\n\n*   For example, `\"/leetcode \"` and `\"/leetcode/problems \"` are valid paths while an empty string and `\"/ \"` are not.\n\n**Example 1:**\n\n**Input:** folder = \\[ \"/a \", \"/a/b \", \"/c/d \", \"/c/d/e \", \"/c/f \"\\]\n**Output:** \\[ \"/a \", \"/c/d \", \"/c/f \"\\]\n**Explanation:** Folders  \"/a/b \" is a subfolder of  \"/a \" and  \"/c/d/e \" is inside of folder  \"/c/d \" in our filesystem.\n\n**Example 2:**\n\n**Input:** folder = \\[ \"/a \", \"/a/b/c \", \"/a/b/d \"\\]\n**Output:** \\[ \"/a \"\\]\n**Explanation:** Folders  \"/a/b/c \" and  \"/a/b/d \" will be removed because they are subfolders of  \"/a \".\n\n**Example 3:**\n\n**Input:** folder = \\[ \"/a/b/c \", \"/a/b/ca \", \"/a/b/d \"\\]\n**Output:** \\[ \"/a/b/c \", \"/a/b/ca \", \"/a/b/d \"\\]\n\n**Constraints:**\n\n*   `1 <= folder.length <= 4 * 104`\n*   `2 <= folder[i].length <= 100`\n*   `folder[i]` contains only lowercase letters and `'/'`.\n*   `folder[i]` always starts with the character `'/'`.\n*   Each folder name is **unique**.\"\"\"\n\n\ndef removeSubfolders(folder: List[str]) -> List[str]:\n    result = []\n    folder.sort()\n    prefix = \"/\"\n    \n    for path in folder:\n        if not path.startswith(prefix):\n            result.append(path)\n            prefix = path + \"/\"\n    return result"}}, "leetcode/leetcode_946.txt": {"score": 0.8594475984573364, "content": {"text": "def minimum_score(nums, k):\n    \"\"\"Given two integer arrays `pushed` and `popped` each with distinct values, return `true` _if this could have been the result of a sequence of push and pop operations on an initially empty stack, or_ `false` _otherwise._\n\n**Example 1:**\n\n**Input:** pushed = \\[1,2,3,4,5\\], popped = \\[4,5,3,2,1\\]\n**Output:** true\n**Explanation:** We might do the following sequence:\npush(1), push(2), push(3), push(4),\npop() -> 4,\npush(5),\npop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\n**Example 2:**\n\n**Input:** pushed = \\[1,2,3,4,5\\], popped = \\[4,3,5,1,2\\]\n**Output:** false\n**Explanation:** 1 cannot be popped before 2.\n\n**Constraints:**\n\n*   `1 <= pushed.length <= 1000`\n*   `0 <= pushed[i] <= 1000`\n*   All the elements of `pushed` are **unique**.\n*   `popped.length == pushed.length`\n*   `popped` is a permutation of `pushed`.\"\"\"\n\n    nums.sort()\n    n = len(nums)\n    res = nums[n - 1] - nums[0]\n\n    for i in range(n - 1):\n        high = max(nums[i] + k, nums[n - 1] - k)\n        low = min(nums[i + 1] - k, nums[0] + k)\n        res = min(res, high - low)\n\n    return res"}}, "leetcode/leetcode_971.txt": {"score": 0.8592583537101746, "content": {"text": "from collections import deque\n    \"\"\"You are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired** [**pre-order traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order) of the binary tree.\n\nAny node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\nFlip the **smallest** number of nodes so that the **pre-order traversal** of the tree **matches** `voyage`.\n\nReturn _a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the pre-order traversal match_ `voyage`_, return the list_ `[-1]`.\n\n**Example 1:**\n\n**Input:** root = \\[1,2\\], voyage = \\[2,1\\]\n**Output:** \\[-1\\]\n**Explanation:** It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\], voyage = \\[1,3,2\\]\n**Output:** \\[1\\]\n**Explanation:** Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n\n**Example 3:**\n\n**Input:** root = \\[1,2,3\\], voyage = \\[1,2,3\\]\n**Output:** \\[\\]\n**Explanation:** The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `n == voyage.length`\n*   `1 <= n <= 100`\n*   `1 <= Node.val, voyage[i] <= n`\n*   All the values in the tree are **unique**.\n*   All the values in `voyage` are **unique**.\"\"\"\n\n\ndef shortestBridge(grid):\n    n = len(grid)\n    q = deque()\n\n    # Find the first island and mark it\n    for i in range(n):\n        if any(grid[i]):\n            first_row = i\n            first_col = grid[first_row].index(1)\n            break\n\n    dfs(grid, q, first_row, first_col)\n\n    steps = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    while q:\n        for _ in range(len(q)):\n            x, y = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n:\n                    if grid[nx][ny] == 1:\n                        return steps\n                    elif grid[nx][ny] == 0:\n                        grid[nx][ny] = -1\n                        q.append((nx, ny))\n        steps += 1\n    return -1\n\ndef dfs(grid, q, i, j):\n    n = len(grid)\n    if not (0 <= i < n and 0 <= j < n and grid[i][j] == 1):\n        return\n    grid[i][j] = -1\n    q.append((i, j))\n    \n    dfs(grid, q, i - 1, j)\n    dfs(grid, q, i + 1, j)\n    dfs(grid, q, i, j - 1)\n    dfs(grid, q, i, j + 1)"}}, "leetcode/leetcode_1658.txt": {"score": 0.8657467365264893, "content": {"text": "def min_swaps(grid):\n    \"\"\"You are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn _the **minimum number** of operations to reduce_ `x` _to **exactly**_ `0` _if it is possible__, otherwise, return_ `-1`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,4,2,3\\], x = 5\n**Output:** 2\n**Explanation:** The optimal solution is to remove the last two elements to reduce x to zero.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,7,8,9\\], x = 4\n**Output:** -1\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,20,1,1,3\\], x = 10\n**Output:** 5\n**Explanation:** The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`\n*   `1 <= x <= 109`\"\"\"\n\n    n = len(grid)\n    row_zeros = [0] * n\n    \n    for i in range(n):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j] == 0:\n                row_zeros[i] += 1\n            else:\n                break\n    \n    steps = 0\n    for i in range(n):\n        target = n - i - 1\n        current_row = i\n        while current_row < n and row_zeros[current_row] < target:\n            current_row += 1\n        if current_row == n:\n            return -1\n        steps += current_row - i\n        row_zeros.pop(current_row)\n        row_zeros.insert(i, target)\n    \n    return steps"}}, "leetcode/leetcode_1963.txt": {"score": 0.8596278429031372, "content": {"text": "def get_xor_sum(arr1, arr2):\n    \"\"\"You are given a **0-indexed** string `s` of **even** length `n`. The string consists of **exactly** `n / 2` opening brackets `'['` and `n / 2` closing brackets `']'`.\n\nA string is called **balanced** if and only if:\n\n*   It is the empty string, or\n*   It can be written as `AB`, where both `A` and `B` are **balanced** strings, or\n*   It can be written as `[C]`, where `C` is a **balanced** string.\n\nYou may swap the brackets at **any** two indices **any** number of times.\n\nReturn _the **minimum** number of swaps to make_ `s` _**balanced**_.\n\n**Example 1:**\n\n**Input:** s =  \"\\]\\[\\]\\[ \"\n**Output:** 1\n**Explanation:** You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is  \"\\[\\[\\]\\] \".\n\n**Example 2:**\n\n**Input:** s =  \"\\]\\]\\]\\[\\[\\[ \"\n**Output:** 2\n**Explanation:** You can do the following to make the string balanced:\n- Swap index 0 with index 4. s =  \"\\[\\]\\]\\[\\]\\[ \".\n- Swap index 1 with index 5. s =  \"\\[\\[\\]\\[\\]\\] \".\nThe resulting string is  \"\\[\\[\\]\\[\\]\\] \".\n\n**Example 3:**\n\n**Input:** s =  \"\\[\\] \"\n**Output:** 0\n**Explanation:** The string is already balanced.\n\n**Constraints:**\n\n*   `n == s.length`\n*   `2 <= n <= 106`\n*   `n` is even.\n*   `s[i]` is either `'['` or `']'`.\n*   The number of opening brackets `'['` equals `n / 2`, and the number of closing brackets `']'` equals `n / 2`.\"\"\"\n\n    xor_arr1 = xor_arr2 = 0\n    for i in arr1:\n        xor_arr1 ^= i\n    for j in arr2:\n        xor_arr2 ^= j\n    return xor_arr1 & xor_arr2"}}, "leetcode/leetcode_301.txt": {"score": 0.8598479628562927, "content": {"text": "from collections import deque\n    \"\"\"Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n\nReturn _a list of **unique strings** that are valid with the minimum number of removals_. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** s =  \"()())() \"\n**Output:** \\[ \"(())() \", \"()()() \"\\]\n\n**Example 2:**\n\n**Input:** s =  \"(a)())() \"\n**Output:** \\[ \"(a())() \", \"(a)()() \"\\]\n\n**Example 3:**\n\n**Input:** s =  \")( \"\n**Output:** \\[ \" \"\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 25`\n*   `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n*   There will be at most `20` parentheses in `s`.\"\"\"\n\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        visited = set()\n        queue = deque([s])\n        result = []\n        found = False\n\n        while queue:\n            cur = queue.popleft()\n\n            if self.is_valid(cur):\n                found = True\n                result.append(cur)\n\n            if found: continue\n\n            for i in range(len(cur)):\n                if cur[i] == '(' or cur[i] == ')':\n                    next_str = cur[:i] + cur[i+1:]\n                    if next_str not in visited:\n                        visited.add(next_str)\n                        queue.append(next_str)\n\n        return result\n\n    def is_valid(self, s: str) -> bool:\n        count = 0\n        for c in s:\n            if c == '(': count += 1\n            if c == ')':\n                count -= 1\n                if count < 0: return False\n        return count == 0"}}, "leetcode/leetcode_979.txt": {"score": 0.8628761172294617, "content": {"text": "def decode_permutation(s: str):\n    \"\"\"You are given the `root` of a binary tree with `n` nodes where each `node` in the tree has `node.val` coins. There are `n` coins in total throughout the whole tree.\n\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\n\nReturn _the **minimum** number of moves required to make every node have **exactly** one coin_.\n\n**Example 1:**\n\n**Input:** root = \\[3,0,0\\]\n**Output:** 2\n**Explanation:** From the root of the tree, we move one coin to its left child, and one coin to its right child.\n\n**Example 2:**\n\n**Input:** root = \\[0,3,0\\]\n**Output:** 3\n**Explanation:** From the left child of the root, we move two coins to the root \\[taking two moves\\]. Then, we move one coin from the root of the tree to the right child.\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= n <= 100`\n*   `0 <= Node.val <= n`\n*   The sum of all `Node.val` is `n`.\"\"\"\n\n    n = len(s)\n    perm = [0] * (n + 1)\n    next_zero, next_one = 0, n\n\n    for c in s:\n        if c == '0':\n            perm[next_zero] = next_one\n            next_zero += 1\n            next_one -= 1\n        else:\n            perm[next_one] = next_zero\n            next_one -= 1\n            next_zero += 1\n\n    perm[next_zero] = next_one\n    return perm"}}, "leetcode/leetcode_1298.txt": {"score": 0.8696252703666687, "content": {"text": "def reverseParentheses(s: str) -> str:\n    \"\"\"You have `n` boxes labeled from `0` to `n - 1`. You are given four arrays: `status`, `candies`, `keys`, and `containedBoxes` where:\n\n*   `status[i]` is `1` if the `ith` box is open and `0` if the `ith` box is closed,\n*   `candies[i]` is the number of candies in the `ith` box,\n*   `keys[i]` is a list of the labels of the boxes you can open after opening the `ith` box.\n*   `containedBoxes[i]` is a list of the boxes you found inside the `ith` box.\n\nYou are given an integer array `initialBoxes` that contains the labels of the boxes you initially have. You can take all the candies in **any open box** and you can use the keys in it to open new boxes and you also can use the boxes you find in it.\n\nReturn _the maximum number of candies you can get following the rules above_.\n\n**Example 1:**\n\n**Input:** status = \\[1,0,1,0\\], candies = \\[7,5,4,100\\], keys = \\[\\[\\],\\[\\],\\[1\\],\\[\\]\\], containedBoxes = \\[\\[1,2\\],\\[3\\],\\[\\],\\[\\]\\], initialBoxes = \\[0\\]\n**Output:** 16\n**Explanation:** You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.\nBox 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.\nIn box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.\nTotal number of candies collected = 7 + 4 + 5 = 16 candy.\n\n**Example 2:**\n\n**Input:** status = \\[1,0,0,0,0,0\\], candies = \\[1,1,1,1,1,1\\], keys = \\[\\[1,2,3,4,5\\],\\[\\],\\[\\],\\[\\],\\[\\],\\[\\]\\], containedBoxes = \\[\\[1,2,3,4,5\\],\\[\\],\\[\\],\\[\\],\\[\\],\\[\\]\\], initialBoxes = \\[0\\]\n**Output:** 6\n**Explanation:** You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys.\nThe total number of candies will be 6.\n\n**Constraints:**\n\n*   `n == status.length == candies.length == keys.length == containedBoxes.length`\n*   `1 <= n <= 1000`\n*   `status[i]` is either `0` or `1`.\n*   `1 <= candies[i] <= 1000`\n*   `0 <= keys[i].length <= n`\n*   `0 <= keys[i][j] < n`\n*   All values of `keys[i]` are **unique**.\n*   `0 <= containedBoxes[i].length <= n`\n*   `0 <= containedBoxes[i][j] < n`\n*   All values of `containedBoxes[i]` are unique.\n*   Each box is contained in one box at most.\n*   `0 <= initialBoxes.length <= n`\n*   `0 <= initialBoxes[i] < n`\"\"\"\n\n    st = []\n    result = []\n\n    for c in s:\n        if c != ')':\n            st.append(c)\n        else:\n            temp = []\n            while st and st[-1] != '(':\n                temp.append(st.pop())\n            if st: st.pop()  # Remove '('\n            st.extend(temp)\n\n    result = \"\".join(st)\n    return result"}}, "leetcode/leetcode_2390.txt": {"score": 0.8668816089630127, "content": {"text": "def remove_stars(s: str) -> str:\n    \"\"\"You are given a string `s`, which contains stars `*`.\n\nIn one operation, you can:\n\n*   Choose a star in `s`.\n*   Remove the closest **non-star** character to its **left**, as well as remove the star itself.\n\nReturn _the string after **all** stars have been removed_.\n\n**Note:**\n\n*   The input will be generated such that the operation is always possible.\n*   It can be shown that the resulting string will always be unique.\n\n**Example 1:**\n\n**Input:** s =  \"leet\\*\\*cod\\*e \"\n**Output:**  \"lecoe \"\n**Explanation:** Performing the removals from left to right:\n- The closest character to the 1st star is 't' in  \"lee**t**\\*\\*cod\\*e \". s becomes  \"lee\\*cod\\*e \".\n- The closest character to the 2nd star is 'e' in  \"le**e**\\*cod\\*e \". s becomes  \"lecod\\*e \".\n- The closest character to the 3rd star is 'd' in  \"leco**d**\\*e \". s becomes  \"lecoe \".\nThere are no more stars, so we return  \"lecoe \".\n\n**Example 2:**\n\n**Input:** s =  \"erase\\*\\*\\*\\*\\* \"\n**Output:**  \" \"\n**Explanation:** The entire string is removed, so we return an empty string.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters and stars `*`.\n*   The operation above can be performed on `s`.\"\"\"\n\n    result = []\n    for c in s:\n        if c == '*':\n            if result:\n                result.pop()\n        else:\n            result.append(c)\n    return ''.join(result)"}}, "leetcode/leetcode_1598.txt": {"score": 0.9973626732826233, "content": {"text": "def minOperations(logs):\n    \"\"\"The Leetcode file system keeps a log each time some user performs a _change folder_ operation.\n\nThe operations are described below:\n\n*   `\"../ \"` : Move to the parent folder of the current folder. (If you are already in the main folder, **remain in the same folder**).\n*   `\"./ \"` : Remain in the same folder.\n*   `\"x/ \"` : Move to the child folder named `x` (This folder is **guaranteed to always exist**).\n\nYou are given a list of strings `logs` where `logs[i]` is the operation performed by the user at the `ith` step.\n\nThe file system starts in the main folder, then the operations in `logs` are performed.\n\nReturn _the minimum number of operations needed to go back to the main folder after the change folder operations._\n\n**Example 1:**\n\n**Input:** logs = \\[ \"d1/ \", \"d2/ \", \"../ \", \"d21/ \", \"./ \"\\]\n**Output:** 2\n**Explanation:** Use this change folder operation  \"../ \" 2 times and go back to the main folder.\n\n**Example 2:**\n\n**Input:** logs = \\[ \"d1/ \", \"d2/ \", \"./ \", \"d3/ \", \"../ \", \"d31/ \"\\]\n**Output:** 3\n\n**Example 3:**\n\n**Input:** logs = \\[ \"d1/ \", \"../ \", \"../ \", \"../ \"\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= logs.length <= 103`\n*   `2 <= logs[i].length <= 10`\n*   `logs[i]` contains lowercase English letters, digits, `'.'`, and `'/'`.\n*   `logs[i]` follows the format described in the statement.\n*   Folder names consist of lowercase English letters and digits.\"\"\"\n\n    depth = 0\n    for log in logs:\n        if log == \"../\":\n            depth = max(0, depth - 1)\n        elif log != \"./\":\n            depth += 1\n    return depth"}}}}, "73": {"gold": {"leetcode/leetcode_778.txt": 1}, "retrieved": {"leetcode/leetcode_1986.txt": {"score": 0.9119762182235718, "content": {"text": "from collections import defaultdict\n    \"\"\"There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break.\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n*   If you start a task in a work session, you must complete it in the **same** work session.\n*   You can start a new task **immediately** after finishing the previous one.\n*   You may complete the tasks in **any order**.\n\nGiven `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._\n\nThe tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,3\\], sessionTime = 3\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n**Example 2:**\n\n**Input:** tasks = \\[3,1,3,1,1\\], sessionTime = 8\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n**Example 3:**\n\n**Input:** tasks = \\[1,2,3,4,5\\], sessionTime = 15\n**Output:** 1\n**Explanation:** You can finish all the tasks in one work session.\n\n**Constraints:**\n\n*   `n == tasks.length`\n*   `1 <= n <= 14`\n*   `1 <= tasks[i] <= 10`\n*   `max(tasks[i]) <= sessionTime <= 15`\"\"\"\n\n\n\ndef largestPathValue(colors, edges):\n    def dfs(node):\n        if not cache[node][ord(colors[node]) - ord('a')]:\n            cache[node][ord(colors[node]) - ord('a')] = 1\n            for neighbor in graph[node]:\n                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],\n                                                               1 + dfs(neighbor))\n        return cache[node][ord(colors[node]) - ord('a')]\n\n    n = len(colors)\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n\n    cache = [[0] * 26 for _ in range(n)]\n    in_degree = [0] * n\n    for a, b in edges:\n        in_degree[b] += 1\n    res = -1\n    for i in range(n):\n        if in_degree[i] == 0:\n            res = max(res, dfs(i))\n    return res"}}, "leetcode/leetcode_2017.txt": {"score": 0.9159321188926697, "content": {"text": "def min_operations(s):\n    \"\"\"You are given a **0-indexed** 2D array `grid` of size `2 x n`, where `grid[r][c]` represents the number of points at position `(r, c)` on the matrix. Two robots are playing a game on this matrix.\n\nBoth robots initially start at `(0, 0)` and want to reach `(1, n-1)`. Each robot may only move to the **right** (`(r, c)` to `(r, c + 1)`) or **down** (`(r, c)` to `(r + 1, c)`).\n\nAt the start of the game, the **first** robot moves from `(0, 0)` to `(1, n-1)`, collecting all the points from the cells on its path. For all cells `(r, c)` traversed on the path, `grid[r][c]` is set to `0`. Then, the **second** robot moves from `(0, 0)` to `(1, n-1)`, collecting the points on its path. Note that their paths may intersect with one another.\n\nThe **first** robot wants to **minimize** the number of points collected by the **second** robot. In contrast, the **second** robot wants to **maximize** the number of points it collects. If both robots play **optimally**, return _the **number of points** collected by the **second** robot._\n\n**Example 1:**\n\n**Input:** grid = \\[\\[2,5,4\\],\\[1,5,1\\]\\]\n**Output:** 4\n**Explanation:** The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[3,3,1\\],\\[8,5,2\\]\\]\n**Output:** 4\n**Explanation:** The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,3,1,15\\],\\[1,3,3,1\\]\\]\n**Output:** 7\n**Explanation:** The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.\n\n**Constraints:**\n\n*   `grid.length == 2`\n*   `n == grid[r].length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= grid[r][c] <= 105`\"\"\"\n\n    cnt = 0\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            cnt += 1\n    return cnt"}}, "leetcode/leetcode_1824.txt": {"score": 0.9135275483131409, "content": {"text": "import heapq\n    \"\"\"There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** lane and wants to jump to point `n`. However, there could be obstacles along the way.\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n*   For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n*   For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn _the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n**Example 1:**\n\n**Input:** obstacles = \\[0,1,2,3,0\\]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n**Example 2:**\n\n**Input:** obstacles = \\[0,1,1,3,3,0\\]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n**Example 3:**\n\n**Input:** obstacles = \\[0,2,1,0,3,0\\]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n**Constraints:**\n\n*   `obstacles.length == n + 1`\n*   `1 <= n <= 5 * 105`\n*   `0 <= obstacles[i] <= 3`\n*   `obstacles[0] == obstacles[n] == 0`\"\"\"\n\n\ndef eatenApples(apples, days):\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans"}}, "leetcode/leetcode_2498.txt": {"score": 0.9316208958625793, "content": {"text": "def minimum_path_cost(stones):\n    \"\"\"You are given a **0-indexed** integer array `stones` sorted in **strictly increasing order** representing the positions of stones in a river.\n\nA frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone **at most once**.\n\nThe **length** of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.\n\n*   More formally, if the frog is at `stones[i]` and is jumping to `stones[j]`, the length of the jump is `|stones[i] - stones[j]|`.\n\nThe **cost** of a path is the **maximum length of a jump** among all jumps in the path.\n\nReturn _the **minimum** cost of a path for the frog_.\n\n**Example 1:**\n\n**Input:** stones = \\[0,2,5,6,7\\]\n**Output:** 5\n**Explanation:** The above figure represents one of the optimal paths the frog can take.\nThe cost of this path is 5, which is the maximum length of a jump.\nSince it is not possible to achieve a cost of less than 5, we return it.\n\n**Example 2:**\n\n**Input:** stones = \\[0,3,9\\]\n**Output:** 9\n**Explanation:** \nThe frog can jump directly to the last stone and come back to the first stone. \nIn this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.\nIt can be shown that this is the minimum achievable cost.\n\n**Constraints:**\n\n*   `2 <= stones.length <= 105`\n*   `0 <= stones[i] <= 109`\n*   `stones[0] == 0`\n*   `stones` is sorted in a strictly increasing order.\"\"\"\n\n    n = len(stones)\n    max_cost = stones[n-1]\n    for i in range(1, n-1):\n        max_cost = min(max_cost, max(stones[i], stones[n-1]-stones[i]))\n    return max_cost"}}, "leetcode/leetcode_2383.txt": {"score": 0.9171720743179321, "content": {"text": "def min_training_hours(initial_energy, initial_experience, energy, experience):\n    \"\"\"You are entering a competition, and are given two **positive** integers `initialEnergy` and `initialExperience` denoting your initial energy and initial experience respectively.\n\nYou are also given two **0-indexed** integer arrays `energy` and `experience`, both of length `n`.\n\nYou will face `n` opponents **in order**. The energy and experience of the `ith` opponent is denoted by `energy[i]` and `experience[i]` respectively. When you face an opponent, you need to have both **strictly** greater experience and energy to defeat them and move to the next opponent if available.\n\nDefeating the `ith` opponent **increases** your experience by `experience[i]`, but **decreases** your energy by `energy[i]`.\n\nBefore starting the competition, you can train for some number of hours. After each hour of training, you can **either** choose to increase your initial experience by one, or increase your initial energy by one.\n\nReturn _the **minimum** number of training hours required to defeat all_ `n` _opponents_.\n\n**Example 1:**\n\n**Input:** initialEnergy = 5, initialExperience = 3, energy = \\[1,4,3,2\\], experience = \\[2,6,3,1\\]\n**Output:** 8\n**Explanation:** You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0th opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1st opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2nd opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3rd opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists.\n\n**Example 2:**\n\n**Input:** initialEnergy = 2, initialExperience = 4, energy = \\[1\\], experience = \\[3\\]\n**Output:** 0\n**Explanation:** You do not need any additional energy or experience to win the competition, so we return 0.\n\n**Constraints:**\n\n*   `n == energy.length == experience.length`\n*   `1 <= n <= 100`\n*   `1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100`\"\"\"\n\n    n = len(energy)\n    ans = int(1e9)\n    for exp_gain in range(initial_energy + initial_experience + 1):\n        training_hours = exp_gain\n        energy_left = initial_energy - exp_gain\n        curr_experience = initial_experience + exp_gain\n        \n        for i in range(n):\n            while curr_experience <= experience[i] or energy_left <= energy[i]:\n                energy_left -= 1\n                training_hours += 1\n            energy_left -= energy[i]\n            curr_experience += experience[i]\n        ans = min(ans, training_hours)\n    return ans"}}, "leetcode/leetcode_2304.txt": {"score": 0.9189847111701965, "content": {"text": "def excel_sheet_cells(s: str):\n    \"\"\"You are given a **0-indexed** `m x n` integer matrix `grid` consisting of **distinct** integers from `0` to `m * n - 1`. You can move in this matrix from a cell to any other cell in the **next** row. That is, if you are in cell `(x, y)` such that `x < m - 1`, you can move to any of the cells `(x + 1, 0)`, `(x + 1, 1)`, ..., `(x + 1, n - 1)`. **Note** that it is not possible to move from cells in the last row.\n\nEach possible move has a cost given by a **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row. The cost of moving from cells in the last row of `grid` can be ignored.\n\nThe cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made. Return _the **minimum** cost of a path that starts from any cell in the **first** row and ends at any cell in the **last** row._\n\n**Example 1:**\n\n**Input:** grid = \\[\\[5,3\\],\\[4,0\\],\\[2,1\\]\\], moveCost = \\[\\[9,8\\],\\[1,5\\],\\[10,12\\],\\[18,6\\],\\[2,4\\],\\[14,3\\]\\]\n**Output:** 17\n**Explanation:** The path with the minimum possible cost is the path 5 -> 0 -> 1.\n- The sum of the values of cells visited is 5 + 0 + 1 = 6.\n- The cost of moving from 5 to 0 is 3.\n- The cost of moving from 0 to 1 is 8.\nSo the total cost of the path is 6 + 3 + 8 = 17.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[5,1,2\\],\\[4,0,3\\]\\], moveCost = \\[\\[12,10,15\\],\\[20,23,8\\],\\[21,7,1\\],\\[8,1,13\\],\\[9,10,25\\],\\[5,3,2\\]\\]\n**Output:** 6\n**Explanation:** The path with the minimum possible cost is the path 2 -> 3.\n- The sum of the values of cells visited is 2 + 3 = 5.\n- The cost of moving from 2 to 3 is 1.\nSo the total cost of this path is 5 + 1 = 6.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 50`\n*   `grid` consists of distinct integers from `0` to `m * n - 1`.\n*   `moveCost.length == m * n`\n*   `moveCost[i].length == n`\n*   `1 <= moveCost[i][j] <= 100`\"\"\"\n\n    c1, r1, c2, r2 = s.split(':')\n    r1, r2 = int(r1[1:]), int(r2[1:])\n    c1, c2 = ord(c1[0]), ord(c2[0])\n    result = []\n\n    for c in range(c1, c2 + 1):\n        for r in range(r1, r2 + 1):\n            result.append(chr(c) + str(r))\n\n    return result"}}, "leetcode/leetcode_1665.txt": {"score": 0.9158322215080261, "content": {"text": "def minimumEffort(tasks):\n    \"\"\"You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n\n*   `actuali` is the actual amount of energy you **spend to finish** the `ith` task.\n*   `minimumi` is the minimum amount of energy you **require to begin** the `ith` task.\n\nFor example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n\nYou can finish the tasks in **any order** you like.\n\nReturn _the **minimum** initial amount of energy you will need_ _to finish all the tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[4,8\\]\\]\n**Output:** 8\n**Explanation:**\nStarting with 8 energy, we finish the tasks in the following order:\n    - 3rd task. Now energy = 8 - 4 = 4.\n    - 2nd task. Now energy = 4 - 2 = 2.\n    - 1st task. Now energy = 2 - 1 = 1.\nNotice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3\\],\\[2,4\\],\\[10,11\\],\\[10,12\\],\\[8,9\\]\\]\n**Output:** 32\n**Explanation:**\nStarting with 32 energy, we finish the tasks in the following order:\n    - 1st task. Now energy = 32 - 1 = 31.\n    - 2nd task. Now energy = 31 - 2 = 29.\n    - 3rd task. Now energy = 29 - 10 = 19.\n    - 4th task. Now energy = 19 - 10 = 9.\n    - 5th task. Now energy = 9 - 8 = 1.\n\n**Example 3:**\n\n**Input:** tasks = \\[\\[1,7\\],\\[2,8\\],\\[3,9\\],\\[4,10\\],\\[5,11\\],\\[6,12\\]\\]\n**Output:** 27\n**Explanation:**\nStarting with 27 energy, we finish the tasks in the following order:\n    - 5th task. Now energy = 27 - 5 = 22.\n    - 2nd task. Now energy = 22 - 2 = 20.\n    - 3rd task. Now energy = 20 - 3 = 17.\n    - 1st task. Now energy = 17 - 1 = 16.\n    - 4th task. Now energy = 16 - 4 = 12.\n    - 6th task. Now energy = 12 - 6 = 6.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= actual\u200bi <= minimumi <= 104`\"\"\"\n\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n    ans, sum_energy = 0, 0\n    for task in tasks:\n        ans = max(ans, sum_energy + task[1])\n        sum_energy += task[0]\n    return ans"}}, "leetcode/leetcode_2087.txt": {"score": 0.9397302865982056, "content": {"text": "def minTotalCost(startPos, homePos, rowCosts, colCosts):\n    \"\"\"There is an `m x n` grid, where `(0, 0)` is the top-left cell and `(m - 1, n - 1)` is the bottom-right cell. You are given an integer array `startPos` where `startPos = [startrow, startcol]` indicates that **initially**, a **robot** is at the cell `(startrow, startcol)`. You are also given an integer array `homePos` where `homePos = [homerow, homecol]` indicates that its **home** is at the cell `(homerow, homecol)`.\n\nThe robot needs to go to its home. It can move one cell in four directions: **left**, **right**, **up**, or **down**, and it can not move outside the boundary. Every move incurs some cost. You are further given two **0-indexed** integer arrays: `rowCosts` of length `m` and `colCosts` of length `n`.\n\n*   If the robot moves **up** or **down** into a cell whose **row** is `r`, then this move costs `rowCosts[r]`.\n*   If the robot moves **left** or **right** into a cell whose **column** is `c`, then this move costs `colCosts[c]`.\n\nReturn _the **minimum total cost** for this robot to return home_.\n\n**Example 1:**\n\n**Input:** startPos = \\[1, 0\\], homePos = \\[2, 3\\], rowCosts = \\[5, 4, 3\\], colCosts = \\[8, 2, 6, 7\\]\n**Output:** 18\n**Explanation:** One optimal path is that:\nStarting from (1, 0)\n-> It goes down to (**2**, 0). This move costs rowCosts\\[2\\] = 3.\n-> It goes right to (2, **1**). This move costs colCosts\\[1\\] = 2.\n-> It goes right to (2, **2**). This move costs colCosts\\[2\\] = 6.\n-> It goes right to (2, **3**). This move costs colCosts\\[3\\] = 7.\nThe total cost is 3 + 2 + 6 + 7 = 18\n\n**Example 2:**\n\n**Input:** startPos = \\[0, 0\\], homePos = \\[0, 0\\], rowCosts = \\[5\\], colCosts = \\[26\\]\n**Output:** 0\n**Explanation:** The robot is already at its home. Since no moves occur, the total cost is 0.\n\n**Constraints:**\n\n*   `m == rowCosts.length`\n*   `n == colCosts.length`\n*   `1 <= m, n <= 105`\n*   `0 <= rowCosts[r], colCosts[c] <= 104`\n*   `startPos.length == 2`\n*   `homePos.length == 2`\n*   `0 <= startrow, homerow < m`\n*   `0 <= startcol, homecol < n`\"\"\"\n\n    row_difference = abs(startPos[0] - homePos[0])\n    col_difference = abs(startPos[1] - homePos[1])\n\n    row_cost = sum(rowCosts[min(startPos[0], homePos[0]):min(startPos[0], homePos[0]) + row_difference])\n    col_cost = sum(colCosts[min(startPos[1], homePos[1]):min(startPos[1], homePos[1]) + col_difference])\n\n    return row_cost + col_cost"}}, "leetcode/leetcode_1266.txt": {"score": 0.931690514087677, "content": {"text": "def minTimeToVisitAllPoints(points):\n    \"\"\"On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi, yi]`. Return _the **minimum time** in seconds to visit all the points in the order given by_ `points`.\n\nYou can move according to these rules:\n\n*   In `1` second, you can either:\n    *   move vertically by one unit,\n    *   move horizontally by one unit, or\n    *   move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second).\n*   You have to visit the points in the same order as they appear in the array.\n*   You are allowed to pass through points that appear later in the order, but these do not count as visits.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,4\\],\\[-1,0\\]\\]\n**Output:** 7\n**Explanation:** One optimal path is **\\[1,1\\]** -> \\[2,2\\] -> \\[3,3\\] -> **\\[3,4\\]** \\-> \\[2,3\\] -> \\[1,2\\] -> \\[0,1\\] -> **\\[-1,0\\]**   \nTime from \\[1,1\\] to \\[3,4\\] = 3 seconds \nTime from \\[3,4\\] to \\[-1,0\\] = 4 seconds\nTotal time = 7 seconds\n\n**Example 2:**\n\n**Input:** points = \\[\\[3,2\\],\\[-2,2\\]\\]\n**Output:** 5\n\n**Constraints:**\n\n*   `points.length == n`\n*   `1 <= n <= 100`\n*   `points[i].length == 2`\n*   `-1000 <= points[i][0], points[i][1] <= 1000`\"\"\"\n\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i - 1][0])\n        dy = abs(points[i][1] - points[i - 1][1])\n        time += max(dx, dy)\n    return time"}}, "leetcode/leetcode_1631.txt": {"score": 0.9956524968147278, "content": {"text": "def numOfSubarrays(arr):\n    \"\"\"You are a hiker preparing for an upcoming hike. You are given `heights`, a 2D array of size `rows x columns`, where `heights[row][col]` represents the height of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`, and you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e., **0-indexed**). You can move **up**, **down**, **left**, or **right**, and you wish to find a route that requires the minimum **effort**.\n\nA route's **effort** is the **maximum absolute difference** in heights between two consecutive cells of the route.\n\nReturn _the minimum **effort** required to travel from the top-left cell to the bottom-right cell._\n\n**Example 1:**\n\n**Input:** heights = \\[\\[1,2,2\\],\\[3,8,2\\],\\[5,3,5\\]\\]\n**Output:** 2\n**Explanation:** The route of \\[1,3,5,3,5\\] has a maximum absolute difference of 2 in consecutive cells.\nThis is better than the route of \\[1,2,2,2,5\\], where the maximum absolute difference is 3.\n\n**Example 2:**\n\n**Input:** heights = \\[\\[1,2,3\\],\\[3,8,4\\],\\[5,3,5\\]\\]\n**Output:** 1\n**Explanation:** The route of \\[1,2,3,4,5\\] has a maximum absolute difference of 1 in consecutive cells, which is better than route \\[1,3,5,3,5\\].\n\n**Example 3:**\n\n**Input:** heights = \\[\\[1,2,1,1,1\\],\\[1,2,1,2,1\\],\\[1,2,1,2,1\\],\\[1,2,1,2,1\\],\\[1,1,1,2,1\\]\\]\n**Output:** 0\n**Explanation:** This route does not require any effort.\n\n**Constraints:**\n\n*   `rows == heights.length`\n*   `columns == heights[i].length`\n*   `1 <= rows, columns <= 100`\n*   `1 <= heights[i][j] <= 106`\"\"\"\n\n    odd, even, sum_, result = 0, 1, 0, 0\n    mod = 10**9 + 7\n    for x in arr:\n        sum_ = (sum_ + x) % 2\n        if sum_ % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n        result = (result + odd) % mod\n    return result"}}}}, "74": {"gold": {"leetcode/leetcode_2141.txt": 1}, "retrieved": {"leetcode/leetcode_1705.txt": {"score": 0.9220970869064331, "content": {"text": "def unhappyFriends(n, preferences, pairs):\n    \"\"\"There is a special kind of apple tree that grows apples every day for `n` days. On the `ith` day, the tree grows `apples[i]` apples that will rot after `days[i]` days, that is on day `i + days[i]` the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by `apples[i] == 0` and `days[i] == 0`.\n\nYou decided to eat **at most** one apple a day (to keep the doctors away). Note that you can keep eating after the first `n` days.\n\nGiven two integer arrays `days` and `apples` of length `n`, return _the maximum number of apples you can eat._\n\n**Example 1:**\n\n**Input:** apples = \\[1,2,3,5,2\\], days = \\[3,2,1,4,2\\]\n**Output:** 7\n**Explanation:** You can eat 7 apples:\n- On the first day, you eat an apple that grew on the first day.\n- On the second day, you eat an apple that grew on the second day.\n- On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.\n- On the fourth to the seventh days, you eat apples that grew on the fourth day.\n\n**Example 2:**\n\n**Input:** apples = \\[3,0,0,0,0,2\\], days = \\[3,0,0,0,0,2\\]\n**Output:** 5\n**Explanation:** You can eat 5 apples:\n- On the first to the third day you eat apples that grew on the first day.\n- Do nothing on the fouth and fifth days.\n- On the sixth and seventh days you eat apples that grew on the sixth day.\n\n**Constraints:**\n\n*   `n == apples.length == days.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= apples[i], days[i] <= 2 * 104`\n*   `days[i] = 0` if and only if `apples[i] = 0`.\"\"\"\n\n    pair_mapping = [0] * n\n    for pair in pairs:\n        pair_mapping[pair[0]] = pair[1]\n        pair_mapping[pair[1]] = pair[0]\n\n    unhappy_count = 0\n    for x in range(n):\n        y = pair_mapping[x]\n        pref_x = preferences[x]\n        idx_y = pref_x.index(y)\n\n        for i in range(idx_y):\n            u = pref_x[i]\n            v = pair_mapping[u]\n            pref_u = preferences[u]\n            if x in pref_u[:pref_u.index(v)]:\n                unhappy_count += 1\n                break\n\n    return unhappy_count // 2"}}, "leetcode/leetcode_1770.txt": {"score": 0.9224609732627869, "content": {"text": "def min_deletions(s):\n    \"\"\"You are given two **0-indexed** integer arrays `nums` and `multipliers` of size `n` and `m` respectively, where `n >= m`.\n\nYou begin with a score of `0`. You want to perform **exactly** `m` operations. On the `ith` operation (**0-indexed**) you will:\n\n*   Choose one integer `x` from **either the start or the end** of the array `nums`.\n*   Add `multipliers[i] * x` to your score.\n    *   Note that `multipliers[0]` corresponds to the first operation, `multipliers[1]` to the second operation, and so on.\n*   Remove `x` from `nums`.\n\nReturn _the **maximum** score after performing_ `m` _operations._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], multipliers = \\[3,2,1\\]\n**Output:** 14\n**Explanation:** An optimal solution is as follows:\n- Choose from the end, \\[1,2,**3**\\], adding 3 \\* 3 = 9 to the score.\n- Choose from the end, \\[1,**2**\\], adding 2 \\* 2 = 4 to the score.\n- Choose from the end, \\[**1**\\], adding 1 \\* 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14.\n\n**Example 2:**\n\n**Input:** nums = \\[-5,-3,-3,-2,7,1\\], multipliers = \\[-10,-5,3,4,6\\]\n**Output:** 102\n**Explanation:** An optimal solution is as follows:\n- Choose from the start, \\[**\\-5**,-3,-3,-2,7,1\\], adding -5 \\* -10 = 50 to the score.\n- Choose from the start, \\[**\\-3**,-3,-2,7,1\\], adding -3 \\* -5 = 15 to the score.\n- Choose from the start, \\[**\\-3**,-2,7,1\\], adding -3 \\* 3 = -9 to the score.\n- Choose from the end, \\[-2,7,**1**\\], adding 1 \\* 4 = 4 to the score.\n- Choose from the end, \\[-2,**7**\\], adding 7 \\* 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `m == multipliers.length`\n*   `1 <= m <= 300`\n*   `m <= n <= 105`\n*   `-1000 <= nums[i], multipliers[i] <= 1000`\"\"\"\n\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions"}}, "leetcode/leetcode_857.txt": {"score": 0.9254915714263916, "content": {"text": "def largeGroupPositions(s: str):\n    \"\"\"There are `n` workers. You are given two integer arrays `quality` and `wage` where `quality[i]` is the quality of the `ith` worker and `wage[i]` is the minimum wage expectation for the `ith` worker.\n\nWe want to hire exactly `k` workers to form a paid group. To hire a group of `k` workers, we must pay them according to the following rules:\n\n1.  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2.  Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer `k`, return _the least amount of money needed to form a paid group satisfying the above conditions_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** quality = \\[10,20,5\\], wage = \\[70,50,30\\], k = 2\n**Output:** 105.00000\n**Explanation:** We pay 70 to 0th worker and 35 to 2nd worker.\n\n**Example 2:**\n\n**Input:** quality = \\[3,1,10,10,1\\], wage = \\[4,8,2,2,7\\], k = 3\n**Output:** 30.66667\n**Explanation:** We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.\n\n**Constraints:**\n\n*   `n == quality.length == wage.length`\n*   `1 <= k <= n <= 104`\n*   `1 <= quality[i], wage[i] <= 104`\"\"\"\n\n    result = []\n    start = 0\n    for i in range(1, len(s)):\n        if s[i] != s[start]:\n            if i - start >= 3:\n                result.append([start, i - 1])\n            start = i\n    if len(s) - start >= 3:\n        result.append([start, len(s) - 1])\n    return result"}}, "leetcode/leetcode_2530.txt": {"score": 0.932076096534729, "content": {"text": "import heapq\n    \"\"\"You are given a **0-indexed** integer array `nums` and an integer `k`. You have a **starting score** of `0`.\n\nIn one **operation**:\n\n1.  choose an index `i` such that `0 <= i < nums.length`,\n2.  increase your **score** by `nums[i]`, and\n3.  replace `nums[i]` with `ceil(nums[i] / 3)`.\n\nReturn _the maximum possible **score** you can attain after applying **exactly**_ `k` _operations_.\n\nThe ceiling function `ceil(val)` is the least integer greater than or equal to `val`.\n\n**Example 1:**\n\n**Input:** nums = \\[10,10,10,10,10\\], k = 5\n**Output:** 50\n**Explanation:** Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.\n\n**Example 2:**\n\n**Input:** nums = \\[1,10,3,3,3\\], k = 3\n**Output:** 17\n**Explanation:** You can do the following operations:\nOperation 1: Select i = 1, so nums becomes \\[1,**4**,3,3,3\\]. Your score increases by 10.\nOperation 2: Select i = 1, so nums becomes \\[1,**2**,3,3,3\\]. Your score increases by 4.\nOperation 3: Select i = 2, so nums becomes \\[1,1,**1**,3,3\\]. Your score increases by 3.\nThe final score is 10 + 4 + 3 = 17.\n\n**Constraints:**\n\n*   `1 <= nums.length, k <= 105`\n*   `1 <= nums[i] <= 109`\"\"\"\n\n\ndef max_score(nums, k):\n    pq = [-x for x in nums]\n    heapq.heapify(pq)\n    score = 0\n\n    for _ in range(k):\n        cur = -heapq.heappop(pq)\n        score += cur\n        heapq.heappush(pq, -cur // 3)\n\n    return score"}}, "leetcode/leetcode_2064.txt": {"score": 0.9250982403755188, "content": {"text": "def minimum_maximum(n, quantities):\n    \"\"\"You are given an integer `n` indicating there are `n` specialty retail stores. There are `m` product types of varying amounts, which are given as a **0-indexed** integer array `quantities`, where `quantities[i]` represents the number of products of the `ith` product type.\n\nYou need to distribute **all products** to the retail stores following these rules:\n\n*   A store can only be given **at most one product type** but can be given **any** amount of it.\n*   After distribution, each store will have been given some number of products (possibly `0`). Let `x` represent the maximum number of products given to any store. You want `x` to be as small as possible, i.e., you want to **minimize** the **maximum** number of products that are given to any store.\n\nReturn _the minimum possible_ `x`.\n\n**Example 1:**\n\n**Input:** n = 6, quantities = \\[11,6\\]\n**Output:** 3\n**Explanation:** One optimal way is:\n- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3\n- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3\nThe maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.\n\n**Example 2:**\n\n**Input:** n = 7, quantities = \\[15,10,10\\]\n**Output:** 5\n**Explanation:** One optimal way is:\n- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5\n- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5\n- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5\nThe maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.\n\n**Example 3:**\n\n**Input:** n = 1, quantities = \\[100000\\]\n**Output:** 100000\n**Explanation:** The only optimal way is:\n- The 100000 products of type 0 are distributed to the only store.\nThe maximum number of products given to any store is max(100000) = 100000.\n\n**Constraints:**\n\n*   `m == quantities.length`\n*   `1 <= m <= n <= 105`\n*   `1 <= quantities[i] <= 105`\"\"\"\n\n    sum_products = sum(quantities)\n    x = (sum_products + n - 1) // n\n    remaining_stores = n\n    for q in quantities:\n        remaining_stores -= (q + x - 1) // x\n        if remaining_stores < 0:\n            x = (sum_products + remaining_stores) // (n + remaining_stores)\n            remaining_stores = n\n    return x"}}, "leetcode/leetcode_2141.txt": {"score": 0.9358486533164978, "content": {"text": "def max_computer_runtime(n, batteries):\n    \"\"\"You have `n` computers. You are given the integer `n` and a **0-indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries.\n\nInitially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\nNote that the batteries cannot be recharged.\n\nReturn _the **maximum** number of minutes you can run all the_ `n` _computers simultaneously._\n\n**Example 1:**\n\n**Input:** n = 2, batteries = \\[3,3,3\\]\n**Output:** 4\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n**Example 2:**\n\n**Input:** n = 2, batteries = \\[1,1,1,1\\]\n**Output:** 2\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.\n\n**Constraints:**\n\n*   `1 <= n <= batteries.length <= 105`\n*   `1 <= batteries[i] <= 109`\"\"\"\n\n    batteries.sort()\n    result = 0\n    for i in range(len(batteries)):\n        result = max(result, min(n, len(batteries) - i) * batteries[i])\n    return result"}}, "leetcode/leetcode_2279.txt": {"score": 0.9265212416648865, "content": {"text": "def max_unique_even_sum(final_sum):\n    \"\"\"You have `n` bags numbered from `0` to `n - 1`. You are given two **0-indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in **any** of the bags.\n\nReturn _the **maximum** number of bags that could have full capacity after placing the additional rocks in some bags._\n\n**Example 1:**\n\n**Input:** capacity = \\[2,3,4,5\\], rocks = \\[1,2,4,4\\], additionalRocks = 2\n**Output:** 3\n**Explanation:**\nPlace 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now \\[2,3,4,4\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3.\n\n**Example 2:**\n\n**Input:** capacity = \\[10,2,2\\], rocks = \\[2,2,0\\], additionalRocks = 100\n**Output:** 3\n**Explanation:**\nPlace 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now \\[10,2,2\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks.\n\n**Constraints:**\n\n*   `n == capacity.length == rocks.length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= capacity[i] <= 109`\n*   `0 <= rocks[i] <= capacity[i]`\n*   `1 <= additionalRocks <= 109`\"\"\"\n\n    result = []\n    current = 2\n    while final_sum > 0:\n        if final_sum >= current:\n            result.append(current)\n            final_sum -= current\n            current += 2\n        else:\n            break\n    return result"}}, "leetcode/leetcode_1648.txt": {"score": 0.9732210636138916, "content": {"text": "def minInsertions(s: str) -> int:\n    \"\"\"You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of **any** color.\n\nThe customer weirdly values the colored balls. Each colored ball's value is the number of balls **of that color** you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer).\n\nYou are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls **in any order**.\n\nReturn _the **maximum** total value that you can attain after selling_ `orders` _colored balls_. As the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** inventory = \\[2,5\\], orders = 4\n**Output:** 14\n**Explanation:** Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\nThe maximum total value is 2 + 5 + 4 + 3 = 14.\n\n**Example 2:**\n\n**Input:** inventory = \\[3,5\\], orders = 6\n**Output:** 19\n**Explanation:** Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\nThe maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n\n**Constraints:**\n\n*   `1 <= inventory.length <= 105`\n*   `1 <= inventory[i] <= 109`\n*   `1 <= orders <= min(sum(inventory[i]), 109)`\"\"\"\n\n    ans, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 2\n        else:\n            if s[i - 1] == '(':\n                depth -= 1\n            else:\n                depth -= 2\n            if depth < 0:\n                ans -= depth\n                depth = 0\n    return ans + depth"}}, "leetcode/leetcode_2218.txt": {"score": 0.9410266280174255, "content": {"text": "import heapq\n    \"\"\"There are `n` **piles** of coins on a table. Each pile consists of a **positive number** of coins of assorted denominations.\n\nIn one move, you can choose any coin on **top** of any pile, remove it, and add it to your wallet.\n\nGiven a list `piles`, where `piles[i]` is a list of integers denoting the composition of the `ith` pile from **top to bottom**, and a positive integer `k`, return _the **maximum total value** of coins you can have in your wallet if you choose **exactly**_ `k` _coins optimally_.\n\n**Example 1:**\n\n**Input:** piles = \\[\\[1,100,3\\],\\[7,8,9\\]\\], k = 2\n**Output:** 101\n**Explanation:**\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n\n**Example 2:**\n\n**Input:** piles = \\[\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[1,1,1,1,1,1,700\\]\\], k = 7\n**Output:** 706\n**Explanation:**\nThe maximum total can be obtained if we choose all coins from the last pile.\n\n**Constraints:**\n\n*   `n == piles.length`\n*   `1 <= n <= 1000`\n*   `1 <= piles[i][j] <= 105`\n*   `1 <= k <= sum(piles[i].length) <= 2000`\"\"\"\n\n\ndef maxCoins(piles, k):\n    pq = []\n    for pile in piles:\n        for coin in pile:\n            heapq.heappush(pq, -coin)\n    \n    max_value = 0\n    while k > 0:\n        max_value += -heapq.heappop(pq)\n        k -= 1\n    return max_value"}}, "leetcode/leetcode_740.txt": {"score": 0.9443578124046326, "content": {"text": "def max_points(nums):\n    \"\"\"You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:\n\n*   Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.\n\nReturn _the **maximum number of points** you can earn by applying the above operation some number of times_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,4,2\\]\n**Output:** 6\n**Explanation:** You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = \\[2\\].\n- Delete 2 to earn 2 points. nums = \\[\\].\nYou earn a total of 6 points.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,3,3,3,4\\]\n**Output:** 9\n**Explanation:** You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = \\[3,3\\].\n- Delete a 3 again to earn 3 points. nums = \\[3\\].\n- Delete a 3 once more to earn 3 points. nums = \\[\\].\nYou earn a total of 9 points.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 104`\"\"\"\n\n    dp = [0] * 100001\n    max_points = 0\n    for num in nums:\n        dp[num] += 1\n    for i in range(2, len(dp)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])\n        max_points = max(max_points, dp[i])\n    return max_points"}}}}, "75": {"gold": {"leetcode/leetcode_2490.txt": 1, "leetcode/leetcode_2515.txt": 1, "leetcode/leetcode_2516.txt": 1}, "retrieved": {"leetcode/leetcode_1823.txt": {"score": 0.8865503072738647, "content": {"text": "def halves_are_alike(s: str) -> bool:\n    \"\"\"There are `n` friends that are playing a game. The friends are sitting in a circle and are numbered from `1` to `n` in **clockwise order**. More formally, moving clockwise from the `ith` friend brings you to the `(i+1)th` friend for `1 <= i < n`, and moving clockwise from the `nth` friend brings you to the `1st` friend.\n\nThe rules of the game are as follows:\n\n1.  **Start** at the `1st` friend.\n2.  Count the next `k` friends in the clockwise direction **including** the friend you started at. The counting wraps around the circle and may count some friends more than once.\n3.  The last friend you counted leaves the circle and loses the game.\n4.  If there is still more than one friend in the circle, go back to step `2` **starting** from the friend **immediately clockwise** of the friend who just lost and repeat.\n5.  Else, the last friend in the circle wins the game.\n\nGiven the number of friends, `n`, and an integer `k`, return _the winner of the game_.\n\n**Example 1:**\n\n**Input:** n = 5, k = 2\n**Output:** 3\n**Explanation:** Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.\n\n**Example 2:**\n\n**Input:** n = 6, k = 5\n**Output:** 1\n**Explanation:** The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.\n\n**Constraints:**\n\n*   `1 <= k <= n <= 500`\n\n**Follow up:**\n\nCould you solve this problem in linear time with constant space?\"\"\"\n\n    half_length = len(s) // 2\n    count_a, count_b = 0, 0\n\n    for i in range(half_length):\n        if s[i] in \"aeiouAEIOU\": count_a += 1\n\n    for i in range(half_length, len(s)):\n        if s[i] in \"aeiouAEIOU\": count_b += 1\n\n    return count_a == count_b"}}, "leetcode/leetcode_2607.txt": {"score": 0.8870273232460022, "content": {"text": "def minOperations(arr: List[int], k: int) -> int:\n    \"\"\"You are given a **0-indexed** integer array `arr` and an integer `k`. The array `arr` is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.\n\nYou can do the following operation any number of times:\n\n*   Pick any element from `arr` and increase or decrease it by `1`.\n\nReturn _the minimum number of operations such that the sum of each **subarray** of length_ `k` _is equal_.\n\nA **subarray** is a contiguous part of the array.\n\n**Example 1:**\n\n**Input:** arr = \\[1,4,1,3\\], k = 2\n**Output:** 1\n**Explanation:** we can do one operation on index 1 to make its value equal to 3.\nThe array after the operation is \\[1,3,1,3\\]\n- Subarray starts at index 0 is \\[1, 3\\], and its sum is 4 \n- Subarray starts at index 1 is \\[3, 1\\], and its sum is 4 \n- Subarray starts at index 2 is \\[1, 3\\], and its sum is 4 \n- Subarray starts at index 3 is \\[3, 1\\], and its sum is 4 \n\n**Example 2:**\n\n**Input:** arr = \\[2,5,5,7\\], k = 3\n**Output:** 5\n**Explanation:** we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.\nThe array after the operations is \\[5,5,5,5\\]\n- Subarray starts at index 0 is \\[5, 5, 5\\], and its sum is 15\n- Subarray starts at index 1 is \\[5, 5, 5\\], and its sum is 15\n- Subarray starts at index 2 is \\[5, 5, 5\\], and its sum is 15\n- Subarray starts at index 3 is \\[5, 5, 5\\], and its sum is 15 \n\n**Constraints:**\n\n*   `1 <= k <= arr.length <= 105`\n*   `1 <= arr[i] <= 109`\"\"\"\n\n    n = len(arr)\n    res = float('inf')\n    prefix = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] + arr[i - 1]\n\n    for i in range(1, n - k + 2):\n        target = (prefix[i - 1] + prefix[n] - prefix[i + k - 1] + n // k - 1) // (n // k)\n        curr_cost = 0\n        for j in range(i, i + k):\n            curr_cost += abs(arr[j - 1] - target)\n        res = min(res, curr_cost)\n\n    return res"}}, "leetcode/csn_python_train_287463.txt": {"score": 0.8906194567680359, "content": {"text": "def circ_permutation(items):\n    \"\"\"Calculate the circular permutation for a given list of items.\"\"\"\n    permutations = []\n    for i in range(len(items)):\n        permutations.append(items[i:] + items[:i])\n    return permutations"}}, "leetcode/leetcode_1260.txt": {"score": 0.8959848284721375, "content": {"text": "def dayOfYear(date: str) -> int:\n    \"\"\"Given a 2D `grid` of size `m x n` and an integer `k`. You need to shift the `grid` `k` times.\n\nIn one shift operation:\n\n*   Element at `grid[i][j]` moves to `grid[i][j + 1]`.\n*   Element at `grid[i][n - 1]` moves to `grid[i + 1][0]`.\n*   Element at `grid[m - 1][n - 1]` moves to `grid[0][0]`.\n\nReturn the _2D grid_ after applying shift operation `k` times.\n\n**Example 1:**\n\n**Input:** `grid` = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], k = 1\n**Output:** \\[\\[9,1,2\\],\\[3,4,5\\],\\[6,7,8\\]\\]\n\n**Example 2:**\n\n**Input:** `grid` = \\[\\[3,8,1,9\\],\\[19,7,2,5\\],\\[4,6,11,10\\],\\[12,0,21,13\\]\\], k = 4\n**Output:** \\[\\[12,0,21,13\\],\\[3,8,1,9\\],\\[19,7,2,5\\],\\[4,6,11,10\\]\\]\n\n**Example 3:**\n\n**Input:** `grid` = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], k = 9\n**Output:** \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m <= 50`\n*   `1 <= n <= 50`\n*   `-1000 <= grid[i][j] <= 1000`\n*   `0 <= k <= 100`\"\"\"\n\n    year, month, day = map(int, date.split('-'))\n\n    daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        daysInMonth[2] = 29\n\n    dayOfYear = sum(daysInMonth[:month]) + day\n    return dayOfYear"}}, "leetcode/leetcode_503.txt": {"score": 0.9011159539222717, "content": {"text": "def nextGreaterElements(nums):\n    \"\"\"Given a circular integer array `nums` (i.e., the next element of `nums[nums.length - 1]` is `nums[0]`), return _the **next greater number** for every element in_ `nums`.\n\nThe **next greater number** of a number `x` is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return `-1` for this number.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,1\\]\n**Output:** \\[2,-1,2\\]\nExplanation: The first 1's next greater number is 2; \nThe number 2 can't find next greater number. \nThe second 1's next greater number needs to search circularly, which is also 2.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,3\\]\n**Output:** \\[2,3,4,-1,4\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\"\"\"\n\n    result = [-1] * len(nums)\n    stack = []\n\n    for i in range(len(nums) * 2):\n        index = i % len(nums)\n        while stack and nums[stack[-1]] < nums[index]:\n            result[stack.pop()] = nums[index]\n        if i < len(nums):\n            stack.append(index)\n\n    return result"}}, "leetcode/csn_python_train_393517.txt": {"score": 0.9032015800476074, "content": {"text": "def cycle_slice(sliceable, start, end):\n    \"\"\"Given a list, return right hand cycle direction slice from start to end.\n\n    Usage::\n\n        >>> array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        >>> cycle_slice(array, 4, 7) # from array[4] to array[7]\n        [4, 5, 6, 7]\n\n        >>> cycle_slice(array, 8, 2) # from array[8] to array[2]\n        [8, 9, 0, 1, 2]\n    \"\"\"\n    if type(sliceable) != list:\n        sliceable = list(sliceable)\n\n    if end >= start:\n        return sliceable[start:end+1]\n    else:\n        return sliceable[start:] + sliceable[:end+1]"}}, "leetcode/leetcode_2582.txt": {"score": 0.897419273853302, "content": {"text": "def pillowHolder(n, time):\n    \"\"\"There are `n` people standing in a line labeled from `1` to `n`. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\n\n*   For example, once the pillow reaches the `nth` person they pass it to the `n - 1th` person, then to the `n - 2th` person and so on.\n\nGiven the two positive integers `n` and `time`, return _the index of the person holding the pillow after_ `time` _seconds_.\n\n**Example 1:**\n\n**Input:** n = 4, time = 5\n**Output:** 2\n**Explanation:** People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.\nAfer five seconds, the pillow is given to the 2nd person.\n\n**Example 2:**\n\n**Input:** n = 3, time = 2\n**Output:** 3\n**Explanation:** People pass the pillow in the following way: 1 -> 2 -> 3.\nAfer two seconds, the pillow is given to the 3rd person.\n\n**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= time <= 1000`\"\"\"\n\n    time %= (2 * n - 2)\n    if time <= n - 1:\n        return time + 1\n    else:\n        return 2 * n - time - 1"}}, "leetcode/csn_python_train_281397.txt": {"score": 0.9001142382621765, "content": {"text": "def cycle_slice(sliceable, start, end):\n    \"\"\"Given a list, return right hand cycle direction slice from start to end.\n\n    Example::\n\n        >>> array = [0, 1, 2, 3]\n        >>> cycle_slice(array, 1, 3) # from array[1] to array[3]\n        [1, 2]\n\n        >>> cycle_slice(array, 3, 1) # from array[3] to array[1]\n        [3, 0]\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \"\"\"\n    if type(sliceable) != list:\n        sliceable = list(sliceable)\n    length = len(sliceable)\n\n    if length == 0:\n        raise ValueError(\"sliceable cannot be empty!\")\n    start = start % length\n    end = end % length\n\n    if end > start:\n        return sliceable[start:end]\n    elif end <= start:\n        return sliceable[start:] + sliceable[:end]"}}, "leetcode/csn_python_train_379070.txt": {"score": 0.8960173726081848, "content": {"text": "def circular_shifts(iterable):\n    \"\"\"Return a list of circular shifts of *iterable*.\n\n        >>> circular_shifts(range(4))\n        [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n    \"\"\"\n    lst = list(iterable)\n    return take(len(lst), windowed(cycle(lst), len(lst)))"}}, "leetcode/leetcode_1652.txt": {"score": 0.9898995757102966, "content": {"text": "def minOperations(target: str) -> int:\n    \"\"\"You have a bomb to defuse, and your time is running out! Your informer will provide you with a **circular** array `code` of length of `n` and a key `k`.\n\nTo decrypt the code, you must replace every number. All the numbers are replaced **simultaneously**.\n\n*   If `k > 0`, replace the `ith` number with the sum of the **next** `k` numbers.\n*   If `k < 0`, replace the `ith` number with the sum of the **previous** `k` numbers.\n*   If `k == 0`, replace the `ith` number with `0`.\n\nAs `code` is circular, the next element of `code[n-1]` is `code[0]`, and the previous element of `code[0]` is `code[n-1]`.\n\nGiven the **circular** array `code` and an integer key `k`, return _the decrypted code to defuse the bomb_!\n\n**Example 1:**\n\n**Input:** code = \\[5,7,1,4\\], k = 3\n**Output:** \\[12,10,16,13\\]\n**Explanation:** Each number is replaced by the sum of the next 3 numbers. The decrypted code is \\[7+1+4, 1+4+5, 4+5+7, 5+7+1\\]. Notice that the numbers wrap around.\n\n**Example 2:**\n\n**Input:** code = \\[1,2,3,4\\], k = 0\n**Output:** \\[0,0,0,0\\]\n**Explanation:** When k is zero, the numbers are replaced by 0. \n\n**Example 3:**\n\n**Input:** code = \\[2,4,9,3\\], k = -2\n**Output:** \\[12,5,6,13\\]\n**Explanation:** The decrypted code is \\[3+9, 2+3, 4+2, 9+4\\]. Notice that the numbers wrap around again. If k is negative, the sum is of the **previous** numbers.\n\n**Constraints:**\n\n*   `n == code.length`\n*   `1 <= n <= 100`\n*   `1 <= code[i] <= 100`\n*   `-(n - 1) <= k <= n - 1`\"\"\"\n\n    operations = 0\n    current_bit = '0'\n    for bit in target:\n        if bit != current_bit:\n            operations += 1\n            current_bit = bit\n    return operations"}}}}, "76": {"gold": {"leetcode/leetcode_2368.txt": 1}, "retrieved": {"leetcode/leetcode_2139.txt": {"score": 0.926552414894104, "content": {"text": "class DetectSquares:\n    \"\"\"You are playing a game with integers. You start with the integer `1` and you want to reach the integer `target`.\n\nIn one move, you can either:\n\n*   **Increment** the current integer by one (i.e., `x = x + 1`).\n*   **Double** the current integer (i.e., `x = 2 * x`).\n\nYou can use the **increment** operation **any** number of times, however, you can only use the **double** operation **at most** `maxDoubles` times.\n\nGiven the two integers `target` and `maxDoubles`, return _the minimum number of moves needed to reach_ `target` _starting with_ `1`.\n\n**Example 1:**\n\n**Input:** target = 5, maxDoubles = 0\n**Output:** 4\n**Explanation:** Keep incrementing by 1 until you reach target.\n\n**Example 2:**\n\n**Input:** target = 19, maxDoubles = 2\n**Output:** 7\n**Explanation:** Initially, x = 1\nIncrement 3 times so x = 4\nDouble once so x = 8\nIncrement once so x = 9\nDouble again so x = 18\nIncrement once so x = 19\n\n**Example 3:**\n\n**Input:** target = 10, maxDoubles = 4\n**Output:** 4\n**Explanation:** Initially, x = 1\nIncrement once so x = 2\nDouble once so x = 4\nIncrement once so x = 5\nDouble again so x = 10\n\n**Constraints:**\n\n*   `1 <= target <= 109`\n*   `0 <= maxDoubles <= 100`\"\"\"\n\n\n    def __init__(self):\n        self.points = collections.defaultdict(lambda: collections.defaultdict(int))\n\n    def add(self, point):\n        self.points[point[0]][point[1]] += 1\n\n    def count(self, point):\n        ans = 0\n        for x2 in self.points[point[0]]:\n            if x2 == point[1]:\n                continue\n            for y2 in self.points[x2]:\n                if y2 == point[1] or abs(x2 - point[1]) != abs(y2 - point[0]):\n                    continue\n                ans += self.points[point[0]][x2] * self.points[x2][y2] * self.points[point[0]][y2]\n        return ans"}}, "leetcode/leetcode_2087.txt": {"score": 0.932219922542572, "content": {"text": "def minTotalCost(startPos, homePos, rowCosts, colCosts):\n    \"\"\"There is an `m x n` grid, where `(0, 0)` is the top-left cell and `(m - 1, n - 1)` is the bottom-right cell. You are given an integer array `startPos` where `startPos = [startrow, startcol]` indicates that **initially**, a **robot** is at the cell `(startrow, startcol)`. You are also given an integer array `homePos` where `homePos = [homerow, homecol]` indicates that its **home** is at the cell `(homerow, homecol)`.\n\nThe robot needs to go to its home. It can move one cell in four directions: **left**, **right**, **up**, or **down**, and it can not move outside the boundary. Every move incurs some cost. You are further given two **0-indexed** integer arrays: `rowCosts` of length `m` and `colCosts` of length `n`.\n\n*   If the robot moves **up** or **down** into a cell whose **row** is `r`, then this move costs `rowCosts[r]`.\n*   If the robot moves **left** or **right** into a cell whose **column** is `c`, then this move costs `colCosts[c]`.\n\nReturn _the **minimum total cost** for this robot to return home_.\n\n**Example 1:**\n\n**Input:** startPos = \\[1, 0\\], homePos = \\[2, 3\\], rowCosts = \\[5, 4, 3\\], colCosts = \\[8, 2, 6, 7\\]\n**Output:** 18\n**Explanation:** One optimal path is that:\nStarting from (1, 0)\n-> It goes down to (**2**, 0). This move costs rowCosts\\[2\\] = 3.\n-> It goes right to (2, **1**). This move costs colCosts\\[1\\] = 2.\n-> It goes right to (2, **2**). This move costs colCosts\\[2\\] = 6.\n-> It goes right to (2, **3**). This move costs colCosts\\[3\\] = 7.\nThe total cost is 3 + 2 + 6 + 7 = 18\n\n**Example 2:**\n\n**Input:** startPos = \\[0, 0\\], homePos = \\[0, 0\\], rowCosts = \\[5\\], colCosts = \\[26\\]\n**Output:** 0\n**Explanation:** The robot is already at its home. Since no moves occur, the total cost is 0.\n\n**Constraints:**\n\n*   `m == rowCosts.length`\n*   `n == colCosts.length`\n*   `1 <= m, n <= 105`\n*   `0 <= rowCosts[r], colCosts[c] <= 104`\n*   `startPos.length == 2`\n*   `homePos.length == 2`\n*   `0 <= startrow, homerow < m`\n*   `0 <= startcol, homecol < n`\"\"\"\n\n    row_difference = abs(startPos[0] - homePos[0])\n    col_difference = abs(startPos[1] - homePos[1])\n\n    row_cost = sum(rowCosts[min(startPos[0], homePos[0]):min(startPos[0], homePos[0]) + row_difference])\n    col_cost = sum(colCosts[min(startPos[1], homePos[1]):min(startPos[1], homePos[1]) + col_difference])\n\n    return row_cost + col_cost"}}, "leetcode/leetcode_2365.txt": {"score": 0.9265991449356079, "content": {"text": "def min_days_to_complete_tasks(tasks, space):\n    \"\"\"You are given a **0-indexed** array of positive integers `tasks`, representing tasks that need to be completed **in order**, where `tasks[i]` represents the **type** of the `ith` task.\n\nYou are also given a positive integer `space`, which represents the **minimum** number of days that must pass **after** the completion of a task before another task of the **same** type can be performed.\n\nEach day, until all tasks have been completed, you must either:\n\n*   Complete the next task from `tasks`, or\n*   Take a break.\n\nReturn _the **minimum** number of days needed to complete all tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,1,2,3,1\\], space = 3\n**Output:** 9\n**Explanation:**\nOne way to complete all tasks in 9 days is as follows:\nDay 1: Complete the 0th task.\nDay 2: Complete the 1st task.\nDay 3: Take a break.\nDay 4: Take a break.\nDay 5: Complete the 2nd task.\nDay 6: Complete the 3rd task.\nDay 7: Take a break.\nDay 8: Complete the 4th task.\nDay 9: Complete the 5th task.\nIt can be shown that the tasks cannot be completed in less than 9 days.\n\n**Example 2:**\n\n**Input:** tasks = \\[5,8,8,5\\], space = 2\n**Output:** 6\n**Explanation:**\nOne way to complete all tasks in 6 days is as follows:\nDay 1: Complete the 0th task.\nDay 2: Complete the 1st task.\nDay 3: Take a break.\nDay 4: Take a break.\nDay 5: Complete the 2nd task.\nDay 6: Complete the 3rd task.\nIt can be shown that the tasks cannot be completed in less than 6 days.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= tasks[i] <= 109`\n*   `1 <= space <= tasks.length`\"\"\"\n\n    task_last_complete = {}\n    days = 0\n\n    for task in tasks:\n        if task in task_last_complete:\n            passed_days = days - task_last_complete[task]\n            if passed_days < space:\n                days += space - passed_days\n        days += 1\n        task_last_complete[task] = days\n\n    return days"}}, "leetcode/leetcode_1769.txt": {"score": 0.9349234700202942, "content": {"text": "def maximum_generated(n: int) -> int:\n    \"\"\"You have `n` boxes. You are given a binary string `boxes` of length `n`, where `boxes[i]` is `'0'` if the `ith` box is **empty**, and `'1'` if it contains **one** ball.\n\nIn one operation, you can move **one** ball from a box to an adjacent box. Box `i` is adjacent to box `j` if `abs(i - j) == 1`. Note that after doing so, there may be more than one ball in some boxes.\n\nReturn an array `answer` of size `n`, where `answer[i]` is the **minimum** number of operations needed to move all the balls to the `ith` box.\n\nEach `answer[i]` is calculated considering the **initial** state of the boxes.\n\n**Example 1:**\n\n**Input:** boxes =  \"110 \"\n**Output:** \\[1,1,3\\]\n**Explanation:** The answer for each box is as follows:\n1) First box: you will have to move one ball from the second box to the first box in one operation.\n2) Second box: you will have to move one ball from the first box to the second box in one operation.\n3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.\n\n**Example 2:**\n\n**Input:** boxes =  \"001011 \"\n**Output:** \\[11,8,5,4,3,4\\]\n\n**Constraints:**\n\n*   `n == boxes.length`\n*   `1 <= n <= 2000`\n*   `boxes[i]` is either `'0'` or `'1'`.\"\"\"\n\n    if n == 0:\n        return 0\n    nums = [0] * (n + 1)\n    nums[1] = 1\n    for i in range(2, n + 1):\n        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]\n    return max(nums)"}}, "leetcode/leetcode_754.txt": {"score": 0.9372163414955139, "content": {"text": "def reachNumber(target: int) -> int:\n    \"\"\"You are standing at position `0` on an infinite number line. There is a destination at position `target`.\n\nYou can make some number of moves `numMoves` so that:\n\n*   On each move, you can either go left or right.\n*   During the `ith` move (starting from `i == 1` to `i == numMoves`), you take `i` steps in the chosen direction.\n\nGiven the integer `target`, return _the **minimum** number of moves required (i.e., the minimum_ `numMoves`_) to reach the destination_.\n\n**Example 1:**\n\n**Input:** target = 2\n**Output:** 3\n**Explanation:**\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to -1 (2 steps).\nOn the 3rd move, we step from -1 to 2 (3 steps).\n\n**Example 2:**\n\n**Input:** target = 3\n**Output:** 2\n**Explanation:**\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to 3 (2 steps).\n\n**Constraints:**\n\n*   `-109 <= target <= 109`\n*   `target != 0`\"\"\"\n\n    target = abs(target)\n    step = 0\n    sum = 0\n    while sum < target:\n        step += 1\n        sum += step\n    while (sum - target) % 2 != 0:\n        step += 1\n        sum += step\n    return step"}}, "leetcode/leetcode_1345.txt": {"score": 0.9421000480651855, "content": {"text": "from collections import defaultdict\n    \"\"\"Given an array of integers `arr`, you are initially positioned at the first index of the array.\n\nIn one step you can jump from index `i` to index:\n\n*   `i + 1` where: `i + 1 < arr.length`.\n*   `i - 1` where: `i - 1 >= 0`.\n*   `j` where: `arr[i] == arr[j]` and `i != j`.\n\nReturn _the minimum number of steps_ to reach the **last index** of the array.\n\nNotice that you can not jump outside of the array at any time.\n\n**Example 1:**\n\n**Input:** arr = \\[100,-23,-23,404,100,23,23,23,3,404\\]\n**Output:** 3\n**Explanation:** You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.\n\n**Example 2:**\n\n**Input:** arr = \\[7\\]\n**Output:** 0\n**Explanation:** Start index is the last index. You do not need to jump.\n\n**Example 3:**\n\n**Input:** arr = \\[7,6,9,6,9,6,9,7\\]\n**Output:** 1\n**Explanation:** You can jump directly from index 0 to index 7 which is last index of the array.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 5 * 104`\n*   `-108 <= arr[i] <= 108`\"\"\"\n\n\ndef minJumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n\n    value_indices = defaultdict(list)\n    \n    for i, value in enumerate(arr):\n        value_indices[value].append(i)\n\n    q = [0]\n    visited = [False] * n\n    visited[0] = True\n    steps = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            index = q.pop(0)\n            \n            if index == n - 1:\n                return steps\n            \n            if index > 0 and not visited[index - 1]:\n                q.append(index - 1)\n                visited[index - 1] = True\n                \n            if index < n - 1 and not visited[index + 1]:\n                q.append(index + 1)\n                visited[index + 1] = True\n\n            for neighbor in value_indices[arr[index]]:\n                if not visited[neighbor]:\n                    q.append(neighbor)\n                    visited[neighbor] = True\n            \n            value_indices[arr[index]] = []\n\n        steps += 1\n\n    return -1"}}, "leetcode/leetcode_403.txt": {"score": 0.9278066158294678, "content": {"text": "def can_cross(stones):\n    \"\"\"A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of `stones`' positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.\n\nIf the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.\n\n**Example 1:**\n\n**Input:** stones = \\[0,1,3,5,6,8,12,17\\]\n**Output:** true\n**Explanation:** The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n\n**Example 2:**\n\n**Input:** stones = \\[0,1,2,3,4,8,9,11\\]\n**Output:** false\n**Explanation:** There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n\n**Constraints:**\n\n*   `2 <= stones.length <= 2000`\n*   `0 <= stones[i] <= 231 - 1`\n*   `stones[0] == 0`\n*   `stones` is sorted in a strictly increasing order.\"\"\"\n\n    dp = {stone: set() for stone in stones}\n    dp[0].add(0)\n\n    for stone in stones:\n        for k in dp[stone]:\n            for jump in (k - 1, k, k + 1):\n                if jump > 0 and stone + jump in dp:\n                    dp[stone + jump].add(jump)\n\n    return bool(dp[stones[-1]])"}}, "leetcode/leetcode_1654.txt": {"score": 0.984119176864624, "content": {"text": "from collections import deque\n    \"\"\"A certain bug's home is on the x-axis at position `x`. Help them get there from position `0`.\n\nThe bug jumps according to the following rules:\n\n*   It can jump exactly `a` positions **forward** (to the right).\n*   It can jump exactly `b` positions **backward** (to the left).\n*   It cannot jump backward twice in a row.\n*   It cannot jump to any `forbidden` positions.\n\nThe bug may jump forward **beyond** its home, but it **cannot jump** to positions numbered with **negative** integers.\n\nGiven an array of integers `forbidden`, where `forbidden[i]` means that the bug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and `x`, return _the minimum number of jumps needed for the bug to reach its home_. If there is no possible sequence of jumps that lands the bug on position `x`, return `-1.`\n\n**Example 1:**\n\n**Input:** forbidden = \\[14,4,18,1,15\\], a = 3, b = 15, x = 9\n**Output:** 3\n**Explanation:** 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.\n\n**Example 2:**\n\n**Input:** forbidden = \\[8,3,16,6,12,20\\], a = 15, b = 13, x = 11\n**Output:** -1\n\n**Example 3:**\n\n**Input:** forbidden = \\[1,6,2,14,5,17,4\\], a = 16, b = 9, x = 7\n**Output:** 2\n**Explanation:** One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.\n\n**Constraints:**\n\n*   `1 <= forbidden.length <= 1000`\n*   `1 <= a, b, forbidden[i] <= 2000`\n*   `0 <= x <= 2000`\n*   All the elements in `forbidden` are distinct.\n*   Position `x` is not forbidden.\"\"\"\n\n\ndef minimumJumps(forbidden, a, b, x):\n    forbidden_positions = set(forbidden)\n    q = deque([(0, 0, 0)])\n    visited = {(0, 0)}\n    while q:\n        pos, steps, backward = q.popleft()\n        if pos == x:\n            return steps\n        forward_pos = pos + a\n        backward_pos = pos - b\n        if forward_pos <= 6000 and forward_pos not in forbidden_positions and (forward_pos, 0) not in visited:\n            visited.add((forward_pos, 0))\n            q.append((forward_pos, steps + 1, 0))\n        if backward == 0 and backward_pos > 0 and backward_pos not in forbidden_positions and (backward_pos, 1) not in visited:\n            visited.add((backward_pos, 1))\n            q.append((backward_pos, steps + 1, 1))\n    return -1"}}, "leetcode/leetcode_1306.txt": {"score": 0.9365519881248474, "content": {"text": "def minimumAbsDifference(arr):\n    \"\"\"Given an array of non-negative integers `arr`, you are initially positioned at `start` index of the array. When you are at index `i`, you can jump to `i + arr[i]` or `i - arr[i]`, check if you can reach to **any** index with value 0.\n\nNotice that you can not jump outside of the array at any time.\n\n**Example 1:**\n\n**Input:** arr = \\[4,2,3,0,3,1,2\\], start = 5\n**Output:** true\n**Explanation:** \nAll possible ways to reach at index 3 with value 0 are: \nindex 5 -> index 4 -> index 1 -> index 3 \nindex 5 -> index 6 -> index 4 -> index 1 -> index 3 \n\n**Example 2:**\n\n**Input:** arr = \\[4,2,3,0,3,1,2\\], start = 0\n**Output:** true \n**Explanation:** \nOne possible way to reach at index 3 with value 0 is: \nindex 0 -> index 4 -> index 1 -> index 3\n\n**Example 3:**\n\n**Input:** arr = \\[3,0,2,1,2\\], start = 2\n**Output:** false\n**Explanation:** There is no way to reach at index 1 with value 0.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 5 * 104`\n*   `0 <= arr[i] < arr.length`\n*   `0 <= start < arr.length`\n\na, b are from arr a < b b - a equals to the minimum absolute difference of any two elements in arr\"\"\"\n\n    arr.sort()\n    min_difference = float('inf')\n    result = []\n\n    for i in range(1, len(arr)):\n        difference = arr[i] - arr[i - 1]\n        if difference < min_difference:\n            min_difference = difference\n            result = [[arr[i - 1], arr[i]]]\n        elif difference == min_difference:\n            result.append([arr[i - 1], arr[i]])\n\n    return result"}}, "leetcode/leetcode_818.txt": {"score": 0.9442927241325378, "content": {"text": "def racecar(target: int) -> int:\n    \"\"\"Your car starts at position `0` and speed `+1` on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions `'A'` (accelerate) and `'R'` (reverse):\n\n*   When you get an instruction `'A'`, your car does the following:\n    *   `position += speed`\n    *   `speed *= 2`\n*   When you get an instruction `'R'`, your car does the following:\n    *   If your speed is positive then `speed = -1`\n    *   otherwise `speed = 1`Your position stays the same.\n\nFor example, after commands `\"AAR \"`, your car goes to positions `0 --> 1 --> 3 --> 3`, and your speed goes to `1 --> 2 --> 4 --> -1`.\n\nGiven a target position `target`, return _the length of the shortest sequence of instructions to get there_.\n\n**Example 1:**\n\n**Input:** target = 3\n**Output:** 2\n**Explanation:** \nThe shortest instruction sequence is  \"AA \".\nYour position goes from 0 --> 1 --> 3.\n\n**Example 2:**\n\n**Input:** target = 6\n**Output:** 5\n**Explanation:** \nThe shortest instruction sequence is  \"AAARA \".\nYour position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6.\n\n**Constraints:**\n\n*   `1 <= target <= 104`\"\"\"\n\n    memo = {}\n    def dp(position, speed):\n        if abs(position) > 2 * target:\n            return target + 1\n        if position == target:\n            return 0 if speed == 1 else 1\n        if (position, speed) in memo:\n            return memo[(position, speed)]\n        \n        ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1\n        ans = min(ans, dp(position + speed, speed * 2) + 1)\n        memo[(position, speed)] = ans\n        return ans\n    \n    return dp(0, 1)"}}}}, "77": {"gold": {"leetcode/leetcode_2279.txt": 1}, "retrieved": {"leetcode/leetcode_1383.txt": {"score": 0.9078298211097717, "content": {"text": "import heapq\n    \"\"\"You are given two integers `n` and `k` and two integer arrays `speed` and `efficiency` both of length `n`. There are `n` engineers numbered from `1` to `n`. `speed[i]` and `efficiency[i]` represent the speed and efficiency of the `ith` engineer respectively.\n\nChoose **at most** `k` different engineers out of the `n` engineers to form a team with the maximum **performance**.\n\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\n\nReturn _the maximum performance of this team_. Since the answer can be a huge number, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 2\n**Output:** 60\n**Explanation:** \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) \\* min(4, 7) = 60.\n\n**Example 2:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 3\n**Output:** 68\n**Explanation:**\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) \\* min(5, 4, 7) = 68.\n\n**Example 3:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 4\n**Output:** 72\n\n**Constraints:**\n\n*   `1 <= k <= n <= 105`\n*   `speed.length == n`\n*   `efficiency.length == n`\n*   `1 <= speed[i] <= 105`\n*   `1 <= efficiency[i] <= 108`\"\"\"\n\nfrom typing import List\n\ndef max_performance(n: int, k: int, speed: List[int], efficiency: List[int]) -> int:\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    min_heap = []\n    speed_sum = 0\n    max_performance = 0\n\n    for e, s in engineers:\n        speed_sum += s\n        heapq.heappush(min_heap, s)\n\n        if len(min_heap) > k:\n            speed_sum -= heapq.heappop(min_heap)\n\n        max_performance = max(max_performance, speed_sum * e)\n\n    return max_performance % (10**9 + 7)"}}, "leetcode/leetcode_1751.txt": {"score": 0.9162946939468384, "content": {"text": "def slowestKey(releaseTimes, keysPressed):\n    \"\"\"You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn _the **maximum sum** of values that you can receive by attending events._\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,1\\]\\], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,10\\]\\], k = 2\n**Output:** 10\n**Explanation:** Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,1,1\\],\\[2,2,2\\],\\[3,3,3\\],\\[4,4,4\\]\\], k = 3\n**Output:** 9\n**Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n**Constraints:**\n\n*   `1 <= k <= events.length`\n*   `1 <= k * events.length <= 106`\n*   `1 <= startDayi <= endDayi <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    max_key = keysPressed[0]\n    max_duration = releaseTimes[0]\n    for i in range(1, len(releaseTimes)):\n        duration = releaseTimes[i] - releaseTimes[i - 1]\n        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):\n            max_key = keysPressed[i]\n            max_duration = duration\n    return max_key"}}, "leetcode/leetcode_2054.txt": {"score": 0.9158025979995728, "content": {"text": "def find_chair(times, target_friend):\n    \"\"\"You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose **at most** **two** **non-overlapping** events to attend such that the sum of their values is **maximized**.\n\nReturn _this **maximum** sum._\n\nNote that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[2,4,3\\]\\]\n**Output:** 4\n**Explanation:** Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[1,5,5\\]\\]\n**Output:** 5\n**Explanation:** Choose event 2 for a sum of 5.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,5,3\\],\\[1,5,1\\],\\[6,6,5\\]\\]\n**Output:** 8\n**Explanation:** Choose events 0 and 2 for a sum of 3 + 5 = 8.\n\n**Constraints:**\n\n*   `2 <= events.length <= 105`\n*   `events[i].length == 3`\n*   `1 <= startTimei <= endTimei <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    n = len(times)\n    events = []\n    for i, (arrival, leaving) in enumerate(times):\n        events.append((arrival, i))\n        events.append((leaving, ~i))\n    events.sort()\n    chairs = [-1] * n\n    available_chairs = sorted(range(n))\n    for time, friend_id in events:\n        if friend_id >= 0:\n            chairs[friend_id] = available_chairs.pop(0)\n            if friend_id == target_friend:\n                return chairs[friend_id]\n        else:\n            available_chairs.append(chairs[~friend_id])\n            available_chairs.sort()\n    return -1"}}, "leetcode/leetcode_502.txt": {"score": 0.9300996661186218, "content": {"text": "import heapq\n    \"\"\"Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the **IPO**. Since it has limited resources, it can only finish at most `k` distinct projects before the **IPO**. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.\n\nYou are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.\n\nInitially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return _the final maximized capital_.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n**Example 1:**\n\n**Input:** k = 2, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,1\\]\n**Output:** 4\n**Explanation:** Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** k = 3, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,2\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= k <= 105`\n*   `0 <= w <= 109`\n*   `n == profits.length`\n*   `n == capital.length`\n*   `1 <= n <= 105`\n*   `0 <= profits[i] <= 104`\n*   `0 <= capital[i] <= 109`\"\"\"\n\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w"}}, "leetcode/leetcode_2600.txt": {"score": 0.9214076399803162, "content": {"text": "def max_sum(numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\n    \"\"\"There is a bag that consists of items, each item has a number `1`, `0`, or `-1` written on it.\n\nYou are given four **non-negative** integers `numOnes`, `numZeros`, `numNegOnes`, and `k`.\n\nThe bag initially contains:\n\n*   `numOnes` items with `1`s written on them.\n*   `numZeroes` items with `0`s written on them.\n*   `numNegOnes` items with `-1`s written on them.\n\nWe want to pick exactly `k` items among the available items. Return _the **maximum** possible sum of numbers written on the items_.\n\n**Example 1:**\n\n**Input:** numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\n**Output:** 2\n**Explanation:** We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2.\nIt can be proven that 2 is the maximum possible sum.\n\n**Example 2:**\n\n**Input:** numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\n**Output:** 3\n**Explanation:** We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3.\nIt can be proven that 3 is the maximum possible sum.\n\n**Constraints:**\n\n*   `0 <= numOnes, numZeros, numNegOnes <= 50`\n*   `0 <= k <= numOnes + numZeros + numNegOnes`\"\"\"\n\n    max_sum = 0\n    for i in range(k + 1):\n        ones = min(i, numOnes)\n        neg_ones = min(k - i, numNegOnes)\n        max_sum = max(max_sum, ones - neg_ones)\n    return max_sum"}}, "leetcode/leetcode_1090.txt": {"score": 0.9234141707420349, "content": {"text": "from typing import List\n    \"\"\"There is a set of `n` items. You are given two integer arrays `values` and `labels` where the value and the label of the `ith` element are `values[i]` and `labels[i]` respectively. You are also given two integers `numWanted` and `useLimit`.\n\nChoose a subset `s` of the `n` elements such that:\n\n*   The size of the subset `s` is **less than or equal to** `numWanted`.\n*   There are **at most** `useLimit` items with the same label in `s`.\n\nThe **score** of a subset is the sum of the values in the subset.\n\nReturn _the maximum **score** of a subset_ `s`.\n\n**Example 1:**\n\n**Input:** values = \\[5,4,3,2,1\\], labels = \\[1,1,2,2,3\\], numWanted = 3, useLimit = 1\n**Output:** 9\n**Explanation:** The subset chosen is the first, third, and fifth items.\n\n**Example 2:**\n\n**Input:** values = \\[5,4,3,2,1\\], labels = \\[1,3,3,3,2\\], numWanted = 3, useLimit = 2\n**Output:** 12\n**Explanation:** The subset chosen is the first, second, and third items.\n\n**Example 3:**\n\n**Input:** values = \\[9,8,8,7,6\\], labels = \\[0,0,0,1,1\\], numWanted = 3, useLimit = 1\n**Output:** 16\n**Explanation:** The subset chosen is the first and fourth items.\n\n**Constraints:**\n\n*   `n == values.length == labels.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= values[i], labels[i] <= 2 * 104`\n*   `1 <= numWanted, useLimit <= n`\"\"\"\n\n\ndef largestValsFromLabels(values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\n    items = list(zip(values, labels))\n    items.sort(key=lambda x: x[0], reverse=True)\n\n    label_count = {}\n    ans = 0\n\n    for value, label in items:\n        if label not in label_count:\n            label_count[label] = 0\n        if label_count[label] < useLimit:\n            ans += value\n            label_count[label] += 1\n            numWanted -= 1\n            if numWanted == 0:\n                break\n\n    return ans"}}, "leetcode/leetcode_1833.txt": {"score": 0.9305540323257446, "content": {"text": "def largestAltitude(gain):\n    \"\"\"It is a sweltering summer day, and a boy wants to buy some ice cream bars.\n\nAt the store, there are `n` ice cream bars. You are given an array `costs` of length `n`, where `costs[i]` is the price of the `ith` ice cream bar in coins. The boy initially has `coins` coins to spend, and he wants to buy as many ice cream bars as possible.\n\n**Note:** The boy can buy the ice cream bars in any order.\n\nReturn _the **maximum** number of ice cream bars the boy can buy with_ `coins` _coins._\n\nYou must solve the problem by counting sort.\n\n**Example 1:**\n\n**Input:** costs = \\[1,3,2,4,1\\], coins = 7\n**Output:** 4\n**Explanation:** The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.\n\n**Example 2:**\n\n**Input:** costs = \\[10,6,8,7,7,8\\], coins = 5\n**Output:** 0\n**Explanation:** The boy cannot afford any of the ice cream bars.\n\n**Example 3:**\n\n**Input:** costs = \\[1,6,3,1,2,5\\], coins = 20\n**Output:** 6\n**Explanation:** The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.\n\n**Constraints:**\n\n*   `costs.length == n`\n*   `1 <= n <= 105`\n*   `1 <= costs[i] <= 105`\n*   `1 <= coins <= 108`\"\"\"\n\n    max_altitude, current_altitude = 0, 0\n    for i in gain:\n        current_altitude += i\n        max_altitude = max(max_altitude, current_altitude)\n    return max_altitude"}}, "leetcode/leetcode_826.txt": {"score": 0.9353537559509277, "content": {"text": "def maxProfitAssignment(difficulty, profit, worker):\n    \"\"\"You have `n` jobs and `m` workers. You are given three arrays: `difficulty`, `profit`, and `worker` where:\n\n*   `difficulty[i]` and `profit[i]` are the difficulty and the profit of the `ith` job, and\n*   `worker[j]` is the ability of `jth` worker (i.e., the `jth` worker can only complete a job with difficulty at most `worker[j]`).\n\nEvery worker can be assigned **at most one job**, but one job can be **completed multiple times**.\n\n*   For example, if three workers attempt the same job that pays `$1`, then the total profit will be `$3`. If a worker cannot complete any job, their profit is `$0`.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n\n**Example 1:**\n\n**Input:** difficulty = \\[2,4,6,8,10\\], profit = \\[10,20,30,40,50\\], worker = \\[4,5,6,7\\]\n**Output:** 100\n**Explanation:** Workers are assigned jobs of difficulty \\[4,4,6,6\\] and they get a profit of \\[20,20,30,30\\] separately.\n\n**Example 2:**\n\n**Input:** difficulty = \\[85,47,57\\], profit = \\[24,66,99\\], worker = \\[40,25,25\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == difficulty.length`\n*   `n == profit.length`\n*   `m == worker.length`\n*   `1 <= n, m <= 104`\n*   `1 <= difficulty[i], profit[i], worker[i] <= 105`\"\"\"\n\n    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit"}}, "leetcode/leetcode_2218.txt": {"score": 0.9354962706565857, "content": {"text": "import heapq\n    \"\"\"There are `n` **piles** of coins on a table. Each pile consists of a **positive number** of coins of assorted denominations.\n\nIn one move, you can choose any coin on **top** of any pile, remove it, and add it to your wallet.\n\nGiven a list `piles`, where `piles[i]` is a list of integers denoting the composition of the `ith` pile from **top to bottom**, and a positive integer `k`, return _the **maximum total value** of coins you can have in your wallet if you choose **exactly**_ `k` _coins optimally_.\n\n**Example 1:**\n\n**Input:** piles = \\[\\[1,100,3\\],\\[7,8,9\\]\\], k = 2\n**Output:** 101\n**Explanation:**\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n\n**Example 2:**\n\n**Input:** piles = \\[\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[1,1,1,1,1,1,700\\]\\], k = 7\n**Output:** 706\n**Explanation:**\nThe maximum total can be obtained if we choose all coins from the last pile.\n\n**Constraints:**\n\n*   `n == piles.length`\n*   `1 <= n <= 1000`\n*   `1 <= piles[i][j] <= 105`\n*   `1 <= k <= sum(piles[i].length) <= 2000`\"\"\"\n\n\ndef maxCoins(piles, k):\n    pq = []\n    for pile in piles:\n        for coin in pile:\n            heapq.heappush(pq, -coin)\n    \n    max_value = 0\n    while k > 0:\n        max_value += -heapq.heappop(pq)\n        k -= 1\n    return max_value"}}, "leetcode/leetcode_1710.txt": {"score": 0.9892733097076416, "content": {"text": "import heapq\n    \"\"\"You are assigned to put some amount of boxes onto **one truck**. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`:\n\n*   `numberOfBoxesi` is the number of boxes of type `i`.\n*   `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.\n\nYou are also given an integer `truckSize`, which is the **maximum** number of **boxes** that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.\n\nReturn _the **maximum** total number of **units** that can be put on the truck._\n\n**Example 1:**\n\n**Input:** boxTypes = \\[\\[1,3\\],\\[2,2\\],\\[3,1\\]\\], truckSize = 4\n**Output:** 8\n**Explanation:** There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 \\* 3) + (2 \\* 2) + (1 \\* 1) = 8.\n\n**Example 2:**\n\n**Input:** boxTypes = \\[\\[5,10\\],\\[2,5\\],\\[4,7\\],\\[3,9\\]\\], truckSize = 10\n**Output:** 91\n\n**Constraints:**\n\n*   `1 <= boxTypes.length <= 1000`\n*   `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`\n*   `1 <= truckSize <= 106`\"\"\"\n\n\ndef busiest_servers(k, arrival, load):\n    server_requests = [0] * k\n    pq = []\n    available_servers = list(range(k))\n\n    for i in range(len(arrival)):\n        while pq and pq[0][0] <= arrival[i]:\n            _, server_id = heapq.heappop(pq)\n            available_servers.append(server_id)\n\n        if available_servers:\n            server_id = available_servers.pop(0)\n            server_requests[server_id] += 1\n            heapq.heappush(pq, (arrival[i] + load[i], server_id))\n\n    max_requests = max(server_requests)\n    return [i for i in range(k) if server_requests[i] == max_requests]"}}}}, "78": {"gold": {"leetcode/leetcode_1986.txt": 1}, "retrieved": {"leetcode/leetcode_2611.txt": {"score": 0.9376084804534912, "content": {"text": "def maxPoints(reward1, reward2, k):\n    \"\"\"There are two mice and `n` different types of cheese, each type of cheese should be eaten by exactly one mouse.\n\nA point of the cheese with index `i` (**0-indexed**) is:\n\n*   `reward1[i]` if the first mouse eats it.\n*   `reward2[i]` if the second mouse eats it.\n\nYou are given a positive integer array `reward1`, a positive integer array `reward2`, and a non-negative integer `k`.\n\nReturn _**the maximum** points the mice can achieve if the first mouse eats exactly_ `k` _types of cheese._\n\n**Example 1:**\n\n**Input:** reward1 = \\[1,1,3,4\\], reward2 = \\[4,4,1,1\\], k = 2\n**Output:** 15\n**Explanation:** In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\n**Example 2:**\n\n**Input:** reward1 = \\[1,1\\], reward2 = \\[1,1\\], k = 2\n**Output:** 2\n**Explanation:** In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n**Constraints:**\n\n*   `1 <= n == reward1.length == reward2.length <= 105`\n*   `1 <= reward1[i], reward2[i] <= 1000`\n*   `0 <= k <= n`\"\"\"\n\n    gap = sorted([(reward2[i] - reward1[i], i) for i in range(len(reward1))], reverse=True)\n    firstMousePoints = sum(reward1[gap[i][1]] for i in range(k))\n    secondMousePoints = sum(reward2[gap[i][1]] for i in range(k, len(reward1)))\n    return firstMousePoints + secondMousePoints"}}, "leetcode/leetcode_1383.txt": {"score": 0.9395882487297058, "content": {"text": "import heapq\n    \"\"\"You are given two integers `n` and `k` and two integer arrays `speed` and `efficiency` both of length `n`. There are `n` engineers numbered from `1` to `n`. `speed[i]` and `efficiency[i]` represent the speed and efficiency of the `ith` engineer respectively.\n\nChoose **at most** `k` different engineers out of the `n` engineers to form a team with the maximum **performance**.\n\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\n\nReturn _the maximum performance of this team_. Since the answer can be a huge number, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 2\n**Output:** 60\n**Explanation:** \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) \\* min(4, 7) = 60.\n\n**Example 2:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 3\n**Output:** 68\n**Explanation:**\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) \\* min(5, 4, 7) = 68.\n\n**Example 3:**\n\n**Input:** n = 6, speed = \\[2,10,3,1,5,8\\], efficiency = \\[5,4,3,9,7,2\\], k = 4\n**Output:** 72\n\n**Constraints:**\n\n*   `1 <= k <= n <= 105`\n*   `speed.length == n`\n*   `efficiency.length == n`\n*   `1 <= speed[i] <= 105`\n*   `1 <= efficiency[i] <= 108`\"\"\"\n\nfrom typing import List\n\ndef max_performance(n: int, k: int, speed: List[int], efficiency: List[int]) -> int:\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    min_heap = []\n    speed_sum = 0\n    max_performance = 0\n\n    for e, s in engineers:\n        speed_sum += s\n        heapq.heappush(min_heap, s)\n\n        if len(min_heap) > k:\n            speed_sum -= heapq.heappop(min_heap)\n\n        max_performance = max(max_performance, speed_sum * e)\n\n    return max_performance % (10**9 + 7)"}}, "leetcode/leetcode_2141.txt": {"score": 0.9377109408378601, "content": {"text": "def max_computer_runtime(n, batteries):\n    \"\"\"You have `n` computers. You are given the integer `n` and a **0-indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries.\n\nInitially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\nNote that the batteries cannot be recharged.\n\nReturn _the **maximum** number of minutes you can run all the_ `n` _computers simultaneously._\n\n**Example 1:**\n\n**Input:** n = 2, batteries = \\[3,3,3\\]\n**Output:** 4\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n**Example 2:**\n\n**Input:** n = 2, batteries = \\[1,1,1,1\\]\n**Output:** 2\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.\n\n**Constraints:**\n\n*   `1 <= n <= batteries.length <= 105`\n*   `1 <= batteries[i] <= 109`\"\"\"\n\n    batteries.sort()\n    result = 0\n    for i in range(len(batteries)):\n        result = max(result, min(n, len(batteries) - i) * batteries[i])\n    return result"}}, "leetcode/leetcode_561.txt": {"score": 0.9459225535392761, "content": {"text": "def array_pair_sum(nums):\n    \"\"\"Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is **maximized**. Return _the maximized sum_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,4,3,2\\]\n**Output:** 4\n**Explanation:** All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\n\n**Example 2:**\n\n**Input:** nums = \\[6,2,6,5,1,2\\]\n**Output:** 9\n**Explanation:** The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `nums.length == 2 * n`\n*   `-104 <= nums[i] <= 104`\"\"\"\n\n    nums.sort()\n    return sum(nums[::2])"}}, "leetcode/leetcode_826.txt": {"score": 0.9415422081947327, "content": {"text": "def maxProfitAssignment(difficulty, profit, worker):\n    \"\"\"You have `n` jobs and `m` workers. You are given three arrays: `difficulty`, `profit`, and `worker` where:\n\n*   `difficulty[i]` and `profit[i]` are the difficulty and the profit of the `ith` job, and\n*   `worker[j]` is the ability of `jth` worker (i.e., the `jth` worker can only complete a job with difficulty at most `worker[j]`).\n\nEvery worker can be assigned **at most one job**, but one job can be **completed multiple times**.\n\n*   For example, if three workers attempt the same job that pays `$1`, then the total profit will be `$3`. If a worker cannot complete any job, their profit is `$0`.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n\n**Example 1:**\n\n**Input:** difficulty = \\[2,4,6,8,10\\], profit = \\[10,20,30,40,50\\], worker = \\[4,5,6,7\\]\n**Output:** 100\n**Explanation:** Workers are assigned jobs of difficulty \\[4,4,6,6\\] and they get a profit of \\[20,20,30,30\\] separately.\n\n**Example 2:**\n\n**Input:** difficulty = \\[85,47,57\\], profit = \\[24,66,99\\], worker = \\[40,25,25\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == difficulty.length`\n*   `n == profit.length`\n*   `m == worker.length`\n*   `1 <= n, m <= 104`\n*   `1 <= difficulty[i], profit[i], worker[i] <= 105`\"\"\"\n\n    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit"}}, "leetcode/leetcode_1029.txt": {"score": 0.9446679353713989, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"A company is planning to interview `2n` people. Given the array `costs` where `costs[i] = [aCosti, bCosti]`, the cost of flying the `ith` person to city `a` is `aCosti`, and the cost of flying the `ith` person to city `b` is `bCosti`.\n\nReturn _the minimum cost to fly every person to a city_ such that exactly `n` people arrive in each city.\n\n**Example 1:**\n\n**Input:** costs = \\[\\[10,20\\],\\[30,200\\],\\[400,50\\],\\[30,20\\]\\]\n**Output:** 110\n**Explanation:** \nThe first person goes to city A for a cost of 10.\nThe second person goes to city A for a cost of 30.\nThe third person goes to city B for a cost of 50.\nThe fourth person goes to city B for a cost of 20.\n\nThe total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.\n\n**Example 2:**\n\n**Input:** costs = \\[\\[259,770\\],\\[448,54\\],\\[926,667\\],\\[184,139\\],\\[840,118\\],\\[577,469\\]\\]\n**Output:** 1859\n\n**Example 3:**\n\n**Input:** costs = \\[\\[515,563\\],\\[451,713\\],\\[537,709\\],\\[343,819\\],\\[855,779\\],\\[457,60\\],\\[650,359\\],\\[631,42\\]\\]\n**Output:** 3086\n\n**Constraints:**\n\n*   `2 * n == costs.length`\n*   `2 <= costs.length <= 100`\n*   `costs.length` is even.\n*   `1 <= aCosti, bCosti <= 1000`\"\"\"\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef verticalTraversal(root):\n    if not root:\n        return []\n\n    columns = defaultdict(lambda: defaultdict(list))\n    q = deque([(root, 0, 0)])\n\n    while q:\n        node, row, col = q.popleft()\n        columns[col][row].append(node.val)\n        columns[col][row].sort()\n\n        if node.left:\n            q.append((node.left, row + 1, col - 1))\n        if node.right:\n            q.append((node.right, row + 1, col + 1))\n\n    return [[val for row in column_data.values() for val in row] for column_data in sorted(columns.values())]"}}, "leetcode/leetcode_1877.txt": {"score": 0.947667121887207, "content": {"text": "def minPairSum(nums):\n    \"\"\"The **pair sum** of a pair `(a,b)` is equal to `a + b`. The **maximum pair sum** is the largest **pair sum** in a list of pairs.\n\n*   For example, if we have pairs `(1,5)`, `(2,3)`, and `(4,4)`, the **maximum pair sum** would be `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`.\n\nGiven an array `nums` of **even** length `n`, pair up the elements of `nums` into `n / 2` pairs such that:\n\n*   Each element of `nums` is in **exactly one** pair, and\n*   The **maximum pair sum** is **minimized**.\n\nReturn _the minimized **maximum pair sum** after optimally pairing up the elements_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,5,2,3\\]\n**Output:** 7\n**Explanation:** The elements can be paired up into pairs (3,3) and (5,2).\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\n\n**Example 2:**\n\n**Input:** nums = \\[3,5,4,2,4,6\\]\n**Output:** 8\n**Explanation:** The elements can be paired up into pairs (3,5), (4,4), and (6,2).\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 105`\n*   `n` is **even**.\n*   `1 <= nums[i] <= 105`\"\"\"\n\n    nums.sort()\n    max_sum = 0\n    for i in range(len(nums) // 2):\n        max_sum = max(max_sum, nums[i] + nums[-1 - i])\n    return max_sum"}}, "leetcode/leetcode_2551.txt": {"score": 0.9483776092529297, "content": {"text": "def maximize_score(weights, k):\n    \"\"\"You have `k` bags. You are given a **0-indexed** integer array `weights` where `weights[i]` is the weight of the `ith` marble. You are also given the integer `k.`\n\nDivide the marbles into the `k` bags according to the following rules:\n\n*   No bag is empty.\n*   If the `ith` marble and `jth` marble are in a bag, then all marbles with an index between the `ith` and `jth` indices should also be in that same bag.\n*   If a bag consists of all the marbles with an index from `i` to `j` inclusively, then the cost of the bag is `weights[i] + weights[j]`.\n\nThe **score** after distributing the marbles is the sum of the costs of all the `k` bags.\n\nReturn _the **difference** between the **maximum** and **minimum** scores among marble distributions_.\n\n**Example 1:**\n\n**Input:** weights = \\[1,3,5,1\\], k = 2\n**Output:** 4\n**Explanation:** \nThe distribution \\[1\\],\\[3,5,1\\] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution \\[1,3\\],\\[5,1\\], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n\n**Example 2:**\n\n**Input:** weights = \\[1, 3\\], k = 2\n**Output:** 0\n**Explanation:** The only distribution possible is \\[1\\],\\[3\\]. \nSince both the maximal and minimal score are the same, we return 0.\n\n**Constraints:**\n\n*   `1 <= k <= weights.length <= 105`\n*   `1 <= weights[i] <= 109`\"\"\"\n\n    n = len(weights)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n    dp = [[-1000000000] * (k + 1) for _ in range(n)]\n\n    for i in range(n):\n        dp[i][1] = prefix_sum[i + 1]\n        if i > 0:\n            dp[i][i + 1] = prefix_sum[i + 1] - prefix_sum[1]\n        for j in range(2, min(i + 1, k) + 1):\n            for q in range(1, i - j + 3):\n                dp[i][j] = max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q])\n\n    return dp[n - 1][k] - dp[n - 1][1]"}}, "leetcode/leetcode_2305.txt": {"score": 0.9739221930503845, "content": {"text": "def min_append_k_sum(nums, k):\n    \"\"\"You are given an integer array `cookies`, where `cookies[i]` denotes the number of cookies in the `ith` bag. You are also given an integer `k` that denotes the number of children to distribute **all** the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.\n\nThe **unfairness** of a distribution is defined as the **maximum** **total** cookies obtained by a single child in the distribution.\n\nReturn _the **minimum** unfairness of all distributions_.\n\n**Example 1:**\n\n**Input:** cookies = \\[8,15,10,20,8\\], k = 2\n**Output:** 31\n**Explanation:** One optimal distribution is \\[8,15,8\\] and \\[10,20\\]\n- The 1st child receives \\[8,15,8\\] which has a total of 8 + 15 + 8 = 31 cookies.\n- The 2nd child receives \\[10,20\\] which has a total of 10 + 20 = 30 cookies.\nThe unfairness of the distribution is max(31,30) = 31.\nIt can be shown that there is no distribution with an unfairness less than 31.\n\n**Example 2:**\n\n**Input:** cookies = \\[6,1,3,2,2,4,1,2\\], k = 3\n**Output:** 7\n**Explanation:** One optimal distribution is \\[6,1\\], \\[3,2,2\\], and \\[4,1,2\\]\n- The 1st child receives \\[6,1\\] which has a total of 6 + 1 = 7 cookies.\n- The 2nd child receives \\[3,2,2\\] which has a total of 3 + 2 + 2 = 7 cookies.\n- The 3rd child receives \\[4,1,2\\] which has a total of 4 + 1 + 2 = 7 cookies.\nThe unfairness of the distribution is max(7,7,7) = 7.\nIt can be shown that there is no distribution with an unfairness less than 7.\n\n**Constraints:**\n\n*   `2 <= cookies.length <= 8`\n*   `1 <= cookies[i] <= 105`\n*   `2 <= k <= cookies.length`\"\"\"\n\n    max_elem = max(nums)\n    return sum(range(max_elem + 1, max_elem + k + 1))"}}, "leetcode/leetcode_1723.txt": {"score": 0.9897316098213196, "content": {"text": "def max_achievable_requests(n, requests, idx=0, counts=None):\n    \"\"\"You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`\"\"\"\n\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)"}}}}, "79": {"gold": {"leetcode/leetcode_789.txt": 1, "leetcode/leetcode_913.txt": 1}, "retrieved": {"leetcode/leetcode_741.txt": {"score": 0.9017290472984314, "content": {"text": "def cherryPickup(self, grid: List[List[int]]) -> int:\n    \"\"\"You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.\n\n*   `0` means the cell is empty, so you can pass through,\n*   `1` means the cell contains a cherry that you can pick up and pass through, or\n*   `-1` means the cell contains a thorn that blocks your way.\n\nReturn _the maximum number of cherries you can collect by following the rules below_:\n\n*   Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).\n*   After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.\n*   When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.\n*   If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,-1\\],\\[1,0,-1\\],\\[1,1,1\\]\\]\n**Output:** 5\n**Explanation:** The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes \\[\\[0,1,-1\\],\\[0,0,-1\\],\\[0,0,0\\]\\].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,-1\\],\\[1,-1,1\\],\\[-1,1,1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `grid[i][j]` is `-1`, `0`, or `1`.\n*   `grid[0][0] != -1`\n*   `grid[n - 1][n - 1] != -1`\"\"\"\n\n    def dp(r1, c1, c2):\n        r2 = r1 + c1 - c2\n        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or\n            grid[r1][c1] == -1 or grid[r2][c2] == -1):\n            return float('-inf')\n        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:\n            return grid[r1][c1]\n        elif memo[r1][c1][c2] != float('-inf'):\n            return memo[r1][c1][c2]\n        else:\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]\n            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),\n                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))\n            memo[r1][c1][c2] += max_cherries\n        \n        return memo[r1][c1][c2]\n    \n    N = len(grid)\n    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]\n    return max(0, dp(0, 0, 0))"}}, "leetcode/leetcode_864.txt": {"score": 0.9071200489997864, "content": {"text": "def largestOverlap(img1, img2):\n    \"\"\"You are given an `m x n` grid `grid` where:\n\n*   `'.'` is an empty cell.\n*   `'#'` is a wall.\n*   `'@'` is the starting point.\n*   Lowercase letters represent keys.\n*   Uppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n\nFor some `1 <= k <= 6`, there is exactly one lowercase and one uppercase letter of the first `k` letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n\nReturn _the lowest number of moves to acquire all keys_. If it is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \"@.a.. \", \"###.# \", \"b.A.B \"\\]\n**Output:** 8\n**Explanation:** Note that the goal is to obtain all the keys not to open all the locks.\n\n**Example 2:**\n\n**Input:** grid = \\[ \"@..aA \", \"..B#. \", \"....b \"\\]\n**Output:** 6\n\n**Example 3:**\n\n**Input:** grid = \\[ \"@Aa \"\\]\n**Output:** -1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either an English letter, `'.'`, `'#'`, or `'@'`.\n*   The number of keys in the grid is in the range `[1, 6]`.\n*   Each key in the grid is **unique**.\n*   Each key in the grid has a matching lock.\"\"\"\n\n    n = len(img1)\n    onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]\n    onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]\n\n    overlaps = {}\n    for pt1 in onesImg1:\n        for pt2 in onesImg2:\n            dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1]\n            key = (dx, dy)\n            if key not in overlaps:\n                overlaps[key] = 0\n            overlaps[key] += 1\n\n    return max(overlaps.values() or [0])"}}, "leetcode/leetcode_999.txt": {"score": 0.9143713712692261, "content": {"text": "def regionsBySlashes(grid):\n    \"\"\"On an `8 x 8` chessboard, there is **exactly one** white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered **attacking** a pawn if the rook can capture the pawn on the rook's turn. The **number of available captures** for the white rook is the number of pawns that the rook is **attacking**.\n\nReturn _the **number of available captures** for the white rook_.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"R \", \". \", \". \", \". \", \"p \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** In this example, the rook is attacking all the pawns.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"B \", \"R \", \"B \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 0\n**Explanation:** The bishops are blocking the rook from attacking any of the pawns.\n\n**Example 3:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \"p \", \"p \", \". \", \"R \", \". \", \"p \", \"B \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** The rook is attacking the pawns at positions b5, d6, and f5.\n\n**Constraints:**\n\n*   `board.length == 8`\n*   `board[i].length == 8`\n*   `board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`\n*   There is exactly one cell with `board[i][j] == 'R'`\"\"\"\n\n    n = len(grid)\n    graph = [[0] * (n * 3) for _ in range(n * 3)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '/':\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1\n            if grid[i][j] == '\\\\':\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1\n\n    regions = 0\n    for i in range(n * 3):\n        for j in range(n * 3):\n            if not graph[i][j]:\n                regions += 1\n                dfs(graph, i, j)\n\n    return regions\n\ndef dfs(graph, i, j):\n    n = len(graph)\n    if i < 0 or j < 0 or i >= n or j >= n or graph[i][j]:\n        return\n\n    graph[i][j] = 1\n    dfs(graph, i - 1, j)\n    dfs(graph, i + 1, j)\n    dfs(graph, i, j - 1)\n    dfs(graph, i, j + 1)"}}, "leetcode/leetcode_909.txt": {"score": 0.9092645645141602, "content": {"text": "def aliceWins(piles):\n    \"\"\"You are given an `n x n` integer matrix `board` where the cells are labeled from `1` to `n2` in a [**Boustrophedon style**](https://en.wikipedia.org/wiki/Boustrophedon) starting from the bottom left of the board (i.e. `board[n - 1][0]`) and alternating direction each row.\n\nYou start on square `1` of the board. In each move, starting from square `curr`, do the following:\n\n*   Choose a destination square `next` with a label in the range `[curr + 1, min(curr + 6, n2)]`.\n    *   This choice simulates the result of a standard **6-sided die roll**: i.e., there are always at most 6 destinations, regardless of the size of the board.\n*   If `next` has a snake or ladder, you **must** move to the destination of that snake or ladder. Otherwise, you move to `next`.\n*   The game ends when you reach the square `n2`.\n\nA board square on row `r` and column `c` has a snake or ladder if `board[r][c] != -1`. The destination of that snake or ladder is `board[r][c]`. Squares `1` and `n2` do not have a snake or ladder.\n\nNote that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do **not** follow the subsequent snake or ladder.\n\n*   For example, suppose the board is `[[-1,4],[-1,3]]`, and on the first move, your destination square is `2`. You follow the ladder to square `3`, but do **not** follow the subsequent ladder to `4`.\n\nReturn _the least number of moves required to reach the square_ `n2`_. If it is not possible to reach the square, return_ `-1`.\n\n**Example 1:**\n\n**Input:** board = \\[\\[-1,-1,-1,-1,-1,-1\\],\\[-1,-1,-1,-1,-1,-1\\],\\[-1,-1,-1,-1,-1,-1\\],\\[-1,35,-1,-1,13,-1\\],\\[-1,-1,-1,-1,-1,-1\\],\\[-1,15,-1,-1,-1,-1\\]\\]\n**Output:** 4\n**Explanation:** \nIn the beginning, you start at square 1 (at row 5, column 0).\nYou decide to move to square 2 and must take the ladder to square 15.\nYou then decide to move to square 17 and must take the snake to square 13.\nYou then decide to move to square 14 and must take the ladder to square 35.\nYou then decide to move to square 36, ending the game.\nThis is the lowest possible number of moves to reach the last square, so return 4.\n\n**Example 2:**\n\n**Input:** board = \\[\\[-1,-1\\],\\[-1,3\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == board.length == board[i].length`\n*   `2 <= n <= 20`\n*   `board[i][j]` is either `-1` or in the range `[1, n2]`.\n*   The squares labeled `1` and `n2` do not have any ladders or snakes.\"\"\"\n\n    n = len(piles)\n    dp = [[0] * n for _ in range(n)]\n    for gap in range(n):\n        for i in range(n - gap):\n            j = i + gap\n            x = dp[i + 2][j] if i + 2 <= j else 0\n            y = dp[i + 1][j - 1] if i + 1 <= j - 1 else 0\n            z = dp[i][j - 2] if i <= j - 2 else 0\n            dp[i][j] = max(piles[i] + min(x, y), piles[j] + min(y, z))\n    sum_of_piles = sum(piles)\n    return dp[0][n - 1] > (sum_of_piles - dp[0][n - 1])"}}, "leetcode/leetcode_913.txt": {"score": 0.9267124533653259, "content": {"text": "import random\n    \"\"\"A game on an **undirected** graph is played by two players, Mouse and Cat, who alternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that `ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first, the cat starts at node `2` and goes second, and there is a hole at node `0`.\n\nDuring each player's turn, they **must** travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it **must** travel to any node in `graph[1]`.\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n\nThen, the game can end in three ways:\n\n*   If ever the Cat occupies the same node as the Mouse, the Cat wins.\n*   If ever the Mouse reaches the Hole, the Mouse wins.\n*   If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a `graph`, and assuming both players play optimally, return\n\n*   `1` if the mouse wins the game,\n*   `2` if the cat wins the game, or\n*   `0` if the game is a draw.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[2,5\\],\\[3\\],\\[0,4,5\\],\\[1,4,5\\],\\[2,3\\],\\[0,2,3\\]\\]\n**Output:** 0\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,3\\],\\[0\\],\\[3\\],\\[0,2\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `3 <= graph.length <= 50`\n*   `1 <= graph[i].length < graph.length`\n*   `0 <= graph[i][j] < graph.length`\n*   `graph[i][j] != i`\n*   `graph[i]` is unique.\n*   The mouse and the cat can always move.\"\"\"\n\n\nclass Solution:\n    def __init__(self, m, n):\n        self.grid = [[0] * n for _ in range(m)]\n        self.zero_count = m * n\n\n    def pick(self):\n        index = random.randrange(self.zero_count)\n\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                if cell == 0:\n                    if index == 0:\n                        self.grid[i][j] = 1\n                        self.zero_count -= 1\n                        return (i, j)\n                    index -= 1\n        return (-1, -1)  # Should not happen"}}, "leetcode/leetcode_789.txt": {"score": 0.9307687878608704, "content": {"text": "import heapq\n    \"\"\"You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point `[0, 0]`, and you are given a destination point `target = [xtarget, ytarget]` that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array `ghosts`, where `ghosts[i] = [xi, yi]` represents the starting position of the `ith` ghost. All inputs are **integral coordinates**.\n\nEach turn, you and all the ghosts may independently choose to either **move 1 unit** in any of the four cardinal directions: north, east, south, or west, or **stay still**. All actions happen **simultaneously**.\n\nYou escape if and only if you can reach the target **before** any ghost reaches you. If you reach any square (including the target) at the **same time** as a ghost, it **does not** count as an escape.\n\nReturn `true` _if it is possible to escape regardless of how the ghosts move, otherwise return_ `false`_._\n\n**Example 1:**\n\n**Input:** ghosts = \\[\\[1,0\\],\\[0,3\\]\\], target = \\[0,1\\]\n**Output:** true\n**Explanation:** You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you.\n\n**Example 2:**\n\n**Input:** ghosts = \\[\\[1,0\\]\\], target = \\[2,0\\]\n**Output:** false\n**Explanation:** You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.\n\n**Example 3:**\n\n**Input:** ghosts = \\[\\[2,0\\]\\], target = \\[1,0\\]\n**Output:** false\n**Explanation:** The ghost can reach the target at the same time as you.\n\n**Constraints:**\n\n*   `1 <= ghosts.length <= 100`\n*   `ghosts[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   There can be **multiple ghosts** in the same location.\n*   `target.length == 2`\n*   `-104 <= xtarget, ytarget <= 104`\"\"\"\n\n\nclass KthLargest:\n\n    def __init__(self, k, nums):\n        self.heap = []\n        self.k = k\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.heap, val)\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        return self.heap[0]"}}, "leetcode/leetcode_1036.txt": {"score": 0.9229996204376221, "content": {"text": "from collections import deque\n    \"\"\"There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are `(x, y)`.\n\nWe start at the `source = [sx, sy]` square and want to reach the `target = [tx, ty]` square. There is also an array of `blocked` squares, where each `blocked[i] = [xi, yi]` represents a blocked square with coordinates `(xi, yi)`.\n\nEach move, we can walk one square north, east, south, or west if the square is **not** in the array of `blocked` squares. We are also not allowed to walk outside of the grid.\n\nReturn `true` _if and only if it is possible to reach the_ `target` _square from the_ `source` _square through a sequence of valid moves_.\n\n**Example 1:**\n\n**Input:** blocked = \\[\\[0,1\\],\\[1,0\\]\\], source = \\[0,0\\], target = \\[0,2\\]\n**Output:** false\n**Explanation:** The target square is inaccessible starting from the source square because we cannot move.\nWe cannot move north or east because those squares are blocked.\nWe cannot move south or west because we cannot go outside of the grid.\n\n**Example 2:**\n\n**Input:** blocked = \\[\\], source = \\[0,0\\], target = \\[999999,999999\\]\n**Output:** true\n**Explanation:** Because there are no blocked cells, it is possible to reach the target square.\n\n**Constraints:**\n\n*   `0 <= blocked.length <= 200`\n*   `blocked[i].length == 2`\n*   `0 <= xi, yi < 106`\n*   `source.length == target.length == 2`\n*   `0 <= sx, sy, tx, ty < 106`\n*   `source != target`\n*   It is guaranteed that `source` and `target` are not blocked.\"\"\"\n\n\ndef orangesRotting(grid):\n    m, n = len(grid), len(grid[0])\n    fresh_oranges = sum(row.count(1) for row in grid)\n    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])\n    \n    minutes = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while rotten and fresh_oranges:\n        for _ in range(len(rotten)):\n            x, y = rotten.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh_oranges -= 1\n                    rotten.append((nx, ny))\n        minutes += 1\n\n    return minutes if fresh_oranges == 0 else -1"}}, "leetcode/leetcode_1728.txt": {"score": 0.9968332052230835, "content": {"text": "class Fancy:\n    \"\"\"A game is played by a cat and a mouse named Cat and Mouse.\n\nThe environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.\n\n*   Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).\n*   Floors are represented by the character `'.'` and can be walked on.\n*   Walls are represented by the character `'#'` and cannot be walked on.\n*   Food is represented by the character `'F'` and can be walked on.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n\nMouse and Cat play according to the following rules:\n\n*   Mouse **moves first**, then they take turns to move.\n*   During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.\n*   `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n*   Staying in the same position is allowed.\n*   Mouse can jump over Cat.\n\nThe game can end in 4 ways:\n\n*   If Cat occupies the same position as Mouse, Cat wins.\n*   If Cat reaches the food first, Cat wins.\n*   If Mouse reaches the food first, Mouse wins.\n*   If Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` _if Mouse can win the game if both Cat and Mouse play optimally, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \"####F \", \"#C... \", \"M.... \"\\], catJump = 1, mouseJump = 2\n**Output:** true\n**Explanation:** Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\n**Example 2:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 4\n**Output:** true\n\n**Example 3:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 3\n**Output:** false\n\n**Constraints:**\n\n*   `rows == grid.length`\n*   `cols = grid[i].length`\n*   `1 <= rows, cols <= 8`\n*   `grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n*   `1 <= catJump, mouseJump <= 8`\"\"\"\n\n    def __init__(self):\n        self.sequence = []\n\n    def append(self, val):\n        self.sequence.append(val)\n\n    def addAll(self, inc):\n        self.sequence = [num + inc for num in self.sequence]\n\n    def multAll(self, m):\n        self.sequence = [num * m for num in self.sequence]\n\n    def getIndex(self, idx):\n        if idx >= len(self.sequence):\n            return -1\n        return self.sequence[idx]"}}, "leetcode/leetcode_2258.txt": {"score": 0.924680769443512, "content": {"text": "from collections import deque\n    \"\"\"You are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:\n\n*   `0` represents grass,\n*   `1` represents fire,\n*   `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls.\n\nReturn _the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\nA cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2,0,0,0,0,0\\],\\[0,0,0,2,2,1,0\\],\\[0,2,0,0,1,2,0\\],\\[0,0,2,2,2,0,2\\],\\[0,0,0,0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[0,1,2,0\\],\\[0,2,0,0\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[2,2,0\\],\\[1,2,0\\]\\]\n**Output:** 1000000000\n**Explanation:** The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 300`\n*   `4 <= m * n <= 2 * 104`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`\"\"\"\n\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef getMaxSafeMinutes(grid):\n    m, n = len(grid), len(grid[0])\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n    q = deque()\n\n    if grid[m - 1][n - 1] != 1:\n        dist[m - 1][n - 1] = 0\n        q.append((m - 1, n - 1))\n\n    while q:\n        x, y = q.popleft()\n        for d in range(4):\n            nx, ny = x + dx[d], y + dy[d]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\n    if dist[0][0] == -1:\n        return -1\n\n    res = 0\n    for test in range(dist[0][0], int(1e9)):\n        ok = True\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    for d in range(4):\n                        nx, ny = x + dx[d], y + dy[d]\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:\n                            break\n                    else:\n                        ok = False\n                        break\n        if ok:\n            res = test\n        else:\n            break\n    return res"}}, "leetcode/leetcode_794.txt": {"score": 0.9304684996604919, "content": {"text": "import heapq\n    \"\"\"Given a Tic-Tac-Toe board as a string array `board`, return `true` if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\n\nThe board is a `3 x 3` array that consists of characters `' '`, `'X'`, and `'O'`. The `' '` character represents an empty square.\n\nHere are the rules of Tic-Tac-Toe:\n\n*   Players take turns placing characters into empty squares `' '`.\n*   The first player always places `'X'` characters, while the second player always places `'O'` characters.\n*   `'X'` and `'O'` characters are always placed into empty squares, never filled ones.\n*   The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n*   The game also ends if all squares are non-empty.\n*   No more moves can be played if the game is over.\n\n**Example 1:**\n\n**Input:** board = \\[ \"O   \", \"    \", \"    \"\\]\n**Output:** false\n**Explanation:** The first player always plays  \"X \".\n\n**Example 2:**\n\n**Input:** board = \\[ \"XOX \", \" X  \", \"    \"\\]\n**Output:** false\n**Explanation:** Players take turns making moves.\n\n**Example 3:**\n\n**Input:** board = \\[ \"XOX \", \"O O \", \"XOX \"\\]\n**Output:** true\n\n**Constraints:**\n\n*   `board.length == 3`\n*   `board[i].length == 3`\n*   `board[i][j]` is either `'X'`, `'O'`, or `' '`.\"\"\"\n\n\ndef swim(n, grid):\n    pq = [(grid[0][0], 0, 0)]\n    visited = [[False] * n for _ in range(n)]\n\n    dr = [-1, 0, 1, 0]\n    dc = [0, 1, 0, -1]\n\n    while pq:\n        curT, curR, curC = heapq.heappop(pq)\n\n        if curR == n - 1 and curC == n - 1:\n            return curT\n\n        for d in range(4):\n            newRow, newCol = curR + dr[d], curC + dc[d]\n            if 0 <= newRow < n and 0 <= newCol < n and not visited[newRow][newCol]:\n                visited[newRow][newCol] = True\n                heapq.heappush(pq, (max(curT, grid[newRow][newCol]), newRow, newCol))\n\n    return -1"}}}}, "80": {"gold": {"leetcode/leetcode_1353.txt": 1, "leetcode/leetcode_2008.txt": 1, "leetcode/leetcode_2054.txt": 1, "leetcode/leetcode_2402.txt": 1}, "retrieved": {"leetcode/leetcode_1537.txt": {"score": 0.911942720413208, "content": {"text": "def maxScore(s):\n    \"\"\"You are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid path** is defined as follows:\n\n*   Choose array `nums1` or `nums2` to traverse (from index-0).\n*   Traverse the current array from left to right.\n*   If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,4,5,8,10\\], nums2 = \\[4,6,8,9\\]\n**Output:** 30\n**Explanation:** Valid paths:\n\\[2,4,5,8,10\\], \\[2,4,5,8,9\\], \\[2,4,6,8,9\\], \\[2,4,6,8,10\\],  (starting from nums1)\n\\[4,6,8,9\\], \\[4,5,8,10\\], \\[4,5,8,9\\], \\[4,6,8,10\\]    (starting from nums2)\nThe maximum is obtained with the path in green **\\[2,4,6,8,10\\]**.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,3,5,7,9\\], nums2 = \\[3,5,100\\]\n**Output:** 109\n**Explanation:** Maximum sum is obtained with the path **\\[1,3,5,100\\]**.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[6,7,8,9,10\\]\n**Output:** 40\n**Explanation:** There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path \\[6,7,8,9,10\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 107`\n*   `nums1` and `nums2` are strictly increasing.\"\"\"\n\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score"}}, "leetcode/leetcode_502.txt": {"score": 0.9120951294898987, "content": {"text": "import heapq\n    \"\"\"Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the **IPO**. Since it has limited resources, it can only finish at most `k` distinct projects before the **IPO**. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.\n\nYou are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.\n\nInitially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return _the final maximized capital_.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n**Example 1:**\n\n**Input:** k = 2, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,1\\]\n**Output:** 4\n**Explanation:** Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** k = 3, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,2\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= k <= 105`\n*   `0 <= w <= 109`\n*   `n == profits.length`\n*   `n == capital.length`\n*   `1 <= n <= 105`\n*   `0 <= profits[i] <= 104`\n*   `0 <= capital[i] <= 109`\"\"\"\n\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w"}}, "leetcode/leetcode_826.txt": {"score": 0.9379984736442566, "content": {"text": "def maxProfitAssignment(difficulty, profit, worker):\n    \"\"\"You have `n` jobs and `m` workers. You are given three arrays: `difficulty`, `profit`, and `worker` where:\n\n*   `difficulty[i]` and `profit[i]` are the difficulty and the profit of the `ith` job, and\n*   `worker[j]` is the ability of `jth` worker (i.e., the `jth` worker can only complete a job with difficulty at most `worker[j]`).\n\nEvery worker can be assigned **at most one job**, but one job can be **completed multiple times**.\n\n*   For example, if three workers attempt the same job that pays `$1`, then the total profit will be `$3`. If a worker cannot complete any job, their profit is `$0`.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n\n**Example 1:**\n\n**Input:** difficulty = \\[2,4,6,8,10\\], profit = \\[10,20,30,40,50\\], worker = \\[4,5,6,7\\]\n**Output:** 100\n**Explanation:** Workers are assigned jobs of difficulty \\[4,4,6,6\\] and they get a profit of \\[20,20,30,30\\] separately.\n\n**Example 2:**\n\n**Input:** difficulty = \\[85,47,57\\], profit = \\[24,66,99\\], worker = \\[40,25,25\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == difficulty.length`\n*   `n == profit.length`\n*   `m == worker.length`\n*   `1 <= n, m <= 104`\n*   `1 <= difficulty[i], profit[i], worker[i] <= 105`\"\"\"\n\n    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit"}}, "leetcode/leetcode_1710.txt": {"score": 0.9127963781356812, "content": {"text": "import heapq\n    \"\"\"You are assigned to put some amount of boxes onto **one truck**. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`:\n\n*   `numberOfBoxesi` is the number of boxes of type `i`.\n*   `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.\n\nYou are also given an integer `truckSize`, which is the **maximum** number of **boxes** that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.\n\nReturn _the **maximum** total number of **units** that can be put on the truck._\n\n**Example 1:**\n\n**Input:** boxTypes = \\[\\[1,3\\],\\[2,2\\],\\[3,1\\]\\], truckSize = 4\n**Output:** 8\n**Explanation:** There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 \\* 3) + (2 \\* 2) + (1 \\* 1) = 8.\n\n**Example 2:**\n\n**Input:** boxTypes = \\[\\[5,10\\],\\[2,5\\],\\[4,7\\],\\[3,9\\]\\], truckSize = 10\n**Output:** 91\n\n**Constraints:**\n\n*   `1 <= boxTypes.length <= 1000`\n*   `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`\n*   `1 <= truckSize <= 106`\"\"\"\n\n\ndef busiest_servers(k, arrival, load):\n    server_requests = [0] * k\n    pq = []\n    available_servers = list(range(k))\n\n    for i in range(len(arrival)):\n        while pq and pq[0][0] <= arrival[i]:\n            _, server_id = heapq.heappop(pq)\n            available_servers.append(server_id)\n\n        if available_servers:\n            server_id = available_servers.pop(0)\n            server_requests[server_id] += 1\n            heapq.heappush(pq, (arrival[i] + load[i], server_id))\n\n    max_requests = max(server_requests)\n    return [i for i in range(k) if server_requests[i] == max_requests]"}}, "leetcode/csn_python_train_308104.txt": {"score": 0.9277269244194031, "content": {"text": "def range_chain(ranges):\n    \"\"\"\n    Take list of weighted intervals, find non-overlapping set with max weight.\n    We proceed with each end point (sorted by their relative positions).\n\n    The input are a list of ranges of the form (start, stop, score), output is\n    subset of the non-overlapping ranges that give the highest score, score\n\n    >>> ranges = [Range(\"1\", 0, 9, 22, 0), Range(\"1\", 3, 18, 24, 1), Range(\"1\", 10, 28, 20, 2)]\n    >>> range_chain(ranges)\n    ([Range(seqid='1', start=0, end=9, score=22, id=0), Range(seqid='1', start=10, end=28, score=20, id=2)], 42)\n    >>> ranges = [Range(\"2\", 0, 1, 3, 0), Range(\"2\", 1, 4, 3, 1), Range(\"3\", 5, 7, 3, 2)]\n    >>> range_chain(ranges)\n    ([Range(seqid='2', start=0, end=1, score=3, id=0), Range(seqid='3', start=5, end=7, score=3, id=2)], 6)\n    \"\"\"\n    endpoints = _make_endpoints(ranges)\n\n    # stores the left end index for quick retrieval\n    left_index = {}\n    # dynamic programming, each entry [score, from_index, which_chain]\n    scores = []\n\n    for i, (seqid, pos, leftright, j, score) in enumerate(endpoints):\n\n        cur_score = [0, -1, -1] if i == 0 else scores[-1][:]\n\n        if leftright == LEFT:\n            left_index[j] = i\n\n        else:  # this is right end of j-th interval\n            # update if chaining j-th interval gives a better score\n            left_j = left_index[j]\n            chain_score = scores[left_j][0] + score\n            if chain_score > cur_score[0]:\n                cur_score = [chain_score, left_j, j]\n\n        scores.append(cur_score)\n\n    chains = []\n    score, last, chain_id = scores[-1]  # start backtracking\n    while last != -1:\n        if chain_id != -1:\n            chains.append(chain_id)\n        _, last, chain_id = scores[last]\n\n    chains.reverse()\n\n    selected = [ranges[x] for x in chains]\n\n    return selected, score"}}, "leetcode/leetcode_1353.txt": {"score": 0.9539288282394409, "content": {"text": "import heapq\n    \"\"\"You are given an array of `events` where `events[i] = [startDayi, endDayi]`. Every event `i` starts at `startDayi` and ends at `endDayi`.\n\nYou can attend an event `i` at any day `d` where `startTimei <= d <= endTimei`. You can only attend one event at any time `d`.\n\nReturn _the maximum number of events you can attend_.\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 3\n**Explanation:** You can attend all the three events.\nOne way to attend them all is as shown.\nAttend the first event on day 1.\nAttend the second event on day 2.\nAttend the third event on day 3.\n\n**Example 2:**\n\n**Input:** events= \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,2\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= events.length <= 105`\n*   `events[i].length == 2`\n*   `1 <= startDayi <= endDayi <= 105`\"\"\"\n\n\ndef maxEvents(events: List[List[int]]) -> int:\n    events.sort(key=lambda x: x[0])\n    min_heap = []\n    event_count, day = 0, 0\n\n    for event in events:\n        while min_heap and min_heap[0] < event[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, event[1])\n        event_count += 1\n        day += 1\n\n    return event_count"}}, "leetcode/leetcode_630.txt": {"score": 0.9390140175819397, "content": {"text": "import heapq\n    \"\"\"There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`.\n\nYou will start on the `1st` day and you cannot take two or more courses simultaneously.\n\nReturn _the maximum number of courses that you can take_.\n\n**Example 1:**\n\n**Input:** courses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]\n**Output:** 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n\n**Example 2:**\n\n**Input:** courses = \\[\\[1,2\\]\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** courses = \\[\\[3,2\\],\\[4,3\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= courses.length <= 104`\n*   `1 <= durationi, lastDayi <= 104`\"\"\"\n\n\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    curr_time, duration_sum = 0, []\n\n    for duration, deadline in courses:\n        curr_time += duration\n        heapq.heappush(duration_sum, -duration)\n\n        if curr_time > deadline:\n            curr_time += heapq.heappop(duration_sum)\n\n    return len(duration_sum)"}}, "leetcode/leetcode_1235.txt": {"score": 0.9670330286026001, "content": {"text": "from bisect import bisect_left\n    \"\"\"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.\n\nYou're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\nIf you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.\n\n**Example 1:**\n\n**Input:** startTime = \\[1,2,3,3\\], endTime = \\[3,4,5,6\\], profit = \\[50,10,40,70\\]\n**Output:** 120\n**Explanation:** The subset chosen is the first and fourth job. \nTime range \\[1-3\\]+\\[3-6\\] , we get profit of 120 = 50 + 70.\n\n**Example 2:**\n\n**Input:** startTime = \\[1,2,3,4,6\\], endTime = \\[3,5,10,6,9\\], profit = \\[20,20,100,70,60\\]\n**Output:** 150\n**Explanation:** The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n**Example 3:**\n\n**Input:** startTime = \\[1,1,1\\], endTime = \\[2,3,4\\], profit = \\[5,6,4\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`\n*   `1 <= startTime[i] < endTime[i] <= 109`\n*   `1 <= profit[i] <= 104`\"\"\"\n\n\ndef jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(endTime, startTime, profit))\n    dp = [jobs[0][2]]\n    \n    def latestNonConflict(index):\n        startTimeToFind = jobs[index][1]\n        index = bisect_left([job[0] for job in jobs], startTimeToFind)\n        if index:\n            return index - 1\n        return -1\n\n    for i in range(1, len(jobs)):\n        L = latestNonConflict(i)\n        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))\n\n    return dp[-1]"}}, "leetcode/leetcode_1751.txt": {"score": 0.9769692420959473, "content": {"text": "def slowestKey(releaseTimes, keysPressed):\n    \"\"\"You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn _the **maximum sum** of values that you can receive by attending events._\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,1\\]\\], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,10\\]\\], k = 2\n**Output:** 10\n**Explanation:** Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,1,1\\],\\[2,2,2\\],\\[3,3,3\\],\\[4,4,4\\]\\], k = 3\n**Output:** 9\n**Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n**Constraints:**\n\n*   `1 <= k <= events.length`\n*   `1 <= k * events.length <= 106`\n*   `1 <= startDayi <= endDayi <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    max_key = keysPressed[0]\n    max_duration = releaseTimes[0]\n    for i in range(1, len(releaseTimes)):\n        duration = releaseTimes[i] - releaseTimes[i - 1]\n        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):\n            max_key = keysPressed[i]\n            max_duration = duration\n    return max_key"}}, "leetcode/leetcode_2054.txt": {"score": 0.9795870184898376, "content": {"text": "def find_chair(times, target_friend):\n    \"\"\"You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose **at most** **two** **non-overlapping** events to attend such that the sum of their values is **maximized**.\n\nReturn _this **maximum** sum._\n\nNote that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[2,4,3\\]\\]\n**Output:** 4\n**Explanation:** Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[1,5,5\\]\\]\n**Output:** 5\n**Explanation:** Choose event 2 for a sum of 5.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,5,3\\],\\[1,5,1\\],\\[6,6,5\\]\\]\n**Output:** 8\n**Explanation:** Choose events 0 and 2 for a sum of 3 + 5 = 8.\n\n**Constraints:**\n\n*   `2 <= events.length <= 105`\n*   `events[i].length == 3`\n*   `1 <= startTimei <= endTimei <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    n = len(times)\n    events = []\n    for i, (arrival, leaving) in enumerate(times):\n        events.append((arrival, i))\n        events.append((leaving, ~i))\n    events.sort()\n    chairs = [-1] * n\n    available_chairs = sorted(range(n))\n    for time, friend_id in events:\n        if friend_id >= 0:\n            chairs[friend_id] = available_chairs.pop(0)\n            if friend_id == target_friend:\n                return chairs[friend_id]\n        else:\n            available_chairs.append(chairs[~friend_id])\n            available_chairs.sort()\n    return -1"}}}}, "81": {"gold": {"leetcode/leetcode_853.txt": 1, "leetcode/leetcode_2211.txt": 1}, "retrieved": {"leetcode/leetcode_986.txt": {"score": 0.8979009389877319, "content": {"text": "from itertools import permutations\n    \"\"\"You are given two lists of closed intervals, `firstList` and `secondList`, where `firstList[i] = [starti, endi]` and `secondList[j] = [startj, endj]`. Each list of intervals is pairwise **disjoint** and in **sorted order**.\n\nReturn _the intersection of these two interval lists_.\n\nA **closed interval** `[a, b]` (with `a <= b`) denotes the set of real numbers `x` with `a <= x <= b`.\n\nThe **intersection** of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of `[1, 3]` and `[2, 4]` is `[2, 3]`.\n\n**Example 1:**\n\n**Input:** firstList = \\[\\[0,2\\],\\[5,10\\],\\[13,23\\],\\[24,25\\]\\], secondList = \\[\\[1,5\\],\\[8,12\\],\\[15,24\\],\\[25,26\\]\\]\n**Output:** \\[\\[1,2\\],\\[5,5\\],\\[8,10\\],\\[15,23\\],\\[24,24\\],\\[25,25\\]\\]\n\n**Example 2:**\n\n**Input:** firstList = \\[\\[1,3\\],\\[5,9\\]\\], secondList = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `0 <= firstList.length, secondList.length <= 1000`\n*   `firstList.length + secondList.length >= 1`\n*   `0 <= starti < endi <= 109`\n*   `endi < starti+1`\n*   `0 <= startj < endj <= 109`\n*   `endj < startj+1`\"\"\"\n\n\ndef largestTimeFromDigits(arr):\n    max_time = -1\n    for h, i, j, k in permutations(arr):\n        hour = h * 10 + i\n        minute = j * 10 + k\n        time = hour * 60 + minute\n        if hour < 24 and minute < 60 and time > max_time:\n            max_time = time\n\n    if max_time == -1:\n        return \"\"\n    else:\n        return \"{:02d}:{:02d}\".format(max_time // 60, max_time % 60)"}}, "leetcode/leetcode_2589.txt": {"score": 0.8994847536087036, "content": {"text": "def min_time_on(tasks):\n    \"\"\"There is a computer that can run an unlimited number of tasks **at the same time**. You are given a 2D integer array `tasks` where `tasks[i] = [starti, endi, durationi]` indicates that the `ith` task should run for a total of `durationi` seconds (not necessarily continuous) within the **inclusive** time range `[starti, endi]`.\n\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\n\nReturn _the minimum time during which the computer should be turned on to complete all tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[2,3,1\\],\\[4,5,1\\],\\[1,5,2\\]\\]\n**Output:** 2\n**Explanation:** \n- The first task can be run in the inclusive time range \\[2, 2\\].\n- The second task can be run in the inclusive time range \\[5, 5\\].\n- The third task can be run in the two inclusive time ranges \\[2, 2\\] and \\[5, 5\\].\nThe computer will be on for a total of 2 seconds.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3,2\\],\\[2,5,3\\],\\[5,6,2\\]\\]\n**Output:** 4\n**Explanation:** \n- The first task can be run in the inclusive time range \\[2, 3\\].\n- The second task can be run in the inclusive time ranges \\[2, 3\\] and \\[5, 5\\].\n- The third task can be run in the two inclusive time range \\[5, 6\\].\nThe computer will be on for a total of 4 seconds.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 2000`\n*   `tasks[i].length == 3`\n*   `1 <= starti, endi <= 2000`\n*   `1 <= durationi <= endi - starti + 1`\"\"\"\n\n    intervals = sorted([[task[1] + 1, task[2]] for task in tasks])\n\n    dp = [0] * 2001\n    for interval in intervals:\n        for i in range(2000, interval[0] - 1, -1):\n            dp[i] = max(dp[i], dp[i - interval[1]] + interval[1])\n\n    return dp[-1]"}}, "leetcode/leetcode_1921.txt": {"score": 0.9098734855651855, "content": {"text": "def eliminate_maximum(dist, speed):\n    \"\"\"You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0-indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city.\n\nThe monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute.\n\nYou have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge.The weapon is fully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon.\n\nReturn _the **maximum** number of monsters that you can eliminate before you lose, or_ `n` _if you can eliminate all the monsters before they reach the city._\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,4\\], speed = \\[1,1,1\\]\n**Output:** 3\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,3,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,2,3\\]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are \\[X,X,2\\]. You eliminate the thrid monster.\nAll 3 monsters can be eliminated.\n\n**Example 2:**\n\n**Input:** dist = \\[1,1,2,3\\], speed = \\[1,1,1,1\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,1,2,3\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,1,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Example 3:**\n\n**Input:** dist = \\[3,2,4\\], speed = \\[5,3,2\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[3,2,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Constraints:**\n\n*   `n == dist.length == speed.length`\n*   `1 <= n <= 105`\n*   `1 <= dist[i], speed[i] <= 105`\"\"\"\n\n    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated"}}, "leetcode/leetcode_2463.txt": {"score": 0.9001156091690063, "content": {"text": "def min_total_distance(robot: List[int], factory: List[List[int]]) -> int:\n    \"\"\"There are some robots and factories on the X-axis. You are given an integer array `robot` where `robot[i]` is the position of the `ith` robot. You are also given a 2D integer array `factory` where `factory[j] = [positionj, limitj]` indicates that `positionj` is the position of the `jth` factory and that the `jth` factory can repair at most `limitj` robots.\n\nThe positions of each robot are **unique**. The positions of each factory are also **unique**. Note that a robot can be **in the same position** as a factory initially.\n\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\n\n**At any moment**, you can set the initial direction of moving for **some** robot. Your target is to minimize the total distance traveled by all the robots.\n\nReturn _the minimum total distance traveled by all the robots_. The test cases are generated such that all the robots can be repaired.\n\n**Note that**\n\n*   All robots move at the same speed.\n*   If two robots move in the same direction, they will never collide.\n*   If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.\n*   If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.\n*   If the robot moved from a position `x` to a position `y`, the distance it moved is `|y - x|`.\n\n**Example 1:**\n\n**Input:** robot = \\[0,4,6\\], factory = \\[\\[2,2\\],\\[6,2\\]\\]\n**Output:** 4\n**Explanation:** As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n\n**Example 2:**\n\n**Input:** robot = \\[1,-1\\], factory = \\[\\[-2,1\\],\\[2,1\\]\\]\n**Output:** 2\n**Explanation:** As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.\n\n**Constraints:**\n\n*   `1 <= robot.length, factory.length <= 100`\n*   `factory[j].length == 2`\n*   `-109 <= robot[i], positionj <= 109`\n*   `0 <= limitj <= robot.length`\n*   The input will be generated such that it is always possible to repair every robot.\"\"\"\n\n    robot.sort()\n    factory.sort()\n\n    res = 0\n    idx = 0\n    for f_pos, f_limit in factory:\n        while f_limit > 0 and idx < len(robot):\n            res += abs(f_pos - robot[idx])\n            idx += 1\n            f_limit -= 1\n    \n    return res"}}, "leetcode/leetcode_475.txt": {"score": 0.9058971405029297, "content": {"text": "def findRadius(houses, heaters):\n    \"\"\"Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.\n\nEvery house can be warmed, as long as the house is within the heater's warm radius range.\n\nGiven the positions of `houses` and `heaters` on a horizontal line, return _the minimum radius standard of heaters so that those heaters could cover all houses._\n\n**Notice** that all the `heaters` follow your radius standard, and the warm radius will the same.\n\n**Example 1:**\n\n**Input:** houses = \\[1,2,3\\], heaters = \\[2\\]\n**Output:** 1\n**Explanation:** The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n\n**Example 2:**\n\n**Input:** houses = \\[1,2,3,4\\], heaters = \\[1,4\\]\n**Output:** 1\n**Explanation:** The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n**Example 3:**\n\n**Input:** houses = \\[1,5\\], heaters = \\[2\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= houses.length, heaters.length <= 3 * 104`\n*   `1 <= houses[i], heaters[i] <= 109`\"\"\"\n\n    houses.sort()\n    heaters.sort()\n    result, i = 0, 0\n\n    for house in houses:\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        result = max(result, abs(heaters[i] - house))\n\n    return result"}}, "leetcode/leetcode_1503.txt": {"score": 0.9443018436431885, "content": {"text": "def max_satisfaction(satisfaction):\n    \"\"\"We have a wooden plank of the length `n` **units**. Some ants are walking on the plank, each ant moves with a speed of **1 unit per second**. Some of the ants move to the **left**, the other move to the **right**.\n\nWhen two ants moving in two **different** directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\n\nWhen an ant reaches **one end** of the plank at a time `t`, it falls out of the plank immediately.\n\nGiven an integer `n` and two integer arrays `left` and `right`, the positions of the ants moving to the left and the right, return _the moment when the last ant(s) fall out of the plank_.\n\n**Example 1:**\n\n**Input:** n = 4, left = \\[4,3\\], right = \\[0,1\\]\n**Output:** 4\n**Explanation:** In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n\n**Example 2:**\n\n**Input:** n = 7, left = \\[\\], right = \\[0,1,2,3,4,5,6,7\\]\n**Output:** 7\n**Explanation:** All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n\n**Example 3:**\n\n**Input:** n = 7, left = \\[0,1,2,3,4,5,6,7\\], right = \\[\\]\n**Output:** 7\n**Explanation:** All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `0 <= left.length <= n + 1`\n*   `0 <= left[i] <= n`\n*   `0 <= right.length <= n + 1`\n*   `0 <= right[i] <= n`\n*   `1 <= left.length + right.length <= n + 1`\n*   All values of `left` and `right` are unique, and each value can appear **only in one** of the two arrays.\"\"\"\n\n    satisfaction.sort(reverse=True)\n    ans = total = sum = 0\n    for i in satisfaction:\n        total += i\n        if total > 0:\n            sum += total\n            ans = max(ans, sum)\n    return ans"}}, "leetcode/leetcode_1900.txt": {"score": 0.9115898609161377, "content": {"text": "def closest_cost(base_costs, topping_costs, target):\n    \"\"\"There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their **initial** standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.).\n\nThe tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n\n*   For example, if the row consists of players `1, 2, 4, 6, 7`\n    *   Player `1` competes against player `7`.\n    *   Player `2` competes against player `6`.\n    *   Player `4` automatically advances to the next round.\n\nAfter each round is over, the winners are lined back up in the row based on the **original ordering** assigned to them initially (ascending order).\n\nThe players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may **choose** the outcome of this round.\n\nGiven the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the **earliest** possible round number and the **latest** possible round number in which these two players will compete against each other, respectively_.\n\n**Example 1:**\n\n**Input:** n = 11, firstPlayer = 2, secondPlayer = 4\n**Output:** \\[3,4\\]\n**Explanation:**\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n\n**Example 2:**\n\n**Input:** n = 5, firstPlayer = 1, secondPlayer = 5\n**Output:** \\[1,1\\]\n**Explanation:** The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.\n\n**Constraints:**\n\n*   `2 <= n <= 28`\n*   `1 <= firstPlayer < secondPlayer <= n`\"\"\"\n\n    closest = base_costs[0]\n    \n    for base in base_costs:\n        cost = base\n        \n        for i in range(1 << (len(topping_costs) * 2)):\n            bit_mask = i\n            \n            for j, topping_cost in enumerate(topping_costs):\n                cost += (bit_mask & 3) * topping_cost\n                bit_mask >>= 2\n                \n            if abs(target - cost) < abs(target - closest):\n                closest = cost\n            elif abs(target - cost) == abs(target - closest) and cost < closest:\n                closest = cost\n                \n            cost = base\n            \n    return closest"}}, "leetcode/leetcode_1776.txt": {"score": 0.9878057241439819, "content": {"text": "def minOperations(nums, x):\n    \"\"\"There are `n` cars traveling at different speeds in the same direction along a one-lane road. You are given an array `cars` of length `n`, where `cars[i] = [positioni, speedi]` represents:\n\n*   `positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`.\n*   `speedi` is the initial speed of the `ith` car in meters per second.\n\nFor simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the **slowest** car in the fleet.\n\nReturn an array `answer`, where `answer[i]` is the time, in seconds, at which the `ith` car collides with the next car, or `-1` if the car does not collide with the next car. Answers within `10-5` of the actual answers are accepted.\n\n**Example 1:**\n\n**Input:** cars = \\[\\[1,2\\],\\[2,1\\],\\[4,3\\],\\[7,2\\]\\]\n**Output:** \\[1.00000,-1.00000,3.00000,-1.00000\\]\n**Explanation:** After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.\n\n**Example 2:**\n\n**Input:** cars = \\[\\[3,4\\],\\[5,4\\],\\[6,3\\],\\[9,1\\]\\]\n**Output:** \\[2.00000,1.00000,1.50000,-1.00000\\]\n\n**Constraints:**\n\n*   `1 <= cars.length <= 105`\n*   `1 <= positioni, speedi <= 106`\n*   `positioni < positioni+1`\"\"\"\n\n    total = sum(nums)\n    target = total - x\n    if target < 0:\n        return -1\n\n    maxLength = -1\n    left = 0\n    current_sum = 0\n\n    for right in range(len(nums)):\n        current_sum += nums[right]\n\n        while current_sum > target:\n            current_sum -= nums[left]\n            left += 1\n\n        if current_sum == target:\n            maxLength = max(maxLength, right - left + 1)\n\n    return -1 if maxLength == -1 else len(nums) - maxLength"}}, "leetcode/leetcode_2332.txt": {"score": 0.9126057028770447, "content": {"text": "def last_passenger_time(buses, passengers, capacity):\n    \"\"\"You are given a **0-indexed** integer array `buses` of length `n`, where `buses[i]` represents the departure time of the `ith` bus. You are also given a **0-indexed** integer array `passengers` of length `m`, where `passengers[j]` represents the arrival time of the `jth` passenger. All bus departure times are unique. All passenger arrival times are unique.\n\nYou are given an integer `capacity`, which represents the **maximum** number of passengers that can get on each bus.\n\nWhen a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at `x` minutes if you arrive at `y` minutes where `y <= x`, and the bus is not full. Passengers with the **earliest** arrival times get on the bus first.\n\nMore formally when a bus arrives, either:\n\n*   If `capacity` or fewer passengers are waiting for a bus, they will **all** get on the bus, or\n*   The `capacity` passengers with the **earliest** arrival times will get on the bus.\n\nReturn _the latest time you may arrive at the bus station to catch a bus_. You **cannot** arrive at the same time as another passenger.\n\n**Note:** The arrays `buses` and `passengers` are not necessarily sorted.\n\n**Example 1:**\n\n**Input:** buses = \\[10,20\\], passengers = \\[2,17,18,19\\], capacity = 2\n**Output:** 16\n**Explanation:** Suppose you arrive at time 16.\nAt time 10, the first bus departs with the 0th passenger. \nAt time 20, the second bus departs with you and the 1st passenger.\nNote that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus.\n\n**Example 2:**\n\n**Input:** buses = \\[20,30,10\\], passengers = \\[19,13,26,4,25,11,21\\], capacity = 2\n**Output:** 20\n**Explanation:** Suppose you arrive at time 20.\nAt time 10, the first bus departs with the 3rd passenger. \nAt time 20, the second bus departs with the 5th and 1st passengers.\nAt time 30, the third bus departs with the 0th passenger and you.\nNotice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus.\n\n**Constraints:**\n\n*   `n == buses.length`\n*   `m == passengers.length`\n*   `1 <= n, m, capacity <= 105`\n*   `2 <= buses[i], passengers[i] <= 109`\n*   Each element in `buses` is **unique**.\n*   Each element in `passengers` is **unique**.\"\"\"\n\n    buses.sort()\n    passengers.sort()\n\n    last_index = 0\n    for bus in buses:\n        cnt = 0\n        while last_index < len(passengers) and passengers[last_index] <= bus and cnt < capacity:\n            cnt += 1\n            last_index += 1\n\n    return buses[0] - 1 if last_index == 0 else passengers[last_index - 1] - 1"}}, "leetcode/leetcode_853.txt": {"score": 0.9289361834526062, "content": {"text": "def max_profit_assignment(difficulty, profit, worker):\n    \"\"\"There are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\n\nYou are given two integer array `position` and `speed`, both of length `n`, where `position[i]` is the position of the `ith` car and `speed[i]` is the speed of the `ith` car (in miles per hour).\n\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper **at the same speed**. The faster car will **slow down** to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n\nA **car fleet** is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\n\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\n\nReturn _the **number of car fleets** that will arrive at the destination_.\n\n**Example 1:**\n\n**Input:** target = 12, position = \\[10,8,0,5,3\\], speed = \\[2,4,1,1,3\\]\n**Output:** 3\n**Explanation:**\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\nNote that no other cars meet these fleets before the destination, so the answer is 3.\n\n**Example 2:**\n\n**Input:** target = 10, position = \\[3\\], speed = \\[3\\]\n**Output:** 1\n**Explanation:** There is only one car, hence there is only one fleet.\n\n**Example 3:**\n\n**Input:** target = 100, position = \\[0,2,4\\], speed = \\[4,2,1\\]\n**Output:** 1\n**Explanation:**\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n\n**Constraints:**\n\n*   `n == position.length == speed.length`\n*   `1 <= n <= 105`\n*   `0 < target <= 106`\n*   `0 <= position[i] < target`\n*   All the values of `position` are **unique**.\n*   `0 < speed[i] <= 106`\"\"\"\n\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    i, max_profit, total_profit = 0, 0, 0\n    for ability in worker:\n        while i < len(difficulty) and ability >= jobs[i][0]:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        total_profit += max_profit\n    return total_profit"}}}}, "82": {"gold": {"leetcode/leetcode_2192.txt": 1}, "retrieved": {"leetcode/leetcode_1976.txt": {"score": 0.8931595683097839, "content": {"text": "def can_split_string(s: str) -> bool:\n    \"\"\"You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with **bi-directional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the **shortest amount of time**.\n\nReturn _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 7, roads = \\[\\[0,6,7\\],\\[0,1,2\\],\\[1,2,3\\],\\[1,3,3\\],\\[6,3,3\\],\\[3,5,1\\],\\[6,5,1\\],\\[2,5,1\\],\\[0,4,5\\],\\[4,6,2\\]\\]\n**Output:** 4\n**Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u279d 6\n- 0 \u279d 4 \u279d 6\n- 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6\n- 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6\n\n**Example 2:**\n\n**Input:** n = 2, roads = \\[\\[1,0,10\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\n*   `n - 1 <= roads.length <= n * (n - 1) / 2`\n*   `roads[i].length == 3`\n*   `0 <= ui, vi <= n - 1`\n*   `1 <= timei <= 109`\n*   `ui != vi`\n*   There is at most one road connecting any two intersections.\n*   You can reach any intersection from any other intersection.\"\"\"\n\n    count = [0] * 10\n\n    for c in s:\n        count[int(c)] += 1\n\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n\n    return False"}}, "leetcode/csn_python_train_321038.txt": {"score": 0.8945822715759277, "content": {"text": "def dist01(graph, weight, source=0, target=None):\n    \"\"\"Shortest path in a 0,1 weighted graph\n\n    :param graph: directed graph in listlist or listdict format\n    :param weight: matrix or adjacency dictionary\n    :param int source: vertex\n    :param target: exploration stops once distance to target is found\n    :returns: distance table, predecessor table\n    :complexity: `O(|V|+|E|)`\n    \"\"\"\n    n = len(graph)\n    dist = [float('inf')] * n\n    prec = [None] * n\n    black = [False] * n\n    dist[source] = 0\n    gray = deque([source])\n    while gray:\n        node = gray.pop()\n        if black[node]:\n            continue\n        black[node] = True\n        if node == target:\n            break\n        for neighbor in graph[node]:\n            ell = dist[node] + weight[node][neighbor]\n            if black[neighbor] or dist[neighbor] <= ell:\n                continue\n            dist[neighbor] = ell\n            prec[neighbor] = node\n            if weight[node][neighbor] == 0:\n                gray.append(neighbor)\n            else:\n                gray.appendleft(neighbor)\n    return dist, prec"}}, "leetcode/leetcode_787.txt": {"score": 0.8980691432952881, "content": {"text": "from collections import deque\n    \"\"\"There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return `-1`.\n\n**Example 1:**\n\n**Input:** n = 4, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[2,0,100\\],\\[1,3,600\\],\\[2,3,200\\]\\], src = 0, dst = 3, k = 1\n**Output:** 700\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities \\[0,1,2,3\\] is cheaper but is invalid because it uses 2 stops.\n\n**Example 2:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 1\n**Output:** 200\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\n**Example 3:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 0\n**Output:** 500\n**Explanation:**\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= flights.length <= (n * (n - 1) / 2)`\n*   `flights[i].length == 3`\n*   `0 <= fromi, toi < n`\n*   `fromi != toi`\n*   `1 <= pricei <= 104`\n*   There will not be any multiple flights between two cities.\n*   `0 <= src, dst, k < n`\n*   `src != dst`\"\"\"\n\n\ndef slidingPuzzle(board):\n    m, n = 2, 3\n    target = \"123450\"\n    start = \"\".join(str(num) for row in board for num in row)\n    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]\n    q = deque([start])\n    res = 0\n    visited = {start}\n    while q:\n        for _ in range(len(q)):\n            cur = q.popleft()\n            if cur == target:\n                return res\n            zero_idx = cur.index(\"0\")\n            for dir in dirs[zero_idx]:\n                neighbor = list(cur)\n                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]\n                neighbor = \"\".join(neighbor)\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        res += 1\n    return -1"}}, "leetcode/leetcode_743.txt": {"score": 0.9013065695762634, "content": {"text": "import heapq\n    \"\"\"You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return _the **minimum** time it takes for all the_ `n` _nodes to receive the signal_. If it is impossible for all the `n` nodes to receive the signal, return `-1`.\n\n**Example 1:**\n\n**Input:** times = \\[\\[2,1,1\\],\\[2,3,1\\],\\[3,4,1\\]\\], n = 4, k = 2\n**Output:** 2\n\n**Example 2:**\n\n**Input:** times = \\[\\[1,2,1\\]\\], n = 2, k = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** times = \\[\\[1,2,1\\]\\], n = 2, k = 2\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= k <= n <= 100`\n*   `1 <= times.length <= 6000`\n*   `times[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `0 <= wi <= 100`\n*   All the pairs `(ui, vi)` are **unique**. (i.e., no multiple edges.)\"\"\"\n\n\ndef networkDelayTime(times, n, k):\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {u: float('inf') for u in range(1, n+1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n\n        for v, weight in graph[u]:\n            new_dist = curr_dist + weight\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n\n    max_time = max(dist.values())\n    return max_time if max_time < float('inf') else -1"}}, "leetcode/leetcode_1514.txt": {"score": 0.9185605645179749, "content": {"text": "def min_start_value(nums):\n    \"\"\"You are given an undirected weighted graph of `n` nodes (0-indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes `a` and `b` with a probability of success of traversing that edge `succProb[i]`.\n\nGiven two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability.\n\nIf there is no path from `start` to `end`, **return 0**. Your answer will be accepted if it differs from the correct answer by at most **1e-5**.\n\n**Example 1:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,2\\]\\], succProb = \\[0.5,0.5,0.2\\], start = 0, end = 2\n**Output:** 0.25000\n**Explanation:** There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 \\* 0.5 = 0.25.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,2\\]\\], succProb = \\[0.5,0.5,0.3\\], start = 0, end = 2\n**Output:** 0.30000\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\]\\], succProb = \\[0.5\\], start = 0, end = 2\n**Output:** 0.00000\n**Explanation:** There is no path between 0 and 2.\n\n**Constraints:**\n\n*   `2 <= n <= 10^4`\n*   `0 <= start, end < n`\n*   `start != end`\n*   `0 <= a, b < n`\n*   `a != b`\n*   `0 <= succProb.length == edges.length <= 2*10^4`\n*   `0 <= succProb[i] <= 1`\n*   There is at most one edge between every two nodes.\"\"\"\n\n    min_sum, sum = 0, 0\n    for num in nums:\n        sum += num\n        min_sum = min(min_sum, sum)\n    return 1 - min_sum"}}, "leetcode/leetcode_1928.txt": {"score": 0.9412527680397034, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"There is a country of `n` cities numbered from `0` to `n - 1` where **all the cities are connected** by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is represented as a **0-indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime` **minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or_ `-1` _if you cannot complete it within_ `maxTime` _minutes_.\n\n**Example 1:**\n\n**Input:** maxTime = 30, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 11\n**Explanation:** The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n\n**Example 2:**\n\n**Input:** maxTime = 29, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 48\n**Explanation:** The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n\n**Example 3:**\n\n**Input:** maxTime = 25, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** -1\n**Explanation:** There is no way to reach city 5 from city 0 within 25 minutes.\n\n**Constraints:**\n\n*   `1 <= maxTime <= 1000`\n*   `n == passingFees.length`\n*   `2 <= n <= 1000`\n*   `n - 1 <= edges.length <= 1000`\n*   `0 <= xi, yi <= n - 1`\n*   `1 <= timei <= 1000`\n*   `1 <= passingFees[j] <= 1000`\n*   The graph may contain multiple edges between two nodes.\n*   The graph does not contain self loops.\"\"\"\n\n\ndef getNumberOfBacklogOrders(orders):\n    buy, sell = [], []\n\n    for price, amount, orderType in orders:\n        if orderType == 0:\n            while amount > 0 and sell and -sell[0][0] <= price:\n                executedAmount = min(amount, sell[0][1])\n                amount -= executedAmount\n                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]\n                if sell[0][1] == 0:\n                    heappop(sell)\n            if amount:\n                heappush(buy, [-price, amount])\n        else:\n            while amount > 0 and buy and buy[0][0] >= price:\n                executedAmount = min(amount, buy[0][1])\n                amount -= executedAmount\n                buy[0] = [buy[0][0], buy[0][1] - executedAmount]\n                if buy[0][1] == 0:\n                    heappop(buy)\n            if amount:\n                heappush(sell, [-price, amount])\n\n    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)\n    return res % 1000000007"}}, "leetcode/leetcode_2203.txt": {"score": 0.9113754034042358, "content": {"text": "from heapq import heappop, heappush\n    \"\"\"You are given an integer `n` denoting the number of nodes of a **weighted directed** graph. The nodes are numbered from `0` to `n - 1`.\n\nYou are also given a 2D integer array `edges` where `edges[i] = [fromi, toi, weighti]` denotes that there exists a **directed** edge from `fromi` to `toi` with weight `weighti`.\n\nLastly, you are given three **distinct** integers `src1`, `src2`, and `dest` denoting three distinct nodes of the graph.\n\nReturn _the **minimum weight** of a subgraph of the graph such that it is **possible** to reach_ `dest` _from both_ `src1` _and_ `src2` _via a set of edges of this subgraph_. In case such a subgraph does not exist, return `-1`.\n\nA **subgraph** is a graph whose vertices and edges are subsets of the original graph. The **weight** of a subgraph is the sum of weights of its constituent edges.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,2,2\\],\\[0,5,6\\],\\[1,0,3\\],\\[1,4,5\\],\\[2,1,1\\],\\[2,3,3\\],\\[2,3,4\\],\\[3,4,2\\],\\[4,5,1\\]\\], src1 = 0, src2 = 1, dest = 5\n**Output:** 9\n**Explanation:**\nThe above figure represents the input graph.\nThe blue edges represent one of the subgraphs that yield the optimal answer.\nNote that the subgraph \\[\\[1,0,3\\],\\[0,5,6\\]\\] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1,1\\],\\[2,1,1\\]\\], src1 = 0, src2 = 1, dest = 2\n**Output:** -1\n**Explanation:**\nThe above figure represents the input graph.\nIt can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.\n\n**Constraints:**\n\n*   `3 <= n <= 105`\n*   `0 <= edges.length <= 105`\n*   `edges[i].length == 3`\n*   `0 <= fromi, toi, src1, src2, dest <= n - 1`\n*   `fromi != toi`\n*   `src1`, `src2`, and `dest` are pairwise distinct.\n*   `1 <= weight[i] <= 105`\"\"\"\n\nfrom sys import maxsize\n\ndef dijkstra(src, adj):\n    dist = [maxsize] * len(adj)\n    dist[src] = 0\n    pq = [(0, src)]\n\n    while pq:\n        d, u = heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in adj[u]:\n            if d + w < dist[v]:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\ndef min_weight_subgraph(n, edges, src1, src2, dest):\n    adj = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj[u].append((v, w))\n\n    dist1 = dijkstra(src1, adj)\n    dist2 = dijkstra(src2, adj)\n\n    res = dist1[dest] + dist2[dest]\n    for u, v, w in edges:\n        res = min(res, dist1[u] + dist2[v] + w)\n        res = min(res, dist1[v] + dist2[u] + w)\n\n    return res if res != maxsize else -1"}}, "leetcode/leetcode_1786.txt": {"score": 0.9706465601921082, "content": {"text": "def count_consistent_strings(allowed, words):\n    \"\"\"There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[1,2,3\\],\\[1,3,3\\],\\[2,3,1\\],\\[1,4,2\\],\\[5,2,2\\],\\[3,5,1\\],\\[5,4,10\\]\\]\n**Output:** 3\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,3,1\\],\\[4,1,2\\],\\[7,3,4\\],\\[2,5,3\\],\\[5,6,1\\],\\[6,7,2\\],\\[7,5,3\\],\\[2,6,4\\]\\]\n**Output:** 1\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The only restricted path is 1 --> 3 --> 7.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `n - 1 <= edges.length <= 4 * 104`\n*   `edges[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= weighti <= 105`\n*   There is at most one edge between any two nodes.\n*   There is at least one path between any two nodes.\"\"\"\n\n    allowed_set = set(allowed)\n    count = 0\n    for word in words:\n        is_valid = True\n        for c in word:\n            if c not in allowed_set:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n    return count"}}, "leetcode/leetcode_2492.txt": {"score": 0.9316493272781372, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are given a positive integer `n` representing `n` cities numbered from `1` to `n`. You are also given a **2D** array `roads` where `roads[i] = [ai, bi, distancei]` indicates that there is a **bidirectional** road between cities `ai` and `bi` with a distance equal to `distancei`. The cities graph is not necessarily connected.\n\nThe **score** of a path between two cities is defined as the **minimum** distance of a road in this path.\n\nReturn _the **minimum** possible score of a path between cities_ `1` _and_ `n`.\n\n**Note**:\n\n*   A path is a sequence of roads between two cities.\n*   It is allowed for a path to contain the same road **multiple** times, and you can visit cities `1` and `n` multiple times along the path.\n*   The test cases are generated such that there is **at least** one path between `1` and `n`.\n\n**Example 1:**\n\n**Input:** n = 4, roads = \\[\\[1,2,9\\],\\[2,3,6\\],\\[2,4,5\\],\\[1,4,7\\]\\]\n**Output:** 5\n**Explanation:** The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n\n**Example 2:**\n\n**Input:** n = 4, roads = \\[\\[1,2,2\\],\\[1,3,4\\],\\[3,4,7\\]\\]\n**Output:** 2\n**Explanation:** The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `1 <= roads.length <= 105`\n*   `roads[i].length == 3`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   `1 <= distancei <= 104`\n*   There are no repeated edges.\n*   There is at least one path between `1` and `n`.\"\"\"\n\nfrom collections import defaultdict\n\ndef minimumScore(n, roads):\n    adj = defaultdict(list)\n    for road in roads:\n        adj[road[0]].append((road[1], road[2]))\n        adj[road[1]].append((road[0], road[2]))\n\n    INF = int(1e9)\n    pq = [(0, 1)]\n\n    minDist = [INF] * (n + 1)\n    while pq:\n        curDist, curCity = heappop(pq)\n\n        if curCity == n:\n            return curDist\n\n        if curDist < minDist[curCity]:\n            minDist[curCity] = curDist\n            for nextCity, nextDist in adj[curCity]:\n                candidate_dist = max(curDist, nextDist)\n                if candidate_dist < minDist[nextCity]:\n                    heappush(pq, (candidate_dist, nextCity))\n\n    return -1"}}, "leetcode/leetcode_1334.txt": {"score": 0.9379631280899048, "content": {"text": "def findTheCity(n, edges, distanceThreshold):\n    \"\"\"There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[0,1,3\\],\\[1,2,1\\],\\[1,3,4\\],\\[2,3,1\\]\\], distanceThreshold = 4\n**Output:** 3\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> \\[City 1, City 2\\] \nCity 1 -> \\[City 0, City 2, City 3\\] \nCity 2 -> \\[City 0, City 1, City 3\\] \nCity 3 -> \\[City 1, City 2\\] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1,2\\],\\[0,4,8\\],\\[1,2,3\\],\\[1,4,2\\],\\[2,3,1\\],\\[3,4,1\\]\\], distanceThreshold = 2\n**Output:** 0\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> \\[City 1\\] \nCity 1 -> \\[City 0, City 4\\] \nCity 2 -> \\[City 3, City 4\\] \nCity 3 -> \\[City 2, City 4\\]\nCity 4 -> \\[City 1, City 2, City 3\\] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= edges.length <= n * (n - 1) / 2`\n*   `edges[i].length == 3`\n*   `0 <= fromi < toi < n`\n*   `1 <= weighti, distanceThreshold <= 10^4`\n*   All pairs `(fromi, toi)` are distinct.\"\"\"\n\n    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res"}}}}, "83": {"gold": {"leetcode/leetcode_2050.txt": 1, "leetcode/leetcode_2589.txt": 1}, "retrieved": {"leetcode/leetcode_2136.txt": {"score": 0.8842418193817139, "content": {"text": "def earliestBlooms(plantTime, growTime):\n    \"\"\"You have `n` flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two **0-indexed** integer arrays `plantTime` and `growTime`, of length `n` each:\n\n*   `plantTime[i]` is the number of **full days** it takes you to **plant** the `ith` seed. Every day, you can work on planting exactly one seed. You **do not** have to work on planting the same seed on consecutive days, but the planting of a seed is not complete **until** you have worked `plantTime[i]` days on planting it in total.\n*   `growTime[i]` is the number of **full days** it takes the `ith` seed to grow after being completely planted. **After** the last day of its growth, the flower **blooms** and stays bloomed forever.\n\nFrom the beginning of day `0`, you can plant the seeds in **any** order.\n\nReturn _the **earliest** possible day where **all** seeds are blooming_.\n\n**Example 1:**\n\n**Input:** plantTime = \\[1,4,3\\], growTime = \\[2,3,1\\]\n**Output:** 9\n**Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n**Example 2:**\n\n**Input:** plantTime = \\[1,2,3,2\\], growTime = \\[2,1,2,1\\]\n**Output:** 9\n**Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n**Example 3:**\n\n**Input:** plantTime = \\[1\\], growTime = \\[1\\]\n**Output:** 2\n**Explanation:** On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming.\n\n**Constraints:**\n\n*   `n == plantTime.length == growTime.length`\n*   `1 <= n <= 105`\n*   `1 <= plantTime[i], growTime[i] <= 104`\"\"\"\n\n    n = len(plantTime)\n    processTime = list(zip(plantTime, growTime))\n    processTime.sort()\n\n    day = 0\n    blooms = 0\n    for p in processTime:\n        day += p[0]\n        blooms = max(blooms, day + p[1])\n    return blooms"}}, "leetcode/leetcode_2402.txt": {"score": 0.8859332799911499, "content": {"text": "import heapq\n    \"\"\"You are given an integer `n`. There are `n` rooms numbered from `0` to `n - 1`.\n\nYou are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the **half-closed** time interval `[starti, endi)`. All the values of `starti` are **unique**.\n\nMeetings are allocated to rooms in the following manner:\n\n1.  Each meeting will take place in the unused room with the **lowest** number.\n2.  If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the **same** duration as the original meeting.\n3.  When a room becomes unused, meetings that have an earlier original **start** time should be given the room.\n\nReturn _the **number** of the room that held the most meetings._ If there are multiple rooms, return _the room with the **lowest** number._\n\nA **half-closed interval** `[a, b)` is the interval between `a` and `b` **including** `a` and **not including** `b`.\n\n**Example 1:**\n\n**Input:** n = 2, meetings = \\[\\[0,10\\],\\[1,5\\],\\[2,7\\],\\[3,4\\]\\]\n**Output:** 0\n**Explanation:**\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period \\[5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period \\[10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\n**Example 2:**\n\n**Input:** n = 3, meetings = \\[\\[1,20\\],\\[2,10\\],\\[3,5\\],\\[4,9\\],\\[6,8\\]\\]\n**Output:** 1\n**Explanation:**\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period \\[5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period \\[10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `1 <= meetings.length <= 105`\n*   `meetings[i].length == 2`\n*   `0 <= starti < endi <= 5 * 105`\n*   All the values of `starti` are **unique**.\"\"\"\n\n\ndef most_visited_room(n, meetings):\n    meetings.sort()\n    pq = []\n    rooms = [0] * n\n    \n    for start, end in meetings:\n        while pq and pq[0][0] <= start:\n            _, room = heapq.heappop(pq)\n            rooms[room] += 1\n        heapq.heappush(pq, (end, len(pq) % n))\n    \n    return rooms.index(max(rooms))"}}, "leetcode/leetcode_1701.txt": {"score": 0.8900837302207947, "content": {"text": "def maxNumEdgesToRemove(n, edges):\n    \"\"\"There is a restaurant with a single chef. You are given an array `customers`, where `customers[i] = [arrivali, timei]:`\n\n*   `arrivali` is the arrival time of the `ith` customer. The arrival times are sorted in **non-decreasing** order.\n*   `timei` is the time needed to prepare the order of the `ith` customer.\n\nWhen a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers **in the order they were given in the input**.\n\nReturn _the **average** waiting time of all customers_. Solutions within `10-5` from the actual answer are considered accepted.\n\n**Example 1:**\n\n**Input:** customers = \\[\\[1,2\\],\\[2,5\\],\\[4,3\\]\\]\n**Output:** 5.00000\n**Explanation:**\n1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.\n2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.\n3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.\nSo the average waiting time = (2 + 6 + 7) / 3 = 5.\n\n**Example 2:**\n\n**Input:** customers = \\[\\[5,2\\],\\[5,4\\],\\[10,3\\],\\[20,1\\]\\]\n**Output:** 3.25000\n**Explanation:**\n1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.\n2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.\n3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.\n4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.\nSo the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.\n\n**Constraints:**\n\n*   `1 <= customers.length <= 105`\n*   `1 <= arrivali, timei <= 104`\n*   `arrivali <= arrivali+1`\"\"\"\n\n    def find(u):\n        if parent[u] == u:\n            return u\n        else:\n            parent[u] = find(parent[u])\n            return parent[u]\n\n    def unite(u, v):\n        u = find(u)\n        v = find(v)\n        if u != v:\n            parent[u] = v\n            return True\n        return False\n\n    parent = list(range(2 * n + 1))\n    ct = [0, 0]\n    both = n - 1\n    edges.sort(reverse=True)\n    for edge in edges:\n        type, u, v = edge\n        if type == 3 and unite(u, v + n):\n            both -= 1\n        if both == 0:\n            break\n\n    for type in range(1, 3):\n        for edge in edges:\n            a, u, v = edge\n            if a == type and unite(u, v + n):\n                ct[type - 1] += 1\n        if both + ct[type - 1] < n - 1:\n            return -1\n\n    return ct[0] + ct[1] - n + 1"}}, "leetcode/csn_python_train_353893.txt": {"score": 0.8888038992881775, "content": {"text": "def next(self):\n        \"\"\"Get the next processable item of the queue.\n\n        A processable item is supposed to have the status `queued`.\n\n        Returns:\n            None : If no key is found.\n            Int: If a valid entry is found.\n\n        \"\"\"\n        smallest = None\n        for key in self.queue.keys():\n            if self.queue[key]['status'] == 'queued':\n                if smallest is None or key < smallest:\n                    smallest = key\n        return smallest"}}, "leetcode/leetcode_2073.txt": {"score": 0.8897764086723328, "content": {"text": "def time_to_buy_tickets(tickets, k):\n    \"\"\"There are `n` people in a line queuing to buy tickets, where the `0th` person is at the **front** of the line and the `(n - 1)th` person is at the **back** of the line.\n\nYou are given a **0-indexed** integer array `tickets` of length `n` where the number of tickets that the `ith` person would like to buy is `tickets[i]`.\n\nEach person takes **exactly 1 second** to buy a ticket. A person can only buy **1 ticket at a time** and has to go back to **the end** of the line (which happens **instantaneously**) in order to buy more tickets. If a person does not have any tickets left to buy, the person will **leave** the line.\n\nReturn _the **time taken** for the person at position_ `k` **_(0-indexed)_** _to finish buying tickets_.\n\n**Example 1:**\n\n**Input:** tickets = \\[2,3,2\\], k = 2\n**Output:** 6\n**Explanation:** \n- In the first pass, everyone in the line buys a ticket and the line becomes \\[1, 2, 1\\].\n- In the second pass, everyone in the line buys a ticket and the line becomes \\[0, 1, 0\\].\nThe person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n\n**Example 2:**\n\n**Input:** tickets = \\[5,1,1,1\\], k = 0\n**Output:** 8\n**Explanation:**\n- In the first pass, everyone in the line buys a ticket and the line becomes \\[4, 0, 0, 0\\].\n- In the next 4 passes, only the person in position 0 is buying tickets.\nThe person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.\n\n**Constraints:**\n\n*   `n == tickets.length`\n*   `1 <= n <= 100`\n*   `1 <= tickets[i] <= 100`\n*   `0 <= k < n`\"\"\"\n\n    time = 0\n    while tickets[k] > 0:\n        for i in range(len(tickets)):\n            if tickets[i] > 0:\n                tickets[i] -= 1\n                time += 1\n                if i == k and tickets[k] == 0:\n                    break\n    return time"}}, "leetcode/leetcode_1882.txt": {"score": 0.9377548098564148, "content": {"text": "import heapq\n    \"\"\"You are given two **0-indexed** integer arrays `servers` and `tasks` of lengths `n`\u200b\u200b\u200b\u200b\u200b\u200b and `m`\u200b\u200b\u200b\u200b\u200b\u200b respectively. `servers[i]` is the **weight** of the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b server, and `tasks[j]` is the **time needed** to process the `j\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b task **in seconds**.\n\nTasks are assigned to the servers using a **task queue**. Initially, all servers are free, and the queue is **empty**.\n\nAt second `j`, the `jth` task is **inserted** into the queue (starting with the `0th` task being inserted at second `0`). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the **smallest weight**, and in case of a tie, it is assigned to a free server with the **smallest index**.\n\nIf there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned **in order of insertion** following the weight and index priorities above.\n\nA server that is assigned task `j` at second `t` will be free again at second `t + tasks[j]`.\n\nBuild an array `ans`\u200b\u200b\u200b\u200b of length `m`, where `ans[j]` is the **index** of the server the `j\u200b\u200b\u200b\u200b\u200b\u200bth` task will be assigned to.\n\nReturn _the array_ `ans`\u200b\u200b\u200b\u200b.\n\n**Example 1:**\n\n**Input:** servers = \\[3,3,2\\], tasks = \\[1,2,3,2,1,2\\]\n**Output:** \\[2,2,0,2,1,2\\]\n**Explanation:** Events in chronological order go as follows:\n- At second 0, task 0 is added and processed using server 2 until second 1.\n- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.\n- At second 2, task 2 is added and processed using server 0 until second 5.\n- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.\n- At second 4, task 4 is added and processed using server 1 until second 5.\n- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.\n\n**Example 2:**\n\n**Input:** servers = \\[5,1,4,3,2\\], tasks = \\[2,1,2,4,5,2,1\\]\n**Output:** \\[1,4,1,4,1,3,2\\]\n**Explanation:** Events in chronological order go as follows: \n- At second 0, task 0 is added and processed using server 1 until second 2.\n- At second 1, task 1 is added and processed using server 4 until second 2.\n- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. \n- At second 3, task 3 is added and processed using server 4 until second 7.\n- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. \n- At second 5, task 5 is added and processed using server 3 until second 7.\n- At second 6, task 6 is added and processed using server 2 until second 7.\n\n**Constraints:**\n\n*   `servers.length == n`\n*   `tasks.length == m`\n*   `1 <= n, m <= 2 * 105`\n*   `1 <= servers[i], tasks[j] <= 2 * 105`\"\"\"\n\nfrom typing import List\n\ndef assignTasks(servers: List[int], tasks: List[int]) -> List[int]:\n    free_servers = [(servers[i], i) for i in range(len(servers))]\n    heapq.heapify(free_servers)\n    busy_servers = []\n    result = [0] * len(tasks)\n\n    for time in range(len(tasks)):\n        while busy_servers and busy_servers[0][0] <= time:\n            _, server_elem = heapq.heappop(busy_servers)\n            heapq.heappush(free_servers, server_elem)\n        \n        if free_servers:\n            server_elem = heapq.heappop(free_servers)\n            result[time] = server_elem[1]\n            heapq.heappush(busy_servers, (time + tasks[time], server_elem))\n\n    return result"}}, "leetcode/leetcode_2462.txt": {"score": 0.8915510773658752, "content": {"text": "def hireWorkers(costs, k, candidates):\n    \"\"\"You are given a **0-indexed** integer array `costs` where `costs[i]` is the cost of hiring the `ith` worker.\n\nYou are also given two integers `k` and `candidates`. We want to hire exactly `k` workers according to the following rules:\n\n*   You will run `k` sessions and hire exactly one worker in each session.\n*   In each hiring session, choose the worker with the lowest cost from either the first `candidates` workers or the last `candidates` workers. Break the tie by the smallest index.\n    *   For example, if `costs = [3,2,7,7,1,2]` and `candidates = 2`, then in the first hiring session, we will choose the `4th` worker because they have the lowest cost `[3,2,7,7,**1**,2]`.\n    *   In the second hiring session, we will choose `1st` worker because they have the same lowest cost as `4th` worker but they have the smallest index `[3,**2**,7,7,2]`. Please note that the indexing may be changed in the process.\n*   If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n*   A worker can only be chosen once.\n\nReturn _the total cost to hire exactly_ `k` _workers._\n\n**Example 1:**\n\n**Input:** costs = \\[17,12,10,2,7,2,11,20,8\\], k = 3, candidates = 4\n**Output:** 11\n**Explanation:** We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from \\[17,12,10,2,7,2,11,20,8\\]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.\n- In the second hiring round we choose the worker from \\[17,12,10,7,2,11,20,8\\]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.\n- In the third hiring round we choose the worker from \\[17,12,10,7,11,20,8\\]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.\nThe total hiring cost is 11.\n\n**Example 2:**\n\n**Input:** costs = \\[1,2,4,1\\], k = 3, candidates = 3\n**Output:** 4\n**Explanation:** We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from \\[1,2,4,1\\]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.\n- In the second hiring round we choose the worker from \\[2,4,1\\]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.\n- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers \\[2,4\\]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.\nThe total hiring cost is 4.\n\n**Constraints:**\n\n*   `1 <= costs.length <= 105`\n*   `1 <= costs[i] <= 105`\n*   `1 <= k, candidates <= costs.length`\"\"\"\n\n    n = len(costs)\n    workers = sorted([(cost, i) for i, cost in enumerate(costs)])\n\n    cost = 0\n    for i in range(k):\n        if min(workers[i][1], n - workers[i][1] - 1) < candidates:\n            cost += workers[i][0]\n\n    return cost"}}, "leetcode/leetcode_1834.txt": {"score": 0.9880601167678833, "content": {"text": "def minimum_teachings(n, languages, friendships):\n    \"\"\"You are given `n`\u200b\u200b\u200b\u200b\u200b\u200b tasks labeled from `0` to `n - 1` represented by a 2D integer array `tasks`, where `tasks[i] = [enqueueTimei, processingTimei]` means that the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b task will be available to process at `enqueueTimei` and will take `processingTimei` to finish processing.\n\nYou have a single-threaded CPU that can process **at most one** task at a time and will act in the following way:\n\n*   If the CPU is idle and there are no available tasks to process, the CPU remains idle.\n*   If the CPU is idle and there are available tasks, the CPU will choose the one with the **shortest processing time**. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.\n*   Once a task is started, the CPU will **process the entire task** without stopping.\n*   The CPU can finish a task then start a new one instantly.\n\nReturn _the order in which the CPU will process the tasks._\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[3,2\\],\\[4,1\\]\\]\n**Output:** \\[0,2,3,1\\]\n**Explanation:** The events go as follows: \n- At time = 1, task 0 is available to process. Available tasks = {0}.\n- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n- At time = 2, task 1 is available to process. Available tasks = {1}.\n- At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n- At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n- At time = 10, the CPU finishes task 1 and becomes idle.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[7,10\\],\\[7,12\\],\\[7,5\\],\\[7,4\\],\\[7,2\\]\\]\n**Output:** \\[4,3,2,0,1\\]\n**Explanation****:** The events go as follows:\n- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n- At time = 40, the CPU finishes task 1 and becomes idle.\n\n**Constraints:**\n\n*   `tasks.length == n`\n*   `1 <= n <= 105`\n*   `1 <= enqueueTimei, processingTimei <= 109`\"\"\"\n\n    language_users = {}\n    unconnected_users = set()\n\n    for u, v in friendships:\n        can_communicate = any(lang in languages[v-1] for lang in languages[u-1])\n        if not can_communicate:\n            unconnected_users.add(u)\n            unconnected_users.add(v)\n\n    res = len(unconnected_users)\n    for i in range(1, n+1):\n        cnt = sum(i not in languages[user-1] for user in unconnected_users)\n        res = min(res, cnt)\n\n    return res"}}, "leetcode/leetcode_1962.txt": {"score": 0.8993805050849915, "content": {"text": "from queue import PriorityQueue\n    \"\"\"You are given a **0-indexed** integer array `piles`, where `piles[i]` represents the number of stones in the `ith` pile, and an integer `k`. You should apply the following operation **exactly** `k` times:\n\n*   Choose any `piles[i]` and **remove** `floor(piles[i] / 2)` stones from it.\n\n**Notice** that you can apply the operation on the **same** pile more than once.\n\nReturn _the **minimum** possible total number of stones remaining after applying the_ `k` _operations_.\n\n`floor(x)` is the **greatest** integer that is **smaller** than or **equal** to `x` (i.e., rounds `x` down).\n\n**Example 1:**\n\n**Input:** piles = \\[5,4,9\\], k = 2\n**Output:** 12\n**Explanation:** Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are \\[5,4,5\\].\n- Apply the operation on pile 0. The resulting piles are \\[3,4,5\\].\nThe total number of stones in \\[3,4,5\\] is 12.\n\n**Example 2:**\n\n**Input:** piles = \\[4,3,6,7\\], k = 3\n**Output:** 12\n**Explanation:** Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are \\[4,3,3,7\\].\n- Apply the operation on pile 3. The resulting piles are \\[4,3,3,4\\].\n- Apply the operation on pile 0. The resulting piles are \\[2,3,3,4\\].\nThe total number of stones in \\[2,3,3,4\\] is 12.\n\n**Constraints:**\n\n*   `1 <= piles.length <= 105`\n*   `1 <= piles[i] <= 104`\n*   `1 <= k <= 105`\"\"\"\n\n\ndef getOrder(tasks):\n    task_indices = sorted(range(len(tasks)), key=lambda i: tasks[i][0])\n    min_heap = PriorityQueue()\n    time = 0\n    task_idx = 0\n    result = []\n\n    while task_indices:\n        while task_idx < len(task_indices) and tasks[task_indices[task_idx]][0] <= time:\n            idx = task_indices[task_idx]\n            min_heap.put((tasks[idx][1], idx))\n            task_idx += 1\n\n        if not min_heap.empty():\n            processing_time, index = min_heap.get()\n            time += processing_time\n            result.append(index)\n            task_indices.remove(index)\n        elif task_idx < len(task_indices):\n            time = max(time, tasks[task_indices[task_idx]][0])\n\n    return result"}}, "leetcode/leetcode_2532.txt": {"score": 0.9169250130653381, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"There are `k` workers who want to move `n` boxes from an old warehouse to a new one. You are given the two integers `n` and `k`, and a 2D integer array `time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]`.\n\nThe warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all `k` workers are waiting on the left side of the bridge. To move the boxes, the `ith` worker (**0-indexed**) can :\n\n*   Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.\n*   Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.\n*   Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.\n*   Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.\n\nA worker `i` is **less efficient** than a worker `j` if either condition is met:\n\n*   `leftToRighti + rightToLefti > leftToRightj + rightToLeftj`\n*   `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j`\n\nThe following rules regulate the movement of the workers through the bridge :\n\n*   If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.\n*   If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with **the lowest efficiency** crosses first.\n*   If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with **the lowest efficiency** crosses first.\n\nReturn _the instance of time at which the last worker **reaches the left bank** of the river after all n boxes have been put in the new warehouse_.\n\n**Example 1:**\n\n**Input:** n = 1, k = 3, time = \\[\\[1,1,2,1\\],\\[1,1,3,1\\],\\[1,1,4,1\\]\\]\n**Output:** 6\n**Explanation:** \nFrom 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\nFrom 1 to 2: worker 2 picks up a box from the old warehouse.\nFrom 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\nFrom 6 to 7: worker 2 puts a box at the new warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n**Example 2:**\n\n**Input:** n = 3, k = 2, time = \\[\\[1,9,1,8\\],\\[10,10,10,10\\]\\]\n**Output:** 50\n**Explanation:** \nFrom 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.\nFrom 10 to 20: worker 1 picks up a box from the old warehouse.\nFrom 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 11 to 20: worker 0 picks up a box from the old warehouse.\nFrom 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\nFrom 30 to 40: worker 1 puts a box at the new warehouse.\nFrom 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 31 to 39: worker 0 puts a box at the new warehouse.\nFrom 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 40 to 49: worker 0 picks up a box from the old warehouse.\nFrom 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 50 to 58: worker 0 puts a box at the new warehouse.\nThe whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n**Constraints:**\n\n*   `1 <= n, k <= 104`\n*   `time.length == k`\n*   `time[i].length == 4`\n*   `1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000`\"\"\"\n\n\ndef getLastMoment(n, k, time):\n    left = [(time[j][0] + time[j][2], j) for j in range(k)]\n    right = []\n\n    while n:\n        while right and right[0][0] <= left[0][0]:\n            right_top = heappop(right)\n            heappush(left, (right_top[0] + time[right_top[1]][0] + time[right_top[1]][2], right_top[1]))\n        left_top = heappop(left)\n        time[left_top[1]][2] += time[left_top[1]][3] + time[left_top[1]][0] + time[left_top[1]][1]\n        heappush(right, (left_top[0] + time[left_top[1]][1], left_top[1]))\n        n -= 1\n\n    lastMoment = -1\n    while right:\n        right_top = heappop(right)\n        lastMoment = max(lastMoment, time[right_top[1]][2])\n    return lastMoment"}}}}, "84": {"gold": {"leetcode/leetcode_2381.txt": 1}, "retrieved": {"leetcode/leetcode_757.txt": {"score": 0.9118726849555969, "content": {"text": "from collections import defaultdict\n    \"\"\"You are given a 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents all the integers from `starti` to `endi` inclusively.\n\nA **containing set** is an array `nums` where each interval from `intervals` has **at least two** integers in `nums`.\n\n*   For example, if `intervals = [[1,3], [3,7], [8,9]]`, then `[1,2,4,7,8,9]` and `[2,3,4,8,9]` are **containing sets**.\n\nReturn _the minimum possible size of a containing set_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[3,7\\],\\[8,9\\]\\]\n**Output:** 5\n**Explanation:** let nums = \\[2, 3, 4, 8, 9\\].\nIt can be shown that there cannot be any containing array of size 4.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[3,5\\]\\]\n**Output:** 3\n**Explanation:** let nums = \\[2, 3, 4\\].\nIt can be shown that there cannot be any containing array of size 2.\n\n**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\],\\[4,5\\]\\]\n**Output:** 5\n**Explanation:** let nums = \\[1, 2, 3, 4, 5\\].\nIt can be shown that there cannot be any containing array of size 4.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 3000`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 108`\"\"\"\n\n\ndef pyramidTransition(bottom, allowed):\n    mapping = defaultdict(list)\n    for s in allowed:\n        mapping[s[:2]].append(s[2])\n    return dfs(\"\", bottom, mapping)\n\ndef dfs(curr, bottom, mapping):\n    if len(bottom) == 1:\n        return True\n    for i in range(len(bottom) - 1):\n        if bottom[i:i+2] not in mapping:\n            return False\n    curr = \"\".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))\n    return dfs(curr, curr, mapping)"}}, "leetcode/leetcode_2402.txt": {"score": 0.9160152077674866, "content": {"text": "import heapq\n    \"\"\"You are given an integer `n`. There are `n` rooms numbered from `0` to `n - 1`.\n\nYou are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the **half-closed** time interval `[starti, endi)`. All the values of `starti` are **unique**.\n\nMeetings are allocated to rooms in the following manner:\n\n1.  Each meeting will take place in the unused room with the **lowest** number.\n2.  If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the **same** duration as the original meeting.\n3.  When a room becomes unused, meetings that have an earlier original **start** time should be given the room.\n\nReturn _the **number** of the room that held the most meetings._ If there are multiple rooms, return _the room with the **lowest** number._\n\nA **half-closed interval** `[a, b)` is the interval between `a` and `b` **including** `a` and **not including** `b`.\n\n**Example 1:**\n\n**Input:** n = 2, meetings = \\[\\[0,10\\],\\[1,5\\],\\[2,7\\],\\[3,4\\]\\]\n**Output:** 0\n**Explanation:**\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period \\[5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period \\[10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\n**Example 2:**\n\n**Input:** n = 3, meetings = \\[\\[1,20\\],\\[2,10\\],\\[3,5\\],\\[4,9\\],\\[6,8\\]\\]\n**Output:** 1\n**Explanation:**\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period \\[5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period \\[10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `1 <= meetings.length <= 105`\n*   `meetings[i].length == 2`\n*   `0 <= starti < endi <= 5 * 105`\n*   All the values of `starti` are **unique**.\"\"\"\n\n\ndef most_visited_room(n, meetings):\n    meetings.sort()\n    pq = []\n    rooms = [0] * n\n    \n    for start, end in meetings:\n        while pq and pq[0][0] <= start:\n            _, room = heapq.heappop(pq)\n            rooms[room] += 1\n        heapq.heappush(pq, (end, len(pq) % n))\n    \n    return rooms.index(max(rooms))"}}, "leetcode/leetcode_1262.txt": {"score": 0.9122418165206909, "content": {"text": "from collections import defaultdict\n    \"\"\"Given an integer array `nums`, return _the **maximum possible sum** of elements of the array such that it is divisible by three_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,5,1,8\\]\n**Output:** 18\n**Explanation:** Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).\n\n**Example 2:**\n\n**Input:** nums = \\[4\\]\n**Output:** 0\n**Explanation:** Since 4 is not divisible by 3, do not pick any number.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,4\\]\n**Output:** 12\n**Explanation:** Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).\n\n**Constraints:**\n\n*   `1 <= nums.length <= 4 * 104`\n*   `1 <= nums[i] <= 104`\"\"\"\n\nfrom random import randint\n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.positions = defaultdict(list)\n        for i, num in enumerate(arr):\n            self.positions[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):\n            randomIndex = randint(left, right)\n            num = self.arr[randomIndex]\n            lb = self.lower_bound(self.positions[num], left)\n            ub = self.upper_bound(self.positions[num], right)\n            if ub - lb >= threshold:\n                return num\n        return -1\n\n    def lower_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n\n    def upper_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}}, "leetcode/leetcode_2251.txt": {"score": 0.9174693822860718, "content": {"text": "MOD = 10**9 + 7\n    \"\"\"You are given a **0-indexed** 2D integer array `flowers`, where `flowers[i] = [starti, endi]` means the `ith` flower will be in **full bloom** from `starti` to `endi` (**inclusive**). You are also given a **0-indexed** integer array `people` of size `n`, where `poeple[i]` is the time that the `ith` person will arrive to see the flowers.\n\nReturn _an integer array_ `answer` _of size_ `n`_, where_ `answer[i]` _is the **number** of flowers that are in full bloom when the_ `ith` _person arrives._\n\n**Example 1:**\n\n**Input:** flowers = \\[\\[1,6\\],\\[3,7\\],\\[9,12\\],\\[4,13\\]\\], poeple = \\[2,3,7,11\\]\n**Output:** \\[1,2,2,2\\]\n**Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n**Example 2:**\n\n**Input:** flowers = \\[\\[1,10\\],\\[3,3\\]\\], poeple = \\[3,3,2\\]\n**Output:** \\[2,2,1\\]\n**Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n**Constraints:**\n\n*   `1 <= flowers.length <= 5 * 104`\n*   `flowers[i].length == 2`\n*   `1 <= starti <= endi <= 109`\n*   `1 <= people.length <= 5 * 104`\n*   `1 <= people[i] <= 109`\"\"\"\n\n\ndef corridor_ways(corridor):\n    n = len(corridor)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    seats = 0\n    for i in range(n):\n        if corridor[i] == 'S':\n            seats += 1\n            if seats % 2 == 0:\n                dp[i + 1] = dp[max(0, i - 1)]\n            dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        else:\n            dp[i + 1] = dp[i]\n\n    return dp[n]"}}, "leetcode/csn_python_train_321039.txt": {"score": 0.918572187423706, "content": {"text": "def max_interval_intersec(S):\n    \"\"\"determine a value that is contained in a largest number of given intervals\n\n    :param S: list of half open intervals\n    :complexity: O(n log n), where n = len(S)\n    \"\"\"\n    B = ([(left,  +1) for left, right in S] +\n         [(right, -1) for left, right in S])\n    B.sort()\n    c = 0\n    best = (c, None)\n    for x, d in B:\n        c += d\n        if best[0] < c:\n            best = (c, x)\n    return best"}}, "leetcode/leetcode_2432.txt": {"score": 0.9218084812164307, "content": {"text": "def worker_with_longest_task(n, logs):\n    \"\"\"There are `n` employees, each with a unique id from `0` to `n - 1`.\n\nYou are given a 2D integer array `logs` where `logs[i] = [idi, leaveTimei]` where:\n\n*   `idi` is the id of the employee that worked on the `ith` task, and\n*   `leaveTimei` is the time at which the employee finished the `ith` task. All the values `leaveTimei` are **unique**.\n\nNote that the `ith` task starts the moment right after the `(i - 1)th` task ends, and the `0th` task starts at time `0`.\n\nReturn _the id of the employee that worked the task with the longest time._ If there is a tie between two or more employees, return _the **smallest** id among them_.\n\n**Example 1:**\n\n**Input:** n = 10, logs = \\[\\[0,3\\],\\[2,5\\],\\[0,9\\],\\[1,15\\]\\]\n**Output:** 1\n**Explanation:** \nTask 0 started at 0 and ended at 3 with 3 units of times.\nTask 1 started at 3 and ended at 5 with 2 units of times.\nTask 2 started at 5 and ended at 9 with 4 units of times.\nTask 3 started at 9 and ended at 15 with 6 units of times.\nThe task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n\n**Example 2:**\n\n**Input:** n = 26, logs = \\[\\[1,1\\],\\[3,7\\],\\[2,12\\],\\[7,17\\]\\]\n**Output:** 3\n**Explanation:** \nTask 0 started at 0 and ended at 1 with 1 unit of times.\nTask 1 started at 1 and ended at 7 with 6 units of times.\nTask 2 started at 7 and ended at 12 with 5 units of times.\nTask 3 started at 12 and ended at 17 with 5 units of times.\nThe tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3.\n\n**Example 3:**\n\n**Input:** n = 2, logs = \\[\\[0,10\\],\\[1,20\\]\\]\n**Output:** 0\n**Explanation:** \nTask 0 started at 0 and ended at 10 with 10 units of times.\nTask 1 started at 10 and ended at 20 with 10 units of times.\nThe tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.\n\n**Constraints:**\n\n*   `2 <= n <= 500`\n*   `1 <= logs.length <= 500`\n*   `logs[i].length == 2`\n*   `0 <= idi <= n - 1`\n*   `1 <= leaveTimei <= 500`\n*   `idi != idi+1`\n*   `leaveTimei` are sorted in a strictly increasing order.\"\"\"\n\n    result = 0\n    max_time = logs[0][1] - 0\n\n    for i in range(1, len(logs)):\n        time = logs[i][1] - logs[i-1][1]\n        if time > max_time:\n            max_time = time\n            result = logs[i][0]\n\n    return result"}}, "leetcode/leetcode_2342.txt": {"score": 0.9124644994735718, "content": {"text": "def max_sum_numbers_with_equal_sum_of_digits(nums):\n    \"\"\"You are given a **0-indexed** array `nums` consisting of **positive** integers. You can choose two indices `i` and `j`, such that `i != j`, and the sum of digits of the number `nums[i]` is equal to that of `nums[j]`.\n\nReturn _the **maximum** value of_ `nums[i] + nums[j]` _that you can obtain over all possible indices_ `i` _and_ `j` _that satisfy the conditions._\n\n**Example 1:**\n\n**Input:** nums = \\[18,43,36,13,7\\]\n**Output:** 54\n**Explanation:** The pairs (i, j) that satisfy the conditions are:\n- (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.\n- (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.\nSo the maximum sum that we can obtain is 54.\n\n**Example 2:**\n\n**Input:** nums = \\[10,12,19,14\\]\n**Output:** -1\n**Explanation:** There are no two numbers that satisfy the conditions, so we return -1.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\"\"\"\n\n    digit_sum_to_max = {}\n    ans = -1\n\n    for num in nums:\n        sum_of_digits = sum(map(int, str(num)))\n        \n        prev_max = digit_sum_to_max.get(sum_of_digits, 0)\n        if prev_max:\n            ans = max(ans, num + prev_max)\n        \n        digit_sum_to_max[sum_of_digits] = max(num, prev_max)\n\n    return ans"}}, "leetcode/leetcode_1817.txt": {"score": 0.923604428768158, "content": {"text": "def total_money(n):\n    \"\"\"You are given the logs for users' actions on LeetCode, and an integer `k`. The logs are represented by a 2D integer array `logs` where each `logs[i] = [IDi, timei]` indicates that the user with `IDi` performed an action at the minute `timei`.\n\n**Multiple users** can perform actions simultaneously, and a single user can perform **multiple actions** in the same minute.\n\nThe **user active minutes (UAM)** for a given user is defined as the **number of unique minutes** in which the user performed an action on LeetCode. A minute can only be counted once, even if multiple actions occur during it.\n\nYou are to calculate a **1-indexed** array `answer` of size `k` such that, for each `j` (`1 <= j <= k`), `answer[j]` is the **number of users** whose **UAM** equals `j`.\n\nReturn _the array_ `answer` _as described above_.\n\n**Example 1:**\n\n**Input:** logs = \\[\\[0,5\\],\\[1,2\\],\\[0,2\\],\\[0,5\\],\\[1,3\\]\\], k = 5\n**Output:** \\[0,2,0,0,0\\]\n**Explanation:**\nThe user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).\nThe user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\nSince both users have a UAM of 2, answer\\[2\\] is 2, and the remaining answer\\[j\\] values are 0.\n\n**Example 2:**\n\n**Input:** logs = \\[\\[1,1\\],\\[2,2\\],\\[2,3\\]\\], k = 4\n**Output:** \\[1,1,0,0\\]\n**Explanation:**\nThe user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.\nThe user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\nThere is one user with a UAM of 1 and one with a UAM of 2.\nHence, answer\\[1\\] = 1, answer\\[2\\] = 1, and the remaining values are 0.\n\n**Constraints:**\n\n*   `1 <= logs.length <= 104`\n*   `0 <= IDi <= 109`\n*   `1 <= timei <= 105`\n*   `k` is in the range `[The maximum **UAM** for a user, 105]`.\"\"\"\n\n    weeks = n // 7\n    days_remaining = n % 7\n    return 28 * weeks + 7 * weeks * (weeks - 1) // 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) // 2"}}, "leetcode/leetcode_575.txt": {"score": 0.9195969700813293, "content": {"text": "def maxNumberOfCandies(candyType):\n    \"\"\"Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.\n\nThe doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n\nGiven the integer array `candyType` of length `n`, return _the **maximum** number of different types of candies she can eat if she only eats_ `n / 2` _of them_.\n\n**Example 1:**\n\n**Input:** candyType = \\[1,1,2,2,3,3\\]\n**Output:** 3\n**Explanation:** Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n\n**Example 2:**\n\n**Input:** candyType = \\[1,1,2,3\\]\n**Output:** 2\n**Explanation:** Alice can only eat 4 / 2 = 2 candies. Whether she eats types \\[1,2\\], \\[1,3\\], or \\[2,3\\], she still can only eat 2 different types.\n\n**Example 3:**\n\n**Input:** candyType = \\[6,6,6,6\\]\n**Output:** 1\n**Explanation:** Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.\n\n**Constraints:**\n\n*   `n == candyType.length`\n*   `2 <= n <= 104`\n*   `n` is even.\n*   `-105 <= candyType[i] <= 105`\"\"\"\n\n    uniqueCandies = set(candyType)\n    return min(len(uniqueCandies), len(candyType) // 2)"}}, "leetcode/leetcode_1854.txt": {"score": 0.992645800113678, "content": {"text": "def maxAliveYear(logs):\n    \"\"\"You are given a 2D integer array `logs` where each `logs[i] = [birthi, deathi]` indicates the birth and death years of the `ith` person.\n\nThe **population** of some year `x` is the number of people alive during that year. The `ith` person is counted in year `x`'s population if `x` is in the **inclusive** range `[birthi, deathi - 1]`. Note that the person is **not** counted in the year that they die.\n\nReturn _the **earliest** year with the **maximum population**_.\n\n**Example 1:**\n\n**Input:** logs = \\[\\[1993,1999\\],\\[2000,2010\\]\\]\n**Output:** 1993\n**Explanation:** The maximum population is 1, and 1993 is the earliest year with this population.\n\n**Example 2:**\n\n**Input:** logs = \\[\\[1950,1961\\],\\[1960,1971\\],\\[1970,1981\\]\\]\n**Output:** 1960\n**Explanation:** \nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960.\n\n**Constraints:**\n\n*   `1 <= logs.length <= 100`\n*   `1950 <= birthi < deathi <= 2050`\"\"\"\n\n    years = [0] * 101\n    for log in logs:\n        years[log[0] - 1950] += 1\n        years[log[1] - 1950] -= 1\n    max_population = years[0]\n    max_year = 1950\n    for i in range(1, 101):\n        years[i] += years[i - 1]\n        if years[i] > max_population:\n            max_population = years[i]\n            max_year = i + 1950\n    return max_year"}}}}, "85": {"gold": {"leetcode/leetcode_2475.txt": 1}, "retrieved": {"leetcode/leetcode_2177.txt": {"score": 0.8997628092765808, "content": {"text": "def almost_equivalent(word1, word2):\n    \"\"\"Given an integer `num`, return _three consecutive integers (as a sorted array)_ _that **sum** to_ `num`. If `num` cannot be expressed as the sum of three consecutive integers, return _an **empty** array._\n\n**Example 1:**\n\n**Input:** num = 33\n**Output:** \\[10,11,12\\]\n**Explanation:** 33 can be expressed as 10 + 11 + 12 = 33.\n10, 11, 12 are 3 consecutive integers, so we return \\[10, 11, 12\\].\n\n**Example 2:**\n\n**Input:** num = 4\n**Output:** \\[\\]\n**Explanation:** There is no way to express 4 as the sum of 3 consecutive integers.\n\n**Constraints:**\n\n*   `0 <= num <= 1015`\"\"\"\n\n    freq1 = {}\n    freq2 = {}\n\n    for c in word1:\n        freq1[c] = freq1.get(c, 0) + 1\n    for c in word2:\n        freq2[c] = freq2.get(c, 0) + 1\n\n    for c in \"abcdefghijklmnopqrstuvwxyz\":\n        if abs(freq1.get(c, 0) - freq2.get(c, 0)) > 3:\n            return False\n\n    return True"}}, "leetcode/leetcode_2597.txt": {"score": 0.8998373746871948, "content": {"text": "def countBeautifulSubsets(nums, k):\n    \"\"\"You are given an array `nums` of positive integers and a **positive** integer `k`.\n\nA subset of `nums` is **beautiful** if it does not contain two integers with an absolute difference equal to `k`.\n\nReturn _the number of **non-empty beautiful** subsets of the array_ `nums`.\n\nA **subset** of `nums` is an array that can be obtained by deleting some (possibly none) elements from `nums`. Two subsets are different if and only if the chosen indices to delete are different.\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,6\\], k = 2\n**Output:** 4\n**Explanation:** The beautiful subsets of the array nums are: \\[2\\], \\[4\\], \\[6\\], \\[2, 6\\].\nIt can be proved that there are only 4 beautiful subsets in the array \\[2,4,6\\].\n\n**Example 2:**\n\n**Input:** nums = \\[1\\], k = 1\n**Output:** 1\n**Explanation:** The beautiful subset of the array nums is \\[1\\].\nIt can be proved that there is only 1 beautiful subset in the array \\[1\\].\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `1 <= nums[i], k <= 1000`\"\"\"\n\n    nums.sort()\n    ans = 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        l = r = 0\n        for j in range(i):\n            while l < j and nums[j] - nums[l] >= k:\n                l += 1\n            while r + 1 < j and nums[r + 1] - nums[j] < k:\n                r += 1\n            dp[j] -= dp[l - 1] if l <= r else 0\n            dp[j] += dp[j - 1] + 1\n            ans += dp[j]\n    return ans"}}, "leetcode/leetcode_996.txt": {"score": 0.9104007482528687, "content": {"text": "from collections import Counter\n    \"\"\"An array is **squareful** if the sum of every pair of adjacent elements is a **perfect square**.\n\nGiven an integer array nums, return _the number of permutations of_ `nums` _that are **squareful**_.\n\nTwo permutations `perm1` and `perm2` are different if there is some index `i` such that `perm1[i] != perm2[i]`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,17,8\\]\n**Output:** 2\n**Explanation:** \\[1,8,17\\] and \\[17,8,1\\] are the valid permutations.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,2\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 12`\n*   `0 <= nums[i] <= 109`\"\"\"\n\n\ndef numSquarefulPerms(nums):\n    def is_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    def dfs(idx):\n        if idx == len(nums):\n            return 1\n\n        count = 0\n        for key in counter.keys():\n            if counter[key] and (idx == 0 or is_square(nums[idx - 1] + key)):\n                counter[key] -= 1\n                nums[idx] = key\n                count += dfs(idx + 1)\n                counter[key] += 1\n\n        return count\n\n    key_set, counter = set(nums), Counter(nums)\n    return dfs(0)"}}, "leetcode/leetcode_2367.txt": {"score": 0.9005935788154602, "content": {"text": "def count_arithmetic_triplets(nums, diff):\n    \"\"\"You are given a **0-indexed**, **strictly increasing** integer array `nums` and a positive integer `diff`. A triplet `(i, j, k)` is an **arithmetic triplet** if the following conditions are met:\n\n*   `i < j < k`,\n*   `nums[j] - nums[i] == diff`, and\n*   `nums[k] - nums[j] == diff`.\n\nReturn _the number of unique **arithmetic triplets**._\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,4,6,7,10\\], diff = 3\n**Output:** 2\n**Explanation:**\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. \n\n**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,8,9\\], diff = 2\n**Output:** 2\n**Explanation:**\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 200`\n*   `0 <= nums[i] <= 200`\n*   `1 <= diff <= 50`\n*   `nums` is **strictly** increasing.\"\"\"\n\n    count = 0\n    mp = {}\n    for num in nums:\n        if num - diff in mp:\n            count += mp[num - diff]\n        mp[num] = mp.get(num, 0) + 1\n    return count"}}, "leetcode/leetcode_829.txt": {"score": 0.9003468155860901, "content": {"text": "from collections import defaultdict\n    \"\"\"Given an integer `n`, return _the number of ways you can write_ `n` _as the sum of consecutive positive integers._\n\n**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** 5 = 2 + 3\n\n**Example 2:**\n\n**Input:** n = 9\n**Output:** 3\n**Explanation:** 9 = 4 + 5 = 2 + 3 + 4\n\n**Example 3:**\n\n**Input:** n = 15\n**Output:** 4\n**Explanation:** 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n\n**Constraints:**\n\n*   `1 <= n <= 109`\"\"\"\n\n\ndef subdomainVisits(cpdomains):\n    counts = defaultdict(int)\n    result = []\n\n    for cpdomain in cpdomains:\n        count, domain = cpdomain.split()\n        count = int(count)\n\n        for i in range(len(domain)):\n            if domain[i] == '.':\n                counts[domain[i + 1:]] += count\n        counts[domain] += count\n\n    for sub, cnt in counts.items():\n        result.append(f\"{cnt} {sub}\")\n        \n    return result"}}, "leetcode/leetcode_633.txt": {"score": 0.9307904243469238, "content": {"text": "def judge_square_sum(c):\n    \"\"\"Given a non-negative integer `c`, decide whether there're two integers `a` and `b` such that `a2 + b2 = c`.\n\n**Example 1:**\n\n**Input:** c = 5\n**Output:** true\n**Explanation:** 1 \\* 1 + 2 \\* 2 = 5\n\n**Example 2:**\n\n**Input:** c = 3\n**Output:** false\n\n**Constraints:**\n\n*   `0 <= c <= 231 - 1`\"\"\"\n\n    for a in range(int(c ** 0.5) + 1):\n        b = int((c - a * a) ** 0.5)\n        if a * a + b * b == c:\n            return True\n    return False"}}, "leetcode/leetcode_1925.txt": {"score": 0.9551509618759155, "content": {"text": "def reverse(x):\n    \"\"\"A **square triple** `(a,b,c)` is a triple where `a`, `b`, and `c` are **integers** and `a2 + b2 = c2`.\n\nGiven an integer `n`, return _the number of **square triples** such that_ `1 <= a, b, c <= n`.\n\n**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation**: The square triples are (3,4,5) and (4,3,5).\n\n**Example 2:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation**: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).\n\n**Constraints:**\n\n*   `1 <= n <= 250`\"\"\"\n\n    rev = 0\n\n    while x != 0:\n        rev = rev * 10 + x % 10\n        x = x // 10\n\n    return rev\n\ndef count_nice_pairs(nums):\n    MOD = 1_000_000_007\n    count = {}\n    result = 0\n\n    for num in nums:\n        diff = num - reverse(num)\n        count[diff] = count.get(diff, 0) + 1\n\n    for val in count.values():\n        result = (result + ((val * (val - 1)) // 2) % MOD) % MOD\n\n    return result"}}, "leetcode/leetcode_1010.txt": {"score": 0.904929518699646, "content": {"text": "def powerful_integers(x, y, bound):\n    \"\"\"You are given a list of songs where the `ith` song has a duration of `time[i]` seconds.\n\nReturn _the number of pairs of songs for which their total duration in seconds is divisible by_ `60`. Formally, we want the number of indices `i`, `j` such that `i < j` with `(time[i] + time[j]) % 60 == 0`.\n\n**Example 1:**\n\n**Input:** time = \\[30,20,150,100,40\\]\n**Output:** 3\n**Explanation:** Three pairs have a total duration divisible by 60:\n(time\\[0\\] = 30, time\\[2\\] = 150): total duration 180\n(time\\[1\\] = 20, time\\[3\\] = 100): total duration 120\n(time\\[1\\] = 20, time\\[4\\] = 40): total duration 60\n\n**Example 2:**\n\n**Input:** time = \\[60,60,60\\]\n**Output:** 3\n**Explanation:** All three pairs have a total duration of 120, which is divisible by 60.\n\n**Constraints:**\n\n*   `1 <= time.length <= 6 * 104`\n*   `1 <= time[i] <= 500`\"\"\"\n\n    result = set()\n    for i in range(20):\n        for j in range(20):\n            val = x**i + y**j\n            if val <= bound:\n                result.add(val)\n    return list(result)"}}, "leetcode/leetcode_1362.txt": {"score": 0.9106223583221436, "content": {"text": "def findClosestDivisors(num):\n    \"\"\"Given an integer `num`, find the closest two integers in absolute difference whose product equals `num + 1` or `num + 2`.\n\nReturn the two integers in any order.\n\n**Example 1:**\n\n**Input:** num = 8\n**Output:** \\[3,3\\]\n**Explanation:** For num + 1 = 9, the closest divisors are 3 & 3, for num + 2 = 10, the closest divisors are 2 & 5, hence 3 & 3 is chosen.\n\n**Example 2:**\n\n**Input:** num = 123\n**Output:** \\[5,25\\]\n\n**Example 3:**\n\n**Input:** num = 999\n**Output:** \\[40,25\\]\n\n**Constraints:**\n\n*   `1 <= num <= 10^9`\"\"\"\n\n    for i in range(int((num + 2) ** 0.5), 0, -1):\n        if (num + 1) % i == 0:\n            return [i, (num + 1) // i]\n        if (num + 2) % i == 0:\n            return [i, (num + 2) // i]\n    return []"}}, "leetcode/leetcode_447.txt": {"score": 0.9006385803222656, "content": {"text": "def numberOfBoomerangs(points):\n    \"\"\"You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**.\n\nReturn _the number of boomerangs_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:** 2\n**Explanation:** The two boomerangs are \\[\\[1,0\\],\\[0,0\\],\\[2,0\\]\\] and \\[\\[1,0\\],\\[2,0\\],\\[0,0\\]\\].\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** points = \\[\\[1,1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == points.length`\n*   `1 <= n <= 500`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the points are **unique**.\"\"\"\n\n    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count"}}}}, "86": {"gold": {"leetcode/leetcode_2381.txt": 1}, "retrieved": {"leetcode/leetcode_1326.txt": {"score": 0.916991114616394, "content": {"text": "def sum_of_floored_pairs(nums):\n    \"\"\"There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).\n\nThere are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.\n\nGiven an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.\n\nReturn _the minimum number of taps_ that should be open to water the whole garden, If the garden cannot be watered return **\\-1**.\n\n**Example 1:**\n\n**Input:** n = 5, ranges = \\[3,4,1,1,0,0\\]\n**Output:** 1\n**Explanation:** The tap at point 0 can cover the interval \\[-3,3\\]\nThe tap at point 1 can cover the interval \\[-3,5\\]\nThe tap at point 2 can cover the interval \\[1,3\\]\nThe tap at point 3 can cover the interval \\[2,4\\]\nThe tap at point 4 can cover the interval \\[4,4\\]\nThe tap at point 5 can cover the interval \\[5,5\\]\nOpening Only the second tap will water the whole garden \\[0,5\\]\n\n**Example 2:**\n\n**Input:** n = 3, ranges = \\[0,0,0,0\\]\n**Output:** -1\n**Explanation:** Even if you activate all the four taps you cannot water the whole garden.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `ranges.length == n + 1`\n*   `0 <= ranges[i] <= 100`\"\"\"\n\n    mod = 10**9 + 7\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    pref_sum = [0] * (max_val + 1)\n\n    for num in nums:\n        count[num] += 1\n\n    for i in range(1, max_val + 1):\n        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod\n\n    res = 0\n    for x in range(1, max_val + 1):\n        nx = x\n        k = 1\n        while nx <= max_val:\n            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod\n            k += 1\n            nx += x\n    return res"}}, "leetcode/leetcode_2402.txt": {"score": 0.9171393513679504, "content": {"text": "import heapq\n    \"\"\"You are given an integer `n`. There are `n` rooms numbered from `0` to `n - 1`.\n\nYou are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the **half-closed** time interval `[starti, endi)`. All the values of `starti` are **unique**.\n\nMeetings are allocated to rooms in the following manner:\n\n1.  Each meeting will take place in the unused room with the **lowest** number.\n2.  If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the **same** duration as the original meeting.\n3.  When a room becomes unused, meetings that have an earlier original **start** time should be given the room.\n\nReturn _the **number** of the room that held the most meetings._ If there are multiple rooms, return _the room with the **lowest** number._\n\nA **half-closed interval** `[a, b)` is the interval between `a` and `b` **including** `a` and **not including** `b`.\n\n**Example 1:**\n\n**Input:** n = 2, meetings = \\[\\[0,10\\],\\[1,5\\],\\[2,7\\],\\[3,4\\]\\]\n**Output:** 0\n**Explanation:**\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period \\[5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period \\[10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\n**Example 2:**\n\n**Input:** n = 3, meetings = \\[\\[1,20\\],\\[2,10\\],\\[3,5\\],\\[4,9\\],\\[6,8\\]\\]\n**Output:** 1\n**Explanation:**\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period \\[5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period \\[10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `1 <= meetings.length <= 105`\n*   `meetings[i].length == 2`\n*   `0 <= starti < endi <= 5 * 105`\n*   All the values of `starti` are **unique**.\"\"\"\n\n\ndef most_visited_room(n, meetings):\n    meetings.sort()\n    pq = []\n    rooms = [0] * n\n    \n    for start, end in meetings:\n        while pq and pq[0][0] <= start:\n            _, room = heapq.heappop(pq)\n            rooms[room] += 1\n        heapq.heappush(pq, (end, len(pq) % n))\n    \n    return rooms.index(max(rooms))"}}, "leetcode/leetcode_757.txt": {"score": 0.9207313656806946, "content": {"text": "from collections import defaultdict\n    \"\"\"You are given a 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents all the integers from `starti` to `endi` inclusively.\n\nA **containing set** is an array `nums` where each interval from `intervals` has **at least two** integers in `nums`.\n\n*   For example, if `intervals = [[1,3], [3,7], [8,9]]`, then `[1,2,4,7,8,9]` and `[2,3,4,8,9]` are **containing sets**.\n\nReturn _the minimum possible size of a containing set_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[3,7\\],\\[8,9\\]\\]\n**Output:** 5\n**Explanation:** let nums = \\[2, 3, 4, 8, 9\\].\nIt can be shown that there cannot be any containing array of size 4.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[3,5\\]\\]\n**Output:** 3\n**Explanation:** let nums = \\[2, 3, 4\\].\nIt can be shown that there cannot be any containing array of size 2.\n\n**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\],\\[4,5\\]\\]\n**Output:** 5\n**Explanation:** let nums = \\[1, 2, 3, 4, 5\\].\nIt can be shown that there cannot be any containing array of size 4.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 3000`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 108`\"\"\"\n\n\ndef pyramidTransition(bottom, allowed):\n    mapping = defaultdict(list)\n    for s in allowed:\n        mapping[s[:2]].append(s[2])\n    return dfs(\"\", bottom, mapping)\n\ndef dfs(curr, bottom, mapping):\n    if len(bottom) == 1:\n        return True\n    for i in range(len(bottom) - 1):\n        if bottom[i:i+2] not in mapping:\n            return False\n    curr = \"\".join(mapping[bottom[i:i + 2]][0] for i in range(len(bottom) - 1))\n    return dfs(curr, curr, mapping)"}}, "leetcode/csn_python_train_56158.txt": {"score": 0.9254598617553711, "content": {"text": "def windows_union(windows):\n    \"\"\"Given a list of (beginning, ending), return a minimal version that contains the same ranges.\n\n    :rtype: list\n\n    \"\"\"\n    def fix_overlap(left, right):\n        if left == right:\n            return [left]\n        assert left[0] < right[0]\n        if left[1] >= right[0]:\n            if right[1] > left[1]:\n                return [(left[0], right[1])]\n            else:\n                return [left]\n        return [left, right]\n\n    if len(windows) == 1:\n        return windows\n    none_left = []\n    none_right = []\n    otherwise = []\n    for window in windows:\n        if window[0] is None:\n            none_left.append(window)\n        elif window[1] is None:\n            none_right.append(window)\n        else:\n            otherwise.append(window)\n\n    res = []\n    otherwise.sort()\n    for window in none_left:\n        if not res:\n            res.append(window)\n            continue\n        res.extend(fix_overlap(res.pop(), window))\n    while otherwise:\n        window = otherwise.pop(0)\n        if not res:\n            res.append(window)\n            continue\n        res.extend(fix_overlap(res.pop(), window))\n    for window in none_right:\n        if not res:\n            res.append(window)\n            continue\n        res.extend(fix_overlap(res.pop(), window))\n    return res"}}, "leetcode/leetcode_1024.txt": {"score": 0.9341272711753845, "content": {"text": "def count_and_triples(nums):\n    \"\"\"You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n*   For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** clips = \\[\\[0,2\\],\\[4,6\\],\\[8,10\\],\\[1,9\\],\\[1,5\\],\\[5,9\\]\\], time = 10\n**Output:** 3\n**Explanation:** We take the clips \\[0,2\\], \\[8,10\\], \\[1,9\\]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut \\[1,9\\] into segments \\[1,2\\] + \\[2,8\\] + \\[8,9\\].\nNow we have segments \\[0,2\\] + \\[2,8\\] + \\[8,10\\] which cover the sporting event \\[0, 10\\].\n\n**Example 2:**\n\n**Input:** clips = \\[\\[0,1\\],\\[1,2\\]\\], time = 5\n**Output:** -1\n**Explanation:** We cannot cover \\[0,5\\] with only \\[0,1\\] and \\[1,2\\].\n\n**Example 3:**\n\n**Input:** clips = \\[\\[0,1\\],\\[6,8\\],\\[0,2\\],\\[5,6\\],\\[0,4\\],\\[0,3\\],\\[6,7\\],\\[1,3\\],\\[4,7\\],\\[1,4\\],\\[2,5\\],\\[2,6\\],\\[3,4\\],\\[4,5\\],\\[5,7\\],\\[6,9\\]\\], time = 9\n**Output:** 3\n**Explanation:** We can take clips \\[0,4\\], \\[4,7\\], and \\[6,9\\].\n\n**Constraints:**\n\n*   `1 <= clips.length <= 100`\n*   `0 <= starti <= endi <= 100`\n*   `1 <= time <= 100`\n\n0 <= i < j < k < nums.length, and nums\\[i\\] & nums\\[j\\] & nums\\[k\\] != 0. (\\`&\\` represents the bitwise AND operation.)\"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count"}}, "leetcode/leetcode_2580.txt": {"score": 0.9375786781311035, "content": {"text": "def total_ways_to_split_ranges(ranges):\n    \"\"\"You are given a 2D integer array `ranges` where `ranges[i] = [starti, endi]` denotes that all integers between `starti` and `endi` (both **inclusive**) are contained in the `ith` range.\n\nYou are to split `ranges` into **two** (possibly empty) groups such that:\n\n*   Each range belongs to exactly one group.\n*   Any two **overlapping** ranges must belong to the **same** group.\n\nTwo ranges are said to be **overlapping** if there exists at least **one** integer that is present in both ranges.\n\n*   For example, `[1, 3]` and `[2, 5]` are overlapping because `2` and `3` occur in both ranges.\n\nReturn _the **total number** of ways to split_ `ranges` _into two groups_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** ranges = \\[\\[6,10\\],\\[5,15\\]\\]\n**Output:** 2\n**Explanation:** \nThe two ranges are overlapping, so they must be in the same group.\nThus, there are two possible ways:\n- Put both the ranges together in group 1.\n- Put both the ranges together in group 2.\n\n**Example 2:**\n\n**Input:** ranges = \\[\\[1,3\\],\\[10,20\\],\\[2,5\\],\\[4,8\\]\\]\n**Output:** 4\n**Explanation:** \nRanges \\[1,3\\], and \\[2,5\\] are overlapping. So, they must be in the same group.\nAgain, ranges \\[2,5\\] and \\[4,8\\] are also overlapping. So, they must also be in the same group. \nThus, there are four possible ways to group them:\n- All the ranges in group 1.\n- All the ranges in group 2.\n- Ranges \\[1,3\\], \\[2,5\\], and \\[4,8\\] in group 1 and \\[10,20\\] in group 2.\n- Ranges \\[1,3\\], \\[2,5\\], and \\[4,8\\] in group 2 and \\[10,20\\] in group 1.\n\n**Constraints:**\n\n*   `1 <= ranges.length <= 105`\n*   `ranges[i].length == 2`\n*   `0 <= starti <= endi <= 109`\"\"\"\n\n    MOD = 10**9 + 7\n    ranges.sort(key=lambda x: x[1])\n    overlapping, non_overlapping, prev_end = 0, 1, -1\n\n    for start, end in ranges:\n        if start <= prev_end:\n            overlapping += 1\n        else:\n            non_overlapping += 1\n        prev_end = max(prev_end, end)\n\n    result = 1\n    for i in range(1, overlapping + 1):\n        result = (result * 2) % MOD\n\n    return result"}}, "leetcode/csn_python_train_308100.txt": {"score": 0.929853618144989, "content": {"text": "def range_union(ranges):\n    \"\"\"\n    Returns total size of ranges, expect range as (chr, left, right)\n\n    >>> ranges = [(\"1\", 30, 45), (\"1\", 40, 50), (\"1\", 10, 50)]\n    >>> range_union(ranges)\n    41\n    >>> ranges = [(\"1\", 30, 45), (\"2\", 40, 50)]\n    >>> range_union(ranges)\n    27\n    >>> ranges = [(\"1\", 30, 45), (\"1\", 45, 50)]\n    >>> range_union(ranges)\n    21\n    >>> range_union([])\n    0\n    \"\"\"\n    if not ranges:\n        return 0\n\n    ranges.sort()\n\n    total_len = 0\n    cur_chr, cur_left, cur_right = ranges[0]  # left-most range\n    for r in ranges:\n        # open new range if left > cur_right or chr != cur_chr\n        if r[1] > cur_right or r[0] != cur_chr:\n            total_len += cur_right - cur_left + 1\n            cur_chr, cur_left, cur_right = r\n        else:\n            # update cur_right\n            cur_right = max(r[2], cur_right)\n\n    # the last one\n    total_len += cur_right - cur_left + 1\n\n    return total_len"}}, "leetcode/leetcode_1943.txt": {"score": 0.9976847171783447, "content": {"text": "def splitPainting(segments):\n    \"\"\"There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a **unique** color. You are given a 2D integer array `segments`, where `segments[i] = [starti, endi, colori]` represents the **half-closed segment** `[starti, endi)` with `colori` as the color.\n\nThe colors in the overlapping segments of the painting were **mixed** when it was painted. When two or more colors mix, they form a new color that can be represented as a **set** of mixed colors.\n\n*   For example, if colors `2`, `4`, and `6` are mixed, then the resulting mixed color is `{2,4,6}`.\n\nFor the sake of simplicity, you should only output the **sum** of the elements in the set rather than the full set.\n\nYou want to **describe** the painting with the **minimum** number of non-overlapping **half-closed segments** of these mixed colors. These segments can be represented by the 2D array `painting` where `painting[j] = [leftj, rightj, mixj]` describes a **half-closed segment** `[leftj, rightj)` with the mixed color **sum** of `mixj`.\n\n*   For example, the painting created with `segments = [[1,4,5],[1,7,7]]` can be described by `painting = [[1,4,12],[4,7,7]]` because:\n    *   `[1,4)` is colored `{5,7}` (with a sum of `12`) from both the first and second segments.\n    *   `[4,7)` is colored `{7}` from only the second segment.\n\nReturn _the 2D array_ `painting` _describing the finished painting (excluding any parts that are **not** painted). You may return the segments in **any order**_.\n\nA **half-closed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`.\n\n**Example 1:**\n\n**Input:** segments = \\[\\[1,4,5\\],\\[4,7,7\\],\\[1,7,9\\]\\]\n**Output:** \\[\\[1,4,14\\],\\[4,7,16\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,4) is colored {5,9} (with a sum of 14) from the first and third segments.\n- \\[4,7) is colored {7,9} (with a sum of 16) from the second and third segments.\n\n**Example 2:**\n\n**Input:** segments = \\[\\[1,7,9\\],\\[6,8,15\\],\\[8,10,7\\]\\]\n**Output:** \\[\\[1,6,9\\],\\[6,7,24\\],\\[7,8,15\\],\\[8,10,7\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,6) is colored 9 from the first segment.\n- \\[6,7) is colored {9,15} (with a sum of 24) from the first and second segments.\n- \\[7,8) is colored 15 from the second segment.\n- \\[8,10) is colored 7 from the third segment.\n\n**Example 3:**\n\n**Input:** segments = \\[\\[1,4,5\\],\\[1,4,7\\],\\[4,7,1\\],\\[4,7,11\\]\\]\n**Output:** \\[\\[1,4,12\\],\\[4,7,12\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,4) is colored {5,7} (with a sum of 12) from the first and second segments.\n- \\[4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.\nNote that returning a single segment \\[1,7) is incorrect because the mixed color sets are different.\n\n**Constraints:**\n\n*   `1 <= segments.length <= 2 * 104`\n*   `segments[i].length == 3`\n*   `1 <= starti < endi <= 105`\n*   `1 <= colori <= 109`\n*   Each `colori` is distinct.\"\"\"\n\n    line = {}\n    for s in segments:\n        start, end, color = s\n        if start not in line:\n            line[start] = 0\n        if end not in line:\n            line[end] = 0\n        line[start] += color\n        line[end] -= color\n    res = []\n    pre = 0\n    sum = 0\n    for key in sorted(line.keys()):\n        if pre > 0:\n            if sum > 0:\n                res.append([pre, key, sum])\n        pre = key\n        sum += line[key]\n    return res"}}, "leetcode/leetcode_2406.txt": {"score": 0.9378215074539185, "content": {"text": "import heapq\n    \"\"\"You are given a 2D integer array `intervals` where `intervals[i] = [lefti, righti]` represents the **inclusive** interval `[lefti, righti]`.\n\nYou have to divide the intervals into one or more **groups** such that each interval is in **exactly** one group, and no two intervals that are in the same group **intersect** each other.\n\nReturn _the **minimum** number of groups you need to make_.\n\nTwo intervals **intersect** if there is at least one common number between them. For example, the intervals `[1, 5]` and `[5, 8]` intersect.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[5,10\\],\\[6,8\\],\\[1,5\\],\\[2,3\\],\\[1,10\\]\\]\n**Output:** 3\n**Explanation:** We can divide the intervals into the following groups:\n- Group 1: \\[1, 5\\], \\[6, 8\\].\n- Group 2: \\[2, 3\\], \\[5, 10\\].\n- Group 3: \\[1, 10\\].\nIt can be proven that it is not possible to divide the intervals into fewer than 3 groups.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[5,6\\],\\[8,10\\],\\[11,13\\]\\]\n**Output:** 1\n**Explanation:** None of the intervals overlap, so we can put all of them in one group.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `intervals[i].length == 2`\n*   `1 <= lefti <= righti <= 106`\"\"\"\n\n\ndef min_groups(intervals):\n    intervals.sort()\n    pq = []\n    for interval in intervals:\n        if pq and pq[0] < interval[0]:\n            heapq.heappop(pq)\n        heapq.heappush(pq, interval[1])\n    return len(pq)"}}, "leetcode/leetcode_2589.txt": {"score": 0.9389011263847351, "content": {"text": "def min_time_on(tasks):\n    \"\"\"There is a computer that can run an unlimited number of tasks **at the same time**. You are given a 2D integer array `tasks` where `tasks[i] = [starti, endi, durationi]` indicates that the `ith` task should run for a total of `durationi` seconds (not necessarily continuous) within the **inclusive** time range `[starti, endi]`.\n\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\n\nReturn _the minimum time during which the computer should be turned on to complete all tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[2,3,1\\],\\[4,5,1\\],\\[1,5,2\\]\\]\n**Output:** 2\n**Explanation:** \n- The first task can be run in the inclusive time range \\[2, 2\\].\n- The second task can be run in the inclusive time range \\[5, 5\\].\n- The third task can be run in the two inclusive time ranges \\[2, 2\\] and \\[5, 5\\].\nThe computer will be on for a total of 2 seconds.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3,2\\],\\[2,5,3\\],\\[5,6,2\\]\\]\n**Output:** 4\n**Explanation:** \n- The first task can be run in the inclusive time range \\[2, 3\\].\n- The second task can be run in the inclusive time ranges \\[2, 3\\] and \\[5, 5\\].\n- The third task can be run in the two inclusive time range \\[5, 6\\].\nThe computer will be on for a total of 4 seconds.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 2000`\n*   `tasks[i].length == 3`\n*   `1 <= starti, endi <= 2000`\n*   `1 <= durationi <= endi - starti + 1`\"\"\"\n\n    intervals = sorted([[task[1] + 1, task[2]] for task in tasks])\n\n    dp = [0] * 2001\n    for interval in intervals:\n        for i in range(2000, interval[0] - 1, -1):\n            dp[i] = max(dp[i], dp[i - interval[1]] + interval[1])\n\n    return dp[-1]"}}}}, "87": {"gold": {"leetcode/leetcode_2104.txt": 1, "leetcode/leetcode_2281.txt": 1}, "retrieved": {"leetcode/leetcode_1800.txt": {"score": 0.9025672078132629, "content": {"text": "def concatenated_binary(n: int) -> int:\n    \"\"\"Given an array of positive integers `nums`, return the _maximum possible sum of an **ascending** subarray in_ `nums`.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nA subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is **ascending** if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is **ascending**.\n\n**Example 1:**\n\n**Input:** nums = \\[10,20,30,5,10,50\\]\n**Output:** 65\n**Explanation:** \\[5,10,50\\] is the ascending subarray with the maximum sum of 65.\n\n**Example 2:**\n\n**Input:** nums = \\[10,20,30,40,50\\]\n**Output:** 150\n**Explanation:** \\[10,20,30,40,50\\] is the ascending subarray with the maximum sum of 150.\n\n**Example 3:**\n\n**Input:** nums = \\[12,17,15,13,10,11,12\\]\n**Output:** 33\n**Explanation:** \\[10,11,12\\] is the ascending subarray with the maximum sum of 33.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`\"\"\"\n\n    result = 0\n    mod = 1000000007\n    for i in range(1, n + 1):\n        length = len(bin(i)) - 2\n        result = ((result << length) % mod + i) % mod\n    return result"}}, "leetcode/leetcode_825.txt": {"score": 0.9032261371612549, "content": {"text": "def max_increase_keeping_skyline(grid):\n    \"\"\"There are `n` persons on a social media website. You are given an integer array `ages` where `ages[i]` is the age of the `ith` person.\n\nA Person `x` will not send a friend request to a person `y` (`x != y`) if any of the following conditions is true:\n\n*   `age[y] <= 0.5 * age[x] + 7`\n*   `age[y] > age[x]`\n*   `age[y] > 100 && age[x] < 100`\n\nOtherwise, `x` will send a friend request to `y`.\n\nNote that if `x` sends a request to `y`, `y` will not necessarily send a request to `x`. Also, a person will not send a friend request to themself.\n\nReturn _the total number of friend requests made_.\n\n**Example 1:**\n\n**Input:** ages = \\[16,16\\]\n**Output:** 2\n**Explanation:** 2 people friend request each other.\n\n**Example 2:**\n\n**Input:** ages = \\[16,17,18\\]\n**Output:** 2\n**Explanation:** Friend requests are made 17 -> 16, 18 -> 17.\n\n**Example 3:**\n\n**Input:** ages = \\[20,30,100,110,120\\]\n**Output:** 3\n**Explanation:** Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\n**Constraints:**\n\n*   `n == ages.length`\n*   `1 <= n <= 2 * 104`\n*   `1 <= ages[i] <= 120`\"\"\"\n\n    n = len(grid)\n    row_max = [0] * n\n    col_max = [0] * n\n    \n    for i in range(n):\n        for j in range(n):\n            row_max[i] = max(row_max[i], grid[i][j])\n            col_max[j] = max(col_max[j], grid[i][j])\n    \n    total_sum = 0\n    for i in range(n):\n        for j in range(n):\n            total_sum += min(row_max[i], col_max[j]) - grid[i][j]\n    \n    return total_sum"}}, "leetcode/leetcode_2274.txt": {"score": 0.9078668355941772, "content": {"text": "def final_value(nums, original):\n    \"\"\"Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.\n\nYou are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.\n\nReturn _the **maximum** number of consecutive floors without a special floor_.\n\n**Example 1:**\n\n**Input:** bottom = 2, top = 9, special = \\[4,6\\]\n**Output:** 3\n**Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors.\n\n**Example 2:**\n\n**Input:** bottom = 6, top = 8, special = \\[7,6,8\\]\n**Output:** 0\n**Explanation:** Every floor rented is a special floor, so we return 0.\n\n**Constraints:**\n\n*   `1 <= special.length <= 105`\n*   `1 <= bottom <= special[i] <= top <= 109`\n*   All the values of `special` are **unique**.\"\"\"\n\n    while original in nums:\n        original += 1\n    return original"}}, "leetcode/leetcode_2454.txt": {"score": 0.9175246357917786, "content": {"text": "def find_second_greater(nums):\n    \"\"\"You are given a **0-indexed** array of non-negative integers `nums`. For each integer in `nums`, you must find its respective **second greater** integer.\n\nThe **second greater** integer of `nums[i]` is `nums[j]` such that:\n\n*   `j > i`\n*   `nums[j] > nums[i]`\n*   There exists **exactly one** index `k` such that `nums[k] > nums[i]` and `i < k < j`.\n\nIf there is no such `nums[j]`, the second greater integer is considered to be `-1`.\n\n*   For example, in the array `[1, 2, 4, 3]`, the second greater integer of `1` is `4`, `2` is `3`, and that of `3` and `4` is `-1`.\n\nReturn _an integer array_ `answer`_, where_ `answer[i]` _is the second greater integer of_ `nums[i]`_._\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,0,9,6\\]\n**Output:** \\[9,6,6,-1,-1\\]\n**Explanation:**\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return \\[9,6,6,-1,-1\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,3\\]\n**Output:** \\[-1,-1\\]\n**Explanation:**\nWe return \\[-1,-1\\] since neither integer has any integer greater than it.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`\"\"\"\n\n    n = len(nums)\n    answer = [-1] * n\n    for i in range(n):\n        k = -1\n        for j in range(i + 1, n):\n            if nums[j] > nums[i]:\n                if k == -1:\n                    k = j\n                else:\n                    answer[i] = nums[j]\n                    break\n    return answer"}}, "leetcode/leetcode_1840.txt": {"score": 0.9080771803855896, "content": {"text": "from collections import defaultdict\n    \"\"\"You want to build `n` new buildings in a city. The new buildings will be built in a line and are labeled from `1` to `n`.\n\nHowever, there are city restrictions on the heights of the new buildings:\n\n*   The height of each building must be a non-negative integer.\n*   The height of the first building **must** be `0`.\n*   The height difference between any two adjacent buildings **cannot exceed** `1`.\n\nAdditionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array `restrictions` where `restrictions[i] = [idi, maxHeighti]` indicates that building `idi` must have a height **less than or equal to** `maxHeighti`.\n\nIt is guaranteed that each building will appear **at most once** in `restrictions`, and building `1` will **not** be in `restrictions`.\n\nReturn _the **maximum possible height** of the **tallest** building_.\n\n**Example 1:**\n\n**Input:** n = 5, restrictions = \\[\\[2,1\\],\\[4,1\\]\\]\n**Output:** 2\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,1,2\\], and the tallest building has a height of 2.\n\n**Example 2:**\n\n**Input:** n = 6, restrictions = \\[\\]\n**Output:** 5\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,3,4,5\\], and the tallest building has a height of 5.\n\n**Example 3:**\n\n**Input:** n = 10, restrictions = \\[\\[5,3\\],\\[2,5\\],\\[7,4\\],\\[10,3\\]\\]\n**Output:** 5\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,3,3,4,4,5,4,3\\], and the tallest building has a height of 5.\n\n**Constraints:**\n\n*   `2 <= n <= 109`\n*   `0 <= restrictions.length <= min(n - 1, 105)`\n*   `2 <= idi <= n`\n*   `idi` is **unique**.\n*   `0 <= maxHeighti <= 109`\"\"\"\n\n\ndef dfs(node, visited, graph, group):\n    if visited[node]:\n        return\n    visited[node] = 1\n    group.append(node)\n    for neighbor in graph[node]:\n        dfs(neighbor, visited, graph, group)\n\ndef minimumHammingDistance(source, target, allowedSwaps):\n    n = len(source)\n    graph = defaultdict(list)\n    for a, b in allowedSwaps:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    res = 0\n    visited = [0] * n\n    for i in range(n):\n        if not visited[i]:\n            group = []\n            dfs(i, visited, graph, group)\n            count = defaultdict(int)\n\n            for node in group:\n                count[source[node]] += 1\n            for node in group:\n                if count[target[node]] > 0:\n                    res += 1\n                    count[target[node]] -= 1\n\n    return n - res"}}, "leetcode/leetcode_2432.txt": {"score": 0.90838223695755, "content": {"text": "def worker_with_longest_task(n, logs):\n    \"\"\"There are `n` employees, each with a unique id from `0` to `n - 1`.\n\nYou are given a 2D integer array `logs` where `logs[i] = [idi, leaveTimei]` where:\n\n*   `idi` is the id of the employee that worked on the `ith` task, and\n*   `leaveTimei` is the time at which the employee finished the `ith` task. All the values `leaveTimei` are **unique**.\n\nNote that the `ith` task starts the moment right after the `(i - 1)th` task ends, and the `0th` task starts at time `0`.\n\nReturn _the id of the employee that worked the task with the longest time._ If there is a tie between two or more employees, return _the **smallest** id among them_.\n\n**Example 1:**\n\n**Input:** n = 10, logs = \\[\\[0,3\\],\\[2,5\\],\\[0,9\\],\\[1,15\\]\\]\n**Output:** 1\n**Explanation:** \nTask 0 started at 0 and ended at 3 with 3 units of times.\nTask 1 started at 3 and ended at 5 with 2 units of times.\nTask 2 started at 5 and ended at 9 with 4 units of times.\nTask 3 started at 9 and ended at 15 with 6 units of times.\nThe task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n\n**Example 2:**\n\n**Input:** n = 26, logs = \\[\\[1,1\\],\\[3,7\\],\\[2,12\\],\\[7,17\\]\\]\n**Output:** 3\n**Explanation:** \nTask 0 started at 0 and ended at 1 with 1 unit of times.\nTask 1 started at 1 and ended at 7 with 6 units of times.\nTask 2 started at 7 and ended at 12 with 5 units of times.\nTask 3 started at 12 and ended at 17 with 5 units of times.\nThe tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3.\n\n**Example 3:**\n\n**Input:** n = 2, logs = \\[\\[0,10\\],\\[1,20\\]\\]\n**Output:** 0\n**Explanation:** \nTask 0 started at 0 and ended at 10 with 10 units of times.\nTask 1 started at 10 and ended at 20 with 10 units of times.\nThe tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.\n\n**Constraints:**\n\n*   `2 <= n <= 500`\n*   `1 <= logs.length <= 500`\n*   `logs[i].length == 2`\n*   `0 <= idi <= n - 1`\n*   `1 <= leaveTimei <= 500`\n*   `idi != idi+1`\n*   `leaveTimei` are sorted in a strictly increasing order.\"\"\"\n\n    result = 0\n    max_time = logs[0][1] - 0\n\n    for i in range(1, len(logs)):\n        time = logs[i][1] - logs[i-1][1]\n        if time > max_time:\n            max_time = time\n            result = logs[i][0]\n\n    return result"}}, "leetcode/leetcode_875.txt": {"score": 0.9119672179222107, "content": {"text": "def longest_mountain(arr):\n    \"\"\"Koko loves to eat bananas. There are `n` piles of bananas, the `ith` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.\n\n**Example 1:**\n\n**Input:** piles = \\[3,6,7,11\\], h = 8\n**Output:** 4\n\n**Example 2:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 5\n**Output:** 30\n\n**Example 3:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 6\n**Output:** 23\n\n**Constraints:**\n\n*   `1 <= piles.length <= 104`\n*   `piles.length <= h <= 109`\n*   `1 <= piles[i] <= 109`\"\"\"\n\n    n = len(arr)\n    max_length = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            left = i - 1\n            right = i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] > arr[right + 1]:\n                right += 1\n            max_length = max(max_length, right - left + 1)\n            i = right\n        else:\n            i += 1\n    return max_length"}}, "leetcode/leetcode_1964.txt": {"score": 0.9354729652404785, "content": {"text": "def longest_obstacle_course(obstacles):\n    \"\"\"You want to build some obstacle courses. You are given a **0-indexed** integer array `obstacles` of length `n`, where `obstacles[i]` describes the height of the `ith` obstacle.\n\nFor every index `i` between `0` and `n - 1` (**inclusive**), find the length of the **longest obstacle course** in `obstacles` such that:\n\n*   You choose any number of obstacles between `0` and `i` **inclusive**.\n*   You must include the `ith` obstacle in the course.\n*   You must put the chosen obstacles in the **same order** as they appear in `obstacles`.\n*   Every obstacle (except the first) is **taller** than or the **same height** as the obstacle immediately before it.\n\nReturn _an array_ `ans` _of length_ `n`, _where_ `ans[i]` _is the length of the **longest obstacle course** for index_ `i` _as described above_.\n\n**Example 1:**\n\n**Input:** obstacles = \\[1,2,3,2\\]\n**Output:** \\[1,2,3,3\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[1\\], \\[1\\] has length 1.\n- i = 1: \\[1,2\\], \\[1,2\\] has length 2.\n- i = 2: \\[1,2,3\\], \\[1,2,3\\] has length 3.\n- i = 3: \\[1,2,3,2\\], \\[1,2,2\\] has length 3.\n\n**Example 2:**\n\n**Input:** obstacles = \\[2,2,1\\]\n**Output:** \\[1,2,1\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[2\\], \\[2\\] has length 1.\n- i = 1: \\[2,2\\], \\[2,2\\] has length 2.\n- i = 2: \\[2,2,1\\], \\[1\\] has length 1.\n\n**Example 3:**\n\n**Input:** obstacles = \\[3,1,5,6,4,2\\]\n**Output:** \\[1,1,2,3,2,2\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[3\\], \\[3\\] has length 1.\n- i = 1: \\[3,1\\], \\[1\\] has length 1.\n- i = 2: \\[3,1,5\\], \\[3,5\\] has length 2. \\[1,5\\] is also valid.\n- i = 3: \\[3,1,5,6\\], \\[3,5,6\\] has length 3. \\[1,5,6\\] is also valid.\n- i = 4: \\[3,1,5,6,4\\], \\[3,4\\] has length 2. \\[1,4\\] is also valid.\n- i = 5: \\[3,1,5,6,4,2\\], \\[1,2\\] has length 2.\n\n**Constraints:**\n\n*   `n == obstacles.length`\n*   `1 <= n <= 105`\n*   `1 <= obstacles[i] <= 107`\"\"\"\n\n    dp = []\n    ans = [0] * len(obstacles)\n\n    for obstacle in obstacles:\n        index = bisect_left(dp, obstacle)\n        ans[index] = index + 1\n        if index == len(dp):\n            dp.append(obstacle)\n        else:\n            dp[index] = obstacle\n\n    return ans"}}, "leetcode/leetcode_2012.txt": {"score": 0.9192745089530945, "content": {"text": "from queue import PriorityQueue\n    \"\"\"You are given a **0-indexed** integer array `nums`. For each index `i` (`1 <= i <= nums.length - 2`) the **beauty** of `nums[i]` equals:\n\n*   `2`, if `nums[j] < nums[i] < nums[k]`, for **all** `0 <= j < i` and for **all** `i < k <= nums.length - 1`.\n*   `1`, if `nums[i - 1] < nums[i] < nums[i + 1]`, and the previous condition is not satisfied.\n*   `0`, if none of the previous conditions holds.\n\nReturn _the **sum of beauty** of all_ `nums[i]` _where_ `1 <= i <= nums.length - 2`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** For each index i in the range 1 <= i <= 1:\n- The beauty of nums\\[1\\] equals 2.\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,6,4\\]\n**Output:** 1\n**Explanation:** For each index i in the range 1 <= i <= 2:\n- The beauty of nums\\[1\\] equals 1.\n- The beauty of nums\\[2\\] equals 0.\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 0\n**Explanation:** For each index i in the range 1 <= i <= 1:\n- The beauty of nums\\[1\\] equals 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\"\"\"\n\n\ndef assignTasks(servers, tasks):\n    n, m = len(servers), len(tasks)\n    ans = [0] * m\n    freeServers = PriorityQueue()\n\n    for i in range(n):\n        freeServers.put((servers[i], i))\n\n    busyServers = PriorityQueue()\n    currentTask = 0\n\n    while currentTask < m:\n        while not busyServers.empty() and busyServers.queue[0][0] <= currentTask:\n            _, idx = busyServers.get()\n            freeServers.put((servers[idx], idx))\n\n        while not freeServers.empty() and currentTask < m:\n            _, idx = freeServers.get()\n            ans[currentTask] = idx\n            busyServers.put((currentTask + tasks[currentTask], idx))\n            currentTask += 1\n            \n        if freeServers.empty():\n            currentTask = busyServers.queue[0][0]\n    \n    return ans"}}, "leetcode/leetcode_1944.txt": {"score": 0.991288959980011, "content": {"text": "def truncate_sentence(s, k):\n    \"\"\"There are `n` people standing in a queue, and they numbered from `0` to `n - 1` in **left to right** order. You are given an array `heights` of **distinct** integers where `heights[i]` represents the height of the `ith` person.\n\nA person can **see** another person to their right in the queue if everybody in between is **shorter** than both of them. More formally, the `ith` person can see the `jth` person if `i < j` and `min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])`.\n\nReturn _an array_ `answer` _of length_ `n` _where_ `answer[i]` _is the **number of people** the_ `ith` _person can **see** to their right in the queue_.\n\n**Example 1:**\n\n**Input:** heights = \\[10,6,8,5,11,9\\]\n**Output:** \\[3,1,2,1,1,0\\]\n**Explanation:**\nPerson 0 can see person 1, 2, and 4.\nPerson 1 can see person 2.\nPerson 2 can see person 3 and 4.\nPerson 3 can see person 4.\nPerson 4 can see person 5.\nPerson 5 can see no one since nobody is to the right of them.\n\n**Example 2:**\n\n**Input:** heights = \\[5,1,2,3,10\\]\n**Output:** \\[4,1,1,1,0\\]\n\n**Constraints:**\n\n*   `n == heights.length`\n*   `1 <= n <= 105`\n*   `1 <= heights[i] <= 105`\n*   All the values of `heights` are **unique**.\"\"\"\n\n    words = s.split(' ')\n    return ' '.join(words[:k])"}}}}, "88": {"gold": {"leetcode/leetcode_1979.txt": 1, "leetcode/leetcode_2413.txt": 1}, "retrieved": {"leetcode/csn_python_train_171692.txt": {"score": 0.9248184561729431, "content": {"text": "def divisors(n):\n    \"\"\"\n    From a given natural integer, returns the list of divisors in ascending order\n    :param n: Natural integer\n    :return: List of divisors of n in ascending order\n    \"\"\"\n    factors = _factor_generator(n)\n    _divisors = []\n    listexponents = [[k**x for x in range(0, factors[k]+1)] for k in list(factors.keys())]\n    listfactors = _cartesian_product(listexponents)\n    for f in listfactors:\n        _divisors.append(reduce(lambda x, y: x*y, f, 1))\n    _divisors.sort()\n    return _divisors"}}, "leetcode/csn_python_train_70107.txt": {"score": 0.9313786625862122, "content": {"text": "def factors(number):\n    \"\"\"\n    Find all of the factors of a number and return it as a list.\n\n    :type number: integer\n    :param number: The number to find the factors for.\n    \"\"\"\n\n    if not (isinstance(number, int)):\n        raise TypeError(\n            \"Incorrect number type provided. Only integers are accepted.\")\n\n    factors = []\n    for i in range(1, number + 1):\n        if number % i == 0:\n            factors.append(i)\n    return factors"}}, "leetcode/csn_python_train_3924.txt": {"score": 0.9326907992362976, "content": {"text": "def get_factors(n):\n    \"\"\"[summary]\n    \n    Arguments:\n        n {[int]} -- [to analysed number]\n    \n    Returns:\n        [list of lists] -- [all factors of the number n]\n    \"\"\"\n\n    def factor(n, i, combi, res):\n        \"\"\"[summary]\n        helper function\n\n        Arguments:\n            n {[int]} -- [number]\n            i {[int]} -- [to tested divisor]\n            combi {[list]} -- [catch divisors]\n            res {[list]} -- [all factors of the number n]\n        \n        Returns:\n            [list] -- [res]\n        \"\"\"\n\n        while i * i <= n:\n            if n % i == 0:\n                res += combi + [i, int(n/i)],\n                factor(n/i, i, combi+[i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])"}}, "leetcode/csn_python_train_85244.txt": {"score": 0.9348095655441284, "content": {"text": "def count_divisors(n):\n\n    \"\"\" Count the number of divisors of an integer n\n\n    Args:\n        n (int): strictly positive integer\n\n    Returns:\n        The number of distinct divisors of n\n\n    Raises:\n        TypeError: if n is not an integer\n        ValueError: if n is negative\n\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Expecting a strictly positive integer\")\n    if n <= 0:\n        raise ValueError(\"Expecting a strictly positive integer\")\n\n    number_of_divisors = 1\n    remain = n\n\n    for p in prime_generator():\n        if p > n:\n            return number_of_divisors\n\n        exponent = 1\n        while remain % p == 0:\n            remain = remain // p\n            exponent += 1\n        number_of_divisors *= exponent\n\n        if remain == 1:\n            return number_of_divisors"}}, "leetcode/csn_python_train_48424.txt": {"score": 0.9436153173446655, "content": {"text": "def divisors(n):\n  \"\"\"Generate the divisors of n\"\"\"\n  for i in range(1, int(math.sqrt(n) + 1)):\n    if n % i == 0:\n      yield i\n      if i*i != n:\n        yield n / i"}}, "leetcode/csn_python_train_85243.txt": {"score": 0.9472046494483948, "content": {"text": "def find_divisors(n):\n\n    \"\"\" Find all the positive divisors of the given integer n.\n\n    Args:\n        n (int): strictly positive integer\n\n    Returns:\n        A generator of all the positive divisors of n\n\n    Raises:\n        TypeError: if n is not an integer\n        ValueError: if n is negative\n\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Expecting a strictly positive integer\")\n    if n <= 0:\n        raise ValueError(\"Expecting a strictly positive integer\")\n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors = {i, n//i}\n            for divisor in divisors:\n                yield divisor"}}, "leetcode/csn_python_train_286785.txt": {"score": 0.9392593502998352, "content": {"text": "def factors(n):\n    \"\"\"\n    Computes all the integer factors of the number `n`\n\n    Example:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_alg import *  # NOQA\n        >>> import utool as ut\n        >>> result = sorted(ut.factors(10))\n        >>> print(result)\n        [1, 2, 5, 10]\n\n    References:\n        http://stackoverflow.com/questions/6800193/finding-all-the-factors\n    \"\"\"\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))"}}, "leetcode/leetcode_1952.txt": {"score": 0.9652895927429199, "content": {"text": "def minSideJumps(obstacles):\n    \"\"\"Given an integer `n`, return `true` _if_ `n` _has **exactly three positive divisors**. Otherwise, return_ `false`.\n\nAn integer `m` is a **divisor** of `n` if there exists an integer `k` such that `n = k * m`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** false\n**Explantion:** 2 has only two divisors: 1 and 2.\n\n**Example 2:**\n\n**Input:** n = 4\n**Output:** true\n**Explantion:** 4 has three divisors: 1, 2, and 4.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\"\"\"\n\n    n = len(obstacles)\n    dp = [[n] * 3 for _ in range(n)]\n    dp[0][1] = 0\n    dp[0][0] = dp[0][2] = 1\n\n    for i in range(1, n):\n        if obstacles[i] != 1:\n            dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + 1, dp[i - 1][2] + 1)\n        if obstacles[i] != 2:\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0] + 1, dp[i - 1][2] + 1)\n        if obstacles[i] != 3:\n            dp[i][2] = min(dp[i - 1][2], dp[i - 1][0] + 1, dp[i - 1][1] + 1)\n\n    return min(dp[-1])"}}, "leetcode/leetcode_507.txt": {"score": 0.9357019662857056, "content": {"text": "def checkPerfectNumber(num: int) -> bool:\n    \"\"\"A [**perfect number**](https://en.wikipedia.org/wiki/Perfect_number) is a **positive integer** that is equal to the sum of its **positive divisors**, excluding the number itself. A **divisor** of an integer `x` is an integer that can divide `x` evenly.\n\nGiven an integer `n`, return `true` _if_ `n` _is a perfect number, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** num = 28\n**Output:** true\n**Explanation:** 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n\n**Example 2:**\n\n**Input:** num = 7\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= num <= 108`\"\"\"\n\n    if num <= 1:\n        return False\n    sum = 1\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            sum += i\n            if i * i != num:\n                sum += num // i\n        i += 1\n    return sum == num"}}, "leetcode/leetcode_1390.txt": {"score": 0.9654008150100708, "content": {"text": "def sum_of_four_divisors(nums):\n    \"\"\"Given an integer array `nums`, return _the sum of divisors of the integers in that array that have exactly four divisors_. If there is no such integer in the array, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[21,4,7\\]\n**Output:** 32\n**Explanation:** \n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\n\n**Example 2:**\n\n**Input:** nums = \\[21,21\\]\n**Output:** 64\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `1 <= nums[i] <= 105`\"\"\"\n\n    total_sum = 0\n    for num in nums:\n        count = 0\n        div_sum = 0\n        i = 1\n        while i * i <= num:\n            if num % i == 0:\n                count += 1 if i * i == num else 2\n                div_sum += i + (num // i)\n                if count > 4:\n                    break\n            i += 1\n        if count == 4:\n            total_sum += div_sum\n    return total_sum"}}}}, "89": {"gold": {"leetcode/leetcode_300.txt": 1}, "retrieved": {"leetcode/leetcode_962.txt": {"score": 0.9305096864700317, "content": {"text": "def minFlipsMonoIncr(s: str) -> int:\n    \"\"\"A **ramp** in an integer array `nums` is a pair `(i, j)` for which `i < j` and `nums[i] <= nums[j]`. The **width** of such a ramp is `j - i`.\n\nGiven an integer array `nums`, return _the maximum width of a **ramp** in_ `nums`. If there is no **ramp** in `nums`, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[6,0,8,2,1,5\\]\n**Output:** 4\n**Explanation:** The maximum width ramp is achieved at (i, j) = (1, 5): nums\\[1\\] = 0 and nums\\[5\\] = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[9,8,1,0,1,9,4,0,4,1\\]\n**Output:** 7\n**Explanation:** The maximum width ramp is achieved at (i, j) = (2, 9): nums\\[2\\] = 1 and nums\\[9\\] = 1.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 5 * 104`\"\"\"\n\n    flipCount, oneCount = 0, 0\n    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)\n    return flipCount"}}, "leetcode/leetcode_2140.txt": {"score": 0.9311712384223938, "content": {"text": "def longest_subsequence_repeated_k(s, k):\n    \"\"\"You are given a **0-indexed** 2D integer array `questions` where `questions[i] = [pointsi, brainpoweri]`.\n\nThe array describes the questions of an exam, where you have to process the questions **in order** (i.e., starting from question `0`) and make a decision whether to **solve** or **skip** each question. Solving question `i` will **earn** you `pointsi` points but you will be **unable** to solve each of the next `brainpoweri` questions. If you skip question `i`, you get to make the decision on the next question.\n\n*   For example, given `questions = [[3, 2], [4, 3], [4, 4], [2, 5]]`:\n    *   If question `0` is solved, you will earn `3` points but you will be unable to solve questions `1` and `2`.\n    *   If instead, question `0` is skipped and question `1` is solved, you will earn `4` points but you will be unable to solve questions `2` and `3`.\n\nReturn _the **maximum** points you can earn for the exam_.\n\n**Example 1:**\n\n**Input:** questions = \\[\\[3,2\\],\\[4,3\\],\\[4,4\\],\\[2,5\\]\\]\n**Output:** 5\n**Explanation:** The maximum points can be earned by solving questions 0 and 3.\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n- Unable to solve questions 1 and 2\n- Solve question 3: Earn 2 points\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n\n**Example 2:**\n\n**Input:** questions = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\],\\[5,5\\]\\]\n**Output:** 7\n**Explanation:** The maximum points can be earned by solving questions 1 and 4.\n- Skip question 0\n- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\n- Unable to solve questions 2 and 3\n- Solve question 4: Earn 5 points\nTotal points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.\n\n**Constraints:**\n\n*   `1 <= questions.length <= 105`\n*   `questions[i].length == 2`\n*   `1 <= pointsi, brainpoweri <= 105`\"\"\"\n\n    counts = [0] * 26\n    for c in s:\n        counts[ord(c) - ord('a')] += 1\n    seq = ''.join([chr(i + ord('a')) * (counts[i] // k) for i in range(25, -1, -1)])\n    return seq"}}, "leetcode/leetcode_891.txt": {"score": 0.9318114519119263, "content": {"text": "def matrixScore(grid):\n    \"\"\"The **width** of a sequence is the difference between the maximum and minimum elements in the sequence.\n\nGiven an array of integers `nums`, return _the sum of the **widths** of all the non-empty **subsequences** of_ `nums`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,1,3\\]\n**Output:** 6\nExplanation: The subsequences are \\[1\\], \\[2\\], \\[3\\], \\[2,1\\], \\[2,3\\], \\[1,3\\], \\[2,1,3\\].\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\nThe sum of these widths is 6.\n\n**Example 2:**\n\n**Input:** nums = \\[2\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\"\"\"\n\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        if grid[i][0] == 0:\n            for j in range(n):\n                grid[i][j] = 1 - grid[i][j]\n    for j in range(1, n):\n        count = sum(grid[i][j] for i in range(m))\n        if count <= m // 2:\n            for i in range(m):\n                grid[i][j] = 1 - grid[i][j]\n    return sum(sum(grid[i][j]*(1 << (n - 1 - j)) for j in range(n)) for i in range(m))"}}, "leetcode/leetcode_1626.txt": {"score": 0.9321231245994568, "content": {"text": "def can_make_arithmetic_progression(arr):\n    \"\"\"You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team.\n\nHowever, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age.\n\nGiven two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return _the highest overall score of all possible basketball teams_.\n\n**Example 1:**\n\n**Input:** scores = \\[1,3,5,10,15\\], ages = \\[1,2,3,4,5\\]\n**Output:** 34\n**Explanation:** You can choose all the players.\n\n**Example 2:**\n\n**Input:** scores = \\[4,5,6,5\\], ages = \\[2,1,2,1\\]\n**Output:** 16\n**Explanation:** It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n**Example 3:**\n\n**Input:** scores = \\[1,2,3,5\\], ages = \\[8,9,10,1\\]\n**Output:** 6\n**Explanation:** It is best to choose the first 3 players. \n\n**Constraints:**\n\n*   `1 <= scores.length, ages.length <= 1000`\n*   `scores.length == ages.length`\n*   `1 <= scores[i] <= 106`\n*   `1 <= ages[i] <= 1000`\"\"\"\n\n    arr.sort()\n    difference = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] != difference:\n            return False\n    return True"}}, "leetcode/leetcode_2398.txt": {"score": 0.9339455962181091, "content": {"text": "def max_consecutive_robots(charge_times, running_costs, budget):\n    \"\"\"You have `n` robots. You are given two **0-indexed** integer arrays, `chargeTimes` and `runningCosts`, both of length `n`. The `ith` robot costs `chargeTimes[i]` units to charge and costs `runningCosts[i]` units to run. You are also given an integer `budget`.\n\nThe **total cost** of running `k` chosen robots is equal to `max(chargeTimes) + k * sum(runningCosts)`, where `max(chargeTimes)` is the largest charge cost among the `k` robots and `sum(runningCosts)` is the sum of running costs among the `k` robots.\n\nReturn _the **maximum** number of **consecutive** robots you can run such that the total cost **does not** exceed_ `budget`.\n\n**Example 1:**\n\n**Input:** chargeTimes = \\[3,6,1,3,4\\], runningCosts = \\[2,1,3,4,5\\], budget = 25\n**Output:** 3\n**Explanation:** \nIt is possible to run all individual and consecutive pairs of robots within budget.\nTo obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 \\* sum(2,1,3) = 6 + 3 \\* 6 = 24 which is less than 25.\nIt can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.\n\n**Example 2:**\n\n**Input:** chargeTimes = \\[11,12,19\\], runningCosts = \\[10,8,7\\], budget = 19\n**Output:** 0\n**Explanation:** No robot can be run that does not exceed the budget, so we return 0.\n\n**Constraints:**\n\n*   `chargeTimes.length == runningCosts.length == n`\n*   `1 <= n <= 5 * 104`\n*   `1 <= chargeTimes[i], runningCosts[i] <= 105`\n*   `1 <= budget <= 1015`\"\"\"\n\n    n = len(charge_times)\n    max_robots = 0\n    for i in range(n):\n        max_charge = 0\n        running_sum = 0\n        for j in range(i, n):\n            max_charge = max(max_charge, charge_times[j])\n            running_sum += running_costs[j]\n            cost = max_charge + running_sum * (j - i + 1)\n            if cost <= budget:\n                max_robots = max(max_robots, j - i + 1)\n            else:\n                break\n    return max_robots"}}, "leetcode/leetcode_1840.txt": {"score": 0.9459442496299744, "content": {"text": "from collections import defaultdict\n    \"\"\"You want to build `n` new buildings in a city. The new buildings will be built in a line and are labeled from `1` to `n`.\n\nHowever, there are city restrictions on the heights of the new buildings:\n\n*   The height of each building must be a non-negative integer.\n*   The height of the first building **must** be `0`.\n*   The height difference between any two adjacent buildings **cannot exceed** `1`.\n\nAdditionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array `restrictions` where `restrictions[i] = [idi, maxHeighti]` indicates that building `idi` must have a height **less than or equal to** `maxHeighti`.\n\nIt is guaranteed that each building will appear **at most once** in `restrictions`, and building `1` will **not** be in `restrictions`.\n\nReturn _the **maximum possible height** of the **tallest** building_.\n\n**Example 1:**\n\n**Input:** n = 5, restrictions = \\[\\[2,1\\],\\[4,1\\]\\]\n**Output:** 2\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,1,2\\], and the tallest building has a height of 2.\n\n**Example 2:**\n\n**Input:** n = 6, restrictions = \\[\\]\n**Output:** 5\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,3,4,5\\], and the tallest building has a height of 5.\n\n**Example 3:**\n\n**Input:** n = 10, restrictions = \\[\\[5,3\\],\\[2,5\\],\\[7,4\\],\\[10,3\\]\\]\n**Output:** 5\n**Explanation:** The green area in the image indicates the maximum allowed height for each building.\nWe can build the buildings with heights \\[0,1,2,3,3,4,4,5,4,3\\], and the tallest building has a height of 5.\n\n**Constraints:**\n\n*   `2 <= n <= 109`\n*   `0 <= restrictions.length <= min(n - 1, 105)`\n*   `2 <= idi <= n`\n*   `idi` is **unique**.\n*   `0 <= maxHeighti <= 109`\"\"\"\n\n\ndef dfs(node, visited, graph, group):\n    if visited[node]:\n        return\n    visited[node] = 1\n    group.append(node)\n    for neighbor in graph[node]:\n        dfs(neighbor, visited, graph, group)\n\ndef minimumHammingDistance(source, target, allowedSwaps):\n    n = len(source)\n    graph = defaultdict(list)\n    for a, b in allowedSwaps:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    res = 0\n    visited = [0] * n\n    for i in range(n):\n        if not visited[i]:\n            group = []\n            dfs(i, visited, graph, group)\n            count = defaultdict(int)\n\n            for node in group:\n                count[source[node]] += 1\n            for node in group:\n                if count[target[node]] > 0:\n                    res += 1\n                    count[target[node]] -= 1\n\n    return n - res"}}, "leetcode/leetcode_1800.txt": {"score": 0.9575627446174622, "content": {"text": "def concatenated_binary(n: int) -> int:\n    \"\"\"Given an array of positive integers `nums`, return the _maximum possible sum of an **ascending** subarray in_ `nums`.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nA subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is **ascending** if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is **ascending**.\n\n**Example 1:**\n\n**Input:** nums = \\[10,20,30,5,10,50\\]\n**Output:** 65\n**Explanation:** \\[5,10,50\\] is the ascending subarray with the maximum sum of 65.\n\n**Example 2:**\n\n**Input:** nums = \\[10,20,30,40,50\\]\n**Output:** 150\n**Explanation:** \\[10,20,30,40,50\\] is the ascending subarray with the maximum sum of 150.\n\n**Example 3:**\n\n**Input:** nums = \\[12,17,15,13,10,11,12\\]\n**Output:** 33\n**Explanation:** \\[10,11,12\\] is the ascending subarray with the maximum sum of 33.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`\"\"\"\n\n    result = 0\n    mod = 1000000007\n    for i in range(1, n + 1):\n        length = len(bin(i)) - 2\n        result = ((result << length) % mod + i) % mod\n    return result"}}, "leetcode/leetcode_1964.txt": {"score": 0.9980077743530273, "content": {"text": "def longest_obstacle_course(obstacles):\n    \"\"\"You want to build some obstacle courses. You are given a **0-indexed** integer array `obstacles` of length `n`, where `obstacles[i]` describes the height of the `ith` obstacle.\n\nFor every index `i` between `0` and `n - 1` (**inclusive**), find the length of the **longest obstacle course** in `obstacles` such that:\n\n*   You choose any number of obstacles between `0` and `i` **inclusive**.\n*   You must include the `ith` obstacle in the course.\n*   You must put the chosen obstacles in the **same order** as they appear in `obstacles`.\n*   Every obstacle (except the first) is **taller** than or the **same height** as the obstacle immediately before it.\n\nReturn _an array_ `ans` _of length_ `n`, _where_ `ans[i]` _is the length of the **longest obstacle course** for index_ `i` _as described above_.\n\n**Example 1:**\n\n**Input:** obstacles = \\[1,2,3,2\\]\n**Output:** \\[1,2,3,3\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[1\\], \\[1\\] has length 1.\n- i = 1: \\[1,2\\], \\[1,2\\] has length 2.\n- i = 2: \\[1,2,3\\], \\[1,2,3\\] has length 3.\n- i = 3: \\[1,2,3,2\\], \\[1,2,2\\] has length 3.\n\n**Example 2:**\n\n**Input:** obstacles = \\[2,2,1\\]\n**Output:** \\[1,2,1\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[2\\], \\[2\\] has length 1.\n- i = 1: \\[2,2\\], \\[2,2\\] has length 2.\n- i = 2: \\[2,2,1\\], \\[1\\] has length 1.\n\n**Example 3:**\n\n**Input:** obstacles = \\[3,1,5,6,4,2\\]\n**Output:** \\[1,1,2,3,2,2\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[3\\], \\[3\\] has length 1.\n- i = 1: \\[3,1\\], \\[1\\] has length 1.\n- i = 2: \\[3,1,5\\], \\[3,5\\] has length 2. \\[1,5\\] is also valid.\n- i = 3: \\[3,1,5,6\\], \\[3,5,6\\] has length 3. \\[1,5,6\\] is also valid.\n- i = 4: \\[3,1,5,6,4\\], \\[3,4\\] has length 2. \\[1,4\\] is also valid.\n- i = 5: \\[3,1,5,6,4,2\\], \\[1,2\\] has length 2.\n\n**Constraints:**\n\n*   `n == obstacles.length`\n*   `1 <= n <= 105`\n*   `1 <= obstacles[i] <= 107`\"\"\"\n\n    dp = []\n    ans = [0] * len(obstacles)\n\n    for obstacle in obstacles:\n        index = bisect_left(dp, obstacle)\n        ans[index] = index + 1\n        if index == len(dp):\n            dp.append(obstacle)\n        else:\n            dp[index] = obstacle\n\n    return ans"}}, "leetcode/leetcode_2407.txt": {"score": 0.9323357343673706, "content": {"text": "def longestSubsequence(nums, k):\n    \"\"\"You are given an integer array `nums` and an integer `k`.\n\nFind the longest subsequence of `nums` that meets the following requirements:\n\n*   The subsequence is **strictly increasing** and\n*   The difference between adjacent elements in the subsequence is **at most** `k`.\n\nReturn _the length of the **longest** **subsequence** that meets the requirements._\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n\n**Input:** nums = \\[4,2,1,4,3,4,5,8,15\\], k = 3\n**Output:** 5\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[1,3,4,5,8\\].\nThe subsequence has a length of 5, so we return 5.\nNote that the subsequence \\[1,3,4,5,8,15\\] does not meet the requirements because 15 - 8 = 7 is larger than 3.\n\n**Example 2:**\n\n**Input:** nums = \\[7,4,5,1,8,12,4,7\\], k = 5\n**Output:** 4\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[4,5,8,12\\].\nThe subsequence has a length of 4, so we return 4.\n\n**Example 3:**\n\n**Input:** nums = \\[1,5\\], k = 1\n**Output:** 1\n**Explanation:**\nThe longest subsequence that meets the requirements is \\[1\\].\nThe subsequence has a length of 1, so we return 1.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i], k <= 105`\"\"\"\n\n    n = len(nums)\n    dp = {}\n    ans = 0\n\n    for num in nums:\n        temp = 0\n        keys = [key for key in dp if num - k <= key]\n        if keys:\n            temp = dp[max(keys)]\n\n        dp[num] = max(dp.get(num, 0), temp + 1)\n        ans = max(ans, dp[num])\n\n    return ans"}}, "leetcode/leetcode_1425.txt": {"score": 0.942085862159729, "content": {"text": "def maxSum(nums, k):\n    \"\"\"Given an integer array `nums` and an integer `k`, return the maximum sum of a **non-empty** subsequence of that array such that for every two **consecutive** integers in the subsequence, `nums[i]` and `nums[j]`, where `i < j`, the condition `j - i <= k` is satisfied.\n\nA _subsequence_ of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.\n\n**Example 1:**\n\n**Input:** nums = \\[10,2,-10,5,20\\], k = 2\n**Output:** 37\n**Explanation:** The subsequence is \\[10, 2, 5, 20\\].\n\n**Example 2:**\n\n**Input:** nums = \\[-1,-2,-3\\], k = 1\n**Output:** -1\n**Explanation:** The subsequence must be non-empty, so we choose the largest number.\n\n**Example 3:**\n\n**Input:** nums = \\[10,-2,-10,-5,20\\], k = 2\n**Output:** 23\n**Explanation:** The subsequence is \\[10, -2, -5, 20\\].\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\"\"\"\n\n    n = len(nums)\n    dp = [0] * (n + 1)\n    pq = []\n    sum_ = 0\n\n    for i in range(n):\n        if i >= k:\n            pq.remove(-(dp[i] - nums[i]))  # Remove element from pq\n        heapq.heappush(pq, -(dp[i] - nums[i]))  # Push in the negative for max heap\n        dp[i + 1] = max(dp[i], nums[i] - pq[0])\n        sum_ = max(sum_, dp[i + 1])\n\n    return sum_"}}}}, "90": {"gold": {"leetcode/leetcode_797.txt": 1, "leetcode/leetcode_1514.txt": 1, "leetcode/leetcode_2045.txt": 1}, "retrieved": {"leetcode/leetcode_2359.txt": {"score": 0.9005405902862549, "content": {"text": "def get_index_with_min_max_distance(edges, node1, node2):\n    \"\"\"You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from `i`, then `edges[i] == -1`.\n\nYou are also given two integers `node1` and `node2`.\n\nReturn _the **index** of the node that can be reached from both_ `node1` _and_ `node2`_, such that the **maximum** between the distance from_ `node1` _to that node, and from_ `node2` _to that node is **minimized**_. If there are multiple answers, return the node with the **smallest** index, and if no possible answer exists, return `-1`.\n\nNote that `edges` may contain cycles.\n\n**Example 1:**\n\n**Input:** edges = \\[2,2,3,-1\\], node1 = 0, node2 = 1\n**Output:** 2\n**Explanation:** The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n\n**Example 2:**\n\n**Input:** edges = \\[1,2,-1\\], node1 = 0, node2 = 2\n**Output:** 2\n**Explanation:** The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n\n**Constraints:**\n\n*   `n == edges.length`\n*   `2 <= n <= 105`\n*   `-1 <= edges[i] < n`\n*   `edges[i] != i`\n*   `0 <= node1, node2 < n`\"\"\"\n\n    dist1 = [-1] * len(edges)\n    dist2 = [-1] * len(edges)\n\n    dist1[node1] = 0\n    dist2[node2] = 0\n    for i in range(len(edges)):\n        if dist1[i] != -1 and edges[i] != -1:\n            if dist1[edges[i]] == -1:\n                dist1[edges[i]] = dist1[i] + 1\n            else:\n                dist1[edges[i]] = min(dist1[edges[i]], dist1[i] + 1)\n\n        if dist2[i] != -1 and edges[i] != -1:\n            if dist2[edges[i]] == -1:\n                dist2[edges[i]] = dist2[i] + 1\n            else:\n                dist2[edges[i]] = min(dist2[edges[i]], dist2[i] + 1)\n\n    ans = -1\n    min_max_dist = float(\"inf\")\n    for i in range(len(edges)):\n        if dist1[i] != -1 and dist2[i] != -1:\n            max_dist = max(dist1[i], dist2[i])\n            if max_dist < min_max_dist:\n                min_max_dist = max_dist\n                ans = i\n\n    return ans"}}, "leetcode/leetcode_2045.txt": {"score": 0.9007240533828735, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"A city is represented as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from **green** to **red** and vice versa every `change` minutes. All signals change **at the same time**. You can enter a vertex at **any time**, but can leave a vertex **only when the signal is green**. You **cannot wait** at a vertex if the signal is **green**.\n\nThe **second minimum value** is defined as the smallest value **strictly larger** than the minimum value.\n\n*   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return _the **second minimum time** it will take to go from vertex_ `1` _to vertex_ `n`.\n\n**Notes:**\n\n*   You can go through any vertex **any** number of times, **including** `1` and `n`.\n*   You can assume that when the journey **starts**, all signals have just turned **green**.\n\n**Example 1:**\n\n\u2003 \u2003 \u2003 \u2003\n\n**Input:** n = 5, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[3,4\\],\\[4,5\\]\\], time = 3, change = 5\n**Output:** 13\n**Explanation:**\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\], time = 3, change = 2\n**Output:** 11\n**Explanation:**\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n**Constraints:**\n\n*   `2 <= n <= 104`\n*   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each vertex can be reached directly or indirectly from every other vertex.\n*   `1 <= time, change <= 103`\"\"\"\n\n\ndef secondMinimum(n, edges, time, change):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dist = [float('inf')] * (n + 1)\n    dist2 = [float('inf')] * (n + 1)\n    dist[1] = 0\n\n    q = deque([1])\n\n    while q:\n        cur = q.popleft()\n\n        nextDist = dist[cur] + time\n        waitTime = change if (nextDist // change) % 2 == 1 else 0\n        nextDist += waitTime\n\n        for next in graph[cur]:\n            if nextDist < dist[next]:\n                nextDist, dist[next] = dist[next], nextDist\n                q.append(next)\n            if nextDist < dist2[next]:\n                nextDist, dist2[next] = dist2[next], nextDist\n                q.append(next)\n\n    return dist2[n]"}}, "leetcode/leetcode_2050.txt": {"score": 0.9017943739891052, "content": {"text": "def count_good_digit_strings(n):\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.\"\"\"\n\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total"}}, "leetcode/leetcode_1334.txt": {"score": 0.9038177728652954, "content": {"text": "def findTheCity(n, edges, distanceThreshold):\n    \"\"\"There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[0,1,3\\],\\[1,2,1\\],\\[1,3,4\\],\\[2,3,1\\]\\], distanceThreshold = 4\n**Output:** 3\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> \\[City 1, City 2\\] \nCity 1 -> \\[City 0, City 2, City 3\\] \nCity 2 -> \\[City 0, City 1, City 3\\] \nCity 3 -> \\[City 1, City 2\\] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1,2\\],\\[0,4,8\\],\\[1,2,3\\],\\[1,4,2\\],\\[2,3,1\\],\\[3,4,1\\]\\], distanceThreshold = 2\n**Output:** 0\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> \\[City 1\\] \nCity 1 -> \\[City 0, City 4\\] \nCity 2 -> \\[City 3, City 4\\] \nCity 3 -> \\[City 2, City 4\\]\nCity 4 -> \\[City 1, City 2, City 3\\] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= edges.length <= n * (n - 1) / 2`\n*   `edges[i].length == 3`\n*   `0 <= fromi < toi < n`\n*   `1 <= weighti, distanceThreshold <= 10^4`\n*   All pairs `(fromi, toi)` are distinct.\"\"\"\n\n    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res"}}, "leetcode/leetcode_1928.txt": {"score": 0.9116781949996948, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"There is a country of `n` cities numbered from `0` to `n - 1` where **all the cities are connected** by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is represented as a **0-indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime` **minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or_ `-1` _if you cannot complete it within_ `maxTime` _minutes_.\n\n**Example 1:**\n\n**Input:** maxTime = 30, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 11\n**Explanation:** The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n\n**Example 2:**\n\n**Input:** maxTime = 29, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 48\n**Explanation:** The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n\n**Example 3:**\n\n**Input:** maxTime = 25, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** -1\n**Explanation:** There is no way to reach city 5 from city 0 within 25 minutes.\n\n**Constraints:**\n\n*   `1 <= maxTime <= 1000`\n*   `n == passingFees.length`\n*   `2 <= n <= 1000`\n*   `n - 1 <= edges.length <= 1000`\n*   `0 <= xi, yi <= n - 1`\n*   `1 <= timei <= 1000`\n*   `1 <= passingFees[j] <= 1000`\n*   The graph may contain multiple edges between two nodes.\n*   The graph does not contain self loops.\"\"\"\n\n\ndef getNumberOfBacklogOrders(orders):\n    buy, sell = [], []\n\n    for price, amount, orderType in orders:\n        if orderType == 0:\n            while amount > 0 and sell and -sell[0][0] <= price:\n                executedAmount = min(amount, sell[0][1])\n                amount -= executedAmount\n                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]\n                if sell[0][1] == 0:\n                    heappop(sell)\n            if amount:\n                heappush(buy, [-price, amount])\n        else:\n            while amount > 0 and buy and buy[0][0] >= price:\n                executedAmount = min(amount, buy[0][1])\n                amount -= executedAmount\n                buy[0] = [buy[0][0], buy[0][1] - executedAmount]\n                if buy[0][1] == 0:\n                    heappop(buy)\n            if amount:\n                heappush(sell, [-price, amount])\n\n    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)\n    return res % 1000000007"}}, "leetcode/leetcode_1786.txt": {"score": 0.9314441680908203, "content": {"text": "def count_consistent_strings(allowed, words):\n    \"\"\"There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[1,2,3\\],\\[1,3,3\\],\\[2,3,1\\],\\[1,4,2\\],\\[5,2,2\\],\\[3,5,1\\],\\[5,4,10\\]\\]\n**Output:** 3\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,3,1\\],\\[4,1,2\\],\\[7,3,4\\],\\[2,5,3\\],\\[5,6,1\\],\\[6,7,2\\],\\[7,5,3\\],\\[2,6,4\\]\\]\n**Output:** 1\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The only restricted path is 1 --> 3 --> 7.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `n - 1 <= edges.length <= 4 * 104`\n*   `edges[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= weighti <= 105`\n*   There is at most one edge between any two nodes.\n*   There is at least one path between any two nodes.\"\"\"\n\n    allowed_set = set(allowed)\n    count = 0\n    for word in words:\n        is_valid = True\n        for c in word:\n            if c not in allowed_set:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n    return count"}}, "leetcode/leetcode_2188.txt": {"score": 0.9033392667770386, "content": {"text": "def min_x(n, quantities):\n    \"\"\"You are given a **0-indexed** 2D integer array `tires` where `tires[i] = [fi, ri]` indicates that the `ith` tire can finish its `xth` successive lap in `fi * ri(x-1)` seconds.\n\n*   For example, if `fi = 3` and `ri = 2`, then the tire would finish its `1st` lap in `3` seconds, its `2nd` lap in `3 * 2 = 6` seconds, its `3rd` lap in `3 * 22 = 12` seconds, etc.\n\nYou are also given an integer `changeTime` and an integer `numLaps`.\n\nThe race consists of `numLaps` laps and you may start the race with **any** tire. You have an **unlimited** supply of each tire and after every lap, you may **change** to any given tire (including the current tire type) if you wait `changeTime` seconds.\n\nReturn _the **minimum** time to finish the race._\n\n**Example 1:**\n\n**Input:** tires = \\[\\[2,3\\],\\[3,4\\]\\], changeTime = 5, numLaps = 4\n**Output:** 21\n**Explanation:** \nLap 1: Start with tire 0 and finish the lap in 2 seconds.\nLap 2: Continue with tire 0 and finish the lap in 2 \\* 3 = 6 seconds.\nLap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 0 and finish the lap in 2 \\* 3 = 6 seconds.\nTotal time = 2 + 6 + 5 + 2 + 6 = 21 seconds.\nThe minimum time to complete the race is 21 seconds.\n\n**Example 2:**\n\n**Input:** tires = \\[\\[1,10\\],\\[2,2\\],\\[3,4\\]\\], changeTime = 6, numLaps = 5\n**Output:** 25\n**Explanation:** \nLap 1: Start with tire 1 and finish the lap in 2 seconds.\nLap 2: Continue with tire 1 and finish the lap in 2 \\* 2 = 4 seconds.\nLap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 1 and finish the lap in 2 \\* 2 = 4 seconds.\nLap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second.\nTotal time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds.\nThe minimum time to complete the race is 25 seconds. \n\n**Constraints:**\n\n*   `1 <= tires.length <= 105`\n*   `tires[i].length == 2`\n*   `1 <= fi, changeTime <= 105`\n*   `2 <= ri <= 105`\n*   `1 <= numLaps <= 1000`\"\"\"\n\n    total_products = sum(quantities)\n    return (total_products + n - 1) // n"}}, "leetcode/leetcode_787.txt": {"score": 0.934862494468689, "content": {"text": "from collections import deque\n    \"\"\"There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return `-1`.\n\n**Example 1:**\n\n**Input:** n = 4, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[2,0,100\\],\\[1,3,600\\],\\[2,3,200\\]\\], src = 0, dst = 3, k = 1\n**Output:** 700\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities \\[0,1,2,3\\] is cheaper but is invalid because it uses 2 stops.\n\n**Example 2:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 1\n**Output:** 200\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\n**Example 3:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 0\n**Output:** 500\n**Explanation:**\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= flights.length <= (n * (n - 1) / 2)`\n*   `flights[i].length == 3`\n*   `0 <= fromi, toi < n`\n*   `fromi != toi`\n*   `1 <= pricei <= 104`\n*   There will not be any multiple flights between two cities.\n*   `0 <= src, dst, k < n`\n*   `src != dst`\"\"\"\n\n\ndef slidingPuzzle(board):\n    m, n = 2, 3\n    target = \"123450\"\n    start = \"\".join(str(num) for row in board for num in row)\n    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]\n    q = deque([start])\n    res = 0\n    visited = {start}\n    while q:\n        for _ in range(len(q)):\n            cur = q.popleft()\n            if cur == target:\n                return res\n            zero_idx = cur.index(\"0\")\n            for dir in dirs[zero_idx]:\n                neighbor = list(cur)\n                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]\n                neighbor = \"\".join(neighbor)\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        res += 1\n    return -1"}}, "leetcode/leetcode_743.txt": {"score": 0.9057603478431702, "content": {"text": "import heapq\n    \"\"\"You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return _the **minimum** time it takes for all the_ `n` _nodes to receive the signal_. If it is impossible for all the `n` nodes to receive the signal, return `-1`.\n\n**Example 1:**\n\n**Input:** times = \\[\\[2,1,1\\],\\[2,3,1\\],\\[3,4,1\\]\\], n = 4, k = 2\n**Output:** 2\n\n**Example 2:**\n\n**Input:** times = \\[\\[1,2,1\\]\\], n = 2, k = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** times = \\[\\[1,2,1\\]\\], n = 2, k = 2\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= k <= n <= 100`\n*   `1 <= times.length <= 6000`\n*   `times[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `0 <= wi <= 100`\n*   All the pairs `(ui, vi)` are **unique**. (i.e., no multiple edges.)\"\"\"\n\n\ndef networkDelayTime(times, n, k):\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {u: float('inf') for u in range(1, n+1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n\n        for v, weight in graph[u]:\n            new_dist = curr_dist + weight\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n\n    max_time = max(dist.values())\n    return max_time if max_time < float('inf') else -1"}}, "leetcode/leetcode_1976.txt": {"score": 0.9876942038536072, "content": {"text": "def can_split_string(s: str) -> bool:\n    \"\"\"You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with **bi-directional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the **shortest amount of time**.\n\nReturn _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 7, roads = \\[\\[0,6,7\\],\\[0,1,2\\],\\[1,2,3\\],\\[1,3,3\\],\\[6,3,3\\],\\[3,5,1\\],\\[6,5,1\\],\\[2,5,1\\],\\[0,4,5\\],\\[4,6,2\\]\\]\n**Output:** 4\n**Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u279d 6\n- 0 \u279d 4 \u279d 6\n- 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6\n- 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6\n\n**Example 2:**\n\n**Input:** n = 2, roads = \\[\\[1,0,10\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\n*   `n - 1 <= roads.length <= n * (n - 1) / 2`\n*   `roads[i].length == 3`\n*   `0 <= ui, vi <= n - 1`\n*   `1 <= timei <= 109`\n*   `ui != vi`\n*   There is at most one road connecting any two intersections.\n*   You can reach any intersection from any other intersection.\"\"\"\n\n    count = [0] * 10\n\n    for c in s:\n        count[int(c)] += 1\n\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n\n    return False"}}}}, "91": {"gold": {"leetcode/leetcode_561.txt": 1}, "retrieved": {"leetcode/leetcode_1200.txt": {"score": 0.9253405928611755, "content": {"text": "from typing import List\n    \"\"\"Given an array of **distinct** integers `arr`, find all pairs of elements with the minimum absolute difference of any two elements.\n\nReturn a list of pairs in ascending order(with respect to pairs), each pair `[a, b]` follows\n\n*   `a, b` are from `arr`\n*   `a < b`\n*   `b - a` equals to the minimum absolute difference of any two elements in `arr`\n\n**Example 1:**\n\n**Input:** arr = \\[4,2,1,3\\]\n**Output:** \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Explanation:** The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.\n\n**Example 2:**\n\n**Input:** arr = \\[1,3,6,10,15\\]\n**Output:** \\[\\[1,3\\]\\]\n\n**Example 3:**\n\n**Input:** arr = \\[3,8,-10,23,19,-4,-14,27\\]\n**Output:** \\[\\[-14,-10\\],\\[19,23\\],\\[23,27\\]\\]\n\n**Constraints:**\n\n*   `2 <= arr.length <= 105`\n*   `-106 <= arr[i] <= 106`\"\"\"\n\n\ndef minimumAbsDifference(arr: List[int]) -> List[List[int]]:\n    arr.sort()\n    min_diff = min(arr[i] - arr[i - 1] for i in range(1, len(arr)))\n\n    result = []\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] == min_diff:\n            result.append([arr[i - 1], arr[i]])\n\n    return result"}}, "leetcode/leetcode_1675.txt": {"score": 0.9291131496429443, "content": {"text": "from typing import List\n    \"\"\"You are given an array `nums` of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number of times:\n\n*   If the element is **even**, **divide** it by `2`.\n    *   For example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2].`\n*   If the element is **odd**, **multiply** it by `2`.\n    *   For example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4].`\n\nThe **deviation** of the array is the **maximum difference** between any two elements in the array.\n\nReturn _the **minimum deviation** the array can have after performing some number of operations._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 1\n**Explanation:** You can transform the array to \\[1,2,3,2\\], then to \\[2,2,3,2\\], then the deviation will be 3 - 2 = 1.\n\n**Example 2:**\n\n**Input:** nums = \\[4,1,5,20,3\\]\n**Output:** 3\n**Explanation:** You can transform the array after two operations to \\[4,2,5,5,3\\], then the deviation will be 5 - 2 = 3.\n\n**Example 3:**\n\n**Input:** nums = \\[2,10,8\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 5 * 104`\n*   `1 <= nums[i] <= 109`\"\"\"\n\n\ndef can_place_balls(force: int, position: List[int], m: int) -> bool:\n    last_position = position[0]\n    placed_balls = 1\n\n    for i in range(1, len(position)):\n        if position[i] - last_position >= force:\n            placed_balls += 1\n            last_position = position[i]\n\n            if placed_balls == m:\n                return True\n\n    return False\n\ndef max_distance(position: List[int], m: int) -> int:\n    position.sort()\n\n    left = 1\n    right = position[-1] - position[0]\n    ans = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_place_balls(mid, position, m):\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return ans"}}, "leetcode/leetcode_2171.txt": {"score": 0.9254987239837646, "content": {"text": "import heapq\n    \"\"\"You are given an array of **positive** integers `beans`, where each integer represents the number of magic beans found in a particular magic bag.\n\n**Remove** any number of beans (**possibly none**) from each bag such that the number of beans in each remaining **non-empty** bag (still containing **at least one** bean) is **equal**. Once a bean has been removed from a bag, you are **not** allowed to return it to any of the bags.\n\nReturn _the **minimum** number of magic beans that you have to remove_.\n\n**Example 1:**\n\n**Input:** beans = \\[4,**1**,6,5\\]\n**Output:** 4\n**Explanation:** \n- We remove 1 bean from the bag with only 1 bean.\n  This results in the remaining bags: \\[4,**0**,6,5\\]\n- Then we remove 2 beans from the bag with 6 beans.\n  This results in the remaining bags: \\[4,0,**4**,5\\]\n- Then we remove 1 bean from the bag with 5 beans.\n  This results in the remaining bags: \\[4,0,4,**4**\\]\nWe removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that remove 4 beans or fewer.\n\n**Example 2:**\n\n**Input:** beans = \\[**2**,10,**3**,**2**\\]\n**Output:** 7\n**Explanation:**\n- We remove 2 beans from one of the bags with 2 beans.\n  This results in the remaining bags: \\[**0**,10,3,2\\]\n- Then we remove 2 beans from the other bag with 2 beans.\n  This results in the remaining bags: \\[0,10,3,**0**\\]\n- Then we remove 3 beans from the bag with 3 beans. \n  This results in the remaining bags: \\[0,10,**0**,0\\]\nWe removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that removes 7 beans or fewer.\n\n**Constraints:**\n\n*   `1 <= beans.length <= 105`\n*   `1 <= beans[i] <= 105`\"\"\"\n\n\ndef second_minimum(n: int, edges: List[List[int]], time: int, change: int) -> int:\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    dist = [-1] * (n + 1)\n    queue = [(0, 1)]\n    dist[1] = 0\n\n    while queue:\n        t1, v1 = heapq.heappop(queue)\n\n        if v1 == n:\n            return t1\n\n        for v2 in adj[v1]:\n            t2 = t1 + time\n            waiting = change - (t2 % change) if (t2 // change) % 2 == 1 else 0\n\n            if dist[v2] == -1 or dist[v2] > t2 + waiting:\n                if dist[v2] != -1:\n                    heapq.heappush(queue, (dist[v2], v2))\n                dist[v2] = t2 + waiting\n                heapq.heappush(queue, (dist[v2], v2))\n\n    return -1"}}, "leetcode/leetcode_1509.txt": {"score": 0.9431626796722412, "content": {"text": "def minDifference(nums):\n    \"\"\"You are given an integer array `nums`.\n\nIn one move, you can choose one element of `nums` and change it to **any value**.\n\nReturn _the minimum difference between the largest and smallest value of `nums` **after performing at most three moves**_.\n\n**Example 1:**\n\n**Input:** nums = \\[5,3,2,4\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 2 to 3. nums becomes \\[5,3,3,4\\].\nIn the second move, change 4 to 3. nums becomes \\[5,3,3,3\\].\nIn the third move, change 5 to 3. nums becomes \\[3,3,3,3\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,0,10,14\\]\n**Output:** 1\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 5 to 0. nums becomes \\[1,0,0,10,14\\].\nIn the second move, change 10 to 0. nums becomes \\[1,0,0,0,14\\].\nIn the third move, change 14 to 1. nums becomes \\[1,0,0,0,1\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 0.\nIt can be shown that there is no way to make the difference 0 in 3 moves.\n\n**Example 3:**\n\n**Input:** nums = \\[3,100,20\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 100 to 7. nums becomes \\[4,7,20\\].\nIn the second move, change 20 to 7. nums becomes \\[4,7,7\\].\nIn the third move, change 4 to 3. nums becomes \\[7,7,7\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\"\"\"\n\n    n = len(nums)\n    if n <= 4: return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res"}}, "leetcode/leetcode_2560.txt": {"score": 0.9307512044906616, "content": {"text": "def minimumCapability(nums, k):\n    \"\"\"There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he **refuses to steal from adjacent homes**.\n\nThe **capability** of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\n\nYou are given an integer array `nums` representing how much money is stashed in each house. More formally, the `ith` house from the left has `nums[i]` dollars.\n\nYou are also given an integer `k`, representing the **minimum** number of houses the robber will steal from. It is always possible to steal at least `k` houses.\n\nReturn _the **minimum** capability of the robber out of all the possible ways to steal at least_ `k` _houses_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,5,9\\], k = 2\n**Output:** 5\n**Explanation:** \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums\\[0\\], nums\\[2\\]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums\\[0\\], nums\\[3\\]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums\\[1\\], nums\\[3\\]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\], k = 2\n**Output:** 2\n**Explanation:** There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums\\[0\\], nums\\[4\\]) = 2.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `1 <= k <= (nums.length + 1)/2`\"\"\"\n\n    n, l, r = len(nums), 1, 10**9\n    while l < r:\n        mid = l + (r - l) // 2\n        i, cnt = 0, 0\n        for j in range(n):\n            if nums[j] <= mid:\n                cnt += 1\n                i = j + 2\n                while i + 1 < n and (i == j + 1 or nums[i] > mid):\n                    i += 1\n        if cnt < k:\n            l = mid + 1\n        else:\n            r = mid\n    return l"}}, "leetcode/leetcode_2294.txt": {"score": 0.9343767762184143, "content": {"text": "def minimum_time_for_trips(time, total_trips):\n    \"\"\"You are given an integer array `nums` and an integer `k`. You may partition `nums` into one or more **subsequences** such that each element in `nums` appears in **exactly** one of the subsequences.\n\nReturn _the **minimum** number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is **at most**_ `k`_._\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,1,2,5\\], k = 2\n**Output:** 2\n**Explanation:**\nWe can partition nums into the two subsequences \\[3,1,2\\] and \\[6,5\\].\nThe difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\nThe difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\nSince two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3\\], k = 1\n**Output:** 2\n**Explanation:**\nWe can partition nums into the two subsequences \\[1,2\\] and \\[3\\].\nThe difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\nThe difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\nSince two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences \\[1\\] and \\[2,3\\].\n\n**Example 3:**\n\n**Input:** nums = \\[2,2,4,5\\], k = 0\n**Output:** 3\n**Explanation:**\nWe can partition nums into the three subsequences \\[2,2\\], \\[4\\], and \\[5\\].\nThe difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\nThe difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\nThe difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\nSince three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`\n*   `0 <= k <= 105`\"\"\"\n\n    time.sort()\n\n    start, end = 0, time[-1] * total_trips\n    while start < end:\n        mid = start + (end - start) // 2\n        trips = sum(mid // t for t in time)\n        if trips < total_trips:\n            start = mid + 1\n        else:\n            end = mid\n\n    return start"}}, "leetcode/leetcode_2567.txt": {"score": 0.9346706867218018, "content": {"text": "def min_score_after_change(nums):\n    \"\"\"You are given a **0-indexed** integer array `nums`.\n\n*   The **low** score of `nums` is the minimum value of `|nums[i] - nums[j]|` over all `0 <= i < j < nums.length`.\n*   The **high** score of `nums` is the maximum value of `|nums[i] - nums[j]|` over all `0 <= i < j < nums.length`.\n*   The **score** of `nums` is the sum of the **high** and **low** scores of nums.\n\nTo minimize the score of `nums`, we can change the value of **at most two** elements of `nums`.\n\nReturn _the **minimum** possible **score** after changing the value of **at most two** elements o_f `nums`.\n\nNote that `|x|` denotes the absolute value of `x`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,4,3\\]\n**Output:** 0\n**Explanation:** Change value of nums\\[1\\] and nums\\[2\\] to 1 so that nums becomes \\[1,1,1\\]. Now, the value of `|nums[i] - nums[j]|` is always equal to 0, so we return 0 + 0 = 0.\n\n**Example 2:**\n\n**Input:** nums = \\[1,4,7,8,5\\]\n**Output:** 3\n**Explanation:** Change nums\\[0\\] and nums\\[1\\] to be 6. Now nums becomes \\[6,6,7,8,5\\].\nOur low score is achieved when i = 0 and j = 1, in which case |`nums[i] - nums[j]`| = |6 - 6| = 0.\nOur high score is achieved when i = 3 and j = 4, in which case |`nums[i] - nums[j]`| = |8 - 5| = 3.\nThe sum of our high and low score is 3, which we can prove to be minimal.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\"\"\"\n\n    n = len(nums)\n    first_min, second_min, last_max, second_last_max = nums[0], nums[1], nums[-1], nums[-2]\n\n    for i in range(1, n - 1):\n        first_min = min(first_min, nums[i])\n        second_min = min(second_min, nums[i + 1])\n        last_max = max(last_max, nums[i])\n        second_last_max = max(second_last_max, nums[i - 1])\n\n    low = min(min(first_min, last_max), min(second_min, second_last_max))\n    high = max(max(first_min, last_max), max(second_min, second_last_max))\n\n    return high - low"}}, "leetcode/leetcode_2163.txt": {"score": 0.9464880228042603, "content": {"text": "def kth_distinct_string(arr, k):\n    \"\"\"You are given a **0-indexed** integer array `nums` consisting of `3 * n` elements.\n\nYou are allowed to remove any **subsequence** of elements of size **exactly** `n` from `nums`. The remaining `2 * n` elements will be divided into two **equal** parts:\n\n*   The first `n` elements belonging to the first part and their sum is `sumfirst`.\n*   The next `n` elements belonging to the second part and their sum is `sumsecond`.\n\nThe **difference in sums** of the two parts is denoted as `sumfirst - sumsecond`.\n\n*   For example, if `sumfirst = 3` and `sumsecond = 2`, their difference is `1`.\n*   Similarly, if `sumfirst = 2` and `sumsecond = 3`, their difference is `-1`.\n\nReturn _the **minimum difference** possible between the sums of the two parts after the removal of_ `n` _elements_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,1,2\\]\n**Output:** -1\n**Explanation:** Here, nums has 3 elements, so n = 1. \nThus we have to remove 1 element from nums and divide the array into two equal parts.\n- If we remove nums\\[0\\] = 3, the array will be \\[1,2\\]. The difference in sums of the two parts will be 1 - 2 = -1.\n- If we remove nums\\[1\\] = 1, the array will be \\[3,2\\]. The difference in sums of the two parts will be 3 - 2 = 1.\n- If we remove nums\\[2\\] = 2, the array will be \\[3,1\\]. The difference in sums of the two parts will be 3 - 1 = 2.\nThe minimum difference between sums of the two parts is min(-1,1,2) = -1. \n\n**Example 2:**\n\n**Input:** nums = \\[7,9,5,8,1,3\\]\n**Output:** 1\n**Explanation:** Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\nIf we remove nums\\[2\\] = 5 and nums\\[3\\] = 8, the resultant array will be \\[7,9,1,3\\]. The difference in sums will be (7+9) - (1+3) = 12.\nTo obtain the minimum difference, we should remove nums\\[1\\] = 9 and nums\\[4\\] = 1. The resultant array becomes \\[7,5,8,3\\]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\nIt can be shown that it is not possible to obtain a difference smaller than 1.\n\n**Constraints:**\n\n*   `nums.length == 3 * n`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 105`\"\"\"\n\n    frequency = {}\n    for s in arr:\n        frequency[s] = frequency.get(s, 0) + 1\n\n    count = 0\n    for s in arr:\n        if frequency[s] == 1:\n            count += 1\n            if count == k:\n                return s\n\n    return \"\""}}, "leetcode/leetcode_2517.txt": {"score": 0.9576406478881836, "content": {"text": "def max_tastiness(price, k):\n    \"\"\"You are given an array of positive integers `price` where `price[i]` denotes the price of the `ith` candy and a positive integer `k`.\n\nThe store sells baskets of `k` **distinct** candies. The **tastiness** of a candy basket is the smallest absolute difference of the **prices** of any two candies in the basket.\n\nReturn _the **maximum** tastiness of a candy basket._\n\n**Example 1:**\n\n**Input:** price = \\[13,5,1,8,21,2\\], k = 3\n**Output:** 8\n**Explanation:** Choose the candies with the prices \\[13,5,21\\].\nThe tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\nIt can be proven that 8 is the maximum tastiness that can be achieved.\n\n**Example 2:**\n\n**Input:** price = \\[1,3,1\\], k = 2\n**Output:** 2\n**Explanation:** Choose the candies with the prices \\[1,3\\].\nThe tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\nIt can be proven that 2 is the maximum tastiness that can be achieved.\n\n**Example 3:**\n\n**Input:** price = \\[7,7,7,7\\], k = 2\n**Output:** 0\n**Explanation:** Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n\n**Constraints:**\n\n*   `2 <= k <= price.length <= 105`\n*   `1 <= price[i] <= 109`\"\"\"\n\n    price.sort()\n    max_tastiness = 0\n    for i in range(len(price) - k + 1):\n        min_diff = float('inf')\n        for j in range(i, i + k - 1):\n            min_diff = min(min_diff, price[j + 1] - price[j])\n        max_tastiness = max(max_tastiness, min_diff)\n\n    return max_tastiness"}}, "leetcode/leetcode_1984.txt": {"score": 0.9967547655105591, "content": {"text": "def max_distance(nums1, nums2):\n    \"\"\"You are given a **0-indexed** integer array `nums`, where `nums[i]` represents the score of the `ith` student. You are also given an integer `k`.\n\nPick the scores of any `k` students from the array so that the **difference** between the **highest** and the **lowest** of the `k` scores is **minimized**.\n\nReturn _the **minimum** possible difference_.\n\n**Example 1:**\n\n**Input:** nums = \\[90\\], k = 1\n**Output:** 0\n**Explanation:** There is one way to pick score(s) of one student:\n- \\[**90**\\]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\n\n**Example 2:**\n\n**Input:** nums = \\[9,4,1,7\\], k = 2\n**Output:** 2\n**Explanation:** There are six ways to pick score(s) of two students:\n- \\[**9**,**4**,1,7\\]. The difference between the highest and lowest score is 9 - 4 = 5.\n- \\[**9**,4,**1**,7\\]. The difference between the highest and lowest score is 9 - 1 = 8.\n- \\[**9**,4,1,**7**\\]. The difference between the highest and lowest score is 9 - 7 = 2.\n- \\[9,**4**,**1**,7\\]. The difference between the highest and lowest score is 4 - 1 = 3.\n- \\[9,**4**,1,**7**\\]. The difference between the highest and lowest score is 7 - 4 = 3.\n- \\[9,4,**1**,**7**\\]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 1000`\n*   `0 <= nums[i] <= 105`\"\"\"\n\n    i, j, max_dist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if i <= j and nums1[i] <= nums2[j]:\n            max_dist = max(max_dist, j - i)\n            j += 1\n        else:\n            i += 1\n    return max_dist"}}}}, "92": {"gold": {"leetcode/leetcode_1125.txt": 1, "leetcode/leetcode_2305.txt": 1, "leetcode/leetcode_1723.txt": 1}, "retrieved": {"leetcode/leetcode_1687.txt": {"score": 0.9492881298065186, "content": {"text": "def min_trips(boxes, portsCount, maxBoxes, maxWeight):\n    \"\"\"You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a **limit** on the **number of boxes** and the **total weight** that it can carry.\n\nYou are given an array `boxes`, where `boxes[i] = [ports\u200b\u200bi\u200b, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.\n\n*   `ports\u200b\u200bi` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.\n*   `portsCount` is the number of ports.\n*   `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered **in the order they are given**. The ship will follow these steps:\n\n*   The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.\n*   For each loaded box **in order**, the ship will make a **trip** to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no **trip** is needed, and the box can immediately be delivered.\n*   The ship then makes a return **trip** to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\n\nReturn _the **minimum** number of **trips** the ship needs to make to deliver all boxes to their respective ports._\n\n**Example 1:**\n\n**Input:** boxes = \\[\\[1,1\\],\\[2,1\\],\\[1,1\\]\\], portsCount = 2, maxBoxes = 3, maxWeight = 3\n**Output:** 4\n**Explanation:** The optimal strategy is as follows: \n- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\nSo the total number of trips is 4.\nNote that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n\n**Example 2:**\n\n**Input:** boxes = \\[\\[1,2\\],\\[3,3\\],\\[3,1\\],\\[3,1\\],\\[2,4\\]\\], portsCount = 3, maxBoxes = 3, maxWeight = 6\n**Output:** 6\n**Explanation:** The optimal strategy is as follows: \n- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n**Example 3:**\n\n**Input:** boxes = \\[\\[1,4\\],\\[1,2\\],\\[2,1\\],\\[2,1\\],\\[3,2\\],\\[3,4\\]\\], portsCount = 3, maxBoxes = 6, maxWeight = 7\n**Output:** 6\n**Explanation:** The optimal strategy is as follows:\n- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n**Constraints:**\n\n*   `1 <= boxes.length <= 105`\n*   `1 <= portsCount, maxBoxes, maxWeight <= 105`\n*   `1 <= ports\u200b\u200bi <= portsCount`\n*   `1 <= weightsi <= maxWeight`\"\"\"\n\n    trips = 0\n    idx = 0\n    n = len(boxes)\n    while idx < n:\n        curr_limit = maxWeight\n        prev_port = 0\n        count = 0\n        while count < maxBoxes and idx < n:\n            if boxes[idx][1] <= curr_limit:\n                if prev_port != boxes[idx][0]:\n                    prev_port = boxes[idx][0]\n                    trips += 1\n                curr_limit -= boxes[idx][1]\n                count += 1\n                idx += 1\n            else:\n                break\n        trips += 1\n    return trips"}}, "leetcode/leetcode_2383.txt": {"score": 0.9553630948066711, "content": {"text": "def min_training_hours(initial_energy, initial_experience, energy, experience):\n    \"\"\"You are entering a competition, and are given two **positive** integers `initialEnergy` and `initialExperience` denoting your initial energy and initial experience respectively.\n\nYou are also given two **0-indexed** integer arrays `energy` and `experience`, both of length `n`.\n\nYou will face `n` opponents **in order**. The energy and experience of the `ith` opponent is denoted by `energy[i]` and `experience[i]` respectively. When you face an opponent, you need to have both **strictly** greater experience and energy to defeat them and move to the next opponent if available.\n\nDefeating the `ith` opponent **increases** your experience by `experience[i]`, but **decreases** your energy by `energy[i]`.\n\nBefore starting the competition, you can train for some number of hours. After each hour of training, you can **either** choose to increase your initial experience by one, or increase your initial energy by one.\n\nReturn _the **minimum** number of training hours required to defeat all_ `n` _opponents_.\n\n**Example 1:**\n\n**Input:** initialEnergy = 5, initialExperience = 3, energy = \\[1,4,3,2\\], experience = \\[2,6,3,1\\]\n**Output:** 8\n**Explanation:** You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0th opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1st opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2nd opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3rd opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists.\n\n**Example 2:**\n\n**Input:** initialEnergy = 2, initialExperience = 4, energy = \\[1\\], experience = \\[3\\]\n**Output:** 0\n**Explanation:** You do not need any additional energy or experience to win the competition, so we return 0.\n\n**Constraints:**\n\n*   `n == energy.length == experience.length`\n*   `1 <= n <= 100`\n*   `1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100`\"\"\"\n\n    n = len(energy)\n    ans = int(1e9)\n    for exp_gain in range(initial_energy + initial_experience + 1):\n        training_hours = exp_gain\n        energy_left = initial_energy - exp_gain\n        curr_experience = initial_experience + exp_gain\n        \n        for i in range(n):\n            while curr_experience <= experience[i] or energy_left <= energy[i]:\n                energy_left -= 1\n                training_hours += 1\n            energy_left -= energy[i]\n            curr_experience += experience[i]\n        ans = min(ans, training_hours)\n    return ans"}}, "leetcode/leetcode_1011.txt": {"score": 0.9526882171630859, "content": {"text": "def flipRecur(node, voyage, flipped, idx):\n    \"\"\"A conveyor belt has packages that must be shipped from one port to another within `days` days.\n\nThe `ith` package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship.\n\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `days` days.\n\n**Example 1:**\n\n**Input:** weights = \\[1,2,3,4,5,6,7,8,9,10\\], days = 5\n**Output:** 15\n**Explanation:** A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10\n\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\n\n**Example 2:**\n\n**Input:** weights = \\[3,2,2,4,1,4\\], days = 3\n**Output:** 6\n**Explanation:** A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4\n\n**Example 3:**\n\n**Input:** weights = \\[1,2,3,1,1\\], days = 4\n**Output:** 3\n**Explanation:**\n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1\n\n**Constraints:**\n\n*   `1 <= days <= weights.length <= 5 * 104`\n*   `1 <= weights[i] <= 500`\"\"\"\n\n    if not node:\n        return idx\n    if node.val != voyage[idx]:\n        flipped[0] = -1\n        return idx\n    idx += 1\n    if (idx < len(voyage) and node.left and\n            node.left.val != voyage[idx]):\n        flipped.append(node.val)\n        idx = flipRecur(node.right, voyage, flipped, idx)\n        idx = flipRecur(node.left, voyage, flipped, idx)\n    else:\n        idx = flipRecur(node.left, voyage, flipped, idx)\n        idx = flipRecur(node.right, voyage, flipped, idx)\n    return idx\n\n\ndef flipMatchVoyage(root, voyage):\n    flipped = []\n    flipRecur(root, voyage, flipped, 0)\n    if flipped and flipped[0] == -1:\n        return [-1]\n    return flipped"}}, "leetcode/leetcode_2335.txt": {"score": 0.9587723016738892, "content": {"text": "def min_seconds(amount: List[int]) -> int:\n    \"\"\"You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up `2` cups with **different** types of water, or `1` cup of any type of water.\n\nYou are given a **0-indexed** integer array `amount` of length `3` where `amount[0]`, `amount[1]`, and `amount[2]` denote the number of cold, warm, and hot water cups you need to fill respectively. Return _the **minimum** number of seconds needed to fill up all the cups_.\n\n**Example 1:**\n\n**Input:** amount = \\[1,4,2\\]\n**Output:** 4\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.\n\n**Example 2:**\n\n**Input:** amount = \\[5,4,4\\]\n**Output:** 7\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.\n\n**Example 3:**\n\n**Input:** amount = \\[5,0,0\\]\n**Output:** 5\n**Explanation:** Every second, we fill up a cold cup.\n\n**Constraints:**\n\n*   `amount.length == 3`\n*   `0 <= amount[i] <= 100`\"\"\"\n\n    total = sum(amount)\n    largest_two = max(amount[0] + amount[1], amount[1] + amount[2], amount[0] + amount[2])\n    return (total + 1) // 2 - (largest_two + 1) // 2 + largest_two"}}, "leetcode/leetcode_1883.txt": {"score": 0.9563159346580505, "content": {"text": "def minSkips(dist, speed, hoursBefore):\n    \"\"\"You are given an integer `hoursBefore`, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through `n` roads. The road lengths are given as an integer array `dist` of length `n`, where `dist[i]` describes the length of the `ith` road in **kilometers**. In addition, you are given an integer `speed`, which is the speed (in **km/h**) you will travel at.\n\nAfter you travel road `i`, you must rest and wait for the **next integer hour** before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting.\n\n*   For example, if traveling a road takes `1.4` hours, you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours, you do not need to wait.\n\nHowever, you are allowed to **skip** some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks.\n\n*   For example, suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark, letting you start traveling the third road immediately.\n\nReturn _the **minimum number of skips required** to arrive at the meeting on time, or_ `-1` _if it is **impossible**_.\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,2\\], speed = 4, hoursBefore = 2\n**Output:** 1\n**Explanation:**\nWithout skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.\nYou can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.\nNote that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.\n\n**Example 2:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 2, hoursBefore = 10\n**Output:** 2\n**Explanation:**\nWithout skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.\nYou can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.\n\n**Example 3:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 1, hoursBefore = 10\n**Output:** -1\n**Explanation:** It is impossible to arrive at the meeting on time even if you skip all the rests.\n\n**Constraints:**\n\n*   `n == dist.length`\n*   `1 <= n <= 1000`\n*   `1 <= dist[i] <= 105`\n*   `1 <= speed <= 106`\n*   `1 <= hoursBefore <= 107`\"\"\"\n\n    n = len(dist)\n    dp = [[1e9] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for j in range(i+1):\n            t = dist[i] / speed + (1 if j else 0)\n            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)\n            skipped_t = -(-dist[i] / speed) - dp[i][j]\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)\n\n    for i in range(n + 1):\n        if dp[n][i] <= hoursBefore:\n            return i\n    return -1"}}, "leetcode/leetcode_1665.txt": {"score": 0.9646578431129456, "content": {"text": "def minimumEffort(tasks):\n    \"\"\"You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n\n*   `actuali` is the actual amount of energy you **spend to finish** the `ith` task.\n*   `minimumi` is the minimum amount of energy you **require to begin** the `ith` task.\n\nFor example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n\nYou can finish the tasks in **any order** you like.\n\nReturn _the **minimum** initial amount of energy you will need_ _to finish all the tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[4,8\\]\\]\n**Output:** 8\n**Explanation:**\nStarting with 8 energy, we finish the tasks in the following order:\n    - 3rd task. Now energy = 8 - 4 = 4.\n    - 2nd task. Now energy = 4 - 2 = 2.\n    - 1st task. Now energy = 2 - 1 = 1.\nNotice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3\\],\\[2,4\\],\\[10,11\\],\\[10,12\\],\\[8,9\\]\\]\n**Output:** 32\n**Explanation:**\nStarting with 32 energy, we finish the tasks in the following order:\n    - 1st task. Now energy = 32 - 1 = 31.\n    - 2nd task. Now energy = 31 - 2 = 29.\n    - 3rd task. Now energy = 29 - 10 = 19.\n    - 4th task. Now energy = 19 - 10 = 9.\n    - 5th task. Now energy = 9 - 8 = 1.\n\n**Example 3:**\n\n**Input:** tasks = \\[\\[1,7\\],\\[2,8\\],\\[3,9\\],\\[4,10\\],\\[5,11\\],\\[6,12\\]\\]\n**Output:** 27\n**Explanation:**\nStarting with 27 energy, we finish the tasks in the following order:\n    - 5th task. Now energy = 27 - 5 = 22.\n    - 2nd task. Now energy = 22 - 2 = 20.\n    - 3rd task. Now energy = 20 - 3 = 17.\n    - 1st task. Now energy = 17 - 1 = 16.\n    - 4th task. Now energy = 16 - 4 = 12.\n    - 6th task. Now energy = 12 - 6 = 6.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= actual\u200bi <= minimumi <= 104`\"\"\"\n\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n    ans, sum_energy = 0, 0\n    for task in tasks:\n        ans = max(ans, sum_energy + task[1])\n        sum_energy += task[0]\n    return ans"}}, "leetcode/leetcode_2365.txt": {"score": 0.9568349123001099, "content": {"text": "def min_days_to_complete_tasks(tasks, space):\n    \"\"\"You are given a **0-indexed** array of positive integers `tasks`, representing tasks that need to be completed **in order**, where `tasks[i]` represents the **type** of the `ith` task.\n\nYou are also given a positive integer `space`, which represents the **minimum** number of days that must pass **after** the completion of a task before another task of the **same** type can be performed.\n\nEach day, until all tasks have been completed, you must either:\n\n*   Complete the next task from `tasks`, or\n*   Take a break.\n\nReturn _the **minimum** number of days needed to complete all tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,1,2,3,1\\], space = 3\n**Output:** 9\n**Explanation:**\nOne way to complete all tasks in 9 days is as follows:\nDay 1: Complete the 0th task.\nDay 2: Complete the 1st task.\nDay 3: Take a break.\nDay 4: Take a break.\nDay 5: Complete the 2nd task.\nDay 6: Complete the 3rd task.\nDay 7: Take a break.\nDay 8: Complete the 4th task.\nDay 9: Complete the 5th task.\nIt can be shown that the tasks cannot be completed in less than 9 days.\n\n**Example 2:**\n\n**Input:** tasks = \\[5,8,8,5\\], space = 2\n**Output:** 6\n**Explanation:**\nOne way to complete all tasks in 6 days is as follows:\nDay 1: Complete the 0th task.\nDay 2: Complete the 1st task.\nDay 3: Take a break.\nDay 4: Take a break.\nDay 5: Complete the 2nd task.\nDay 6: Complete the 3rd task.\nIt can be shown that the tasks cannot be completed in less than 6 days.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= tasks[i] <= 109`\n*   `1 <= space <= tasks.length`\"\"\"\n\n    task_last_complete = {}\n    days = 0\n\n    for task in tasks:\n        if task in task_last_complete:\n            passed_days = days - task_last_complete[task]\n            if passed_days < space:\n                days += space - passed_days\n        days += 1\n        task_last_complete[task] = days\n\n    return days"}}, "leetcode/leetcode_1986.txt": {"score": 0.9960743188858032, "content": {"text": "from collections import defaultdict\n    \"\"\"There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break.\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n*   If you start a task in a work session, you must complete it in the **same** work session.\n*   You can start a new task **immediately** after finishing the previous one.\n*   You may complete the tasks in **any order**.\n\nGiven `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._\n\nThe tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,3\\], sessionTime = 3\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n**Example 2:**\n\n**Input:** tasks = \\[3,1,3,1,1\\], sessionTime = 8\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n**Example 3:**\n\n**Input:** tasks = \\[1,2,3,4,5\\], sessionTime = 15\n**Output:** 1\n**Explanation:** You can finish all the tasks in one work session.\n\n**Constraints:**\n\n*   `n == tasks.length`\n*   `1 <= n <= 14`\n*   `1 <= tasks[i] <= 10`\n*   `max(tasks[i]) <= sessionTime <= 15`\"\"\"\n\n\n\ndef largestPathValue(colors, edges):\n    def dfs(node):\n        if not cache[node][ord(colors[node]) - ord('a')]:\n            cache[node][ord(colors[node]) - ord('a')] = 1\n            for neighbor in graph[node]:\n                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],\n                                                               1 + dfs(neighbor))\n        return cache[node][ord(colors[node]) - ord('a')]\n\n    n = len(colors)\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n\n    cache = [[0] * 26 for _ in range(n)]\n    in_degree = [0] * n\n    for a, b in edges:\n        in_degree[b] += 1\n    res = -1\n    for i in range(n):\n        if in_degree[i] == 0:\n            res = max(res, dfs(i))\n    return res"}}, "leetcode/leetcode_1335.txt": {"score": 0.9648035764694214, "content": {"text": "def max_candies(candies, k):\n    \"\"\"You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `ith` job, you have to finish all the jobs `j` where `0 <= j < i`).\n\nYou have to finish **at least** one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done on that day.\n\nYou are given an integer array `jobDifficulty` and an integer `d`. The difficulty of the `ith` job is `jobDifficulty[i]`.\n\nReturn _the minimum difficulty of a job schedule_. If you cannot find a schedule for the jobs return `-1`.\n\n**Example 1:**\n\n**Input:** jobDifficulty = \\[6,5,4,3,2,1\\], d = 2\n**Output:** 7\n**Explanation:** First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n\n**Example 2:**\n\n**Input:** jobDifficulty = \\[9,9,9\\], d = 4\n**Output:** -1\n**Explanation:** If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n\n**Example 3:**\n\n**Input:** jobDifficulty = \\[1,1,1\\], d = 3\n**Output:** 3\n**Explanation:** The schedule is one job per day. total difficulty will be 3.\n\n**Constraints:**\n\n*   `1 <= jobDifficulty.length <= 300`\n*   `0 <= jobDifficulty[i] <= 1000`\n*   `1 <= d <= 10`\"\"\"\n\n    left, right = 1, max(candies)\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        count = sum(candy // mid for candy in candies)\n        if count >= k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right"}}, "leetcode/leetcode_2244.txt": {"score": 0.97111976146698, "content": {"text": "def numOfBeams(bank):\n    \"\"\"You are given a **0-indexed** integer array `tasks`, where `tasks[i]` represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the **same difficulty level**.\n\nReturn _the **minimum** rounds required to complete all the tasks, or_ `-1` _if it is not possible to complete all the tasks._\n\n**Example 1:**\n\n**Input:** tasks = \\[2,2,3,3,2,4,4,4,4,4\\]\n**Output:** 4\n**Explanation:** To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2. \n- In the second round, you complete 2 tasks of difficulty level 3. \n- In the third round, you complete 3 tasks of difficulty level 4. \n- In the fourth round, you complete 2 tasks of difficulty level 4.  \nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n\n**Example 2:**\n\n**Input:** tasks = \\[2,3,3\\]\n**Output:** -1\n**Explanation:** There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= tasks[i] <= 109`\"\"\"\n\n    m = len(bank)\n    n = len(bank[0])\n    beams = 0\n\n    for i in range(m):\n        for j in range(n):\n            if bank[i][j] == '1':\n                k = j + 1\n                while k < n and bank[i][k] != '1':\n                    beams += bank[i][k] == '0'\n                    k += 1\n                k = i + 1\n                while k < m and bank[k][j] != '1':\n                    beams += bank[k][j] == '0'\n                    k += 1\n\n    return beams"}}}}, "93": {"gold": {"leetcode/leetcode_354.txt": 1}, "retrieved": {"leetcode/leetcode_1620.txt": {"score": 0.8997728228569031, "content": {"text": "def canArrange(arr, k):\n    \"\"\"You are given an array of network towers `towers`, where `towers[i] = [xi, yi, qi]` denotes the `ith` network tower with location `(xi, yi)` and quality factor `qi`. All the coordinates are **integral coordinates** on the X-Y plane, and the distance between the two coordinates is the **Euclidean distance**.\n\nYou are also given an integer `radius` where a tower is **reachable** if the distance is **less than or equal to** `radius`. Outside that distance, the signal becomes garbled, and the tower is **not reachable**.\n\nThe signal quality of the `ith` tower at a coordinate `(x, y)` is calculated with the formula `\u230aqi / (1 + d)\u230b`, where `d` is the distance between the tower and the coordinate. The **network quality** at a coordinate is the sum of the signal qualities from all the **reachable** towers.\n\nReturn _the array_ `[cx, cy]` _representing the **integral** coordinate_ `(cx, cy)` _where the **network quality** is maximum. If there are multiple coordinates with the same **network quality**, return the lexicographically minimum **non-negative** coordinate._\n\n**Note:**\n\n*   A coordinate `(x1, y1)` is lexicographically smaller than `(x2, y2)` if either:\n    *   `x1 < x2`, or\n    *   `x1 == x2` and `y1 < y2`.\n*   `\u230aval\u230b` is the greatest integer less than or equal to `val` (the floor function).\n\n**Example 1:**\n\n**Input:** towers = \\[\\[1,2,5\\],\\[2,1,7\\],\\[3,1,9\\]\\], radius = 2\n**Output:** \\[2,1\\]\n**Explanation:** At coordinate (2, 1) the total quality is 13.\n- Quality of 7 from (2, 1) results in \u230a7 / (1 + sqrt(0)\u230b = \u230a7\u230b = 7\n- Quality of 5 from (1, 2) results in \u230a5 / (1 + sqrt(2)\u230b = \u230a2.07\u230b = 2\n- Quality of 9 from (3, 1) results in \u230a9 / (1 + sqrt(1)\u230b = \u230a4.5\u230b = 4\nNo other coordinate has a higher network quality.\n\n**Example 2:**\n\n**Input:** towers = \\[\\[23,11,21\\]\\], radius = 9\n**Output:** \\[23,11\\]\n**Explanation:** Since there is only one tower, the network quality is highest right at the tower's location.\n\n**Example 3:**\n\n**Input:** towers = \\[\\[1,2,13\\],\\[2,1,7\\],\\[0,1,9\\]\\], radius = 2\n**Output:** \\[1,2\\]\n**Explanation:** Coordinate (1, 2) has the highest network quality.\n\n**Constraints:**\n\n*   `1 <= towers.length <= 50`\n*   `towers[i].length == 3`\n*   `0 <= xi, yi, qi <= 50`\n*   `1 <= radius <= 50`\"\"\"\n\n    counts = [0] * k\n    for num in arr:\n        counts[(num % k + k) % k] += 1\n    if counts[0] % 2 != 0:\n        return False\n    for i in range(1, k // 2 + 1):\n        if counts[i] != counts[k - i]:\n            return False\n    return True"}}, "leetcode/leetcode_1395.txt": {"score": 0.9008691906929016, "content": {"text": "def minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    \"\"\"There are `n` soldiers standing in a line. Each soldier is assigned a **unique** `rating` value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\n*   Choose 3 soldiers with index (`i`, `j`, `k`) with rating (`rating[i]`, `rating[j]`, `rating[k]`).\n*   A team is valid if: (`rating[i] < rating[j] < rating[k]`) or (`rating[i] > rating[j] > rating[k]`) where (`0 <= i < j < k < n`).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\n**Example 1:**\n\n**Input:** rating = \\[2,5,3,4,1\\]\n**Output:** 3\n**Explanation:** We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\n**Example 2:**\n\n**Input:** rating = \\[2,1,3\\]\n**Output:** 0\n**Explanation:** We can't form any team given the conditions.\n\n**Example 3:**\n\n**Input:** rating = \\[1,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `n == rating.length`\n*   `3 <= n <= 1000`\n*   `1 <= rating[i] <= 105`\n*   All the integers in `rating` are **unique**.\n\nIn one second, you can either: - Move vertically by one unit, - Move horizontally by one unit, or - Move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in one second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points, but they do not count as visited unless you stop on them.\"\"\"\n\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        time += max(dx, dy)\n    return time"}}, "leetcode/leetcode_1899.txt": {"score": 0.9070850014686584, "content": {"text": "def count_matches(items, rule_key, rule_value):\n    \"\"\"A **triplet** is an array of three integers. You are given a 2D integer array `triplets`, where `triplets[i] = [ai, bi, ci]` describes the `ith` **triplet**. You are also given an integer array `target = [x, y, z]` that describes the **triplet** you want to obtain.\n\nTo obtain `target`, you may apply the following operation on `triplets` **any number** of times (possibly **zero**):\n\n*   Choose two indices (**0-indexed**) `i` and `j` (`i != j`) and **update** `triplets[j]` to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`.\n    *   For example, if `triplets[i] = [2, 5, 3]` and `triplets[j] = [1, 7, 5]`, `triplets[j]` will be updated to `[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]`.\n\nReturn `true` _if it is possible to obtain the_ `target` _**triplet**_ `[x, y, z]` _as an **element** of_ `triplets`_, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** triplets = \\[\\[2,5,3\\],\\[1,8,4\\],\\[1,7,5\\]\\], target = \\[2,7,5\\]\n**Output:** true\n**Explanation:** Perform the following operations:\n- Choose the first and last triplets \\[\\[2,5,3\\],\\[1,8,4\\],\\[1,7,5\\]\\]. Update the last triplet to be \\[max(2,1), max(5,7), max(3,5)\\] = \\[2,7,5\\]. triplets = \\[\\[2,5,3\\],\\[1,8,4\\],\\[2,7,5\\]\\]\nThe target triplet \\[2,7,5\\] is now an element of triplets.\n\n**Example 2:**\n\n**Input:** triplets = \\[\\[3,4,5\\],\\[4,5,6\\]\\], target = \\[3,2,5\\]\n**Output:** false\n**Explanation:** It is impossible to have \\[3,2,5\\] as an element because there is no 2 in any of the triplets.\n\n**Example 3:**\n\n**Input:** triplets = \\[\\[2,5,3\\],\\[2,3,4\\],\\[1,2,5\\],\\[5,2,3\\]\\], target = \\[5,5,5\\]\n**Output:** true\n**Explanation:** Perform the following operations:\n- Choose the first and third triplets \\[\\[2,5,3\\],\\[2,3,4\\],\\[1,2,5\\],\\[5,2,3\\]\\]. Update the third triplet to be \\[max(2,1), max(5,2), max(3,5)\\] = \\[2,5,5\\]. triplets = \\[\\[2,5,3\\],\\[2,3,4\\],\\[2,5,5\\],\\[5,2,3\\]\\].\n- Choose the third and fourth triplets \\[\\[2,5,3\\],\\[2,3,4\\],\\[2,5,5\\],\\[5,2,3\\]\\]. Update the fourth triplet to be \\[max(2,5), max(5,2), max(5,3)\\] = \\[5,5,5\\]. triplets = \\[\\[2,5,3\\],\\[2,3,4\\],\\[2,5,5\\],\\[5,5,5\\]\\].\nThe target triplet \\[5,5,5\\] is now an element of triplets.\n\n**Constraints:**\n\n*   `1 <= triplets.length <= 105`\n*   `triplets[i].length == target.length == 3`\n*   `1 <= ai, bi, ci, x, y, z <= 1000`\"\"\"\n\n    rule = {\"type\": 0, \"color\": 1, \"name\": 2}\n    count = 0\n\n    for item in items:\n        if item[rule[rule_key]] == rule_value:\n            count += 1\n\n    return count"}}, "leetcode/leetcode_2432.txt": {"score": 0.9165124893188477, "content": {"text": "def worker_with_longest_task(n, logs):\n    \"\"\"There are `n` employees, each with a unique id from `0` to `n - 1`.\n\nYou are given a 2D integer array `logs` where `logs[i] = [idi, leaveTimei]` where:\n\n*   `idi` is the id of the employee that worked on the `ith` task, and\n*   `leaveTimei` is the time at which the employee finished the `ith` task. All the values `leaveTimei` are **unique**.\n\nNote that the `ith` task starts the moment right after the `(i - 1)th` task ends, and the `0th` task starts at time `0`.\n\nReturn _the id of the employee that worked the task with the longest time._ If there is a tie between two or more employees, return _the **smallest** id among them_.\n\n**Example 1:**\n\n**Input:** n = 10, logs = \\[\\[0,3\\],\\[2,5\\],\\[0,9\\],\\[1,15\\]\\]\n**Output:** 1\n**Explanation:** \nTask 0 started at 0 and ended at 3 with 3 units of times.\nTask 1 started at 3 and ended at 5 with 2 units of times.\nTask 2 started at 5 and ended at 9 with 4 units of times.\nTask 3 started at 9 and ended at 15 with 6 units of times.\nThe task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n\n**Example 2:**\n\n**Input:** n = 26, logs = \\[\\[1,1\\],\\[3,7\\],\\[2,12\\],\\[7,17\\]\\]\n**Output:** 3\n**Explanation:** \nTask 0 started at 0 and ended at 1 with 1 unit of times.\nTask 1 started at 1 and ended at 7 with 6 units of times.\nTask 2 started at 7 and ended at 12 with 5 units of times.\nTask 3 started at 12 and ended at 17 with 5 units of times.\nThe tasks with the longest time is task 1. The employees that worked on it is 3, so we return 3.\n\n**Example 3:**\n\n**Input:** n = 2, logs = \\[\\[0,10\\],\\[1,20\\]\\]\n**Output:** 0\n**Explanation:** \nTask 0 started at 0 and ended at 10 with 10 units of times.\nTask 1 started at 10 and ended at 20 with 10 units of times.\nThe tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.\n\n**Constraints:**\n\n*   `2 <= n <= 500`\n*   `1 <= logs.length <= 500`\n*   `logs[i].length == 2`\n*   `0 <= idi <= n - 1`\n*   `1 <= leaveTimei <= 500`\n*   `idi != idi+1`\n*   `leaveTimei` are sorted in a strictly increasing order.\"\"\"\n\n    result = 0\n    max_time = logs[0][1] - 0\n\n    for i in range(1, len(logs)):\n        time = logs[i][1] - logs[i-1][1]\n        if time > max_time:\n            max_time = time\n            result = logs[i][0]\n\n    return result"}}, "leetcode/leetcode_851.txt": {"score": 0.9014817476272583, "content": {"text": "def to_goat_latin(sentence: str) -> str:\n    \"\"\"There is a group of `n` people labeled from `0` to `n - 1` where each person has a different amount of money and a different level of quietness.\n\nYou are given an array `richer` where `richer[i] = [ai, bi]` indicates that `ai` has more money than `bi` and an integer array `quiet` where `quiet[i]` is the quietness of the `ith` person. All the given data in richer are **logically correct** (i.e., the data will not lead you to a situation where `x` is richer than `y` and `y` is richer than `x` at the same time).\n\nReturn _an integer array_ `answer` _where_ `answer[x] = y` _if_ `y` _is the least quiet person (that is, the person_ `y` _with the smallest value of_ `quiet[y]`_) among all people who definitely have equal to or more money than the person_ `x`.\n\n**Example 1:**\n\n**Input:** richer = \\[\\[1,0\\],\\[2,1\\],\\[3,1\\],\\[3,7\\],\\[4,3\\],\\[5,3\\],\\[6,3\\]\\], quiet = \\[3,2,5,4,6,1,7,0\\]\n**Output:** \\[5,5,2,5,4,5,6,7\\]\n**Explanation:** \nanswer\\[0\\] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet\\[x\\]) is person 7, but it is not clear if they have more money than person 0.\nanswer\\[7\\] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet\\[x\\]) is person 7.\nThe other answers can be filled out with similar reasoning.\n\n**Example 2:**\n\n**Input:** richer = \\[\\], quiet = \\[0\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   `n == quiet.length`\n*   `1 <= n <= 500`\n*   `0 <= quiet[i] < n`\n*   All the values of `quiet` are **unique**.\n*   `0 <= richer.length <= n * (n - 1) / 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs of `richer` are **unique**.\n*   The observations in `richer` are all logically consistent.\"\"\"\n\n    words = sentence.split()\n    vowels = set(\"AEIOUaeiou\")\n    result = []\n\n    for i, word in enumerate(words):\n        if word[0] not in vowels:\n            word = word[1:] + word[0]\n        result.append(word + \"ma\" + \"a\" * (i + 1))\n\n    return ' '.join(result)"}}, "leetcode/leetcode_2206.txt": {"score": 0.90863436460495, "content": {"text": "from typing import List\n    \"\"\"You are given an integer array `nums` consisting of `2 * n` integers.\n\nYou need to divide `nums` into `n` pairs such that:\n\n*   Each element belongs to **exactly one** pair.\n*   The elements present in a pair are **equal**.\n\nReturn `true` _if nums can be divided into_ `n` _pairs, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** nums = \\[3,2,3,2,2,2\\]\n**Output:** true\n**Explanation:** \nThere are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.\nIf nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** \nThere is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.\n\n**Constraints:**\n\n*   `nums.length == 2 * n`\n*   `1 <= n <= 500`\n*   `1 <= nums[i] <= 500`\"\"\"\n\n\ndef max_bombs_detonated(bombs: List[List[int]]) -> int:\n    n = len(bombs)\n    max_bombs = 0\n\n    for i in range(n):\n        count = 0\n        for j in range(n):\n            dx = bombs[i][0] - bombs[j][0]\n            dy = bombs[i][1] - bombs[j][1]\n            distance = dx * dx + dy * dy\n            range_ = bombs[i][2] * bombs[i][2] + bombs[j][2] * bombs[j][2]\n            if distance <= range_:\n                count += 1\n        max_bombs = max(max_bombs, count)\n\n    return max_bombs"}}, "leetcode/leetcode_1672.txt": {"score": 0.9102162718772888, "content": {"text": "def maximumWealth(accounts):\n    \"\"\"You are given an `m x n` integer grid `accounts` where `accounts[i][j]` is the amount of money the `i\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b` customer has in the `j\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b bank. Return _the **wealth** that the richest customer has._\n\nA customer's **wealth** is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum **wealth**.\n\n**Example 1:**\n\n**Input:** accounts = \\[\\[1,2,3\\],\\[3,2,1\\]\\]\n**Output:** 6\n**Explanation****:**\n`1st customer has wealth = 1 + 2 + 3 = 6`\n`2nd customer has wealth = 3 + 2 + 1 = 6`\nBoth customers are considered the richest with a wealth of 6 each, so return 6.\n\n**Example 2:**\n\n**Input:** accounts = \\[\\[1,5\\],\\[7,3\\],\\[3,5\\]\\]\n**Output:** 10\n**Explanation**: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.\n\n**Example 3:**\n\n**Input:** accounts = \\[\\[2,8,7\\],\\[7,1,3\\],\\[1,9,5\\]\\]\n**Output:** 17\n\n**Constraints:**\n\n*   `m == accounts.length`\n*   `n == accounts[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= accounts[i][j] <= 100`\"\"\"\n\n    max_wealth = 0\n    for customer in accounts:\n        wealth = sum(customer)\n        max_wealth = max(max_wealth, wealth)\n    return max_wealth"}}, "leetcode/leetcode_2001.txt": {"score": 0.9206917881965637, "content": {"text": "def canReach(s: str, minJump: int, maxJump: int) -> bool:\n    \"\"\"You are given `n` rectangles represented by a **0-indexed** 2D integer array `rectangles`, where `rectangles[i] = [widthi, heighti]` denotes the width and height of the `ith` rectangle.\n\nTwo rectangles `i` and `j` (`i < j`) are considered **interchangeable** if they have the **same** width-to-height ratio. More formally, two rectangles are **interchangeable** if `widthi/heighti == widthj/heightj` (using decimal division, not integer division).\n\nReturn _the **number** of pairs of **interchangeable** rectangles in_ `rectangles`.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[4,8\\],\\[3,6\\],\\[10,20\\],\\[15,30\\]\\]\n**Output:** 6\n**Explanation:** The following are the interchangeable pairs of rectangles by index (0-indexed):\n- Rectangle 0 with rectangle 1: 4/8 == 3/6.\n- Rectangle 0 with rectangle 2: 4/8 == 10/20.\n- Rectangle 0 with rectangle 3: 4/8 == 15/30.\n- Rectangle 1 with rectangle 2: 3/6 == 10/20.\n- Rectangle 1 with rectangle 3: 3/6 == 15/30.\n- Rectangle 2 with rectangle 3: 10/20 == 15/30.\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[4,5\\],\\[7,8\\]\\]\n**Output:** 0\n**Explanation:** There are no interchangeable pairs of rectangles.\n\n**Constraints:**\n\n*   `n == rectangles.length`\n*   `1 <= n <= 105`\n*   `rectangles[i].length == 2`\n*   `1 <= widthi, heighti <= 105`\"\"\"\n\n    n = len(s)\n    dp = [False] * n\n    dp[0] = True\n    pre = 0\n    for i in range(1, n):\n        if i >= minJump:\n            pre += dp[i - minJump]\n        if i > maxJump:\n            pre -= dp[i - maxJump - 1]\n        dp[i] = pre > 0 and s[i] == '0'\n    return dp[n - 1]"}}, "leetcode/leetcode_825.txt": {"score": 0.9341177344322205, "content": {"text": "def max_increase_keeping_skyline(grid):\n    \"\"\"There are `n` persons on a social media website. You are given an integer array `ages` where `ages[i]` is the age of the `ith` person.\n\nA Person `x` will not send a friend request to a person `y` (`x != y`) if any of the following conditions is true:\n\n*   `age[y] <= 0.5 * age[x] + 7`\n*   `age[y] > age[x]`\n*   `age[y] > 100 && age[x] < 100`\n\nOtherwise, `x` will send a friend request to `y`.\n\nNote that if `x` sends a request to `y`, `y` will not necessarily send a request to `x`. Also, a person will not send a friend request to themself.\n\nReturn _the total number of friend requests made_.\n\n**Example 1:**\n\n**Input:** ages = \\[16,16\\]\n**Output:** 2\n**Explanation:** 2 people friend request each other.\n\n**Example 2:**\n\n**Input:** ages = \\[16,17,18\\]\n**Output:** 2\n**Explanation:** Friend requests are made 17 -> 16, 18 -> 17.\n\n**Example 3:**\n\n**Input:** ages = \\[20,30,100,110,120\\]\n**Output:** 3\n**Explanation:** Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\n**Constraints:**\n\n*   `n == ages.length`\n*   `1 <= n <= 2 * 104`\n*   `1 <= ages[i] <= 120`\"\"\"\n\n    n = len(grid)\n    row_max = [0] * n\n    col_max = [0] * n\n    \n    for i in range(n):\n        for j in range(n):\n            row_max[i] = max(row_max[i], grid[i][j])\n            col_max[j] = max(col_max[j], grid[i][j])\n    \n    total_sum = 0\n    for i in range(n):\n        for j in range(n):\n            total_sum += min(row_max[i], col_max[j]) - grid[i][j]\n    \n    return total_sum"}}, "leetcode/leetcode_1996.txt": {"score": 0.9866791367530823, "content": {"text": "def numberOfSticks(n, k):\n    \"\"\"You are playing a game that contains multiple characters, and each of the characters has **two** main properties: **attack** and **defense**. You are given a 2D integer array `properties` where `properties[i] = [attacki, defensei]` represents the properties of the `ith` character in the game.\n\nA character is said to be **weak** if any other character has **both** attack and defense levels **strictly greater** than this character's attack and defense levels. More formally, a character `i` is said to be **weak** if there exists another character `j` where `attackj > attacki` and `defensej > defensei`.\n\nReturn _the number of **weak** characters_.\n\n**Example 1:**\n\n**Input:** properties = \\[\\[5,5\\],\\[6,3\\],\\[3,6\\]\\]\n**Output:** 0\n**Explanation:** No character has strictly greater attack and defense than the other.\n\n**Example 2:**\n\n**Input:** properties = \\[\\[2,2\\],\\[3,3\\]\\]\n**Output:** 1\n**Explanation:** The first character is weak because the second character has a strictly greater attack and defense.\n\n**Example 3:**\n\n**Input:** properties = \\[\\[1,5\\],\\[10,4\\],\\[4,3\\]\\]\n**Output:** 1\n**Explanation:** The third character is weak because the second character has a strictly greater attack and defense.\n\n**Constraints:**\n\n*   `2 <= properties.length <= 105`\n*   `properties[i].length == 2`\n*   `1 <= attacki, defensei <= 105`\"\"\"\n\n    MOD = 10**9 + 7\n    if n < k: return 0\n    dp = [[0] * (n+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        dp[i][1] = 1\n        for j in range(2, i+1):\n            dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD\n\n    return dp[n][k]"}}}}, "94": {"gold": {"leetcode/leetcode_1235.txt": 1, "leetcode/leetcode_1353.txt": 1, "leetcode/leetcode_1751.txt": 1}, "retrieved": {"leetcode/leetcode_1751.txt": {"score": 0.9075335264205933, "content": {"text": "def slowestKey(releaseTimes, keysPressed):\n    \"\"\"You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn _the **maximum sum** of values that you can receive by attending events._\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,1\\]\\], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,10\\]\\], k = 2\n**Output:** 10\n**Explanation:** Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,1,1\\],\\[2,2,2\\],\\[3,3,3\\],\\[4,4,4\\]\\], k = 3\n**Output:** 9\n**Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n**Constraints:**\n\n*   `1 <= k <= events.length`\n*   `1 <= k * events.length <= 106`\n*   `1 <= startDayi <= endDayi <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    max_key = keysPressed[0]\n    max_duration = releaseTimes[0]\n    for i in range(1, len(releaseTimes)):\n        duration = releaseTimes[i] - releaseTimes[i - 1]\n        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):\n            max_key = keysPressed[i]\n            max_duration = duration\n    return max_key"}}, "leetcode/leetcode_188.txt": {"score": 0.9085251688957214, "content": {"text": "def maxProfit(k, prices):\n    \"\"\"You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** k = 2, prices = \\[2,4,1\\]\n**Output:** 2\n**Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n**Example 2:**\n\n**Input:** k = 2, prices = \\[3,2,6,5,0,3\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= prices.length <= 1000`\n*   `0 <= prices[i] <= 1000`\"\"\"\n\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]"}}, "leetcode/leetcode_2054.txt": {"score": 0.9124410152435303, "content": {"text": "def find_chair(times, target_friend):\n    \"\"\"You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose **at most** **two** **non-overlapping** events to attend such that the sum of their values is **maximized**.\n\nReturn _this **maximum** sum._\n\nNote that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[2,4,3\\]\\]\n**Output:** 4\n**Explanation:** Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[1,5,5\\]\\]\n**Output:** 5\n**Explanation:** Choose event 2 for a sum of 5.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,5,3\\],\\[1,5,1\\],\\[6,6,5\\]\\]\n**Output:** 8\n**Explanation:** Choose events 0 and 2 for a sum of 3 + 5 = 8.\n\n**Constraints:**\n\n*   `2 <= events.length <= 105`\n*   `events[i].length == 3`\n*   `1 <= startTimei <= endTimei <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    n = len(times)\n    events = []\n    for i, (arrival, leaving) in enumerate(times):\n        events.append((arrival, i))\n        events.append((leaving, ~i))\n    events.sort()\n    chairs = [-1] * n\n    available_chairs = sorted(range(n))\n    for time, friend_id in events:\n        if friend_id >= 0:\n            chairs[friend_id] = available_chairs.pop(0)\n            if friend_id == target_friend:\n                return chairs[friend_id]\n        else:\n            available_chairs.append(chairs[~friend_id])\n            available_chairs.sort()\n    return -1"}}, "leetcode/leetcode_1937.txt": {"score": 0.9153392314910889, "content": {"text": "def maxPoints(points):\n    \"\"\"You are given an `m x n` integer matrix `points` (**0-indexed**). Starting with `0` points, you want to **maximize** the number of points you can get from the matrix.\n\nTo gain points, you must pick one cell in **each row**. Picking the cell at coordinates `(r, c)` will **add** `points[r][c]` to your score.\n\nHowever, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows `r` and `r + 1` (where `0 <= r < m - 1`), picking cells at coordinates `(r, c1)` and `(r + 1, c2)` will **subtract** `abs(c1 - c2)` from your score.\n\nReturn _the **maximum** number of points you can achieve_.\n\n`abs(x)` is defined as:\n\n*   `x` for `x >= 0`.\n*   `-x` for `x < 0`.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,2,3\\],\\[1,5,1\\],\\[3,1,1\\]\\]\n**Output:** 9\n**Explanation:**\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\nYou add 3 + 5 + 3 = 11 to your score.\nHowever, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\nYour final score is 11 - 2 = 9.\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,5\\],\\[2,3\\],\\[4,2\\]\\]\n**Output:** 11\n**Explanation:**\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\nYou add 5 + 3 + 4 = 12 to your score.\nHowever, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\nYour final score is 12 - 1 = 11.\n\n**Constraints:**\n\n*   `m == points.length`\n*   `n == points[r].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `0 <= points[r][c] <= 105`\"\"\"\n\n    m, n = len(points), len(points[0])\n    dp = [0] * n\n    for row in points:\n        next_dp = [0] * n\n        for c1 in range(n):\n            score = dp[c1] + row[c1] - c1\n            for c2 in range(n):\n                next_dp[c2] = max(next_dp[c2], score - row[c1] + c2)\n        dp = next_dp\n    return max(dp)"}}, "leetcode/leetcode_502.txt": {"score": 0.9218510389328003, "content": {"text": "import heapq\n    \"\"\"Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the **IPO**. Since it has limited resources, it can only finish at most `k` distinct projects before the **IPO**. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.\n\nYou are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.\n\nInitially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return _the final maximized capital_.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n**Example 1:**\n\n**Input:** k = 2, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,1\\]\n**Output:** 4\n**Explanation:** Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** k = 3, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,2\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= k <= 105`\n*   `0 <= w <= 109`\n*   `n == profits.length`\n*   `n == capital.length`\n*   `1 <= n <= 105`\n*   `0 <= profits[i] <= 104`\n*   `0 <= capital[i] <= 109`\"\"\"\n\n\ndef findMaximizedCapital(k: int, w: int, profits, capital) -> int:\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n    \n    profit_pool = []\n    \n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n        \n        if not profit_pool:\n            break\n        \n        w -= heapq.heappop(profit_pool)\n        k -= 1\n        \n    return w"}}, "leetcode/leetcode_1696.txt": {"score": 0.9253943562507629, "content": {"text": "def isPrintable(targetGrid):\n    \"\"\"You are given a **0-indexed** integer array `nums` and an integer `k`.\n\nYou are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n - 1, i + k)]` **inclusive**.\n\nYou want to reach the last index of the array (index `n - 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array.\n\nReturn _the **maximum score** you can get_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,\\-1,-2,4,-7,3\\], k = 2\n**Output:** 7\n**Explanation:** You can choose your jumps forming the subsequence \\[1,-1,4,3\\] (underlined above). The sum is 7.\n\n**Example 2:**\n\n**Input:** nums = \\[10,-5,-2,4,0,3\\], k = 3\n**Output:** 17\n**Explanation:** You can choose your jumps forming the subsequence \\[10,4,3\\] (underlined above). The sum is 17.\n\n**Example 3:**\n\n**Input:** nums = \\[1,-5,-20,4,-1,3,-6,-3\\], k = 2\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length, k <= 105`\n*   `-104 <= nums[i] <= 104`\"\"\"\n\n    m, n = len(targetGrid), len(targetGrid[0])\n    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61\n    vis = [[False]*n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            c = targetGrid[i][j]\n            top[c] = min(top[c], i)\n            bottom[c] = max(bottom[c], i)\n            left[c] = min(left[c], j)\n            right[c] = max(right[c], j)\n\n    def dfs(x):\n        i, j = x // n, x % n\n        if vis[i][j]: return True\n        c = targetGrid[i][j]\n        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False\n        vis[i][j] = True\n        for k in range(1, 61):\n            if k == c: continue\n            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False\n            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False\n        return True\n\n    for color in range(1, 61):\n        for i in range(top[color], bottom[color] + 1):\n            for j in range(left[color], right[color] + 1):\n                if not vis[i][j] and not dfs(i * n + j): return False\n\n    return True"}}, "leetcode/leetcode_740.txt": {"score": 0.9148411750793457, "content": {"text": "def max_points(nums):\n    \"\"\"You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:\n\n*   Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.\n\nReturn _the **maximum number of points** you can earn by applying the above operation some number of times_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,4,2\\]\n**Output:** 6\n**Explanation:** You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = \\[2\\].\n- Delete 2 to earn 2 points. nums = \\[\\].\nYou earn a total of 6 points.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,3,3,3,4\\]\n**Output:** 9\n**Explanation:** You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = \\[3,3\\].\n- Delete a 3 again to earn 3 points. nums = \\[3\\].\n- Delete a 3 once more to earn 3 points. nums = \\[\\].\nYou earn a total of 9 points.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 104`\"\"\"\n\n    dp = [0] * 100001\n    max_points = 0\n    for num in nums:\n        dp[num] += 1\n    for i in range(2, len(dp)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])\n        max_points = max(max_points, dp[i])\n    return max_points"}}, "leetcode/leetcode_2008.txt": {"score": 0.9360746145248413, "content": {"text": "def minOperationsToFlip(expression: str) -> int:\n    \"\"\"There are `n` points on a road you are driving your taxi on. The `n` points on the road are labeled from `1` to `n` in the direction you are going, and you want to drive from point `1` to point `n` to make money by picking up passengers. You cannot change the direction of the taxi.\n\nThe passengers are represented by a **0-indexed** 2D integer array `rides`, where `rides[i] = [starti, endi, tipi]` denotes the `ith` passenger requesting a ride from point `starti` to point `endi` who is willing to give a `tipi` dollar tip.\n\nFor **each** passenger `i` you pick up, you **earn** `endi - starti + tipi` dollars. You may only drive **at most one** passenger at a time.\n\nGiven `n` and `rides`, return _the **maximum** number of dollars you can earn by picking up the passengers optimally._\n\n**Note:** You may drop off a passenger and pick up a different passenger at the same point.\n\n**Example 1:**\n\n**Input:** n = 5, rides = \\[\\[2,5,4\\],\\[1,5,1\\]\\]\n**Output:** 7\n**Explanation:** We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.\n\n**Example 2:**\n\n**Input:** n = 20, rides = \\[\\[1,6,1\\],\\[3,10,2\\],\\[10,12,3\\],\\[11,12,2\\],\\[12,15,2\\],\\[13,18,1\\]\\]\n**Output:** 20\n**Explanation:** We will pick up the following passengers:\n- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.\n- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.\n- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.\nWe earn 9 + 5 + 6 = 20 dollars in total.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= rides.length <= 3 * 104`\n*   `rides[i].length == 3`\n*   `1 <= starti < endi <= n`\n*   `1 <= tipi <= 105`\"\"\"\n\n    zero, one, op = [0], [0], []\n    for c in expression:\n        if c == '&':\n            op.append(1)\n        elif c == '|':\n            op.append(2)\n        elif c.isdigit():\n            if c == '0':\n                one.append(1)\n                zero.append(0)\n            else:\n                zero.append(1)\n                one.append(0)\n        elif c == ')':\n            cur_op = op.pop()\n            x = zero.pop()\n            y = one.pop() + 1\n            if cur_op == 1:\n                new_zero = max(x, y)\n                new_one = one[-1] + min(x, zero[-1])\n            else:\n                new_zero = zero[-1] + min(x, one[-1])\n                new_one = max(y, one[-1])\n            zero.pop()\n            one.pop()\n            zero.append(new_zero)\n            one.append(new_one)\n    return zero[-1] + 1"}}, "leetcode/leetcode_1537.txt": {"score": 0.9167097210884094, "content": {"text": "def maxScore(s):\n    \"\"\"You are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid path** is defined as follows:\n\n*   Choose array `nums1` or `nums2` to traverse (from index-0).\n*   Traverse the current array from left to right.\n*   If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,4,5,8,10\\], nums2 = \\[4,6,8,9\\]\n**Output:** 30\n**Explanation:** Valid paths:\n\\[2,4,5,8,10\\], \\[2,4,5,8,9\\], \\[2,4,6,8,9\\], \\[2,4,6,8,10\\],  (starting from nums1)\n\\[4,6,8,9\\], \\[4,5,8,10\\], \\[4,5,8,9\\], \\[4,6,8,10\\]    (starting from nums2)\nThe maximum is obtained with the path in green **\\[2,4,6,8,10\\]**.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,3,5,7,9\\], nums2 = \\[3,5,100\\]\n**Output:** 109\n**Explanation:** Maximum sum is obtained with the path **\\[1,3,5,100\\]**.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[6,7,8,9,10\\]\n**Output:** 40\n**Explanation:** There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path \\[6,7,8,9,10\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 107`\n*   `nums1` and `nums2` are strictly increasing.\"\"\"\n\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score"}}, "leetcode/leetcode_1642.txt": {"score": 0.9220207929611206, "content": {"text": "def maxWaterBottles(numBottles: int, numExchange: int) -> int:\n    \"\"\"You are given an integer array `heights` representing the heights of buildings, some `bricks`, and some `ladders`.\n\nYou start your journey from building `0` and move to the next building by possibly using bricks or ladders.\n\nWhile moving from building `i` to building `i+1` (**0-indexed**),\n\n*   If the current building's height is **greater than or equal** to the next building's height, you do **not** need a ladder or bricks.\n*   If the current building's height is **less than** the next building's height, you can either use **one ladder** or `(h[i+1] - h[i])` **bricks**.\n\n_Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally._\n\n**Example 1:**\n\n**Input:** heights = \\[4,2,7,6,9,14,12\\], bricks = 5, ladders = 1\n**Output:** 4\n**Explanation:** Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n**Example 2:**\n\n**Input:** heights = \\[4,12,2,7,3,18,20,3,19\\], bricks = 10, ladders = 2\n**Output:** 7\n\n**Example 3:**\n\n**Input:** heights = \\[14,3,19,3\\], bricks = 17, ladders = 0\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `1 <= heights[i] <= 106`\n*   `0 <= bricks <= 109`\n*   `0 <= ladders <= heights.length`\"\"\"\n\n    total = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        total += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return total"}}}}, "95": {"gold": {"leetcode/leetcode_1155.txt": 1, "leetcode/leetcode_1223.txt": 1}, "retrieved": {"leetcode/leetcode_1991.txt": {"score": 0.8765172362327576, "content": {"text": "def findMiddleIndex(nums):\n    \"\"\"Given a **0-indexed** integer array `nums`, find the **leftmost** `middleIndex` (i.e., the smallest amongst all the possible ones).\n\nA `middleIndex` is an index where `nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]`.\n\nIf `middleIndex == 0`, the left side sum is considered to be `0`. Similarly, if `middleIndex == nums.length - 1`, the right side sum is considered to be `0`.\n\nReturn _the **leftmost**_ `middleIndex` _that satisfies the condition, or_ `-1` _if there is no such index_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,-1,8,4\\]\n**Output:** 3\n**Explanation:** The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4\n\n**Example 2:**\n\n**Input:** nums = \\[1,-1,4\\]\n**Output:** 2\n**Explanation:** The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0\n\n**Example 3:**\n\n**Input:** nums = \\[2,5\\]\n**Output:** -1\n**Explanation:** There is no valid middleIndex.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `-1000 <= nums[i] <= 1000`\n\"\"\"\n\n    total_sum = sum(nums)\n    left_sum = 0\n\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n\n    return -1"}}, "leetcode/leetcode_805.txt": {"score": 0.8765376210212708, "content": {"text": "from typing import List\n    \"\"\"You are given an integer array `nums`.\n\nYou should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.\n\nReturn `true` if it is possible to achieve that and `false` otherwise.\n\n**Note** that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8\\]\n**Output:** true\n**Explanation:** We can split the array into \\[1,4,5,8\\] and \\[2,3,6,7\\], and both of them have an average of 4.5.\n\n**Example 2:**\n\n**Input:** nums = \\[3,1\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= nums.length <= 30`\n*   `0 <= nums[i] <= 104`\"\"\"\n\n\ndef escape_ghosts(ghosts: List[List[int]], target: List[int]) -> bool:\n    max_dist = abs(target[0]) + abs(target[1])\n    for ghost in ghosts:\n        ghost_dist = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1])\n        if ghost_dist <= max_dist:\n            return False\n    return True"}}, "leetcode/csn_python_train_346637.txt": {"score": 0.8839159607887268, "content": {"text": "def extrapolate_coverage(lines_w_status):\n    \"\"\"\n    Given the following input:\n\n    >>> lines_w_status = [\n        (1, True),\n        (4, True),\n        (7, False),\n        (9, False),\n    ]\n\n    Return expanded lines with their extrapolated line status.\n\n    >>> extrapolate_coverage(lines_w_status) == [\n        (1, True),\n        (2, True),\n        (3, True),\n        (4, True),\n        (5, None),\n        (6, None),\n        (7, False),\n        (8, False),\n        (9, False),\n    ]\n\n    \"\"\"\n    lines = []\n\n    prev_lineno = 0\n    prev_status = True\n    for lineno, status in lines_w_status:\n        while (lineno - prev_lineno) > 1:\n            prev_lineno += 1\n            if prev_status is status:\n                lines.append((prev_lineno, status))\n            else:\n                lines.append((prev_lineno, None))\n        lines.append((lineno, status))\n        prev_lineno = lineno\n        prev_status = status\n\n    return lines"}}, "leetcode/leetcode_2485.txt": {"score": 0.8807724714279175, "content": {"text": "def find_pivot(n: int) -> int:\n    \"\"\"Given a positive integer `n`, find the **pivot integer** `x` such that:\n\n*   The sum of all elements between `1` and `x` inclusively equals the sum of all elements between `x` and `n` inclusively.\n\nReturn _the pivot integer_ `x`. If no such integer exists, return `-1`. It is guaranteed that there will be at most one pivot index for the given input.\n\n**Example 1:**\n\n**Input:** n = 8\n**Output:** 6\n**Explanation:** 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** 1 is the pivot integer since: 1 = 1.\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** -1\n**Explanation:** It can be proved that no such integer exist.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\"\"\"\n\n    total = n * (n + 1) // 2\n    left_sum = 0\n    for x in range(1, n + 1):\n        left_sum += x\n        if 2 * left_sum == total:\n            return x\n    return -1"}}, "leetcode/leetcode_888.txt": {"score": 0.8770652413368225, "content": {"text": "def mirrorReflection(p, q):\n    \"\"\"Alice and Bob have a different total number of candies. You are given two integer arrays `aliceSizes` and `bobSizes` where `aliceSizes[i]` is the number of candies of the `ith` box of candy that Alice has and `bobSizes[j]` is the number of candies of the `jth` box of candy that Bob has.\n\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\n\nReturn a_n integer array_ `answer` _where_ `answer[0]` _is the number of candies in the box that Alice must exchange, and_ `answer[1]` _is the number of candies in the box that Bob must exchange_. If there are multiple answers, you may **return any** one of them. It is guaranteed that at least one answer exists.\n\n**Example 1:**\n\n**Input:** aliceSizes = \\[1,1\\], bobSizes = \\[2,2\\]\n**Output:** \\[1,2\\]\n\n**Example 2:**\n\n**Input:** aliceSizes = \\[1,2\\], bobSizes = \\[2,3\\]\n**Output:** \\[1,2\\]\n\n**Example 3:**\n\n**Input:** aliceSizes = \\[2\\], bobSizes = \\[1,3\\]\n**Output:** \\[2,3\\]\n\n**Constraints:**\n\n*   `1 <= aliceSizes.length, bobSizes.length <= 104`\n*   `1 <= aliceSizes[i], bobSizes[j] <= 105`\n*   Alice and Bob have a different total number of candies.\n*   There will be at least one valid answer for the given input.\"\"\"\n\n    from math import gcd\n    m = p // gcd(p, q)\n\n    if m % 2 == 0:\n        return 2\n    if (q // gcd(p, q)) % 2 == 0:\n        return 0\n    return 1"}}, "leetcode/leetcode_2256.txt": {"score": 0.8926573991775513, "content": {"text": "def count_convertible_words(start_words, target_words):\n    \"\"\"You are given a **0-indexed** integer array `nums` of length `n`.\n\nThe **average difference** of the index `i` is the **absolute** **difference** between the average of the **first** `i + 1` elements of `nums` and the average of the **last** `n - i - 1` elements. Both averages should be **rounded down** to the nearest integer.\n\nReturn _the index with the **minimum average difference**_. If there are multiple such indices, return the **smallest** one.\n\n**Note:**\n\n*   The **absolute difference** of two numbers is the absolute value of their difference.\n*   The **average** of `n` elements is the **sum** of the `n` elements divided (**integer division**) by `n`.\n*   The average of `0` elements is considered to be `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,5,3,9,5,3\\]\n**Output:** 3\n**Explanation:**\n- The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.\n- The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.\n- The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.\n- The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.\n- The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.\n- The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.\nThe average difference of index 3 is the minimum average difference so return 3.\n\n**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** 0\n**Explanation:**\nThe only index is 0 so return 0.\nThe average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`\"\"\"\n\n    count = 0\n    for target in target_words:\n        for start in start_words:\n            if len(start) + 1 == len(target) and target.startswith(start):\n                count += 1\n                break\n    return count"}}, "leetcode/leetcode_1491.txt": {"score": 0.894615113735199, "content": {"text": "def count_prefix_aligned(flips):\n    \"\"\"You are given an array of **unique** integers `salary` where `salary[i]` is the salary of the `ith` employee.\n\nReturn _the average salary of employees excluding the minimum and maximum salary_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** salary = \\[4000,3000,1000,2000\\]\n**Output:** 2500.00000\n**Explanation:** Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500\n\n**Example 2:**\n\n**Input:** salary = \\[1000,2000,3000\\]\n**Output:** 2000.00000\n**Explanation:** Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000\n\n**Constraints:**\n\n*   `3 <= salary.length <= 100`\n*   `1000 <= salary[i] <= 106`\n*   All the integers of `salary` are **unique**.\"\"\"\n\n    count = 0\n    for i in range(len(flips)):\n        if flips[i] == i + 1:\n            count += 1\n    return count"}}, "leetcode/leetcode_2028.txt": {"score": 0.9958627223968506, "content": {"text": "def earliest_and_latest(n, first_player, second_player):\n    \"\"\"You have observations of `n + m` **6-sided** dice rolls with each face numbered from `1` to `6`. `n` of the observations went missing, and you only have the observations of `m` rolls. Fortunately, you have also calculated the **average value** of the `n + m` rolls.\n\nYou are given an integer array `rolls` of length `m` where `rolls[i]` is the value of the `ith` observation. You are also given the two integers `mean` and `n`.\n\nReturn _an array of length_ `n` _containing the missing observations such that the **average value** of the_ `n + m` _rolls is **exactly**_ `mean`. If there are multiple valid answers, return _any of them_. If no such array exists, return _an empty array_.\n\nThe **average value** of a set of `k` numbers is the sum of the numbers divided by `k`.\n\nNote that `mean` is an integer, so the sum of the `n + m` rolls should be divisible by `n + m`.\n\n**Example 1:**\n\n**Input:** rolls = \\[3,2,4,3\\], mean = 4, n = 2\n**Output:** \\[6,6\\]\n**Explanation:** The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.\n\n**Example 2:**\n\n**Input:** rolls = \\[1,5,6\\], mean = 3, n = 4\n**Output:** \\[2,3,2,2\\]\n**Explanation:** The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.\n\n**Example 3:**\n\n**Input:** rolls = \\[1,2,3,4\\], mean = 6, n = 4\n**Output:** \\[\\]\n**Explanation:** It is impossible for the mean to be 6 no matter what the 4 missing rolls are.\n\n**Constraints:**\n\n*   `m == rolls.length`\n*   `1 <= n, m <= 105`\n*   `1 <= rolls[i], mean <= 6`\"\"\"\n\n    earliest, latest = 1, 1\n    while (first_player + second_player) != n + 1 or abs(first_player - second_player) != 1:\n        if (first_player + second_player) <= n + 1 and (first_player - 1) // 2 == (second_player - 1) // 2:\n            break\n        if (first_player + second_player) > n + 1:\n            n = (n + 1) // 2\n            first_player, second_player = (n + 1) - second_player, (n + 1) - first_player\n        else:\n            first_player = (first_player + 1) // 2\n            second_player = (second_player + 1) // 2\n        earliest += 1\n        latest += 1\n\n    return [earliest, latest]"}}, "leetcode/leetcode_1619.txt": {"score": 0.8824652433395386, "content": {"text": "def is_path_crossing(path: str) -> bool:\n    \"\"\"Given an integer array `arr`, return _the mean of the remaining integers after removing the smallest `5%` and the largest `5%` of the elements._\n\nAnswers within `10-5` of the **actual answer** will be considered accepted.\n\n**Example 1:**\n\n**Input:** arr = \\[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3\\]\n**Output:** 2.00000\n**Explanation:** After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.\n\n**Example 2:**\n\n**Input:** arr = \\[6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0\\]\n**Output:** 4.00000\n\n**Example 3:**\n\n**Input:** arr = \\[6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4\\]\n**Output:** 4.77778\n\n**Constraints:**\n\n*   `20 <= arr.length <= 1000`\n*   `arr.length` **is a multiple** of `20`.\n*   `0 <= arr[i] <= 105`\"\"\"\n\n    visited = {(0, 0)}\n    x, y = 0, 0\n    for dir in path:\n        if dir == 'N': y += 1\n        elif dir == 'S': y -= 1\n        elif dir == 'E': x += 1\n        elif dir == 'W': x -= 1\n        if (x, y) in visited: return True\n        visited.add((x, y))\n    return False"}}, "leetcode/leetcode_2212.txt": {"score": 0.8772558569908142, "content": {"text": "def min_deletions(nums):\n    \"\"\"Alice and Bob are opponents in an archery competition. The competition has set the following rules:\n\n1.  Alice first shoots `numArrows` arrows and then Bob shoots `numArrows` arrows.\n2.  The points are then calculated as follows:\n    1.  The target has integer scoring sections ranging from `0` to `11` **inclusive**.\n    2.  For **each** section of the target with score `k` (in between `0` to `11`), say Alice and Bob have shot `ak` and `bk` arrows on that section respectively. If `ak >= bk`, then Alice takes `k` points. If `ak < bk`, then Bob takes `k` points.\n    3.  However, if `ak == bk == 0`, then **nobody** takes `k` points.\n\n*   For example, if Alice and Bob both shot `2` arrows on the section with score `11`, then Alice takes `11` points. On the other hand, if Alice shot `0` arrows on the section with score `11` and Bob shot `2` arrows on that same section, then Bob takes `11` points.\n    \n\nYou are given the integer `numArrows` and an integer array `aliceArrows` of size `12`, which represents the number of arrows Alice shot on each scoring section from `0` to `11`. Now, Bob wants to **maximize** the total number of points he can obtain.\n\nReturn _the array_ `bobArrows` _which represents the number of arrows Bob shot on **each** scoring section from_ `0` _to_ `11`. The sum of the values in `bobArrows` should equal `numArrows`.\n\nIf there are multiple ways for Bob to earn the maximum total points, return **any** one of them.\n\n**Example 1:**\n\n**Input:** numArrows = 9, aliceArrows = \\[1,1,0,1,0,0,2,1,0,1,2,0\\]\n**Output:** \\[0,0,0,0,1,1,0,0,1,2,3,1\\]\n**Explanation:** The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points.\n\n**Example 2:**\n\n**Input:** numArrows = 3, aliceArrows = \\[0,0,1,0,0,0,0,0,0,0,0,2\\]\n**Output:** \\[0,0,0,0,0,0,0,0,1,1,1,0\\]\n**Explanation:** The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points.\n\n**Constraints:**\n\n*   `1 <= numArrows <= 105`\n*   `aliceArrows.length == bobArrows.length == 12`\n*   `0 <= aliceArrows[i], bobArrows[i] <= numArrows`\n*   `sum(aliceArrows[i]) == numArrows`\"\"\"\n\n    n = len(nums)\n    if n <= 2:\n        return 0\n        \n    min_idx, max_idx = 0, 0\n\n    for i in range(1, n):\n        if nums[i] < nums[min_idx]:\n            min_idx = i\n        if nums[i] > nums[max_idx]:\n            max_idx = i\n\n    return min(max(min_idx, max_idx), n - min(min_idx, max_idx) - 1, min_idx + n - max_idx - 1)"}}}}, "96": {"gold": {"leetcode/leetcode_743.txt": 1, "leetcode/leetcode_1334.txt": 1, "leetcode/leetcode_1976.txt": 1}, "retrieved": {"leetcode/leetcode_778.txt": {"score": 0.9292222261428833, "content": {"text": "import heapq\n    \"\"\"You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.\n\nThe rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nReturn _the least time until you can reach the bottom right square_ `(n - 1, n - 1)` _if you start at the top left square_ `(0, 0)`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2\\],\\[1,3\\]\\]\n**Output:** 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,2,3,4\\],\\[24,23,22,21,5\\],\\[12,13,14,15,16\\],\\[11,17,18,19,20\\],\\[10,9,8,7,6\\]\\]\n**Output:** 16\n**Explanation:** The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] < n2`\n*   Each value `grid[i][j]` is **unique**.\"\"\"\n\n\ndef rearrange_string(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    \n    pq = [(-count, char) for char, count in counts.items()]\n    heapq.heapify(pq)\n    \n    result = []\n    previous = (0, '')\n    \n    while pq:\n        count, char = heapq.heappop(pq)\n        result.append(char)\n        \n        if previous[0] < 0:\n            heapq.heappush(pq, previous)\n        \n        count += 1\n        previous = (count, char)\n    \n    result_str = ''.join(result)\n    return result_str if len(result_str) == len(s) else \"\""}}, "leetcode/leetcode_2039.txt": {"score": 0.9310939311981201, "content": {"text": "def sumGame(num: str) -> bool:\n    \"\"\"There is a network of `n` servers, labeled from `0` to `n - 1`. You are given a 2D integer array `edges`, where `edges[i] = [ui, vi]` indicates there is a message channel between servers `ui` and `vi`, and they can pass **any** number of messages to **each other** directly in **one** second. You are also given a **0-indexed** integer array `patience` of length `n`.\n\nAll servers are **connected**, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.\n\nThe server labeled `0` is the **master** server. The rest are **data** servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers **optimally**, so every message takes the **least amount of time** to arrive at the master server. The master server will process all newly arrived messages **instantly** and send a reply to the originating server via the **reversed path** the message had gone through.\n\nAt the beginning of second `0`, each data server sends its message to be processed. Starting from second `1`, at the **beginning** of **every** second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:\n\n*   If it has not, it will **resend** the message periodically. The data server `i` will resend the message every `patience[i]` second(s), i.e., the data server `i` will resend the message if `patience[i]` second(s) have **elapsed** since the **last** time the message was sent from this server.\n*   Otherwise, **no more resending** will occur from this server.\n\nThe network becomes **idle** when there are **no** messages passing between servers or arriving at servers.\n\nReturn _the **earliest second** starting from which the network becomes **idle**_.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\]\\], patience = \\[0,2,1\\]\n**Output:** 8\n**Explanation:**\nAt (the beginning of) second 0,\n- Data server 1 sends its message (denoted 1A) to the master server.\n- Data server 2 sends its message (denoted 2A) to the master server.\n\nAt second 1,\n- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n- Server 1 has not received any reply. 1 second (1 < patience\\[1\\] = 2) elapsed since this server has sent the message, therefore it does not resend the message.\n- Server 2 has not received any reply. 1 second (1 == patience\\[2\\] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).\n\nAt second 2,\n- The reply 1A arrives at server 1. No more resending will occur from server 1.\n- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n- Server 2 resends the message (denoted 2C).\n...\nAt second 4,\n- The reply 2A arrives at server 2. No more resending will occur from server 2.\n...\nAt second 7, reply 2D arrives at server 2.\n\nStarting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.\nThis is the time when the network becomes idle.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\],\\[0,2\\],\\[1,2\\]\\], patience = \\[0,10,10\\]\n**Output:** 3\n**Explanation:** Data servers 1 and 2 receive a reply back at the beginning of second 2.\nFrom the beginning of the second 3, the network becomes idle.\n\n**Constraints:**\n\n*   `n == patience.length`\n*   `2 <= n <= 105`\n*   `patience[0] == 0`\n*   `1 <= patience[i] <= 105` for `1 <= i < n`\n*   `1 <= edges.length <= min(105, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `0 <= ui, vi < n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each server can directly or indirectly reach another server.\"\"\"\n\n    n = len(num)\n    sum1, sum2, cnt1, cnt2 = 0, 0, 0, 0\n\n    for i in range(n // 2):\n        if num[i] == '?': cnt1 += 1\n        else: sum1 += int(num[i])\n\n    for i in range(n // 2, n):\n        if num[i] == '?': cnt2 += 1\n        else: sum2 += int(num[i])\n\n    return (sum1 - sum2) != ((cnt2 - cnt1) // 2) * 9"}}, "leetcode/leetcode_1824.txt": {"score": 0.9387187361717224, "content": {"text": "import heapq\n    \"\"\"There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** lane and wants to jump to point `n`. However, there could be obstacles along the way.\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n*   For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n*   For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn _the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n**Example 1:**\n\n**Input:** obstacles = \\[0,1,2,3,0\\]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n**Example 2:**\n\n**Input:** obstacles = \\[0,1,1,3,3,0\\]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n**Example 3:**\n\n**Input:** obstacles = \\[0,2,1,0,3,0\\]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n**Constraints:**\n\n*   `obstacles.length == n + 1`\n*   `1 <= n <= 5 * 105`\n*   `0 <= obstacles[i] <= 3`\n*   `obstacles[0] == obstacles[n] == 0`\"\"\"\n\n\ndef eatenApples(apples, days):\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans"}}, "leetcode/leetcode_2359.txt": {"score": 0.938214898109436, "content": {"text": "def get_index_with_min_max_distance(edges, node1, node2):\n    \"\"\"You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from `i`, then `edges[i] == -1`.\n\nYou are also given two integers `node1` and `node2`.\n\nReturn _the **index** of the node that can be reached from both_ `node1` _and_ `node2`_, such that the **maximum** between the distance from_ `node1` _to that node, and from_ `node2` _to that node is **minimized**_. If there are multiple answers, return the node with the **smallest** index, and if no possible answer exists, return `-1`.\n\nNote that `edges` may contain cycles.\n\n**Example 1:**\n\n**Input:** edges = \\[2,2,3,-1\\], node1 = 0, node2 = 1\n**Output:** 2\n**Explanation:** The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n\n**Example 2:**\n\n**Input:** edges = \\[1,2,-1\\], node1 = 0, node2 = 2\n**Output:** 2\n**Explanation:** The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n\n**Constraints:**\n\n*   `n == edges.length`\n*   `2 <= n <= 105`\n*   `-1 <= edges[i] < n`\n*   `edges[i] != i`\n*   `0 <= node1, node2 < n`\"\"\"\n\n    dist1 = [-1] * len(edges)\n    dist2 = [-1] * len(edges)\n\n    dist1[node1] = 0\n    dist2[node2] = 0\n    for i in range(len(edges)):\n        if dist1[i] != -1 and edges[i] != -1:\n            if dist1[edges[i]] == -1:\n                dist1[edges[i]] = dist1[i] + 1\n            else:\n                dist1[edges[i]] = min(dist1[edges[i]], dist1[i] + 1)\n\n        if dist2[i] != -1 and edges[i] != -1:\n            if dist2[edges[i]] == -1:\n                dist2[edges[i]] = dist2[i] + 1\n            else:\n                dist2[edges[i]] = min(dist2[edges[i]], dist2[i] + 1)\n\n    ans = -1\n    min_max_dist = float(\"inf\")\n    for i in range(len(edges)):\n        if dist1[i] != -1 and dist2[i] != -1:\n            max_dist = max(dist1[i], dist2[i])\n            if max_dist < min_max_dist:\n                min_max_dist = max_dist\n                ans = i\n\n    return ans"}}, "leetcode/leetcode_1129.txt": {"score": 0.936210036277771, "content": {"text": "def longestStrChain(words):\n    \"\"\"You are given an integer `n`, the number of nodes in a directed graph where the nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n\nYou are given two arrays `redEdges` and `blueEdges` where:\n\n*   `redEdges[i] = [ai, bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph, and\n*   `blueEdges[j] = [uj, vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.\n\nReturn an array `answer` of length `n`, where each `answer[x]` is the length of the shortest path from node `0` to node `x` such that the edge colors alternate along the path, or `-1` if such a path does not exist.\n\n**Example 1:**\n\n**Input:** n = 3, redEdges = \\[\\[0,1\\],\\[1,2\\]\\], blueEdges = \\[\\]\n**Output:** \\[0,1,-1\\]\n\n**Example 2:**\n\n**Input:** n = 3, redEdges = \\[\\[0,1\\]\\], blueEdges = \\[\\[2,1\\]\\]\n**Output:** \\[0,1,-1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= redEdges.length, blueEdges.length <= 400`\n*   `redEdges[i].length == blueEdges[j].length == 2`\n*   `0 <= ai, bi, uj, vj < n`\"\"\"\n\n    words.sort(key=lambda x: len(x))\n    dp = {}\n\n    max_len = 0\n    for word in words:\n        for i in range(len(word)):\n            pre = word[:i] + word[i + 1:]\n            dp[word] = max(dp.get(word, 0), dp.get(pre, 0) + 1)\n        max_len = max(max_len, dp[word])\n\n    return max_len"}}, "leetcode/leetcode_2050.txt": {"score": 0.9619136452674866, "content": {"text": "def count_good_digit_strings(n):\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.\"\"\"\n\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total"}}, "leetcode/leetcode_2477.txt": {"score": 0.9441571831703186, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of `n` cities numbered from `0` to `n - 1` and exactly `n - 1` roads. The capital city is city `0`. You are given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a **bidirectional road** connecting cities `ai` and `bi`.\n\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\n\nThere is a car in each city. You are given an integer `seats` that indicates the number of seats in each car.\n\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\n\nReturn _the minimum number of liters of fuel to reach the capital city_.\n\n**Example 1:**\n\n**Input:** roads = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\]\\], seats = 5\n**Output:** 3\n**Explanation:** \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\n**Example 2:**\n\n**Input:** roads = \\[\\[3,1\\],\\[3,2\\],\\[1,0\\],\\[0,4\\],\\[0,5\\],\\[4,6\\]\\], seats = 2\n**Output:** 7\n**Explanation:** \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\n**Example 3:**\n\n**Input:** roads = \\[\\], seats = 1\n**Output:** 0\n**Explanation:** No representatives need to travel to the capital city.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `roads.length == n - 1`\n*   `roads[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `roads` represents a valid tree.\n*   `1 <= seats <= 105`\"\"\"\n\n\n\ndef min_fuel(roads, seats):\n    n = len(roads) + 1\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n\n    distance = [-1] * n\n    q = deque([0])\n    distance[0] = 0\n\n    while q:\n        city = q.popleft()\n        for neighbor in graph[city]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[city] + 1\n                q.append(neighbor)\n\n    total_fuel = 0\n    for city in range(1, n):\n        total_fuel += (distance[city] - 1) // (seats - 1) + 1\n    return total_fuel"}}, "leetcode/leetcode_2045.txt": {"score": 0.9955175518989563, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"A city is represented as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from **green** to **red** and vice versa every `change` minutes. All signals change **at the same time**. You can enter a vertex at **any time**, but can leave a vertex **only when the signal is green**. You **cannot wait** at a vertex if the signal is **green**.\n\nThe **second minimum value** is defined as the smallest value **strictly larger** than the minimum value.\n\n*   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return _the **second minimum time** it will take to go from vertex_ `1` _to vertex_ `n`.\n\n**Notes:**\n\n*   You can go through any vertex **any** number of times, **including** `1` and `n`.\n*   You can assume that when the journey **starts**, all signals have just turned **green**.\n\n**Example 1:**\n\n\u2003 \u2003 \u2003 \u2003\n\n**Input:** n = 5, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[3,4\\],\\[4,5\\]\\], time = 3, change = 5\n**Output:** 13\n**Explanation:**\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\], time = 3, change = 2\n**Output:** 11\n**Explanation:**\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n**Constraints:**\n\n*   `2 <= n <= 104`\n*   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each vertex can be reached directly or indirectly from every other vertex.\n*   `1 <= time, change <= 103`\"\"\"\n\n\ndef secondMinimum(n, edges, time, change):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dist = [float('inf')] * (n + 1)\n    dist2 = [float('inf')] * (n + 1)\n    dist[1] = 0\n\n    q = deque([1])\n\n    while q:\n        cur = q.popleft()\n\n        nextDist = dist[cur] + time\n        waitTime = change if (nextDist // change) % 2 == 1 else 0\n        nextDist += waitTime\n\n        for next in graph[cur]:\n            if nextDist < dist[next]:\n                nextDist, dist[next] = dist[next], nextDist\n                q.append(next)\n            if nextDist < dist2[next]:\n                nextDist, dist2[next] = dist2[next], nextDist\n                q.append(next)\n\n    return dist2[n]"}}, "leetcode/leetcode_2603.txt": {"score": 0.9452869892120361, "content": {"text": "from collections import defaultdict\n    \"\"\"There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef min_edges_to_collect_coins(coins, edges):\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(adj, coins, 0, -1)[1] // 2\n\ndef dfs(adj, coins, node, parent):\n    sum_coins = coins[node]\n    distance = 0\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            result = dfs(adj, coins, neighbor, node)\n            sum_coins += result[0]\n            distance += 2 * result[0] + result[1]\n    return (sum_coins, distance)"}}, "leetcode/leetcode_1494.txt": {"score": 0.9542019367218018, "content": {"text": "from collections import deque\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`.\n\nIn one semester, you can take **at most** `k` courses as long as you have taken all the prerequisites in the **previous** semesters for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course.\n\n**Example 1:**\n\n**Input:** n = 4, relations = \\[\\[2,1\\],\\[3,1\\],\\[1,4\\]\\], k = 2\n**Output:** 3\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[2,1\\],\\[3,1\\],\\[4,1\\],\\[1,5\\]\\], k = 2\n**Output:** 4\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5.\n\n**Constraints:**\n\n*   `1 <= n <= 15`\n*   `1 <= k <= n`\n*   `0 <= relations.length <= n * (n-1) / 2`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.\n*   The given graph is a directed acyclic graph.\"\"\"\n\n\ndef minNumberOfSemesters(n, relations, k):\n    indegree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev_course, next_course in relations:\n        graph[prev_course].append(next_course)\n        indegree[next_course] += 1\n\n    semesters = 0\n    while n > 0:\n        zero_indegree = deque()\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                zero_indegree.append(i)\n                indegree[i] = -1\n\n        courses = 0\n        while zero_indegree and courses < k:\n            curr_course = zero_indegree.popleft()\n            n -= 1\n\n            for next_course in graph[curr_course]:\n                indegree[next_course] -= 1\n            courses += 1\n        semesters += 1\n    return semesters"}}}}, "97": {"gold": {"leetcode/leetcode_834.txt": 1}, "retrieved": {"leetcode/leetcode_1938.txt": {"score": 0.908096969127655, "content": {"text": "def min_operations(nums):\n    \"\"\"There is a rooted tree consisting of `n` nodes numbered `0` to `n - 1`. Each node's number denotes its **unique genetic value** (i.e. the genetic value of node `x` is `x`). The **genetic difference** between two genetic values is defined as the **bitwise-****XOR** of their values. You are given the integer array `parents`, where `parents[i]` is the parent for node `i`. If node `x` is the **root** of the tree, then `parents[x] == -1`.\n\nYou are also given the array `queries` where `queries[i] = [nodei, vali]`. For each query `i`, find the **maximum genetic difference** between `vali` and `pi`, where `pi` is the genetic value of any node that is on the path between `nodei` and the root (including `nodei` and the root). More formally, you want to maximize `vali XOR pi`.\n\nReturn _an array_ `ans` _where_ `ans[i]` _is the answer to the_ `ith` _query_.\n\n**Example 1:**\n\n**Input:** parents = \\[-1,0,1,1\\], queries = \\[\\[0,2\\],\\[3,2\\],\\[2,5\\]\\]\n**Output:** \\[2,3,7\\]\n**Explanation:** The queries are processed as follows:\n- \\[0,2\\]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.\n- \\[3,2\\]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.\n- \\[2,5\\]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n\n**Example 2:**\n\n**Input:** parents = \\[3,7,-1,2,0,7,0,2\\], queries = \\[\\[4,6\\],\\[1,15\\],\\[0,5\\]\\]\n**Output:** \\[6,14,7\\]\n**Explanation:** The queries are processed as follows:\n- \\[4,6\\]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.\n- \\[1,15\\]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.\n- \\[0,5\\]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.\n\n**Constraints:**\n\n*   `2 <= parents.length <= 105`\n*   `0 <= parents[i] <= parents.length - 1` for every node `i` that is **not** the root.\n*   `parents[root] == -1`\n*   `1 <= queries.length <= 3 * 104`\n*   `0 <= nodei <= parents.length - 1`\n*   `0 <= vali <= 2 * 105`\"\"\"\n\n    operations = 0\n    for i in range(1, len(nums)):\n        if nums[i] <= nums[i - 1]:\n            operations += nums[i - 1] - nums[i] + 1\n            nums[i] = nums[i - 1] + 1\n    return operations"}}, "leetcode/leetcode_2322.txt": {"score": 0.9096276760101318, "content": {"text": "def dfs(node, parent, xor_values, tree):\n    \"\"\"There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nRemove two **distinct** edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n\n1.  Get the XOR of all the values of the nodes for **each** of the three components respectively.\n2.  The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair.\n\n*   For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = **6**`, `1 ^ 9 = **8**`, and `3 ^ 3 ^ 3 = **3**`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn _the **minimum** score of any possible pair of edge removals on the given tree_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,5,4,11\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\]\n**Output:** 9\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[1,3,4\\] with values \\[5,4,11\\]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2nd component has node \\[0\\] with value \\[1\\]. Its XOR value is 1 = 1.\n- The 3rd component has node \\[2\\] with value \\[5\\]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9.\n\n**Example 2:**\n\n**Input:** nums = \\[5,5,2,4,4,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[5,2\\],\\[4,3\\],\\[1,3\\]\\]\n**Output:** 0\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[3,4\\] with values \\[4,4\\]. Its XOR value is 4 ^ 4 = 0.\n- The 2nd component has nodes \\[1,0\\] with values \\[5,5\\]. Its XOR value is 5 ^ 5 = 0.\n- The 3rd component has nodes \\[2,5\\] with values \\[2,2\\]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `3 <= n <= 1000`\n*   `1 <= nums[i] <= 108`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n    xor_value = xor_values[node]\n    for child in tree[node]:\n        if child != parent:\n            xor_value ^= dfs(child, node, xor_values, tree)\n    return xor_value\n\n\ndef minimumScore(nums, edges):\n    n = len(nums)\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]\n    \n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor1 = xor_values[i]\n            xor2 = xor_values[j] ^ nums[i]\n            xor3 = nums[i] ^ nums[j]\n            max_xor = max(xor1, xor2, xor3)\n            min_xor = min(xor1, xor2, xor3)\n            ans = min(ans, max_xor - min_xor)\n    \n    return ans"}}, "leetcode/leetcode_1130.txt": {"score": 0.9085133075714111, "content": {"text": "import heapq\n    \"\"\"Given an array `arr` of positive integers, consider all binary trees such that:\n\n*   Each node has either `0` or `2` children;\n*   The values of `arr` correspond to the values of each **leaf** in an in-order traversal of the tree.\n*   The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n\nAmong all possible binary trees considered, return _the smallest possible sum of the values of each non-leaf node_. It is guaranteed this sum fits into a **32-bit** integer.\n\nA node is a **leaf** if and only if it has zero children.\n\n**Example 1:**\n\n**Input:** arr = \\[6,2,4\\]\n**Output:** 32\n**Explanation:** There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n\n**Example 2:**\n\n**Input:** arr = \\[4,11\\]\n**Output:** 44\n\n**Constraints:**\n\n*   `2 <= arr.length <= 40`\n*   `1 <= arr[i] <= 15`\n*   It is guaranteed that the answer fits into a **32-bit** signed integer (i.e., it is less than 231).\"\"\"\n\n\ndef lastStoneWeight(stones):\n    stones = [-stone for stone in stones]\n    heapq.heapify(stones)\n    while len(stones) > 1:\n        y = -heapq.heappop(stones)\n        x = -heapq.heappop(stones)\n        if x != y:\n            heapq.heappush(stones, -(y - x))\n    return -stones[0] if stones else 0"}}, "leetcode/leetcode_1617.txt": {"score": 0.9105724096298218, "content": {"text": "def winnerSquareGame(n: int) -> bool:\n    \"\"\"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.\"\"\"\n\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]"}}, "leetcode/leetcode_1766.txt": {"score": 0.9157662391662598, "content": {"text": "from bisect import bisect_left\n    \"\"\"There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges. Each node has a value associated with it, and the **root** of the tree is node `0`.\n\nTo represent this tree, you are given an integer array `nums` and a 2D array `edges`. Each `nums[i]` represents the `ith` node's value, and each `edges[j] = [uj, vj]` represents an edge between nodes `uj` and `vj` in the tree.\n\nTwo values `x` and `y` are **coprime** if `gcd(x, y) == 1` where `gcd(x, y)` is the **greatest common divisor** of `x` and `y`.\n\nAn ancestor of a node `i` is any other node on the shortest path from node `i` to the **root**. A node is **not** considered an ancestor of itself.\n\nReturn _an array_ `ans` _of size_ `n`, _where_ `ans[i]` _is the closest ancestor to node_ `i` _such that_ `nums[i]` _and_ `nums[ans[i]]` are **coprime**, or `-1` _if there is no such ancestor_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,3,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[-1,0,0,1\\]\n**Explanation:** In the above figure, each node's value is in parentheses.\n- Node 0 has no coprime ancestors.\n- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).\n- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's\n  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.\n- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its\n  closest valid ancestor.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,10,2,3,6,15\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[2,6\\]\\]\n**Output:** \\[-1,0,-1,0,0,0,-1\\]\n\n**Constraints:**\n\n*   `nums.length == n`\n*   `1 <= nums[i] <= 50`\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[j].length == 2`\n*   `0 <= uj, vj < n`\n*   `uj != vj`\"\"\"\n\n\ndef minimum_mountain_removals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(n):\n        left[i] = bisect_left(left[:i], nums[i])\n        right[n - 1 - i] = bisect_left(right[n - i:], nums[n - 1 - i])\n\n    return n - max(left[i] + right[i] for i in range(1, n - 1)) - 1"}}, "leetcode/leetcode_2440.txt": {"score": 0.9286286234855652, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an undirected tree with `n` nodes labeled from `0` to `n - 1`.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nYou are allowed to **delete** some edges, splitting the tree into multiple connected components. Let the **value** of a component be the sum of **all** `nums[i]` for which node `i` is in the component.\n\nReturn _the **maximum** number of edges you can delete, such that every connected component in the tree has the same value._\n\n**Example 1:**\n\n**Input:** nums = \\[6,2,2,2,6\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\] \n**Output:** 2 \n**Explanation:** The above figure shows how we can delete the edges \\[0,1\\] and \\[3,4\\]. The created components are nodes \\[0\\], \\[1,2,3\\] and \\[4\\]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n\n**Example 2:**\n\n**Input:** nums = \\[2\\], edges = \\[\\]\n**Output:** 0\n**Explanation:** There are no edges to be deleted.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `nums.length == n`\n*   `1 <= nums[i] <= 50`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= edges[i][0], edges[i][1] <= n - 1`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef dfs(node, parent, nums, graph, total, result):\n    total_sum = nums[node]\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            total_sum += dfs(neighbor, node, nums, graph, total, result)\n    if total_sum == total // 2:\n        result.append(1)\n        return 0\n    return total_sum\n\ndef delete_edges_to_balance_tree(nums, edges):\n    n = len(nums)\n    graph = defaultdict(list)\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n\n    total = sum(nums)\n    if total % 2 != 0:\n        return 0  # It is impossible to split the tree fairly.\n\n    result = []\n    dfs(0, -1, nums, graph, total, result)\n    return len(result) - 1"}}, "leetcode/leetcode_508.txt": {"score": 0.9206739664077759, "content": {"text": "from collections import defaultdict\n    \"\"\"Given the `root` of a binary tree, return the most frequent **subtree sum**. If there is a tie, return all the values with the highest frequency in any order.\n\nThe **subtree sum** of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).\n\n**Example 1:**\n\n**Input:** root = \\[5,2,-3\\]\n**Output:** \\[2,-3,4\\]\n\n**Example 2:**\n\n**Input:** root = \\[5,2,-5\\]\n**Output:** \\[2\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`\"\"\"\n\n\ndef helper(node, counts):\n    if not node: return 0\n    val = node.val + helper(node.left, counts) + helper(node.right, counts)\n    counts[val] += 1\n    return val\n\ndef findFrequentTreeSum(root):\n    counts = defaultdict(int)\n    helper(root, counts)\n    max_count = max(counts.values(), default=0)\n    return [s for s, c in counts.items() if c == max_count]"}}, "leetcode/leetcode_1519.txt": {"score": 0.9305695295333862, "content": {"text": "def min_subsequence(nums):\n    \"\"\"You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` `edges`. The **root** of the tree is the node `0`, and each node of the tree has **a label** which is a lower-case character given in the string `labels` (i.e. The node with the number `i` has the label `labels[i]`).\n\nThe `edges` array is given on the form `edges[i] = [ai, bi]`, which means there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn _an array of size `n`_ where `ans[i]` is the number of nodes in the subtree of the `ith` node which have the same label as node `i`.\n\nA subtree of a tree `T` is the tree consisting of a node in `T` and all of its descendant nodes.\n\n**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,4\\],\\[1,5\\],\\[2,3\\],\\[2,6\\]\\], labels =  \"abaedcd \"\n**Output:** \\[2,1,1,1,1,1,1\\]\n**Explanation:** Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.\nNode 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).\n\n**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,3\\]\\], labels =  \"bbbb \"\n**Output:** \\[4,2,1,1\\]\n**Explanation:** The sub-tree of node 2 contains only node 2, so the answer is 1.\nThe sub-tree of node 3 contains only node 3, so the answer is 1.\nThe sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.\nThe sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.\n\n**Example 3:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[0,4\\]\\], labels =  \"aabab \"\n**Output:** \\[3,2,1,1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `labels.length == n`\n*   `labels` is consisting of only of lowercase English letters.\"\"\"\n\n    nums.sort(reverse=True)\n    total_sum, current_sum = sum(nums), 0\n    result = []\n    for num in nums:\n        current_sum += num\n        result.append(num)\n        if current_sum > total_sum - current_sum:\n            break\n    return result"}}, "leetcode/leetcode_2246.txt": {"score": 0.9142522811889648, "content": {"text": "def max_invites(favorite):\n    \"\"\"You are given a **tree** (i.e. a connected, undirected graph that has no cycles) **rooted** at node `0` consisting of `n` nodes numbered from `0` to `n - 1`. The tree is represented by a **0-indexed** array `parent` of size `n`, where `parent[i]` is the parent of node `i`. Since node `0` is the root, `parent[0] == -1`.\n\nYou are also given a string `s` of length `n`, where `s[i]` is the character assigned to node `i`.\n\nReturn _the length of the **longest path** in the tree such that no pair of **adjacent** nodes on the path have the same character assigned to them._\n\n**Example 1:**\n\n**Input:** parent = \\[-1,0,0,1,1,2\\], s =  \"abacbe \"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\nIt can be proven that there is no longer path that satisfies the conditions. \n\n**Example 2:**\n\n**Input:** parent = \\[-1,0,0,0\\], s =  \"aabc \"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.\n\n**Constraints:**\n\n*   `n == parent.length == s.length`\n*   `1 <= n <= 105`\n*   `0 <= parent[i] <= n - 1` for all `i >= 1`\n*   `parent[0] == -1`\n*   `parent` represents a valid tree.\n*   `s` consists of only lowercase English letters.\"\"\"\n\n    n = len(favorite)\n    dp = [0] * n\n    max_invites = 0\n\n    for i in range(n):\n        dp[i] = 2 if i == favorite[favorite[i]] else 1\n        max_invites = max(max_invites, dp[i])\n\n    return max_invites"}}, "leetcode/leetcode_2049.txt": {"score": 0.9937976002693176, "content": {"text": "def eliminate_monsters(dist, speed):\n    \"\"\"There is a **binary** tree rooted at `0` consisting of `n` nodes. The nodes are labeled from `0` to `n - 1`. You are given a **0-indexed** integer array `parents` representing the tree, where `parents[i]` is the parent of node `i`. Since node `0` is the root, `parents[0] == -1`.\n\nEach node has a **score**. To find the score of a node, consider if the node and the edges connected to it were **removed**. The tree would become one or more **non-empty** subtrees. The **size** of a subtree is the number of the nodes in it. The **score** of the node is the **product of the sizes** of all those subtrees.\n\nReturn _the **number** of nodes that have the **highest score**_.\n\n**Example 1:**\n\n**Input:** parents = \\[-1,2,0,2,0\\]\n**Output:** 3\n**Explanation:**\n- The score of node 0 is: 3 \\* 1 = 3\n- The score of node 1 is: 4 = 4\n- The score of node 2 is: 1 \\* 1 \\* 2 = 2\n- The score of node 3 is: 4 = 4\n- The score of node 4 is: 4 = 4\nThe highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.\n\n**Example 2:**\n\n**Input:** parents = \\[-1,2,0\\]\n**Output:** 2\n**Explanation:**\n- The score of node 0 is: 2 = 2\n- The score of node 1 is: 2 = 2\n- The score of node 2 is: 1 \\* 1 = 1\nThe highest score is 2, and two nodes (node 0 and node 1) have the highest score.\n\n**Constraints:**\n\n*   `n == parents.length`\n*   `2 <= n <= 105`\n*   `parents[0] == -1`\n*   `0 <= parents[i] <= n - 1` for `i != 0`\n*   `parents` represents a valid binary tree.\"\"\"\n\n    n = len(dist)\n    time_to_reach = sorted(dist[i] / speed[i] for i in range(n))\n    monsters_eliminated = 0\n    for time in time_to_reach:\n        if monsters_eliminated < time:\n            monsters_eliminated += 1\n    return monsters_eliminated"}}}}, "98": {"gold": {"leetcode/leetcode_630.txt": 1, "leetcode/leetcode_1834.txt": 1, "leetcode/leetcode_1882.txt": 1, "leetcode/leetcode_2127.txt": 1}, "retrieved": {"leetcode/leetcode_778.txt": {"score": 0.9245235919952393, "content": {"text": "import heapq\n    \"\"\"You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.\n\nThe rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nReturn _the least time until you can reach the bottom right square_ `(n - 1, n - 1)` _if you start at the top left square_ `(0, 0)`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2\\],\\[1,3\\]\\]\n**Output:** 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,2,3,4\\],\\[24,23,22,21,5\\],\\[12,13,14,15,16\\],\\[11,17,18,19,20\\],\\[10,9,8,7,6\\]\\]\n**Output:** 16\n**Explanation:** The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] < n2`\n*   Each value `grid[i][j]` is **unique**.\"\"\"\n\n\ndef rearrange_string(s):\n    counts = {}\n    for c in s:\n        counts[c] = counts.get(c, 0) + 1\n    \n    pq = [(-count, char) for char, count in counts.items()]\n    heapq.heapify(pq)\n    \n    result = []\n    previous = (0, '')\n    \n    while pq:\n        count, char = heapq.heappop(pq)\n        result.append(char)\n        \n        if previous[0] < 0:\n            heapq.heappush(pq, previous)\n        \n        count += 1\n        previous = (count, char)\n    \n    result_str = ''.join(result)\n    return result_str if len(result_str) == len(s) else \"\""}}, "leetcode/csn_python_train_310730.txt": {"score": 0.92549067735672, "content": {"text": "def breadth(CIJ, source):\n    '''\n    Implementation of breadth-first search.\n\n    Parameters\n    ----------\n    CIJ : NxN np.ndarray\n        binary directed/undirected connection matrix\n    source : int\n        source vertex\n\n    Returns\n    -------\n    distance : Nx1 np.ndarray\n        vector of distances between source and ith vertex (0 for source)\n    branch : Nx1 np.ndarray\n        vertex that precedes i in the breadth-first search (-1 for source)\n\n    Notes\n    -----\n    Breadth-first search tree does not contain all paths (or all\n    shortest paths), but allows the determination of at least one path with\n    minimum distance. The entire graph is explored, starting from source\n    vertex 'source'.\n    '''\n    n = len(CIJ)\n\n    # colors: white,gray,black\n    white = 0\n    gray = 1\n    black = 2\n\n    color = np.zeros((n,))\n    distance = np.inf * np.ones((n,))\n    branch = np.zeros((n,))\n\n    # start on vertex source\n    color[source] = gray\n    distance[source] = 0\n    branch[source] = -1\n    Q = [source]\n\n    # keep going until the entire graph is explored\n    while Q:\n        u = Q[0]\n        ns, = np.where(CIJ[u, :])\n        for v in ns:\n            # this allows the source distance itself to be recorded\n            if distance[v] == 0:\n                distance[v] = distance[u] + 1\n            if color[v] == white:\n                color[v] = gray\n                distance[v] = distance[u] + 1\n                branch[v] = u\n                Q.append(v)\n        Q = Q[1:]\n        color[u] = black\n\n    return distance, branch"}}, "leetcode/leetcode_2603.txt": {"score": 0.9417218565940857, "content": {"text": "from collections import defaultdict\n    \"\"\"There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef min_edges_to_collect_coins(coins, edges):\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(adj, coins, 0, -1)[1] // 2\n\ndef dfs(adj, coins, node, parent):\n    sum_coins = coins[node]\n    distance = 0\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            result = dfs(adj, coins, neighbor, node)\n            sum_coins += result[0]\n            distance += 2 * result[0] + result[1]\n    return (sum_coins, distance)"}}, "leetcode/csn_python_train_320923.txt": {"score": 0.9372143745422363, "content": {"text": "def bfs(graph, start=0):\n    \"\"\"Shortest path in unweighted graph by BFS\n\n       :param graph: directed graph in listlist or listdict format\n       :param int start: source vertex\n       :returns: distance table, precedence table\n       :complexity: `O(|V|+|E|)`\n       \"\"\"\n    to_visit = deque()\n    dist = [float('inf')] * len(graph)\n    prec = [None] * len(graph)\n    dist[start] = 0\n    to_visit.appendleft(start)\n    while to_visit:              # an empty queue is considered False\n        node = to_visit.pop()\n        for neighbor in graph[node]:\n            if dist[neighbor] == float('inf'):\n                dist[neighbor] = dist[node] + 1\n                prec[neighbor] = node\n                to_visit.appendleft(neighbor)\n    return dist, prec"}}, "leetcode/leetcode_1557.txt": {"score": 0.9294161796569824, "content": {"text": "def has_all_codes(s, k):\n    \"\"\"Given a **directed acyclic graph**, with `n` vertices numbered from `0` to `n-1`, and an array `edges` where `edges[i] = [fromi, toi]` represents a directed edge from node `fromi` to node `toi`.\n\nFind _the smallest set of vertices from which all nodes in the graph are reachable_. It's guaranteed that a unique solution exists.\n\nNotice that you can return the vertices in any order.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,5\\],\\[3,4\\],\\[4,2\\]\\]\n**Output:** \\[0,3\\]\n**Explanation:** It's not possible to reach all the nodes from a single vertex. From 0 we can reach \\[0,1,2,5\\]. From 3 we can reach \\[3,4,2,5\\]. So we output \\[0,3\\].\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[2,1\\],\\[3,1\\],\\[1,4\\],\\[2,4\\]\\]\n**Output:** \\[0,2,3\\]\n**Explanation:** Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.\n\n**Constraints:**\n\n*   `2 <= n <= 10^5`\n*   `1 <= edges.length <= min(10^5, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `0 <= fromi, toi < n`\n*   All pairs `(fromi, toi)` are distinct.\"\"\"\n\n    need = 1 << k\n    got = set()\n    \n    for i in range(len(s) - k + 1):\n        got.add(s[i:i + k])\n    \n    return len(got) == need"}}, "leetcode/leetcode_1494.txt": {"score": 0.973946750164032, "content": {"text": "from collections import deque\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`.\n\nIn one semester, you can take **at most** `k` courses as long as you have taken all the prerequisites in the **previous** semesters for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course.\n\n**Example 1:**\n\n**Input:** n = 4, relations = \\[\\[2,1\\],\\[3,1\\],\\[1,4\\]\\], k = 2\n**Output:** 3\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[2,1\\],\\[3,1\\],\\[4,1\\],\\[1,5\\]\\], k = 2\n**Output:** 4\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5.\n\n**Constraints:**\n\n*   `1 <= n <= 15`\n*   `1 <= k <= n`\n*   `0 <= relations.length <= n * (n-1) / 2`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.\n*   The given graph is a directed acyclic graph.\"\"\"\n\n\ndef minNumberOfSemesters(n, relations, k):\n    indegree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev_course, next_course in relations:\n        graph[prev_course].append(next_course)\n        indegree[next_course] += 1\n\n    semesters = 0\n    while n > 0:\n        zero_indegree = deque()\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                zero_indegree.append(i)\n                indegree[i] = -1\n\n        courses = 0\n        while zero_indegree and courses < k:\n            curr_course = zero_indegree.popleft()\n            n -= 1\n\n            for next_course in graph[curr_course]:\n                indegree[next_course] -= 1\n            courses += 1\n        semesters += 1\n    return semesters"}}, "leetcode/leetcode_2477.txt": {"score": 0.9500012993812561, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of `n` cities numbered from `0` to `n - 1` and exactly `n - 1` roads. The capital city is city `0`. You are given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a **bidirectional road** connecting cities `ai` and `bi`.\n\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\n\nThere is a car in each city. You are given an integer `seats` that indicates the number of seats in each car.\n\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\n\nReturn _the minimum number of liters of fuel to reach the capital city_.\n\n**Example 1:**\n\n**Input:** roads = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\]\\], seats = 5\n**Output:** 3\n**Explanation:** \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\n**Example 2:**\n\n**Input:** roads = \\[\\[3,1\\],\\[3,2\\],\\[1,0\\],\\[0,4\\],\\[0,5\\],\\[4,6\\]\\], seats = 2\n**Output:** 7\n**Explanation:** \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\n**Example 3:**\n\n**Input:** roads = \\[\\], seats = 1\n**Output:** 0\n**Explanation:** No representatives need to travel to the capital city.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `roads.length == n - 1`\n*   `roads[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `roads` represents a valid tree.\n*   `1 <= seats <= 105`\"\"\"\n\n\n\ndef min_fuel(roads, seats):\n    n = len(roads) + 1\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n\n    distance = [-1] * n\n    q = deque([0])\n    distance[0] = 0\n\n    while q:\n        city = q.popleft()\n        for neighbor in graph[city]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[city] + 1\n                q.append(neighbor)\n\n    total_fuel = 0\n    for city in range(1, n):\n        total_fuel += (distance[city] - 1) // (seats - 1) + 1\n    return total_fuel"}}, "leetcode/leetcode_2050.txt": {"score": 0.9912578463554382, "content": {"text": "def count_good_digit_strings(n):\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.\"\"\"\n\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total"}}, "leetcode/leetcode_2192.txt": {"score": 0.9540944695472717, "content": {"text": "def min_cost(grid, start_pos, home_pos, row_costs, col_costs):\n    \"\"\"You are given a positive integer `n` representing the number of nodes of a **Directed Acyclic Graph** (DAG). The nodes are numbered from `0` to `n - 1` (**inclusive**).\n\nYou are also given a 2D integer array `edges`, where `edges[i] = [fromi, toi]` denotes that there is a **unidirectional** edge from `fromi` to `toi` in the graph.\n\nReturn _a list_ `answer`_, where_ `answer[i]` _is the **list of ancestors** of the_ `ith` _node, sorted in **ascending order**_.\n\nA node `u` is an **ancestor** of another node `v` if `u` can reach `v` via a set of edges.\n\n**Example 1:**\n\n**Input:** n = 8, edgeList = \\[\\[0,3\\],\\[0,4\\],\\[1,3\\],\\[2,4\\],\\[2,7\\],\\[3,5\\],\\[3,6\\],\\[3,7\\],\\[4,6\\]\\]\n**Output:** \\[\\[\\],\\[\\],\\[\\],\\[0,1\\],\\[0,2\\],\\[0,1,3\\],\\[0,1,2,3,4\\],\\[0,1,2,3\\]\\]\n**Explanation:**\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.\n\n**Example 2:**\n\n**Input:** n = 5, edgeList = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\],\\[0,4\\],\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[2,3\\],\\[2,4\\],\\[3,4\\]\\]\n**Output:** \\[\\[\\],\\[0\\],\\[0,1\\],\\[0,1,2\\],\\[0,1,2,3\\]\\]\n**Explanation:**\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= edges.length <= min(2000, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `0 <= fromi, toi <= n - 1`\n*   `fromi != toi`\n*   There are no duplicate edges.\n*   The graph is **directed** and **acyclic**.\"\"\"\n\n    return abs(row_costs[start_pos[0]] - row_costs[home_pos[0]]) + abs(col_costs[start_pos[1]] - col_costs[home_pos[1]])"}}, "leetcode/leetcode_2045.txt": {"score": 0.9652097225189209, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"A city is represented as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from **green** to **red** and vice versa every `change` minutes. All signals change **at the same time**. You can enter a vertex at **any time**, but can leave a vertex **only when the signal is green**. You **cannot wait** at a vertex if the signal is **green**.\n\nThe **second minimum value** is defined as the smallest value **strictly larger** than the minimum value.\n\n*   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return _the **second minimum time** it will take to go from vertex_ `1` _to vertex_ `n`.\n\n**Notes:**\n\n*   You can go through any vertex **any** number of times, **including** `1` and `n`.\n*   You can assume that when the journey **starts**, all signals have just turned **green**.\n\n**Example 1:**\n\n\u2003 \u2003 \u2003 \u2003\n\n**Input:** n = 5, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[3,4\\],\\[4,5\\]\\], time = 3, change = 5\n**Output:** 13\n**Explanation:**\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\], time = 3, change = 2\n**Output:** 11\n**Explanation:**\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n**Constraints:**\n\n*   `2 <= n <= 104`\n*   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each vertex can be reached directly or indirectly from every other vertex.\n*   `1 <= time, change <= 103`\"\"\"\n\n\ndef secondMinimum(n, edges, time, change):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dist = [float('inf')] * (n + 1)\n    dist2 = [float('inf')] * (n + 1)\n    dist[1] = 0\n\n    q = deque([1])\n\n    while q:\n        cur = q.popleft()\n\n        nextDist = dist[cur] + time\n        waitTime = change if (nextDist // change) % 2 == 1 else 0\n        nextDist += waitTime\n\n        for next in graph[cur]:\n            if nextDist < dist[next]:\n                nextDist, dist[next] = dist[next], nextDist\n                q.append(next)\n            if nextDist < dist2[next]:\n                nextDist, dist2[next] = dist2[next], nextDist\n                q.append(next)\n\n    return dist2[n]"}}}}, "99": {"gold": {"leetcode/leetcode_2105.txt": 1}, "retrieved": {"leetcode/leetcode_2244.txt": {"score": 0.9304776191711426, "content": {"text": "def numOfBeams(bank):\n    \"\"\"You are given a **0-indexed** integer array `tasks`, where `tasks[i]` represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the **same difficulty level**.\n\nReturn _the **minimum** rounds required to complete all the tasks, or_ `-1` _if it is not possible to complete all the tasks._\n\n**Example 1:**\n\n**Input:** tasks = \\[2,2,3,3,2,4,4,4,4,4\\]\n**Output:** 4\n**Explanation:** To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2. \n- In the second round, you complete 2 tasks of difficulty level 3. \n- In the third round, you complete 3 tasks of difficulty level 4. \n- In the fourth round, you complete 2 tasks of difficulty level 4.  \nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n\n**Example 2:**\n\n**Input:** tasks = \\[2,3,3\\]\n**Output:** -1\n**Explanation:** There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= tasks[i] <= 109`\"\"\"\n\n    m = len(bank)\n    n = len(bank[0])\n    beams = 0\n\n    for i in range(m):\n        for j in range(n):\n            if bank[i][j] == '1':\n                k = j + 1\n                while k < n and bank[i][k] != '1':\n                    beams += bank[i][k] == '0'\n                    k += 1\n                k = i + 1\n                while k < m and bank[k][j] != '1':\n                    beams += bank[k][j] == '0'\n                    k += 1\n\n    return beams"}}, "leetcode/leetcode_2335.txt": {"score": 0.9319700598716736, "content": {"text": "def min_seconds(amount: List[int]) -> int:\n    \"\"\"You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up `2` cups with **different** types of water, or `1` cup of any type of water.\n\nYou are given a **0-indexed** integer array `amount` of length `3` where `amount[0]`, `amount[1]`, and `amount[2]` denote the number of cold, warm, and hot water cups you need to fill respectively. Return _the **minimum** number of seconds needed to fill up all the cups_.\n\n**Example 1:**\n\n**Input:** amount = \\[1,4,2\\]\n**Output:** 4\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.\n\n**Example 2:**\n\n**Input:** amount = \\[5,4,4\\]\n**Output:** 7\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.\n\n**Example 3:**\n\n**Input:** amount = \\[5,0,0\\]\n**Output:** 5\n**Explanation:** Every second, we fill up a cold cup.\n\n**Constraints:**\n\n*   `amount.length == 3`\n*   `0 <= amount[i] <= 100`\"\"\"\n\n    total = sum(amount)\n    largest_two = max(amount[0] + amount[1], amount[1] + amount[2], amount[0] + amount[2])\n    return (total + 1) // 2 - (largest_two + 1) // 2 + largest_two"}}, "leetcode/leetcode_2383.txt": {"score": 0.9357216358184814, "content": {"text": "def min_training_hours(initial_energy, initial_experience, energy, experience):\n    \"\"\"You are entering a competition, and are given two **positive** integers `initialEnergy` and `initialExperience` denoting your initial energy and initial experience respectively.\n\nYou are also given two **0-indexed** integer arrays `energy` and `experience`, both of length `n`.\n\nYou will face `n` opponents **in order**. The energy and experience of the `ith` opponent is denoted by `energy[i]` and `experience[i]` respectively. When you face an opponent, you need to have both **strictly** greater experience and energy to defeat them and move to the next opponent if available.\n\nDefeating the `ith` opponent **increases** your experience by `experience[i]`, but **decreases** your energy by `energy[i]`.\n\nBefore starting the competition, you can train for some number of hours. After each hour of training, you can **either** choose to increase your initial experience by one, or increase your initial energy by one.\n\nReturn _the **minimum** number of training hours required to defeat all_ `n` _opponents_.\n\n**Example 1:**\n\n**Input:** initialEnergy = 5, initialExperience = 3, energy = \\[1,4,3,2\\], experience = \\[2,6,3,1\\]\n**Output:** 8\n**Explanation:** You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0th opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1st opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2nd opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3rd opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists.\n\n**Example 2:**\n\n**Input:** initialEnergy = 2, initialExperience = 4, energy = \\[1\\], experience = \\[3\\]\n**Output:** 0\n**Explanation:** You do not need any additional energy or experience to win the competition, so we return 0.\n\n**Constraints:**\n\n*   `n == energy.length == experience.length`\n*   `1 <= n <= 100`\n*   `1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100`\"\"\"\n\n    n = len(energy)\n    ans = int(1e9)\n    for exp_gain in range(initial_energy + initial_experience + 1):\n        training_hours = exp_gain\n        energy_left = initial_energy - exp_gain\n        curr_experience = initial_experience + exp_gain\n        \n        for i in range(n):\n            while curr_experience <= experience[i] or energy_left <= energy[i]:\n                energy_left -= 1\n                training_hours += 1\n            energy_left -= energy[i]\n            curr_experience += experience[i]\n        ans = min(ans, training_hours)\n    return ans"}}, "leetcode/leetcode_1665.txt": {"score": 0.934565544128418, "content": {"text": "def minimumEffort(tasks):\n    \"\"\"You are given an array `tasks` where `tasks[i] = [actuali, minimumi]`:\n\n*   `actuali` is the actual amount of energy you **spend to finish** the `ith` task.\n*   `minimumi` is the minimum amount of energy you **require to begin** the `ith` task.\n\nFor example, if the task is `[10, 12]` and your current energy is `11`, you cannot start this task. However, if your current energy is `13`, you can complete this task, and your energy will be `3` after finishing it.\n\nYou can finish the tasks in **any order** you like.\n\nReturn _the **minimum** initial amount of energy you will need_ _to finish all the tasks_.\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[4,8\\]\\]\n**Output:** 8\n**Explanation:**\nStarting with 8 energy, we finish the tasks in the following order:\n    - 3rd task. Now energy = 8 - 4 = 4.\n    - 2nd task. Now energy = 4 - 2 = 2.\n    - 1st task. Now energy = 2 - 1 = 1.\nNotice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[1,3\\],\\[2,4\\],\\[10,11\\],\\[10,12\\],\\[8,9\\]\\]\n**Output:** 32\n**Explanation:**\nStarting with 32 energy, we finish the tasks in the following order:\n    - 1st task. Now energy = 32 - 1 = 31.\n    - 2nd task. Now energy = 31 - 2 = 29.\n    - 3rd task. Now energy = 29 - 10 = 19.\n    - 4th task. Now energy = 19 - 10 = 9.\n    - 5th task. Now energy = 9 - 8 = 1.\n\n**Example 3:**\n\n**Input:** tasks = \\[\\[1,7\\],\\[2,8\\],\\[3,9\\],\\[4,10\\],\\[5,11\\],\\[6,12\\]\\]\n**Output:** 27\n**Explanation:**\nStarting with 27 energy, we finish the tasks in the following order:\n    - 5th task. Now energy = 27 - 5 = 22.\n    - 2nd task. Now energy = 22 - 2 = 20.\n    - 3rd task. Now energy = 20 - 3 = 17.\n    - 1st task. Now energy = 17 - 1 = 16.\n    - 4th task. Now energy = 16 - 4 = 12.\n    - 6th task. Now energy = 12 - 6 = 6.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= actual\u200bi <= minimumi <= 104`\"\"\"\n\n    tasks.sort(key=lambda task: task[1] - task[0], reverse=True)\n    ans, sum_energy = 0, 0\n    for task in tasks:\n        ans = max(ans, sum_energy + task[1])\n        sum_energy += task[0]\n    return ans"}}, "leetcode/leetcode_1642.txt": {"score": 0.94243323802948, "content": {"text": "def maxWaterBottles(numBottles: int, numExchange: int) -> int:\n    \"\"\"You are given an integer array `heights` representing the heights of buildings, some `bricks`, and some `ladders`.\n\nYou start your journey from building `0` and move to the next building by possibly using bricks or ladders.\n\nWhile moving from building `i` to building `i+1` (**0-indexed**),\n\n*   If the current building's height is **greater than or equal** to the next building's height, you do **not** need a ladder or bricks.\n*   If the current building's height is **less than** the next building's height, you can either use **one ladder** or `(h[i+1] - h[i])` **bricks**.\n\n_Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally._\n\n**Example 1:**\n\n**Input:** heights = \\[4,2,7,6,9,14,12\\], bricks = 5, ladders = 1\n**Output:** 4\n**Explanation:** Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n**Example 2:**\n\n**Input:** heights = \\[4,12,2,7,3,18,20,3,19\\], bricks = 10, ladders = 2\n**Output:** 7\n\n**Example 3:**\n\n**Input:** heights = \\[14,3,19,3\\], bricks = 17, ladders = 0\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `1 <= heights[i] <= 106`\n*   `0 <= bricks <= 109`\n*   `0 <= ladders <= heights.length`\"\"\"\n\n    total = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        total += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return total"}}, "leetcode/leetcode_871.txt": {"score": 0.9566706418991089, "content": {"text": "def can_visit_all_rooms(rooms):\n    \"\"\"A car travels from a starting position to a destination which is `target` miles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas.\n\nThe car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\nReturn _the minimum number of refueling stops the car must make in order to reach its destination_. If it cannot reach the destination, return `-1`.\n\nNote that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived.\n\n**Example 1:**\n\n**Input:** target = 1, startFuel = 1, stations = \\[\\]\n**Output:** 0\n**Explanation:** We can reach the target without refueling.\n\n**Example 2:**\n\n**Input:** target = 100, startFuel = 1, stations = \\[\\[10,100\\]\\]\n**Output:** -1\n**Explanation:** We can not reach the target (or even the first gas station).\n\n**Example 3:**\n\n**Input:** target = 100, startFuel = 10, stations = \\[\\[10,60\\],\\[20,30\\],\\[30,30\\],\\[60,40\\]\\]\n**Output:** 2\n**Explanation:** We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n\n**Constraints:**\n\n*   `1 <= target, startFuel <= 109`\n*   `0 <= stations.length <= 500`\n*   `1 <= positioni < positioni+1 < target`\n*   `1 <= fueli < 109`\"\"\"\n\n    visited = set()\n    stack = [0]\n\n    while stack:\n        current_room = stack.pop()\n\n        visited.add(current_room)\n\n        for key in rooms[current_room]:\n            if key not in visited:\n                stack.append(key)\n\n    return len(visited) == len(rooms)"}}, "leetcode/leetcode_1883.txt": {"score": 0.9357514977455139, "content": {"text": "def minSkips(dist, speed, hoursBefore):\n    \"\"\"You are given an integer `hoursBefore`, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through `n` roads. The road lengths are given as an integer array `dist` of length `n`, where `dist[i]` describes the length of the `ith` road in **kilometers**. In addition, you are given an integer `speed`, which is the speed (in **km/h**) you will travel at.\n\nAfter you travel road `i`, you must rest and wait for the **next integer hour** before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting.\n\n*   For example, if traveling a road takes `1.4` hours, you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours, you do not need to wait.\n\nHowever, you are allowed to **skip** some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks.\n\n*   For example, suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark, letting you start traveling the third road immediately.\n\nReturn _the **minimum number of skips required** to arrive at the meeting on time, or_ `-1` _if it is **impossible**_.\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,2\\], speed = 4, hoursBefore = 2\n**Output:** 1\n**Explanation:**\nWithout skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.\nYou can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.\nNote that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.\n\n**Example 2:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 2, hoursBefore = 10\n**Output:** 2\n**Explanation:**\nWithout skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.\nYou can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.\n\n**Example 3:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 1, hoursBefore = 10\n**Output:** -1\n**Explanation:** It is impossible to arrive at the meeting on time even if you skip all the rests.\n\n**Constraints:**\n\n*   `n == dist.length`\n*   `1 <= n <= 1000`\n*   `1 <= dist[i] <= 105`\n*   `1 <= speed <= 106`\n*   `1 <= hoursBefore <= 107`\"\"\"\n\n    n = len(dist)\n    dp = [[1e9] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for j in range(i+1):\n            t = dist[i] / speed + (1 if j else 0)\n            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)\n            skipped_t = -(-dist[i] / speed) - dp[i][j]\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)\n\n    for i in range(n + 1):\n        if dp[n][i] <= hoursBefore:\n            return i\n    return -1"}}, "leetcode/leetcode_2079.txt": {"score": 0.9887924790382385, "content": {"text": "from collections import defaultdict\n    \"\"\"You want to water `n` plants in your garden with a watering can. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`. There is a river at `x = -1` that you can refill your watering can at.\n\nEach plant needs a specific amount of water. You will water the plants in the following way:\n\n*   Water the plants in order from left to right.\n*   After watering the current plant, if you do not have enough water to **completely** water the next plant, return to the river to fully refill the watering can.\n*   You **cannot** refill the watering can early.\n\nYou are initially at the river (i.e., `x = -1`). It takes **one step** to move **one unit** on the x-axis.\n\nGiven a **0-indexed** integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and an integer `capacity` representing the watering can capacity, return _the **number of steps** needed to water all the plants_.\n\n**Example 1:**\n\n**Input:** plants = \\[2,2,3,3\\], capacity = 5\n**Output:** 14\n**Explanation:** Start at the river with a full watering can:\n- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.\n- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.\n- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).\n- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.\n- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).\n- Walk to plant 3 (4 steps) and water it.\nSteps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.\n\n**Example 2:**\n\n**Input:** plants = \\[1,1,1,4,2,3\\], capacity = 4\n**Output:** 30\n**Explanation:** Start at the river with a full watering can:\n- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).\n- Water plant 3 (4 steps). Return to river (4 steps).\n- Water plant 4 (5 steps). Return to river (5 steps).\n- Water plant 5 (6 steps).\nSteps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.\n\n**Example 3:**\n\n**Input:** plants = \\[7,7,7,7,7,7,7\\], capacity = 8\n**Output:** 49\n**Explanation:** You have to refill before watering each plant.\nSteps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.\n\n**Constraints:**\n\n*   `n == plants.length`\n*   `1 <= n <= 1000`\n*   `1 <= plants[i] <= 106`\n*   `max(plants[i]) <= capacity <= 109`\"\"\"\n\n\ndef deleteDuplicateFolder(paths):\n    graph = defaultdict(set)\n    count = defaultdict(int)\n\n    for path in paths:\n        serialized_path = \"\"\n        for folder in path:\n            serialized_path += \"/\" + folder\n            graph[serialized_path].add(folder)\n\n    for value in graph.values():\n        count[str(value)] += 1\n\n    ans = []\n    for path in paths:\n        serialized_path = \"\"\n        duplicate = False\n        for folder in path:\n            serialized_path += \"/\" + folder\n            if count[str(graph[serialized_path])] > 1:\n                duplicate = True\n                break\n        if not duplicate:\n            ans.append(path)\n\n    return ans"}}, "leetcode/leetcode_1687.txt": {"score": 0.9386085271835327, "content": {"text": "def min_trips(boxes, portsCount, maxBoxes, maxWeight):\n    \"\"\"You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a **limit** on the **number of boxes** and the **total weight** that it can carry.\n\nYou are given an array `boxes`, where `boxes[i] = [ports\u200b\u200bi\u200b, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.\n\n*   `ports\u200b\u200bi` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.\n*   `portsCount` is the number of ports.\n*   `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered **in the order they are given**. The ship will follow these steps:\n\n*   The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.\n*   For each loaded box **in order**, the ship will make a **trip** to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no **trip** is needed, and the box can immediately be delivered.\n*   The ship then makes a return **trip** to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\n\nReturn _the **minimum** number of **trips** the ship needs to make to deliver all boxes to their respective ports._\n\n**Example 1:**\n\n**Input:** boxes = \\[\\[1,1\\],\\[2,1\\],\\[1,1\\]\\], portsCount = 2, maxBoxes = 3, maxWeight = 3\n**Output:** 4\n**Explanation:** The optimal strategy is as follows: \n- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\nSo the total number of trips is 4.\nNote that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n\n**Example 2:**\n\n**Input:** boxes = \\[\\[1,2\\],\\[3,3\\],\\[3,1\\],\\[3,1\\],\\[2,4\\]\\], portsCount = 3, maxBoxes = 3, maxWeight = 6\n**Output:** 6\n**Explanation:** The optimal strategy is as follows: \n- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n**Example 3:**\n\n**Input:** boxes = \\[\\[1,4\\],\\[1,2\\],\\[2,1\\],\\[2,1\\],\\[3,2\\],\\[3,4\\]\\], portsCount = 3, maxBoxes = 6, maxWeight = 7\n**Output:** 6\n**Explanation:** The optimal strategy is as follows:\n- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n**Constraints:**\n\n*   `1 <= boxes.length <= 105`\n*   `1 <= portsCount, maxBoxes, maxWeight <= 105`\n*   `1 <= ports\u200b\u200bi <= portsCount`\n*   `1 <= weightsi <= maxWeight`\"\"\"\n\n    trips = 0\n    idx = 0\n    n = len(boxes)\n    while idx < n:\n        curr_limit = maxWeight\n        prev_port = 0\n        count = 0\n        while count < maxBoxes and idx < n:\n            if boxes[idx][1] <= curr_limit:\n                if prev_port != boxes[idx][0]:\n                    prev_port = boxes[idx][0]\n                    trips += 1\n                curr_limit -= boxes[idx][1]\n                count += 1\n                idx += 1\n            else:\n                break\n        trips += 1\n    return trips"}}, "leetcode/leetcode_1986.txt": {"score": 0.946956217288971, "content": {"text": "from collections import defaultdict\n    \"\"\"There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break.\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n*   If you start a task in a work session, you must complete it in the **same** work session.\n*   You can start a new task **immediately** after finishing the previous one.\n*   You may complete the tasks in **any order**.\n\nGiven `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._\n\nThe tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,3\\], sessionTime = 3\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n**Example 2:**\n\n**Input:** tasks = \\[3,1,3,1,1\\], sessionTime = 8\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n**Example 3:**\n\n**Input:** tasks = \\[1,2,3,4,5\\], sessionTime = 15\n**Output:** 1\n**Explanation:** You can finish all the tasks in one work session.\n\n**Constraints:**\n\n*   `n == tasks.length`\n*   `1 <= n <= 14`\n*   `1 <= tasks[i] <= 10`\n*   `max(tasks[i]) <= sessionTime <= 15`\"\"\"\n\n\n\ndef largestPathValue(colors, edges):\n    def dfs(node):\n        if not cache[node][ord(colors[node]) - ord('a')]:\n            cache[node][ord(colors[node]) - ord('a')] = 1\n            for neighbor in graph[node]:\n                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],\n                                                               1 + dfs(neighbor))\n        return cache[node][ord(colors[node]) - ord('a')]\n\n    n = len(colors)\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n\n    cache = [[0] * 26 for _ in range(n)]\n    in_degree = [0] * n\n    for a, b in edges:\n        in_degree[b] += 1\n    res = -1\n    for i in range(n):\n        if in_degree[i] == 0:\n            res = max(res, dfs(i))\n    return res"}}}}, "100": {"gold": {"leetcode/leetcode_665.txt": 1, "leetcode/leetcode_845.txt": 1, "leetcode/leetcode_1095.txt": 1, "leetcode/leetcode_1800.txt": 1, "leetcode/leetcode_2420.txt": 1}, "retrieved": {"leetcode/leetcode_1482.txt": {"score": 0.9147106409072876, "content": {"text": "def smallerNumbersThanCurrent(nums):\n    \"\"\"You are given an integer array `bloomDay`, an integer `m` and an integer `k`.\n\nYou want to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden.\n\nThe garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet.\n\nReturn _the minimum number of days you need to wait to be able to make_ `m` _bouquets from the garden_. If it is impossible to make m bouquets return `-1`.\n\n**Example 1:**\n\n**Input:** bloomDay = \\[1,10,3,10,2\\], m = 3, k = 1\n**Output:** 3\n**Explanation:** Let us see what happened in the first three days. x means flower bloomed and \\_ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: \\[x, \\_, \\_, \\_, \\_\\]   // we can only make one bouquet.\nAfter day 2: \\[x, \\_, \\_, \\_, x\\]   // we can only make two bouquets.\nAfter day 3: \\[x, \\_, x, \\_, x\\]   // we can make 3 bouquets. The answer is 3.\n\n**Example 2:**\n\n**Input:** bloomDay = \\[1,10,3,10,2\\], m = 3, k = 2\n**Output:** -1\n**Explanation:** We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n\n**Example 3:**\n\n**Input:** bloomDay = \\[7,7,7,7,12,7,7\\], m = 2, k = 3\n**Output:** 12\n**Explanation:** We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: \\[x, x, x, x, \\_, x, x\\]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: \\[x, x, x, x, x, x, x\\]\nIt is obvious that we can make two bouquets in different ways.\n\n**Constraints:**\n\n*   `bloomDay.length == n`\n*   `1 <= n <= 105`\n*   `1 <= bloomDay[i] <= 109`\n*   `1 <= m <= 106`\n*   `1 <= k <= n`\"\"\"\n\n    result = [0] * len(nums)\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if nums[j] < nums[i]:\n                result[i] += 1\n    return result"}}, "leetcode/leetcode_875.txt": {"score": 0.915939211845398, "content": {"text": "def longest_mountain(arr):\n    \"\"\"Koko loves to eat bananas. There are `n` piles of bananas, the `ith` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.\n\n**Example 1:**\n\n**Input:** piles = \\[3,6,7,11\\], h = 8\n**Output:** 4\n\n**Example 2:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 5\n**Output:** 30\n\n**Example 3:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 6\n**Output:** 23\n\n**Constraints:**\n\n*   `1 <= piles.length <= 104`\n*   `piles.length <= h <= 109`\n*   `1 <= piles[i] <= 109`\"\"\"\n\n    n = len(arr)\n    max_length = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            left = i - 1\n            right = i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] > arr[right + 1]:\n                right += 1\n            max_length = max(max_length, right - left + 1)\n            i = right\n        else:\n            i += 1\n    return max_length"}}, "leetcode/leetcode_2274.txt": {"score": 0.9243008494377136, "content": {"text": "def final_value(nums, original):\n    \"\"\"Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.\n\nYou are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.\n\nReturn _the **maximum** number of consecutive floors without a special floor_.\n\n**Example 1:**\n\n**Input:** bottom = 2, top = 9, special = \\[4,6\\]\n**Output:** 3\n**Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors.\n\n**Example 2:**\n\n**Input:** bottom = 6, top = 8, special = \\[7,6,8\\]\n**Output:** 0\n**Explanation:** Every floor rented is a special floor, so we return 0.\n\n**Constraints:**\n\n*   `1 <= special.length <= 105`\n*   `1 <= bottom <= special[i] <= top <= 109`\n*   All the values of `special` are **unique**.\"\"\"\n\n    while original in nums:\n        original += 1\n    return original"}}, "leetcode/leetcode_1802.txt": {"score": 0.9310964345932007, "content": {"text": "from collections import deque\n    \"\"\"You are given three positive integers: `n`, `index`, and `maxSum`. You want to construct an array `nums` (**0-indexed**) that satisfies the following conditions:\n\n*   `nums.length == n`\n*   `nums[i]` is a **positive** integer where `0 <= i < n`.\n*   `abs(nums[i] - nums[i+1]) <= 1` where `0 <= i < n-1`.\n*   The sum of all the elements of `nums` does not exceed `maxSum`.\n*   `nums[index]` is **maximized**.\n\nReturn `nums[index]` _of the constructed array_.\n\nNote that `abs(x)` equals `x` if `x >= 0`, and `-x` otherwise.\n\n**Example 1:**\n\n**Input:** n = 4, index = 2,  maxSum = 6\n**Output:** 2\n**Explanation:** nums = \\[1,2,**2**,1\\] is one array that satisfies all the conditions.\nThere are no arrays that satisfy all the conditions and have nums\\[2\\] == 3, so 2 is the maximum nums\\[2\\].\n\n**Example 2:**\n\n**Input:** n = 6, index = 1,  maxSum = 10\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= n <= maxSum <= 109`\n*   `0 <= index < n`\"\"\"\n\n\ndef countStudents(students, sandwiches):\n    queue = deque(students)\n    index, attempts = 0, 0\n\n    while queue:\n        student = queue[0]\n        if student == sandwiches[index]:\n            queue.popleft()\n            index += 1\n            attempts = 0\n        else:\n            queue.rotate(-1)\n            attempts += 1\n\n        if attempts == len(queue):\n            break\n\n    return len(queue)"}}, "leetcode/leetcode_2560.txt": {"score": 0.9185050129890442, "content": {"text": "def minimumCapability(nums, k):\n    \"\"\"There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he **refuses to steal from adjacent homes**.\n\nThe **capability** of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\n\nYou are given an integer array `nums` representing how much money is stashed in each house. More formally, the `ith` house from the left has `nums[i]` dollars.\n\nYou are also given an integer `k`, representing the **minimum** number of houses the robber will steal from. It is always possible to steal at least `k` houses.\n\nReturn _the **minimum** capability of the robber out of all the possible ways to steal at least_ `k` _houses_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,5,9\\], k = 2\n**Output:** 5\n**Explanation:** \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums\\[0\\], nums\\[2\\]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums\\[0\\], nums\\[3\\]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums\\[1\\], nums\\[3\\]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\], k = 2\n**Output:** 2\n**Explanation:** There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums\\[0\\], nums\\[4\\]) = 2.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `1 <= k <= (nums.length + 1)/2`\"\"\"\n\n    n, l, r = len(nums), 1, 10**9\n    while l < r:\n        mid = l + (r - l) // 2\n        i, cnt = 0, 0\n        for j in range(n):\n            if nums[j] <= mid:\n                cnt += 1\n                i = j + 2\n                while i + 1 < n and (i == j + 1 or nums[i] > mid):\n                    i += 1\n        if cnt < k:\n            l = mid + 1\n        else:\n            r = mid\n    return l"}}, "leetcode/leetcode_2210.txt": {"score": 0.9387850165367126, "content": {"text": "def sorted_target_indices(nums, target):\n    \"\"\"You are given a **0-indexed** integer array `nums`. An index `i` is part of a **hill** in `nums` if the closest non-equal neighbors of `i` are smaller than `nums[i]`. Similarly, an index `i` is part of a **valley** in `nums` if the closest non-equal neighbors of `i` are larger than `nums[i]`. Adjacent indices `i` and `j` are part of the **same** hill or valley if `nums[i] == nums[j]`.\n\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on **both** the left and right of the index.\n\nReturn _the number of hills and valleys in_ `nums`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,1,1,6,5\\]\n**Output:** 3\n**Explanation:**\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\n**Example 2:**\n\n**Input:** nums = \\[6,6,5,5,4,1\\]\n**Output:** 0\n**Explanation:**\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`\"\"\"\n\n    result = [i for i, num in enumerate(nums) if num == target]\n    return sorted(result)"}}, "leetcode/leetcode_2110.txt": {"score": 0.9309583902359009, "content": {"text": "def num_smooth_descent_periods(prices):\n    \"\"\"You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day.\n\nA **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule.\n\nReturn _the number of **smooth descent periods**_.\n\n**Example 1:**\n\n**Input:** prices = \\[3,2,1,4\\]\n**Output:** 7\n**Explanation:** There are 7 smooth descent periods:\n\\[3\\], \\[2\\], \\[1\\], \\[4\\], \\[3,2\\], \\[2,1\\], and \\[3,2,1\\]\nNote that a period with one day is a smooth descent period by the definition.\n\n**Example 2:**\n\n**Input:** prices = \\[8,6,7,7\\]\n**Output:** 4\n**Explanation:** There are 4 smooth descent periods: \\[8\\], \\[6\\], \\[7\\], and \\[7\\]\nNote that \\[8,6\\] is not a smooth descent period as 8 - 6 \u2260 1.\n\n**Example 3:**\n\n**Input:** prices = \\[1\\]\n**Output:** 1\n**Explanation:** There is 1 smooth descent period: \\[1\\]\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `1 <= prices[i] <= 105`\"\"\"\n\n    result = 0\n    count = 0\n    for i in range(1, len(prices)):\n        if prices[i] == prices[i - 1] - 1:\n            count += 1\n        else:\n            count = 0\n        result += count + 1\n    return result + 1"}}, "leetcode/leetcode_2100.txt": {"score": 0.9806421995162964, "content": {"text": "def minNonZeroProduct(p):\n    \"\"\"You and a gang of thieves are planning on robbing a bank. You are given a **0-indexed** integer array `security`, where `security[i]` is the number of guards on duty on the `ith` day. The days are numbered starting from `0`. You are also given an integer `time`.\n\nThe `ith` day is a good day to rob the bank if:\n\n*   There are at least `time` days before and after the `ith` day,\n*   The number of guards at the bank for the `time` days **before** `i` are **non-increasing**, and\n*   The number of guards at the bank for the `time` days **after** `i` are **non-decreasing**.\n\nMore formally, this means day `i` is a good day to rob the bank if and only if `security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time]`.\n\nReturn _a list of **all** days **(0-indexed)** that are good days to rob the bank_. _The order that the days are returned in does **not** matter._\n\n**Example 1:**\n\n**Input:** security = \\[5,3,3,3,5,6,2\\], time = 2\n**Output:** \\[2,3\\]\n**Explanation:**\nOn day 2, we have security\\[0\\] >= security\\[1\\] >= security\\[2\\] <= security\\[3\\] <= security\\[4\\].\nOn day 3, we have security\\[1\\] >= security\\[2\\] >= security\\[3\\] <= security\\[4\\] <= security\\[5\\].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.\n\n**Example 2:**\n\n**Input:** security = \\[1,1,1,1,1\\], time = 0\n**Output:** \\[0,1,2,3,4\\]\n**Explanation:**\nSince time equals 0, every day is a good day to rob the bank, so return every day.\n\n**Example 3:**\n\n**Input:** security = \\[1,2,3,4,5,6\\], time = 2\n**Output:** \\[\\]\n**Explanation:**\nNo day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list.\n\n**Constraints:**\n\n*   `1 <= security.length <= 105`\n*   `0 <= security[i], time <= 105`\"\"\"\n\n    MOD = 10**9 + 7\n    prod = 1\n    a = (1 << p) - 2\n    b = ((1 << p) - 1) % MOD\n       \n    while a > 0:\n        if a % 2:\n            prod = (prod * b) % MOD\n        b = (b * b) % MOD\n        a //= 2\n    return prod"}}, "leetcode/leetcode_2012.txt": {"score": 0.9402085542678833, "content": {"text": "from queue import PriorityQueue\n    \"\"\"You are given a **0-indexed** integer array `nums`. For each index `i` (`1 <= i <= nums.length - 2`) the **beauty** of `nums[i]` equals:\n\n*   `2`, if `nums[j] < nums[i] < nums[k]`, for **all** `0 <= j < i` and for **all** `i < k <= nums.length - 1`.\n*   `1`, if `nums[i - 1] < nums[i] < nums[i + 1]`, and the previous condition is not satisfied.\n*   `0`, if none of the previous conditions holds.\n\nReturn _the **sum of beauty** of all_ `nums[i]` _where_ `1 <= i <= nums.length - 2`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** For each index i in the range 1 <= i <= 1:\n- The beauty of nums\\[1\\] equals 2.\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,6,4\\]\n**Output:** 1\n**Explanation:** For each index i in the range 1 <= i <= 2:\n- The beauty of nums\\[1\\] equals 1.\n- The beauty of nums\\[2\\] equals 0.\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 0\n**Explanation:** For each index i in the range 1 <= i <= 1:\n- The beauty of nums\\[1\\] equals 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\"\"\"\n\n\ndef assignTasks(servers, tasks):\n    n, m = len(servers), len(tasks)\n    ans = [0] * m\n    freeServers = PriorityQueue()\n\n    for i in range(n):\n        freeServers.put((servers[i], i))\n\n    busyServers = PriorityQueue()\n    currentTask = 0\n\n    while currentTask < m:\n        while not busyServers.empty() and busyServers.queue[0][0] <= currentTask:\n            _, idx = busyServers.get()\n            freeServers.put((servers[idx], idx))\n\n        while not freeServers.empty() and currentTask < m:\n            _, idx = freeServers.get()\n            ans[currentTask] = idx\n            busyServers.put((currentTask + tasks[currentTask], idx))\n            currentTask += 1\n            \n        if freeServers.empty():\n            currentTask = busyServers.queue[0][0]\n    \n    return ans"}}, "leetcode/leetcode_2420.txt": {"score": 0.9687013030052185, "content": {"text": "def find_good_indices(nums, k):\n    \"\"\"You are given a **0-indexed** integer array `nums` of size `n` and a positive integer `k`.\n\nWe call an index `i` in the range `k <= i < n - k` **good** if the following conditions are satisfied:\n\n*   The `k` elements that are just **before** the index `i` are in **non-increasing** order.\n*   The `k` elements that are just **after** the index `i` are in **non-decreasing** order.\n\nReturn _an array of all good indices sorted in **increasing** order_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,1,1,1,3,4,1\\], k = 2\n**Output:** \\[2,3\\]\n**Explanation:** There are two good indices in the array:\n- Index 2. The subarray \\[2,1\\] is in non-increasing order, and the subarray \\[1,3\\] is in non-decreasing order.\n- Index 3. The subarray \\[1,1\\] is in non-increasing order, and the subarray \\[3,4\\] is in non-decreasing order.\nNote that the index 4 is not good because \\[4,1\\] is not non-decreasing.\n\n**Example 2:**\n\n**Input:** nums = \\[2,1,1,2\\], k = 2\n**Output:** \\[\\]\n**Explanation:** There are no good indices in this array.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `3 <= n <= 105`\n*   `1 <= nums[i] <= 106`\n*   `1 <= k <= n / 2`\"\"\"\n\n    good_indices = []\n    for i in range(k, len(nums) - k):\n        left_non_inc = all(nums[i - j - 1] >= nums[i - j - 2] for j in range(k - 1))\n        right_non_dec = all(nums[i + j + 1] >= nums[i + j + 2] for j in range(k - 1))\n\n        if left_non_inc and right_non_dec:\n            good_indices.append(i)\n\n    return good_indices"}}}}, "101": {"gold": {"leetcode/leetcode_529.txt": 1, "leetcode/leetcode_547.txt": 1, "leetcode/leetcode_695.txt": 1, "leetcode/leetcode_994.txt": 1}, "retrieved": {"leetcode/leetcode_825.txt": {"score": 0.8978848457336426, "content": {"text": "def max_increase_keeping_skyline(grid):\n    \"\"\"There are `n` persons on a social media website. You are given an integer array `ages` where `ages[i]` is the age of the `ith` person.\n\nA Person `x` will not send a friend request to a person `y` (`x != y`) if any of the following conditions is true:\n\n*   `age[y] <= 0.5 * age[x] + 7`\n*   `age[y] > age[x]`\n*   `age[y] > 100 && age[x] < 100`\n\nOtherwise, `x` will send a friend request to `y`.\n\nNote that if `x` sends a request to `y`, `y` will not necessarily send a request to `x`. Also, a person will not send a friend request to themself.\n\nReturn _the total number of friend requests made_.\n\n**Example 1:**\n\n**Input:** ages = \\[16,16\\]\n**Output:** 2\n**Explanation:** 2 people friend request each other.\n\n**Example 2:**\n\n**Input:** ages = \\[16,17,18\\]\n**Output:** 2\n**Explanation:** Friend requests are made 17 -> 16, 18 -> 17.\n\n**Example 3:**\n\n**Input:** ages = \\[20,30,100,110,120\\]\n**Output:** 3\n**Explanation:** Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\n**Constraints:**\n\n*   `n == ages.length`\n*   `1 <= n <= 2 * 104`\n*   `1 <= ages[i] <= 120`\"\"\"\n\n    n = len(grid)\n    row_max = [0] * n\n    col_max = [0] * n\n    \n    for i in range(n):\n        for j in range(n):\n            row_max[i] = max(row_max[i], grid[i][j])\n            col_max[j] = max(col_max[j], grid[i][j])\n    \n    total_sum = 0\n    for i in range(n):\n        for j in range(n):\n            total_sum += min(row_max[i], col_max[j]) - grid[i][j]\n    \n    return total_sum"}}, "leetcode/leetcode_2065.txt": {"score": 0.8981530070304871, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an **undirected** graph with `n` nodes numbered from `0` to `n - 1` (**inclusive**). You are given a **0-indexed** integer array `values` where `values[i]` is the **value** of the `ith` node. You are also given a **0-indexed** 2D integer array `edges`, where each `edges[j] = [uj, vj, timej]` indicates that there is an undirected edge between the nodes `uj` and `vj`, and it takes `timej` seconds to travel between the two nodes. Finally, you are given an integer `maxTime`.\n\nA **valid** **path** in the graph is any path that starts at node `0`, ends at node `0`, and takes **at most** `maxTime` seconds to complete. You may visit the same node multiple times. The **quality** of a valid path is the **sum** of the values of the **unique nodes** visited in the path (each node's value is added **at most once** to the sum).\n\nReturn _the **maximum** quality of a valid path_.\n\n**Note:** There are **at most four** edges connected to each node.\n\n**Example 1:**\n\n**Input:** values = \\[0,32,10,43\\], edges = \\[\\[0,1,10\\],\\[1,2,15\\],\\[0,3,10\\]\\], maxTime = 49\n**Output:** 75\n**Explanation:**\nOne possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.\n\n**Example 2:**\n\n**Input:** values = \\[5,10,15,20\\], edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[0,3,10\\]\\], maxTime = 30\n**Output:** 25\n**Explanation:**\nOne possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.\nThe nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.\n\n**Example 3:**\n\n**Input:** values = \\[1,2,3,4\\], edges = \\[\\[0,1,10\\],\\[1,2,11\\],\\[2,3,12\\],\\[1,3,13\\]\\], maxTime = 50\n**Output:** 7\n**Explanation:**\nOne possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.\n\n**Constraints:**\n\n*   `n == values.length`\n*   `1 <= n <= 1000`\n*   `0 <= values[i] <= 108`\n*   `0 <= edges.length <= 2000`\n*   `edges[j].length == 3`\n*   `0 <= uj < vj <= n - 1`\n*   `10 <= timej, maxTime <= 100`\n*   All the pairs `[uj, vj]` are **unique**.\n*   There are **at most four** edges connected to each node.\n*   The graph may not be connected.\"\"\"\n\n\ndef maxQuality_dfs(node, time_left, visited, values, neighbors):\n    acc = 0\n    for neighbor, cost in neighbors[node]:\n        if time_left >= cost and not visited[neighbor]:\n            visited[neighbor] = 1\n            acc = max(acc, values[neighbor] + maxQuality_dfs(neighbor, time_left - cost, visited, values, neighbors))\n            visited[neighbor] = 0\n    return acc\n\ndef maxQuality(values, edges, maxTime):\n    neighbors = defaultdict(list)\n    for u, v, cost in edges:\n        neighbors[u].append((v, cost))\n        neighbors[v].append((u, cost))\n    visited = [0] * len(values)\n    return maxQuality_dfs(0, maxTime, visited, values, neighbors)"}}, "leetcode/leetcode_882.txt": {"score": 0.9046455025672913, "content": {"text": "def peakIndexInMountainArray(arr):\n    \"\"\"You are given an undirected graph (the **\"original graph \"**) with `n` nodes labeled from `0` to `n - 1`. You decide to **subdivide** each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.\n\nThe graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]` indicates that there is an edge between nodes `ui` and `vi` in the original graph, and `cnti` is the total number of new nodes that you will **subdivide** the edge into. Note that `cnti == 0` means you will not subdivide the edge.\n\nTo **subdivide** the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and `cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti-1, xcnti]`, `[xcnti, vi]`.\n\nIn this **new graph**, you want to know how many nodes are **reachable** from the node `0`, where a node is **reachable** if the distance is `maxMoves` or less.\n\nGiven the original graph and `maxMoves`, return _the number of nodes that are **reachable** from node_ `0` _in the new graph_.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1,10\\],\\[0,2,1\\],\\[1,2,2\\]\\], maxMoves = 6, n = 3\n**Output:** 13\n**Explanation:** The edge subdivisions are shown in the image above.\nThe nodes that are reachable are highlighted in yellow.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1,4\\],\\[1,2,6\\],\\[0,2,8\\],\\[1,3,1\\]\\], maxMoves = 10, n = 4\n**Output:** 23\n\n**Example 3:**\n\n**Input:** edges = \\[\\[1,2,4\\],\\[1,4,5\\],\\[1,3,1\\],\\[2,3,4\\],\\[3,4,5\\]\\], maxMoves = 17, n = 5\n**Output:** 1\n**Explanation:** Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.\n\n**Constraints:**\n\n*   `0 <= edges.length <= min(n * (n - 1) / 2, 104)`\n*   `edges[i].length == 3`\n*   `0 <= ui < vi < n`\n*   There are **no multiple edges** in the graph.\n*   `0 <= cnti <= 104`\n*   `0 <= maxMoves <= 109`\n*   `1 <= n <= 3000`\"\"\"\n\n    low, high = 0, len(arr) - 1\n    while low < high:\n        mid = low + (high - low) // 2\n        if arr[mid] < arr[mid + 1]:\n            low = mid + 1\n        else:\n            high = mid\n    return low"}}, "leetcode/leetcode_2580.txt": {"score": 0.9006217122077942, "content": {"text": "def total_ways_to_split_ranges(ranges):\n    \"\"\"You are given a 2D integer array `ranges` where `ranges[i] = [starti, endi]` denotes that all integers between `starti` and `endi` (both **inclusive**) are contained in the `ith` range.\n\nYou are to split `ranges` into **two** (possibly empty) groups such that:\n\n*   Each range belongs to exactly one group.\n*   Any two **overlapping** ranges must belong to the **same** group.\n\nTwo ranges are said to be **overlapping** if there exists at least **one** integer that is present in both ranges.\n\n*   For example, `[1, 3]` and `[2, 5]` are overlapping because `2` and `3` occur in both ranges.\n\nReturn _the **total number** of ways to split_ `ranges` _into two groups_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** ranges = \\[\\[6,10\\],\\[5,15\\]\\]\n**Output:** 2\n**Explanation:** \nThe two ranges are overlapping, so they must be in the same group.\nThus, there are two possible ways:\n- Put both the ranges together in group 1.\n- Put both the ranges together in group 2.\n\n**Example 2:**\n\n**Input:** ranges = \\[\\[1,3\\],\\[10,20\\],\\[2,5\\],\\[4,8\\]\\]\n**Output:** 4\n**Explanation:** \nRanges \\[1,3\\], and \\[2,5\\] are overlapping. So, they must be in the same group.\nAgain, ranges \\[2,5\\] and \\[4,8\\] are also overlapping. So, they must also be in the same group. \nThus, there are four possible ways to group them:\n- All the ranges in group 1.\n- All the ranges in group 2.\n- Ranges \\[1,3\\], \\[2,5\\], and \\[4,8\\] in group 1 and \\[10,20\\] in group 2.\n- Ranges \\[1,3\\], \\[2,5\\], and \\[4,8\\] in group 2 and \\[10,20\\] in group 1.\n\n**Constraints:**\n\n*   `1 <= ranges.length <= 105`\n*   `ranges[i].length == 2`\n*   `0 <= starti <= endi <= 109`\"\"\"\n\n    MOD = 10**9 + 7\n    ranges.sort(key=lambda x: x[1])\n    overlapping, non_overlapping, prev_end = 0, 1, -1\n\n    for start, end in ranges:\n        if start <= prev_end:\n            overlapping += 1\n        else:\n            non_overlapping += 1\n        prev_end = max(prev_end, end)\n\n    result = 1\n    for i in range(1, overlapping + 1):\n        result = (result * 2) % MOD\n\n    return result"}}, "leetcode/leetcode_1617.txt": {"score": 0.9134011268615723, "content": {"text": "def winnerSquareGame(n: int) -> bool:\n    \"\"\"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.\"\"\"\n\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]"}}, "leetcode/leetcode_1620.txt": {"score": 0.9249086976051331, "content": {"text": "def canArrange(arr, k):\n    \"\"\"You are given an array of network towers `towers`, where `towers[i] = [xi, yi, qi]` denotes the `ith` network tower with location `(xi, yi)` and quality factor `qi`. All the coordinates are **integral coordinates** on the X-Y plane, and the distance between the two coordinates is the **Euclidean distance**.\n\nYou are also given an integer `radius` where a tower is **reachable** if the distance is **less than or equal to** `radius`. Outside that distance, the signal becomes garbled, and the tower is **not reachable**.\n\nThe signal quality of the `ith` tower at a coordinate `(x, y)` is calculated with the formula `\u230aqi / (1 + d)\u230b`, where `d` is the distance between the tower and the coordinate. The **network quality** at a coordinate is the sum of the signal qualities from all the **reachable** towers.\n\nReturn _the array_ `[cx, cy]` _representing the **integral** coordinate_ `(cx, cy)` _where the **network quality** is maximum. If there are multiple coordinates with the same **network quality**, return the lexicographically minimum **non-negative** coordinate._\n\n**Note:**\n\n*   A coordinate `(x1, y1)` is lexicographically smaller than `(x2, y2)` if either:\n    *   `x1 < x2`, or\n    *   `x1 == x2` and `y1 < y2`.\n*   `\u230aval\u230b` is the greatest integer less than or equal to `val` (the floor function).\n\n**Example 1:**\n\n**Input:** towers = \\[\\[1,2,5\\],\\[2,1,7\\],\\[3,1,9\\]\\], radius = 2\n**Output:** \\[2,1\\]\n**Explanation:** At coordinate (2, 1) the total quality is 13.\n- Quality of 7 from (2, 1) results in \u230a7 / (1 + sqrt(0)\u230b = \u230a7\u230b = 7\n- Quality of 5 from (1, 2) results in \u230a5 / (1 + sqrt(2)\u230b = \u230a2.07\u230b = 2\n- Quality of 9 from (3, 1) results in \u230a9 / (1 + sqrt(1)\u230b = \u230a4.5\u230b = 4\nNo other coordinate has a higher network quality.\n\n**Example 2:**\n\n**Input:** towers = \\[\\[23,11,21\\]\\], radius = 9\n**Output:** \\[23,11\\]\n**Explanation:** Since there is only one tower, the network quality is highest right at the tower's location.\n\n**Example 3:**\n\n**Input:** towers = \\[\\[1,2,13\\],\\[2,1,7\\],\\[0,1,9\\]\\], radius = 2\n**Output:** \\[1,2\\]\n**Explanation:** Coordinate (1, 2) has the highest network quality.\n\n**Constraints:**\n\n*   `1 <= towers.length <= 50`\n*   `towers[i].length == 3`\n*   `0 <= xi, yi, qi <= 50`\n*   `1 <= radius <= 50`\"\"\"\n\n    counts = [0] * k\n    for num in arr:\n        counts[(num % k + k) % k] += 1\n    if counts[0] % 2 != 0:\n        return False\n    for i in range(1, k // 2 + 1):\n        if counts[i] != counts[k - i]:\n            return False\n    return True"}}, "leetcode/leetcode_2421.txt": {"score": 0.9076664447784424, "content": {"text": "from collections import defaultdict\n    \"\"\"There is a tree (i.e. a connected, undirected graph with no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges.\n\nYou are given a **0-indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nA **good path** is a simple path that satisfies the following conditions:\n\n1.  The starting node and the ending node have the **same** value.\n2.  All nodes between the starting node and the ending node have values **less than or equal to** the starting node (i.e. the starting node's value should be the maximum value along the path).\n\nReturn _the number of distinct good paths_.\n\nNote that a path and its reverse are counted as the **same** path. For example, `0 -> 1` is considered to be the same as `1 -> 0`. A single node is also considered as a valid path.\n\n**Example 1:**\n\n**Input:** vals = \\[1,3,2,1,3\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 6\n**Explanation:** There are 5 good paths consisting of a single node.\nThere is 1 additional good path: 1 -> 0 -> 2 -> 4.\n(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\nNote that 0 -> 2 -> 3 is not a good path because vals\\[2\\] > vals\\[0\\].\n\n**Example 2:**\n\n**Input:** vals = \\[1,1,2,2,3\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 7\n**Explanation:** There are 5 good paths consisting of a single node.\nThere are 2 additional good paths: 0 -> 1 and 2 -> 3.\n\n**Example 3:**\n\n**Input:** vals = \\[1\\], edges = \\[\\]\n**Output:** 1\n**Explanation:** The tree consists of only one node, so there is one good path.\n\n**Constraints:**\n\n*   `n == vals.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= vals[i] <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef dfs(node, parent, adj, vals, cur_max, count):\n    if vals[node] >= cur_max:\n        if vals[node] > cur_max:\n            count[0] += 1\n            cur_max = vals[node]\n        for next in adj[node]:\n            if next != parent:\n                dfs(next, node, adj, vals, cur_max, count)\n\ndef number_of_good_paths(vals, edges):\n    n = len(vals)\n    adj = defaultdict(list)\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    count = [0]\n    for i in range(n):\n        dfs(i, -1, adj, vals, -1, count)\n    return count[0]"}}, "leetcode/leetcode_2101.txt": {"score": 0.99159175157547, "content": {"text": "def can_reach_bottom(grid, row, col):\n    \"\"\"You are given a list of bombs. The **range** of a bomb is defined as the area where its effect can be felt. This area is in the shape of a **circle** with the center as the location of the bomb.\n\nThe bombs are represented by a **0-indexed** 2D integer array `bombs` where `bombs[i] = [xi, yi, ri]`. `xi` and `yi` denote the X-coordinate and Y-coordinate of the location of the `ith` bomb, whereas `ri` denotes the **radius** of its range.\n\nYou may choose to detonate a **single** bomb. When a bomb is detonated, it will detonate **all bombs** that lie in its range. These bombs will further detonate the bombs that lie in their ranges.\n\nGiven the list of `bombs`, return _the **maximum** number of bombs that can be detonated if you are allowed to detonate **only one** bomb_.\n\n**Example 1:**\n\n**Input:** bombs = \\[\\[2,1,3\\],\\[6,1,4\\]\\]\n**Output:** 2\n**Explanation:**\nThe above figure shows the positions and ranges of the 2 bombs.\nIf we detonate the left bomb, the right bomb will not be affected.\nBut if we detonate the right bomb, both bombs will be detonated.\nSo the maximum bombs that can be detonated is max(1, 2) = 2.\n\n**Example 2:**\n\n**Input:** bombs = \\[\\[1,1,5\\],\\[10,10,5\\]\\]\n**Output:** 1\n**Explanation:**\nDetonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.\n\n**Example 3:**\n\n**Input:** bombs = \\[\\[1,2,3\\],\\[2,3,1\\],\\[3,4,2\\],\\[4,5,3\\],\\[5,6,4\\]\\]\n**Output:** 5\n**Explanation:**\nThe best bomb to detonate is bomb 0 because:\n- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.\n- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.\n- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.\nThus all 5 bombs are detonated.\n\n**Constraints:**\n\n*   `1 <= bombs.length <= 100`\n*   `bombs[i].length == 3`\n*   `1 <= xi, yi, ri <= 105`\"\"\"\n\n    if row == len(grid) - 1:\n        return True\n    grid[row][col] = 1\n\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    for dr, dc in directions:\n        nr, nc = row + dr, col + dc\n        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:\n            if can_reach_bottom(grid, nr, nc):\n                return True\n\n    return False\n\ndef latestDayToCross(row, col, cells):\n    grid = [[0] * col for _ in range(row)]\n    ans = 0\n\n    for day, cell in enumerate(cells):\n        grid[cell[0] - 1][cell[1] - 1] = 1\n\n        found = False\n        for j in range(col):\n            if grid[0][j] == 0 and can_reach_bottom(grid, 0, j):\n                found = True\n                break\n\n        if not found:\n            ans = day\n            break\n\n    return ans"}}, "leetcode/leetcode_2092.txt": {"score": 0.9096649885177612, "content": {"text": "def find_secret_sharers(n, meetings, first_person):\n    \"\"\"You are given an integer `n` indicating there are `n` people numbered from `0` to `n - 1`. You are also given a **0-indexed** 2D integer array `meetings` where `meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi` have a meeting at `timei`. A person may attend **multiple meetings** at the same time. Finally, you are given an integer `firstPerson`.\n\nPerson `0` has a **secret** and initially shares the secret with a person `firstPerson` at time `0`. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person `xi` has the secret at `timei`, then they will share the secret with person `yi`, and vice versa.\n\nThe secrets are shared **instantaneously**. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\n\nReturn _a list of all the people that have the secret after all the meetings have taken place._ You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** n = 6, meetings = \\[\\[1,2,5\\],\\[2,3,8\\],\\[1,5,10\\]\\], firstPerson = 1\n**Output:** \\[0,1,2,3,5\\]\n**Explanation:**\nAt time 0, person 0 shares the secret with person 1.\nAt time 5, person 1 shares the secret with person 2.\nAt time 8, person 2 shares the secret with person 3.\nAt time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b\nThus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.\n\n**Example 2:**\n\n**Input:** n = 4, meetings = \\[\\[3,1,3\\],\\[1,2,2\\],\\[0,3,3\\]\\], firstPerson = 3\n**Output:** \\[0,1,3\\]\n**Explanation:**\nAt time 0, person 0 shares the secret with person 3.\nAt time 2, neither person 1 nor person 2 know the secret.\nAt time 3, person 3 shares the secret with person 0 and person 1.\nThus, people 0, 1, and 3 know the secret after all the meetings.\n\n**Example 3:**\n\n**Input:** n = 5, meetings = \\[\\[3,4,2\\],\\[1,2,1\\],\\[2,3,1\\]\\], firstPerson = 1\n**Output:** \\[0,1,2,3,4\\]\n**Explanation:**\nAt time 0, person 0 shares the secret with person 1.\nAt time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\nNote that person 2 can share the secret at the same time as receiving it.\nAt time 2, person 3 shares the secret with person 4.\nThus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `1 <= meetings.length <= 105`\n*   `meetings[i].length == 3`\n*   `0 <= xi, yi <= n - 1`\n*   `xi != yi`\n*   `1 <= timei <= 105`\n*   `1 <= firstPerson <= n - 1`\"\"\"\n\n    secret_holders = [-1] * n\n    secret_holders[0] = 0\n    secret_holders[first_person] = 0\n\n    meetings.sort(key=lambda x: x[2])\n\n    for x, y, time in meetings:\n        if secret_holders[x] != -1 and secret_holders[x] <= time:\n            secret_holders[y] = time\n        if secret_holders[y] != -1 and secret_holders[y] <= time:\n            secret_holders[x] = time\n\n    return [i for i in range(n) if secret_holders[i] != -1]"}}, "leetcode/leetcode_947.txt": {"score": 0.919514000415802, "content": {"text": "from collections import defaultdict\n    \"\"\"On a 2D plane, we place `n` stones at some integer coordinate points. Each coordinate point may have at most one stone.\n\nA stone can be removed if it shares either **the same row or the same column** as another stone that has not been removed.\n\nGiven an array `stones` of length `n` where `stones[i] = [xi, yi]` represents the location of the `ith` stone, return _the largest possible number of stones that can be removed_.\n\n**Example 1:**\n\n**Input:** stones = \\[\\[0,0\\],\\[0,1\\],\\[1,0\\],\\[1,2\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:** 5\n**Explanation:** One way to remove 5 stones is as follows:\n1. Remove stone \\[2,2\\] because it shares the same row as \\[2,1\\].\n2. Remove stone \\[2,1\\] because it shares the same column as \\[0,1\\].\n3. Remove stone \\[1,2\\] because it shares the same row as \\[1,0\\].\n4. Remove stone \\[1,0\\] because it shares the same column as \\[0,0\\].\n5. Remove stone \\[0,1\\] because it shares the same row as \\[0,0\\].\nStone \\[0,0\\] cannot be removed since it does not share a row/column with another stone still on the plane.\n\n**Example 2:**\n\n**Input:** stones = \\[\\[0,0\\],\\[0,2\\],\\[1,1\\],\\[2,0\\],\\[2,2\\]\\]\n**Output:** 3\n**Explanation:** One way to make 3 moves is as follows:\n1. Remove stone \\[2,2\\] because it shares the same row as \\[2,0\\].\n2. Remove stone \\[2,0\\] because it shares the same column as \\[0,0\\].\n3. Remove stone \\[0,2\\] because it shares the same row as \\[0,0\\].\nStones \\[0,0\\] and \\[1,1\\] cannot be removed since they do not share a row/column with another stone still on the plane.\n\n**Example 3:**\n\n**Input:** stones = \\[\\[0,0\\]\\]\n**Output:** 0\n**Explanation:** \\[0,0\\] is the only stone on the plane, so you cannot remove it.\n\n**Constraints:**\n\n*   `1 <= stones.length <= 1000`\n*   `0 <= xi, yi <= 104`\n*   No two stones are at the same coordinate point.\"\"\"\n\nfrom bisect import bisect\n\nclass TopVotedCandidate:\n\n    def __init__(self, persons, times):\n        self.leader_map = {}\n        self.times = times\n        votes = defaultdict(int)\n        leader = -1\n        for i, t in enumerate(times):\n            votes[persons[i]] += 1\n            if votes[persons[i]] >= votes[leader]:\n                leader = persons[i]\n            self.leader_map[t] = leader\n\n    def q(self, t):\n        idx = bisect.bisect(self.times, t)\n        return self.times[idx - 1]"}}}}, "102": {"gold": {"leetcode/leetcode_1941.txt": 1}, "retrieved": {"leetcode/leetcode_1817.txt": {"score": 0.9233949184417725, "content": {"text": "def total_money(n):\n    \"\"\"You are given the logs for users' actions on LeetCode, and an integer `k`. The logs are represented by a 2D integer array `logs` where each `logs[i] = [IDi, timei]` indicates that the user with `IDi` performed an action at the minute `timei`.\n\n**Multiple users** can perform actions simultaneously, and a single user can perform **multiple actions** in the same minute.\n\nThe **user active minutes (UAM)** for a given user is defined as the **number of unique minutes** in which the user performed an action on LeetCode. A minute can only be counted once, even if multiple actions occur during it.\n\nYou are to calculate a **1-indexed** array `answer` of size `k` such that, for each `j` (`1 <= j <= k`), `answer[j]` is the **number of users** whose **UAM** equals `j`.\n\nReturn _the array_ `answer` _as described above_.\n\n**Example 1:**\n\n**Input:** logs = \\[\\[0,5\\],\\[1,2\\],\\[0,2\\],\\[0,5\\],\\[1,3\\]\\], k = 5\n**Output:** \\[0,2,0,0,0\\]\n**Explanation:**\nThe user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).\nThe user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\nSince both users have a UAM of 2, answer\\[2\\] is 2, and the remaining answer\\[j\\] values are 0.\n\n**Example 2:**\n\n**Input:** logs = \\[\\[1,1\\],\\[2,2\\],\\[2,3\\]\\], k = 4\n**Output:** \\[1,1,0,0\\]\n**Explanation:**\nThe user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.\nThe user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.\nThere is one user with a UAM of 1 and one with a UAM of 2.\nHence, answer\\[1\\] = 1, answer\\[2\\] = 1, and the remaining values are 0.\n\n**Constraints:**\n\n*   `1 <= logs.length <= 104`\n*   `0 <= IDi <= 109`\n*   `1 <= timei <= 105`\n*   `k` is in the range `[The maximum **UAM** for a user, 105]`.\"\"\"\n\n    weeks = n // 7\n    days_remaining = n % 7\n    return 28 * weeks + 7 * weeks * (weeks - 1) // 2 + (weeks + 1) * days_remaining + days_remaining * (days_remaining - 1) // 2"}}, "leetcode/leetcode_2284.txt": {"score": 0.9245619177818298, "content": {"text": "def rearrange_digits(num):\n    \"\"\"You have a chat log of `n` messages. You are given two string arrays `messages` and `senders` where `messages[i]` is a **message** sent by `senders[i]`.\n\nA **message** is list of **words** that are separated by a single space with no leading or trailing spaces. The **word count** of a sender is the total number of **words** sent by the sender. Note that a sender may send more than one message.\n\nReturn _the sender with the **largest** word count_. If there is more than one sender with the largest word count, return _the one with the **lexicographically largest** name_.\n\n**Note:**\n\n*   Uppercase letters come before lowercase letters in lexicographical order.\n*   `\"Alice \"` and `\"alice \"` are distinct.\n\n**Example 1:**\n\n**Input:** messages = \\[ \"Hello userTwooo \", \"Hi userThree \", \"Wonderful day Alice \", \"Nice day userThree \"\\], senders = \\[ \"Alice \", \"userTwo \", \"userThree \", \"Alice \"\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice sends a total of 2 + 3 = 5 words.\nuserTwo sends a total of 2 words.\nuserThree sends a total of 3 words.\nSince Alice has the largest word count, we return  \"Alice \".\n\n**Example 2:**\n\n**Input:** messages = \\[ \"How is leetcode for everyone \", \"Leetcode is useful for practice \"\\], senders = \\[ \"Bob \", \"Charlie \"\\]\n**Output:**  \"Charlie \"\n**Explanation:** Bob sends a total of 5 words.\nCharlie sends a total of 5 words.\nSince there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.\n\n**Constraints:**\n\n*   `n == messages.length == senders.length`\n*   `1 <= n <= 104`\n*   `1 <= messages[i].length <= 100`\n*   `1 <= senders[i].length <= 10`\n*   `messages[i]` consists of uppercase and lowercase English letters and `' '`.\n*   All the words in `messages[i]` are separated by **a single space**.\n*   `messages[i]` does not have leading or trailing spaces.\n*   `senders[i]` consists of uppercase and lowercase English letters only.\"\"\"\n\n    if num == 0:\n        return 0\n    digits = sorted(str(num))\n    \n    if digits[0] != '-' and digits[0] == '0':\n        nonzero_index = next(index for index, digit in enumerate(digits) if digit != '0')\n        digits[0], digits[nonzero_index] = digits[nonzero_index], digits[0]\n    \n    return int(\"\".join(digits))"}}, "leetcode/leetcode_1418.txt": {"score": 0.9236810207366943, "content": {"text": "from collections import defaultdict\n    \"\"\"Given the array `orders`, which represents the orders that customers have done in a restaurant. More specifically `orders[i]=[customerNamei,tableNumberi,foodItemi]` where `customerNamei` is the name of the customer, `tableNumberi` is the table customer sit at, and `foodItemi` is the item customer orders.\n\n_Return the restaurant's \"**display table**\"_. The \"**display table**\" is a table whose row entries denote how many of each food item each table ordered. The first column is the table number and the remaining columns correspond to each food item in alphabetical order. The first row should be a header whose first column is \"Table\", followed by the names of the food items. Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order.\n\n**Example 1:**\n\n**Input:** orders = \\[\\[ \"David \", \"3 \", \"Ceviche \"\\],\\[ \"Corina \", \"10 \", \"Beef Burrito \"\\],\\[ \"David \", \"3 \", \"Fried Chicken \"\\],\\[ \"Carla \", \"5 \", \"Water \"\\],\\[ \"Carla \", \"5 \", \"Ceviche \"\\],\\[ \"Rous \", \"3 \", \"Ceviche \"\\]\\]\n**Output:** \\[\\[ \"Table \", \"Beef Burrito \", \"Ceviche \", \"Fried Chicken \", \"Water \"\\],\\[ \"3 \", \"0 \", \"2 \", \"1 \", \"0 \"\\],\\[ \"5 \", \"0 \", \"1 \", \"0 \", \"1 \"\\],\\[ \"10 \", \"1 \", \"0 \", \"0 \", \"0 \"\\]\\] \n**Explanation:**\nThe displaying table looks like:\n**Table,Beef Burrito,Ceviche,Fried Chicken,Water**\n3    ,0           ,2      ,1            ,0\n5    ,0           ,1      ,0            ,1\n10   ,1           ,0      ,0            ,0\nFor the table 3: David orders  \"Ceviche \" and  \"Fried Chicken \", and Rous orders  \"Ceviche \".\nFor the table 5: Carla orders  \"Water \" and  \"Ceviche \".\nFor the table 10: Corina orders  \"Beef Burrito \". \n\n**Example 2:**\n\n**Input:** orders = \\[\\[ \"James \", \"12 \", \"Fried Chicken \"\\],\\[ \"Ratesh \", \"12 \", \"Fried Chicken \"\\],\\[ \"Amadeus \", \"12 \", \"Fried Chicken \"\\],\\[ \"Adam \", \"1 \", \"Canadian Waffles \"\\],\\[ \"Brianna \", \"1 \", \"Canadian Waffles \"\\]\\]\n**Output:** \\[\\[ \"Table \", \"Canadian Waffles \", \"Fried Chicken \"\\],\\[ \"1 \", \"2 \", \"0 \"\\],\\[ \"12 \", \"0 \", \"3 \"\\]\\] \n**Explanation:** \nFor the table 1: Adam and Brianna order  \"Canadian Waffles \".\nFor the table 12: James, Ratesh and Amadeus order  \"Fried Chicken \".\n\n**Example 3:**\n\n**Input:** orders = \\[\\[ \"Laura \", \"2 \", \"Bean Burrito \"\\],\\[ \"Jhon \", \"2 \", \"Beef Burrito \"\\],\\[ \"Melissa \", \"2 \", \"Soda \"\\]\\]\n**Output:** \\[\\[ \"Table \", \"Bean Burrito \", \"Beef Burrito \", \"Soda \"\\],\\[ \"2 \", \"1 \", \"1 \", \"1 \"\\]\\]\n\n**Constraints:**\n\n*   `1 <= orders.length <= 5 * 10^4`\n*   `orders[i].length == 3`\n*   `1 <= customerNamei.length, foodItemi.length <= 20`\n*   `customerNamei` and `foodItemi` consist of lowercase and uppercase English letters and the space character.\n*   `tableNumberi` is a valid integer between `1` and `500`.\"\"\"\n\nfrom typing import List\n\ndef displayTable(orders: List[List[str]]) -> List[List[str]]:\n    tables = defaultdict(lambda: defaultdict(int))\n    foodSet = set()\n\n    for order in orders:\n        tableNumber = int(order[1])\n        foodItem = order[2]\n        tables[tableNumber][foodItem] += 1\n        foodSet.add(foodItem)\n\n    foodList = sorted(foodSet)\n    result = [[\"Table\"] + foodList]\n\n    for tableNumber, table in sorted(tables.items()):\n        row = [str(tableNumber)]\n        row.extend(str(table[foodItem]) for foodItem in foodList)\n        result.append(row)\n\n    return result"}}, "leetcode/leetcode_2032.txt": {"score": 0.9310657382011414, "content": {"text": "def largest_odd(num: str) -> str:\n    \"\"\"Given three integer arrays `nums1`, `nums2`, and `nums3`, return _a **distinct** array containing all the values that are present in **at least two** out of the three arrays. You may return the values in **any** order_.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,1,3,2\\], nums2 = \\[2,3\\], nums3 = \\[3\\]\n**Output:** \\[3,2\\]\n**Explanation:** The values that are present in at least two arrays are:\n- 3, in all three arrays.\n- 2, in nums1 and nums2.\n\n**Example 2:**\n\n**Input:** nums1 = \\[3,1\\], nums2 = \\[2,3\\], nums3 = \\[1,2\\]\n**Output:** \\[2,3,1\\]\n**Explanation:** The values that are present in at least two arrays are:\n- 2, in nums2 and nums3.\n- 3, in nums1 and nums2.\n- 1, in nums1 and nums3.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,2\\], nums2 = \\[4,3,3\\], nums3 = \\[5\\]\n**Output:** \\[\\]\n**Explanation:** No value is present in at least two arrays.\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length, nums3.length <= 100`\n*   `1 <= nums1[i], nums2[j], nums3[k] <= 100`\"\"\"\n\n    for i in range(len(num)):\n        if (int(num[i]) % 2) == 1:\n            return num[:i + 1]\n    return \"\""}}, "leetcode/leetcode_2456.txt": {"score": 0.9284200668334961, "content": {"text": "from collections import defaultdict\n    \"\"\"You are given two string arrays `creators` and `ids`, and an integer array `views`, all of length `n`. The `ith` video on a platform was created by `creator[i]`, has an id of `ids[i]`, and has `views[i]` views.\n\nThe **popularity** of a creator is the **sum** of the number of views on **all** of the creator's videos. Find the creator with the **highest** popularity and the id of their **most** viewed video.\n\n*   If multiple creators have the highest popularity, find all of them.\n*   If multiple videos have the highest view count for a creator, find the lexicographically **smallest** id.\n\nReturn _a 2D array of strings_ `answer` _where_ `answer[i] = [creatori, idi]` _means that_ `creatori` _has the **highest** popularity and_ `idi` _is the id of their most popular video._ The answer can be returned in any order.\n\n**Example 1:**\n\n**Input:** creators = \\[ \"alice \", \"bob \", \"alice \", \"chris \"\\], ids = \\[ \"one \", \"two \", \"three \", \"four \"\\], views = \\[5,10,5,4\\]\n**Output:** \\[\\[ \"alice \", \"one \"\\],\\[ \"bob \", \"two \"\\]\\]\n**Explanation:**\nThe popularity of alice is 5 + 5 = 10.\nThe popularity of bob is 10.\nThe popularity of chris is 4.\nalice and bob are the most popular creators.\nFor bob, the video with the highest view count is  \"two \".\nFor alice, the videos with the highest view count are  \"one \" and  \"three \". Since  \"one \" is lexicographically smaller than  \"three \", it is included in the answer.\n\n**Example 2:**\n\n**Input:** creators = \\[ \"alice \", \"alice \", \"alice \"\\], ids = \\[ \"a \", \"b \", \"c \"\\], views = \\[1,2,2\\]\n**Output:** \\[\\[ \"alice \", \"b \"\\]\\]\n**Explanation:**\nThe videos with id  \"b \" and  \"c \" have the highest view count.\nSince  \"b \" is lexicographically smaller than  \"c \", it is included in the answer.\n\n**Constraints:**\n\n*   `n == creators.length == ids.length == views.length`\n*   `1 <= n <= 105`\n*   `1 <= creators[i].length, ids[i].length <= 5`\n*   `creators[i]` and `ids[i]` consist only of lowercase English letters.\n*   `0 <= views[i] <= 105`\"\"\"\n\n\ndef highest_popularity(creators, ids, views):\n    popularity = defaultdict(int)\n    most_viewed = {}\n\n    for i in range(len(creators)):\n        popularity[creators[i]] += views[i]\n        if creators[i] not in most_viewed or views[i] > most_viewed[creators[i]][1] or (views[i] == most_viewed[creators[i]][1] and ids[i] < most_viewed[creators[i]][0]):\n            most_viewed[creators[i]] = (ids[i], views[i])\n\n    max_popularity = max(popularity.values())\n\n    return [[creator, most_viewed[creator][0]] for creator, pop in popularity.items() if pop == max_popularity]"}}, "leetcode/leetcode_2085.txt": {"score": 0.9348114728927612, "content": {"text": "def rearrangeArray(nums):\n    \"\"\"Given two string arrays `words1` and `words2`, return _the number of strings that appear **exactly once** in **each** of the two arrays._\n\n**Example 1:**\n\n**Input:** words1 = \\[ \"leetcode \", \"is \", \"amazing \", \"as \", \"is \"\\], words2 = \\[ \"amazing \", \"leetcode \", \"is \"\\]\n**Output:** 2\n**Explanation:**\n-  \"leetcode \" appears exactly once in each of the two arrays. We count this string.\n-  \"amazing \" appears exactly once in each of the two arrays. We count this string.\n-  \"is \" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.\n-  \"as \" appears once in words1, but does not appear in words2. We do not count this string.\nThus, there are 2 strings that appear exactly once in each of the two arrays.\n\n**Example 2:**\n\n**Input:** words1 = \\[ \"b \", \"bb \", \"bbb \"\\], words2 = \\[ \"a \", \"aa \", \"aaa \"\\]\n**Output:** 0\n**Explanation:** There are no strings that appear in each of the two arrays.\n\n**Example 3:**\n\n**Input:** words1 = \\[ \"a \", \"ab \"\\], words2 = \\[ \"a \", \"a \", \"a \", \"ab \"\\]\n**Output:** 1\n**Explanation:** The only string that appears exactly once in each of the two arrays is  \"ab \".\n\n**Constraints:**\n\n*   `1 <= words1.length, words2.length <= 1000`\n*   `1 <= words1[i].length, words2[j].length <= 30`\n*   `words1[i]` and `words2[j]` consists only of lowercase English letters.\"\"\"\n\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n```\n    \n    The algorithm first sorts the array. Then, we swap every two adjacent elements starting from the first index until the end of the array. By doing this, we can ensure that no element will be equal to the average of its neighbors, as the elements are distinct integers and the property described in the problem cannot hold after swapping.\n\nFor example, let's take the following array:\n\n```\n3 1 5 9 7\n```\n\nSort the array:\n\n```\n1 3 5 7 9\n```\n\nSwap every two adjacent elements starting from the first index:\n\n```\n1 5 3 9 7"}}, "leetcode/leetcode_781.txt": {"score": 0.9263272285461426, "content": {"text": "from collections import Counter\n    \"\"\"There is a forest with an unknown number of rabbits. We asked n rabbits **\"How many rabbits have the same color as you? \"** and collected the answers in an integer array `answers` where `answers[i]` is the answer of the `ith` rabbit.\n\nGiven the array `answers`, return _the minimum number of rabbits that could be in the forest_.\n\n**Example 1:**\n\n**Input:** answers = \\[1,1,2\\]\n**Output:** 5\n**Explanation:**\nThe two rabbits that answered  \"1 \" could both be the same color, say red.\nThe rabbit that answered  \"2 \" can't be red or the answers would be inconsistent.\nSay the rabbit that answered  \"2 \" was blue.\nThen there should be 2 other blue rabbits in the forest that didn't answer into the array.\nThe smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.\n\n**Example 2:**\n\n**Input:** answers = \\[10,10,10\\]\n**Output:** 11\n\n**Constraints:**\n\n*   `1 <= answers.length <= 1000`\n*   `0 <= answers[i] < 1000`\"\"\"\n\n\ndef numRabbits(answers):\n    count = Counter(answers)\n    rabbits = 0\n    for ans, cnt in count.items():\n        rabbits += (ans + cnt)//(ans + 1) * (ans + 1)\n    return rabbits"}}, "leetcode/leetcode_2103.txt": {"score": 0.9958478808403015, "content": {"text": "def findFarmland(land):\n    \"\"\"There are `n` rings and each ring is either red, green, or blue. The rings are distributed **across ten rods** labeled from `0` to `9`.\n\nYou are given a string `rings` of length `2n` that describes the `n` rings that are placed onto the rods. Every two characters in `rings` forms a **color-position pair** that is used to describe each ring where:\n\n*   The **first** character of the `ith` pair denotes the `ith` ring's **color** (`'R'`, `'G'`, `'B'`).\n*   The **second** character of the `ith` pair denotes the **rod** that the `ith` ring is placed on (`'0'` to `'9'`).\n\nFor example, `\"R3G2B1 \"` describes `n == 3` rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n\nReturn _the number of rods that have **all three colors** of rings on them._\n\n**Example 1:**\n\n**Input:** rings =  \"B0B6G0R6R0R6G9 \"\n**Output:** 1\n**Explanation:** \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.\n\n**Example 2:**\n\n**Input:** rings =  \"B0R0G0R9R0B0G0 \"\n**Output:** 1\n**Explanation:** \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.\n\n**Example 3:**\n\n**Input:** rings =  \"G4 \"\n**Output:** 0\n**Explanation:** \nOnly one ring is given. Thus, no rods have all three colors.\n\n**Constraints:**\n\n*   `rings.length == 2 * n`\n*   `1 <= n <= 100`\n*   `rings[i]` where `i` is **even** is either `'R'`, `'G'`, or `'B'` (**0-indexed**).\n*   `rings[i]` where `i` is **odd** is a digit from `'0'` to `'9'` (**0-indexed**).\"\"\"\n\n    m, n = len(land), len(land[0])\n    res = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r, c = i, j\n                while r < m and land[r][j] == 1: r += 1\n                while c < n and land[i][c] == 1: c += 1\n                for x in range(i, r):\n                    for y in range(j,c):\n                        land[x][y] = 0\n                res.append([i, j, r - 1, c - 1])\n\n    return res"}}, "leetcode/leetcode_1655.txt": {"score": 0.9379663467407227, "content": {"text": "from collections import Counter\n    \"\"\"You are given an array of `n` integers, `nums`, where there are at most `50` unique values in the array. You are also given an array of `m` customer order quantities, `quantity`, where `quantity[i]` is the amount of integers the `ith` customer ordered. Determine if it is possible to distribute `nums` such that:\n\n*   The `ith` customer gets **exactly** `quantity[i]` integers,\n*   The integers the `ith` customer gets are **all equal**, and\n*   Every customer is satisfied.\n\nReturn `true` _if it is possible to distribute_ `nums` _according to the above conditions_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\], quantity = \\[2\\]\n**Output:** false\n**Explanation:** The 0th customer cannot be given two different integers.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,3\\], quantity = \\[2\\]\n**Output:** true\n**Explanation:** The 0th customer is given \\[3,3\\]. The integers \\[1,2\\] are not used.\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,2,2\\], quantity = \\[2,2\\]\n**Output:** true\n**Explanation:** The 0th customer is given \\[1,1\\], and the 1st customer is given \\[2,2\\].\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 1000`\n*   `m == quantity.length`\n*   `1 <= m <= 10`\n*   `1 <= quantity[i] <= 105`\n*   There are at most `50` unique values in `nums`.\"\"\"\n\n\ndef canDistribute(nums, quantity):\n    counts = Counter(nums)\n    values = list(counts.values())\n    quantity.sort(reverse=True)\n\n    def dfs(index, values):\n        if index == len(quantity):\n            return True\n        for i in range(len(values)):\n            if values[i] >= quantity[index]:\n                values[i] -= quantity[index]\n                if dfs(index + 1, values):\n                    return True\n                values[i] += quantity[index]\n        return False\n\n    return dfs(0, values)"}}, "leetcode/leetcode_575.txt": {"score": 0.9389793872833252, "content": {"text": "def maxNumberOfCandies(candyType):\n    \"\"\"Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.\n\nThe doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n\nGiven the integer array `candyType` of length `n`, return _the **maximum** number of different types of candies she can eat if she only eats_ `n / 2` _of them_.\n\n**Example 1:**\n\n**Input:** candyType = \\[1,1,2,2,3,3\\]\n**Output:** 3\n**Explanation:** Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n\n**Example 2:**\n\n**Input:** candyType = \\[1,1,2,3\\]\n**Output:** 2\n**Explanation:** Alice can only eat 4 / 2 = 2 candies. Whether she eats types \\[1,2\\], \\[1,3\\], or \\[2,3\\], she still can only eat 2 different types.\n\n**Example 3:**\n\n**Input:** candyType = \\[6,6,6,6\\]\n**Output:** 1\n**Explanation:** Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.\n\n**Constraints:**\n\n*   `n == candyType.length`\n*   `2 <= n <= 104`\n*   `n` is even.\n*   `-105 <= candyType[i] <= 105`\"\"\"\n\n    uniqueCandies = set(candyType)\n    return min(len(uniqueCandies), len(candyType) // 2)"}}}}, "103": {"gold": {"leetcode/leetcode_2079.txt": 1}, "retrieved": {"leetcode/leetcode_2335.txt": {"score": 0.9291228652000427, "content": {"text": "def min_seconds(amount: List[int]) -> int:\n    \"\"\"You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up `2` cups with **different** types of water, or `1` cup of any type of water.\n\nYou are given a **0-indexed** integer array `amount` of length `3` where `amount[0]`, `amount[1]`, and `amount[2]` denote the number of cold, warm, and hot water cups you need to fill respectively. Return _the **minimum** number of seconds needed to fill up all the cups_.\n\n**Example 1:**\n\n**Input:** amount = \\[1,4,2\\]\n**Output:** 4\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.\n\n**Example 2:**\n\n**Input:** amount = \\[5,4,4\\]\n**Output:** 7\n**Explanation:** One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.\n\n**Example 3:**\n\n**Input:** amount = \\[5,0,0\\]\n**Output:** 5\n**Explanation:** Every second, we fill up a cold cup.\n\n**Constraints:**\n\n*   `amount.length == 3`\n*   `0 <= amount[i] <= 100`\"\"\"\n\n    total = sum(amount)\n    largest_two = max(amount[0] + amount[1], amount[1] + amount[2], amount[0] + amount[2])\n    return (total + 1) // 2 - (largest_two + 1) // 2 + largest_two"}}, "leetcode/leetcode_875.txt": {"score": 0.9292656183242798, "content": {"text": "def longest_mountain(arr):\n    \"\"\"Koko loves to eat bananas. There are `n` piles of bananas, the `ith` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.\n\n**Example 1:**\n\n**Input:** piles = \\[3,6,7,11\\], h = 8\n**Output:** 4\n\n**Example 2:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 5\n**Output:** 30\n\n**Example 3:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 6\n**Output:** 23\n\n**Constraints:**\n\n*   `1 <= piles.length <= 104`\n*   `piles.length <= h <= 109`\n*   `1 <= piles[i] <= 109`\"\"\"\n\n    n = len(arr)\n    max_length = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            left = i - 1\n            right = i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] > arr[right + 1]:\n                right += 1\n            max_length = max(max_length, right - left + 1)\n            i = right\n        else:\n            i += 1\n    return max_length"}}, "leetcode/leetcode_2106.txt": {"score": 0.9291634559631348, "content": {"text": "from math import gcd\n    \"\"\"Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\nReturn _the **maximum total number** of fruits you can harvest_.\n\n**Example 1:**\n\n**Input:** fruits = \\[\\[2,8\\],\\[6,3\\],\\[8,6\\]\\], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n**Example 2:**\n\n**Input:** fruits = \\[\\[0,9\\],\\[4,1\\],\\[5,7\\],\\[6,2\\],\\[7,4\\],\\[10,9\\]\\], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n**Example 3:**\n\n**Input:** fruits = \\[\\[0,3\\],\\[6,4\\],\\[8,5\\]\\], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `fruits[i].length == 2`\n*   `0 <= startPos, positioni <= 2 * 105`\n*   `positioni-1 < positioni` for any `i > 0` (**0-indexed**)\n*   `1 <= amounti <= 104`\n*   `0 <= k <= 2 * 105`\"\"\"\n\n\ndef findGCD(nums):\n    return gcd(min(nums), max(nums))"}}, "leetcode/leetcode_2244.txt": {"score": 0.9309250116348267, "content": {"text": "def numOfBeams(bank):\n    \"\"\"You are given a **0-indexed** integer array `tasks`, where `tasks[i]` represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the **same difficulty level**.\n\nReturn _the **minimum** rounds required to complete all the tasks, or_ `-1` _if it is not possible to complete all the tasks._\n\n**Example 1:**\n\n**Input:** tasks = \\[2,2,3,3,2,4,4,4,4,4\\]\n**Output:** 4\n**Explanation:** To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2. \n- In the second round, you complete 2 tasks of difficulty level 3. \n- In the third round, you complete 3 tasks of difficulty level 4. \n- In the fourth round, you complete 2 tasks of difficulty level 4.  \nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n\n**Example 2:**\n\n**Input:** tasks = \\[2,3,3\\]\n**Output:** -1\n**Explanation:** There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.\n\n**Constraints:**\n\n*   `1 <= tasks.length <= 105`\n*   `1 <= tasks[i] <= 109`\"\"\"\n\n    m = len(bank)\n    n = len(bank[0])\n    beams = 0\n\n    for i in range(m):\n        for j in range(n):\n            if bank[i][j] == '1':\n                k = j + 1\n                while k < n and bank[i][k] != '1':\n                    beams += bank[i][k] == '0'\n                    k += 1\n                k = i + 1\n                while k < m and bank[k][j] != '1':\n                    beams += bank[k][j] == '0'\n                    k += 1\n\n    return beams"}}, "leetcode/leetcode_2279.txt": {"score": 0.9352985620498657, "content": {"text": "def max_unique_even_sum(final_sum):\n    \"\"\"You have `n` bags numbered from `0` to `n - 1`. You are given two **0-indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in **any** of the bags.\n\nReturn _the **maximum** number of bags that could have full capacity after placing the additional rocks in some bags._\n\n**Example 1:**\n\n**Input:** capacity = \\[2,3,4,5\\], rocks = \\[1,2,4,4\\], additionalRocks = 2\n**Output:** 3\n**Explanation:**\nPlace 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now \\[2,3,4,4\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3.\n\n**Example 2:**\n\n**Input:** capacity = \\[10,2,2\\], rocks = \\[2,2,0\\], additionalRocks = 100\n**Output:** 3\n**Explanation:**\nPlace 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now \\[10,2,2\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks.\n\n**Constraints:**\n\n*   `n == capacity.length == rocks.length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= capacity[i] <= 109`\n*   `0 <= rocks[i] <= capacity[i]`\n*   `1 <= additionalRocks <= 109`\"\"\"\n\n    result = []\n    current = 2\n    while final_sum > 0:\n        if final_sum >= current:\n            result.append(current)\n            final_sum -= current\n            current += 2\n        else:\n            break\n    return result"}}, "leetcode/leetcode_2079.txt": {"score": 0.9552105069160461, "content": {"text": "from collections import defaultdict\n    \"\"\"You want to water `n` plants in your garden with a watering can. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`. There is a river at `x = -1` that you can refill your watering can at.\n\nEach plant needs a specific amount of water. You will water the plants in the following way:\n\n*   Water the plants in order from left to right.\n*   After watering the current plant, if you do not have enough water to **completely** water the next plant, return to the river to fully refill the watering can.\n*   You **cannot** refill the watering can early.\n\nYou are initially at the river (i.e., `x = -1`). It takes **one step** to move **one unit** on the x-axis.\n\nGiven a **0-indexed** integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and an integer `capacity` representing the watering can capacity, return _the **number of steps** needed to water all the plants_.\n\n**Example 1:**\n\n**Input:** plants = \\[2,2,3,3\\], capacity = 5\n**Output:** 14\n**Explanation:** Start at the river with a full watering can:\n- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.\n- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.\n- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).\n- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.\n- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).\n- Walk to plant 3 (4 steps) and water it.\nSteps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.\n\n**Example 2:**\n\n**Input:** plants = \\[1,1,1,4,2,3\\], capacity = 4\n**Output:** 30\n**Explanation:** Start at the river with a full watering can:\n- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).\n- Water plant 3 (4 steps). Return to river (4 steps).\n- Water plant 4 (5 steps). Return to river (5 steps).\n- Water plant 5 (6 steps).\nSteps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.\n\n**Example 3:**\n\n**Input:** plants = \\[7,7,7,7,7,7,7\\], capacity = 8\n**Output:** 49\n**Explanation:** You have to refill before watering each plant.\nSteps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.\n\n**Constraints:**\n\n*   `n == plants.length`\n*   `1 <= n <= 1000`\n*   `1 <= plants[i] <= 106`\n*   `max(plants[i]) <= capacity <= 109`\"\"\"\n\n\ndef deleteDuplicateFolder(paths):\n    graph = defaultdict(set)\n    count = defaultdict(int)\n\n    for path in paths:\n        serialized_path = \"\"\n        for folder in path:\n            serialized_path += \"/\" + folder\n            graph[serialized_path].add(folder)\n\n    for value in graph.values():\n        count[str(value)] += 1\n\n    ans = []\n    for path in paths:\n        serialized_path = \"\"\n        duplicate = False\n        for folder in path:\n            serialized_path += \"/\" + folder\n            if count[str(graph[serialized_path])] > 1:\n                duplicate = True\n                break\n        if not duplicate:\n            ans.append(path)\n\n    return ans"}}, "leetcode/leetcode_853.txt": {"score": 0.9299357533454895, "content": {"text": "def max_profit_assignment(difficulty, profit, worker):\n    \"\"\"There are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\n\nYou are given two integer array `position` and `speed`, both of length `n`, where `position[i]` is the position of the `ith` car and `speed[i]` is the speed of the `ith` car (in miles per hour).\n\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper **at the same speed**. The faster car will **slow down** to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n\nA **car fleet** is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\n\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\n\nReturn _the **number of car fleets** that will arrive at the destination_.\n\n**Example 1:**\n\n**Input:** target = 12, position = \\[10,8,0,5,3\\], speed = \\[2,4,1,1,3\\]\n**Output:** 3\n**Explanation:**\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\nNote that no other cars meet these fleets before the destination, so the answer is 3.\n\n**Example 2:**\n\n**Input:** target = 10, position = \\[3\\], speed = \\[3\\]\n**Output:** 1\n**Explanation:** There is only one car, hence there is only one fleet.\n\n**Example 3:**\n\n**Input:** target = 100, position = \\[0,2,4\\], speed = \\[4,2,1\\]\n**Output:** 1\n**Explanation:**\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n\n**Constraints:**\n\n*   `n == position.length == speed.length`\n*   `1 <= n <= 105`\n*   `0 < target <= 106`\n*   `0 <= position[i] < target`\n*   All the values of `position` are **unique**.\n*   `0 < speed[i] <= 106`\"\"\"\n\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    i, max_profit, total_profit = 0, 0, 0\n    for ability in worker:\n        while i < len(difficulty) and ability >= jobs[i][0]:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        total_profit += max_profit\n    return total_profit"}}, "leetcode/leetcode_2105.txt": {"score": 0.9635778665542603, "content": {"text": "def numberOfGoodSubsets(nums: list[int]) -> int:\n    \"\"\"Alice and Bob want to water `n` plants in their garden. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`.\n\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, **initially full**. They water the plants in the following way:\n\n*   Alice waters the plants in order from **left to right**, starting from the `0th` plant. Bob waters the plants in order from **right to left**, starting from the `(n - 1)th` plant. They begin watering the plants **simultaneously**.\n*   It takes the same amount of time to water each plant regardless of how much water it needs.\n*   Alice/Bob **must** water the plant if they have enough in their can to **fully** water it. Otherwise, they **first** refill their can (instantaneously) then water the plant.\n*   In case both Alice and Bob reach the same plant, the one with **more** water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a **0-indexed** integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and two integers `capacityA` and `capacityB` representing the capacities of Alice's and Bob's watering cans respectively, return _the **number of times** they have to refill to water all the plants_.\n\n**Example 1:**\n\n**Input:** plants = \\[2,2,3,3\\], capacityA = 5, capacityB = 5\n**Output:** 1\n**Explanation:**\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.\n\n**Example 2:**\n\n**Input:** plants = \\[2,2,3,3\\], capacityA = 3, capacityB = 4\n**Output:** 2\n**Explanation:**\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.\n\n**Example 3:**\n\n**Input:** plants = \\[5\\], capacityA = 10, capacityB = 8\n**Output:** 0\n**Explanation:**\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0.\n\n**Constraints:**\n\n*   `n == plants.length`\n*   `1 <= n <= 105`\n*   `1 <= plants[i] <= 106`\n*   `max(plants[i]) <= capacityA, capacityB <= 109`\"\"\"\n\n    MOD = 10**9 + 7\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, 91) if is_prime(i)]\n    cnt = [0] * 100\n    for n in nums:\n        cnt[n] += 1\n\n    dp = [0] * (1 << 20)\n    dp[0] = 1\n    \n    for i in range(30, 0, -1):\n        if cnt[i] == 0:\n            continue\n        mask = [j for j in primes if i % j == 0]\n        i = i // j\n        if i > 1:\n            continue\n\n        m = 0\n        for j in mask:\n            m |= 1 << (j - 2)\n\n        for j in range(len(dp)-1, -1, -1):\n            if dp[j] == 0:\n                continue\n            cur = 1\n            for k in range(cnt[m]):\n                cur = (cur * 2) % MOD\n                dp[j | m] = (dp[j | m] + dp[j] * cur) % MOD\n\n    ans = sum(dp) % MOD\n    ans = (ans - dp[0] + MOD) % MOD\n    return (ans * (1 << (cnt[1] - 1))) % MOD"}}, "leetcode/leetcode_2141.txt": {"score": 0.9451276659965515, "content": {"text": "def max_computer_runtime(n, batteries):\n    \"\"\"You have `n` computers. You are given the integer `n` and a **0-indexed** integer array `batteries` where the `ith` battery can **run** a computer for `batteries[i]` minutes. You are interested in running **all** `n` computers **simultaneously** using the given batteries.\n\nInitially, you can insert **at most one battery** into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery **any number of times**. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\nNote that the batteries cannot be recharged.\n\nReturn _the **maximum** number of minutes you can run all the_ `n` _computers simultaneously._\n\n**Example 1:**\n\n**Input:** n = 2, batteries = \\[3,3,3\\]\n**Output:** 4\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n**Example 2:**\n\n**Input:** n = 2, batteries = \\[1,1,1,1\\]\n**Output:** 2\n**Explanation:** \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.\n\n**Constraints:**\n\n*   `1 <= n <= batteries.length <= 105`\n*   `1 <= batteries[i] <= 109`\"\"\"\n\n    batteries.sort()\n    result = 0\n    for i in range(len(batteries)):\n        result = max(result, min(n, len(batteries) - i) * batteries[i])\n    return result"}}, "leetcode/leetcode_1921.txt": {"score": 0.9461121559143066, "content": {"text": "def eliminate_maximum(dist, speed):\n    \"\"\"You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0-indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city.\n\nThe monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute.\n\nYou have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge.The weapon is fully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon.\n\nReturn _the **maximum** number of monsters that you can eliminate before you lose, or_ `n` _if you can eliminate all the monsters before they reach the city._\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,4\\], speed = \\[1,1,1\\]\n**Output:** 3\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,3,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,2,3\\]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are \\[X,X,2\\]. You eliminate the thrid monster.\nAll 3 monsters can be eliminated.\n\n**Example 2:**\n\n**Input:** dist = \\[1,1,2,3\\], speed = \\[1,1,1,1\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,1,2,3\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,1,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Example 3:**\n\n**Input:** dist = \\[3,2,4\\], speed = \\[5,3,2\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[3,2,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Constraints:**\n\n*   `n == dist.length == speed.length`\n*   `1 <= n <= 105`\n*   `1 <= dist[i], speed[i] <= 105`\"\"\"\n\n    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated"}}}}, "104": {"gold": {"leetcode/leetcode_1383.txt": 1}, "retrieved": {"leetcode/leetcode_1340.txt": {"score": 0.9256851077079773, "content": {"text": "import threading\n    \"\"\"Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:\n\n*   `i + x` where: `i + x < arr.length` and `0 < x <= d`.\n*   `i - x` where: `i - x >= 0` and `0 < x <= d`.\n\nIn addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).\n\nYou can choose any index of the array and start jumping. Return _the maximum number of indices_ you can visit.\n\nNotice that you can not jump outside of the array at any time.\n\n**Example 1:**\n\n**Input:** arr = \\[6,4,14,6,8,13,9,7,10,6,12\\], d = 2\n**Output:** 4\n**Explanation:** You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\nNote that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\nSimilarly You cannot jump from index 3 to index 2 or index 1.\n\n**Example 2:**\n\n**Input:** arr = \\[3,3,3,3,3\\], d = 3\n**Output:** 1\n**Explanation:** You can start at any index. You always cannot jump to any index.\n\n**Example 3:**\n\n**Input:** arr = \\[7,6,5,4,3,2,1\\], d = 1\n**Output:** 7\n**Explanation:** Start at index 0. You can visit all the indicies. \n\n**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 105`\n*   `1 <= d <= arr.length`\"\"\"\n\n\nclass DiningPhilosophers:\n    def __init__(self):\n        self.forks = [threading.Lock() for _ in range(5)]\n        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]\n\n    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:\n        left_fork = philosopher\n        right_fork = (philosopher + 1) % 5\n\n        with self.forks[left_fork]:\n            with self.not_busy[left_fork]:\n                while not self.forks[right_fork].acquire(blocking=False):\n                    self.not_busy[left_fork].wait()\n            pickLeftFork()\n\n            with self.forks[right_fork]:\n                pickRightFork()\n                eat()\n                putRightFork()\n                self.forks[right_fork].release()\n                with self.not_busy[right_fork]:\n                    self.not_busy[right_fork].notify_all()\n\n            putLeftFork()\n            self.not_busy[left_fork].notify_all()"}}, "leetcode/leetcode_2008.txt": {"score": 0.9262306094169617, "content": {"text": "def minOperationsToFlip(expression: str) -> int:\n    \"\"\"There are `n` points on a road you are driving your taxi on. The `n` points on the road are labeled from `1` to `n` in the direction you are going, and you want to drive from point `1` to point `n` to make money by picking up passengers. You cannot change the direction of the taxi.\n\nThe passengers are represented by a **0-indexed** 2D integer array `rides`, where `rides[i] = [starti, endi, tipi]` denotes the `ith` passenger requesting a ride from point `starti` to point `endi` who is willing to give a `tipi` dollar tip.\n\nFor **each** passenger `i` you pick up, you **earn** `endi - starti + tipi` dollars. You may only drive **at most one** passenger at a time.\n\nGiven `n` and `rides`, return _the **maximum** number of dollars you can earn by picking up the passengers optimally._\n\n**Note:** You may drop off a passenger and pick up a different passenger at the same point.\n\n**Example 1:**\n\n**Input:** n = 5, rides = \\[\\[2,5,4\\],\\[1,5,1\\]\\]\n**Output:** 7\n**Explanation:** We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.\n\n**Example 2:**\n\n**Input:** n = 20, rides = \\[\\[1,6,1\\],\\[3,10,2\\],\\[10,12,3\\],\\[11,12,2\\],\\[12,15,2\\],\\[13,18,1\\]\\]\n**Output:** 20\n**Explanation:** We will pick up the following passengers:\n- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.\n- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.\n- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.\nWe earn 9 + 5 + 6 = 20 dollars in total.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= rides.length <= 3 * 104`\n*   `rides[i].length == 3`\n*   `1 <= starti < endi <= n`\n*   `1 <= tipi <= 105`\"\"\"\n\n    zero, one, op = [0], [0], []\n    for c in expression:\n        if c == '&':\n            op.append(1)\n        elif c == '|':\n            op.append(2)\n        elif c.isdigit():\n            if c == '0':\n                one.append(1)\n                zero.append(0)\n            else:\n                zero.append(1)\n                one.append(0)\n        elif c == ')':\n            cur_op = op.pop()\n            x = zero.pop()\n            y = one.pop() + 1\n            if cur_op == 1:\n                new_zero = max(x, y)\n                new_one = one[-1] + min(x, zero[-1])\n            else:\n                new_zero = zero[-1] + min(x, one[-1])\n                new_one = max(y, one[-1])\n            zero.pop()\n            one.pop()\n            zero.append(new_zero)\n            one.append(new_one)\n    return zero[-1] + 1"}}, "leetcode/leetcode_875.txt": {"score": 0.9278227090835571, "content": {"text": "def longest_mountain(arr):\n    \"\"\"Koko loves to eat bananas. There are `n` piles of bananas, the `ith` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.\n\n**Example 1:**\n\n**Input:** piles = \\[3,6,7,11\\], h = 8\n**Output:** 4\n\n**Example 2:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 5\n**Output:** 30\n\n**Example 3:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 6\n**Output:** 23\n\n**Constraints:**\n\n*   `1 <= piles.length <= 104`\n*   `piles.length <= h <= 109`\n*   `1 <= piles[i] <= 109`\"\"\"\n\n    n = len(arr)\n    max_length = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            left = i - 1\n            right = i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] > arr[right + 1]:\n                right += 1\n            max_length = max(max_length, right - left + 1)\n            i = right\n        else:\n            i += 1\n    return max_length"}}, "leetcode/leetcode_1537.txt": {"score": 0.9316135048866272, "content": {"text": "def maxScore(s):\n    \"\"\"You are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid path** is defined as follows:\n\n*   Choose array `nums1` or `nums2` to traverse (from index-0).\n*   Traverse the current array from left to right.\n*   If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,4,5,8,10\\], nums2 = \\[4,6,8,9\\]\n**Output:** 30\n**Explanation:** Valid paths:\n\\[2,4,5,8,10\\], \\[2,4,5,8,9\\], \\[2,4,6,8,9\\], \\[2,4,6,8,10\\],  (starting from nums1)\n\\[4,6,8,9\\], \\[4,5,8,10\\], \\[4,5,8,9\\], \\[4,6,8,10\\]    (starting from nums2)\nThe maximum is obtained with the path in green **\\[2,4,6,8,10\\]**.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,3,5,7,9\\], nums2 = \\[3,5,100\\]\n**Output:** 109\n**Explanation:** Maximum sum is obtained with the path **\\[1,3,5,100\\]**.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[6,7,8,9,10\\]\n**Output:** 40\n**Explanation:** There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path \\[6,7,8,9,10\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 107`\n*   `nums1` and `nums2` are strictly increasing.\"\"\"\n\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score"}}, "leetcode/leetcode_1770.txt": {"score": 0.926331639289856, "content": {"text": "def min_deletions(s):\n    \"\"\"You are given two **0-indexed** integer arrays `nums` and `multipliers` of size `n` and `m` respectively, where `n >= m`.\n\nYou begin with a score of `0`. You want to perform **exactly** `m` operations. On the `ith` operation (**0-indexed**) you will:\n\n*   Choose one integer `x` from **either the start or the end** of the array `nums`.\n*   Add `multipliers[i] * x` to your score.\n    *   Note that `multipliers[0]` corresponds to the first operation, `multipliers[1]` to the second operation, and so on.\n*   Remove `x` from `nums`.\n\nReturn _the **maximum** score after performing_ `m` _operations._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], multipliers = \\[3,2,1\\]\n**Output:** 14\n**Explanation:** An optimal solution is as follows:\n- Choose from the end, \\[1,2,**3**\\], adding 3 \\* 3 = 9 to the score.\n- Choose from the end, \\[1,**2**\\], adding 2 \\* 2 = 4 to the score.\n- Choose from the end, \\[**1**\\], adding 1 \\* 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14.\n\n**Example 2:**\n\n**Input:** nums = \\[-5,-3,-3,-2,7,1\\], multipliers = \\[-10,-5,3,4,6\\]\n**Output:** 102\n**Explanation:** An optimal solution is as follows:\n- Choose from the start, \\[**\\-5**,-3,-3,-2,7,1\\], adding -5 \\* -10 = 50 to the score.\n- Choose from the start, \\[**\\-3**,-3,-2,7,1\\], adding -3 \\* -5 = 15 to the score.\n- Choose from the start, \\[**\\-3**,-2,7,1\\], adding -3 \\* 3 = -9 to the score.\n- Choose from the end, \\[-2,7,**1**\\], adding 1 \\* 4 = 4 to the score.\n- Choose from the end, \\[-2,**7**\\], adding 7 \\* 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `m == multipliers.length`\n*   `1 <= m <= 300`\n*   `m <= n <= 105`\n*   `-1000 <= nums[i], multipliers[i] <= 1000`\"\"\"\n\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions"}}, "leetcode/leetcode_1696.txt": {"score": 0.9492312669754028, "content": {"text": "def isPrintable(targetGrid):\n    \"\"\"You are given a **0-indexed** integer array `nums` and an integer `k`.\n\nYou are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n - 1, i + k)]` **inclusive**.\n\nYou want to reach the last index of the array (index `n - 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array.\n\nReturn _the **maximum score** you can get_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,\\-1,-2,4,-7,3\\], k = 2\n**Output:** 7\n**Explanation:** You can choose your jumps forming the subsequence \\[1,-1,4,3\\] (underlined above). The sum is 7.\n\n**Example 2:**\n\n**Input:** nums = \\[10,-5,-2,4,0,3\\], k = 3\n**Output:** 17\n**Explanation:** You can choose your jumps forming the subsequence \\[10,4,3\\] (underlined above). The sum is 17.\n\n**Example 3:**\n\n**Input:** nums = \\[1,-5,-20,4,-1,3,-6,-3\\], k = 2\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length, k <= 105`\n*   `-104 <= nums[i] <= 104`\"\"\"\n\n    m, n = len(targetGrid), len(targetGrid[0])\n    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61\n    vis = [[False]*n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            c = targetGrid[i][j]\n            top[c] = min(top[c], i)\n            bottom[c] = max(bottom[c], i)\n            left[c] = min(left[c], j)\n            right[c] = max(right[c], j)\n\n    def dfs(x):\n        i, j = x // n, x % n\n        if vis[i][j]: return True\n        c = targetGrid[i][j]\n        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False\n        vis[i][j] = True\n        for k in range(1, 61):\n            if k == c: continue\n            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False\n            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False\n        return True\n\n    for color in range(1, 61):\n        for i in range(top[color], bottom[color] + 1):\n            for j in range(left[color], right[color] + 1):\n                if not vis[i][j] and not dfs(i * n + j): return False\n\n    return True"}}, "leetcode/leetcode_1140.txt": {"score": 0.9284199476242065, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`\"\"\"\n\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes"}}, "leetcode/leetcode_2106.txt": {"score": 0.9763182401657104, "content": {"text": "from math import gcd\n    \"\"\"Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\nReturn _the **maximum total number** of fruits you can harvest_.\n\n**Example 1:**\n\n**Input:** fruits = \\[\\[2,8\\],\\[6,3\\],\\[8,6\\]\\], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n**Example 2:**\n\n**Input:** fruits = \\[\\[0,9\\],\\[4,1\\],\\[5,7\\],\\[6,2\\],\\[7,4\\],\\[10,9\\]\\], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n**Example 3:**\n\n**Input:** fruits = \\[\\[0,3\\],\\[6,4\\],\\[8,5\\]\\], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `fruits[i].length == 2`\n*   `0 <= startPos, positioni <= 2 * 105`\n*   `positioni-1 < positioni` for any `i > 0` (**0-indexed**)\n*   `1 <= amounti <= 104`\n*   `0 <= k <= 2 * 105`\"\"\"\n\n\ndef findGCD(nums):\n    return gcd(min(nums), max(nums))"}}, "leetcode/leetcode_2511.txt": {"score": 0.9335362911224365, "content": {"text": "def max_captured_forts(forts):\n    \"\"\"You are given a **0-indexed** integer array `forts` of length `n` representing the positions of several forts. `forts[i]` can be `-1`, `0`, or `1` where:\n\n*   `-1` represents there is **no fort** at the `ith` position.\n*   `0` indicates there is an **enemy** fort at the `ith` position.\n*   `1` indicates the fort at the `ith` the position is under your command.\n\nNow you have decided to move your army from one of your forts at position `i` to an empty position `j` such that:\n\n*   `0 <= i, j <= n - 1`\n*   The army travels over enemy forts **only**. Formally, for all `k` where `min(i,j) < k < max(i,j)`, `forts[k] == 0.`\n\nWhile moving the army, all the enemy forts that come in the way are **captured**.\n\nReturn _the **maximum** number of enemy forts that can be captured_. In case it is **impossible** to move your army, or you do not have any fort under your command, return `0`_._\n\n**Example 1:**\n\n**Input:** forts = \\[1,0,0,-1,0,0,0,0,1\\]\n**Output:** 4\n**Explanation:**\n- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n- Moving the army from position 8 to position 3 captures 4 enemy forts.\nSince 4 is the maximum number of enemy forts that can be captured, we return 4.\n\n**Example 2:**\n\n**Input:** forts = \\[0,0,1,-1\\]\n**Output:** 0\n**Explanation:** Since no enemy fort can be captured, 0 is returned.\n\n**Constraints:**\n\n*   `1 <= forts.length <= 1000`\n*   `-1 <= forts[i] <= 1`\"\"\"\n\n    n = len(forts)\n    max_capture = 0\n    for i in range(n):\n        if forts[i] == 1:\n            for j in range(i+1, n):\n                if forts[j] != -1:\n                    capture = sum(1 for k in range(i+1, j) if forts[k] == 0)\n                    if forts[j] == 1:\n                        max_capture = max(max_capture, capture)\n    return max_capture"}}, "leetcode/leetcode_1642.txt": {"score": 0.9405890107154846, "content": {"text": "def maxWaterBottles(numBottles: int, numExchange: int) -> int:\n    \"\"\"You are given an integer array `heights` representing the heights of buildings, some `bricks`, and some `ladders`.\n\nYou start your journey from building `0` and move to the next building by possibly using bricks or ladders.\n\nWhile moving from building `i` to building `i+1` (**0-indexed**),\n\n*   If the current building's height is **greater than or equal** to the next building's height, you do **not** need a ladder or bricks.\n*   If the current building's height is **less than** the next building's height, you can either use **one ladder** or `(h[i+1] - h[i])` **bricks**.\n\n_Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally._\n\n**Example 1:**\n\n**Input:** heights = \\[4,2,7,6,9,14,12\\], bricks = 5, ladders = 1\n**Output:** 4\n**Explanation:** Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n**Example 2:**\n\n**Input:** heights = \\[4,12,2,7,3,18,20,3,19\\], bricks = 10, ladders = 2\n**Output:** 7\n\n**Example 3:**\n\n**Input:** heights = \\[14,3,19,3\\], bricks = 17, ladders = 0\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `1 <= heights[i] <= 106`\n*   `0 <= bricks <= 109`\n*   `0 <= ladders <= heights.length`\"\"\"\n\n    total = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        total += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return total"}}}}, "105": {"gold": {"leetcode/leetcode_713.txt": 1, "leetcode/leetcode_2348.txt": 1}, "retrieved": {"leetcode/leetcode_875.txt": {"score": 0.9032178521156311, "content": {"text": "def longest_mountain(arr):\n    \"\"\"Koko loves to eat bananas. There are `n` piles of bananas, the `ith` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.\n\n**Example 1:**\n\n**Input:** piles = \\[3,6,7,11\\], h = 8\n**Output:** 4\n\n**Example 2:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 5\n**Output:** 30\n\n**Example 3:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 6\n**Output:** 23\n\n**Constraints:**\n\n*   `1 <= piles.length <= 104`\n*   `piles.length <= h <= 109`\n*   `1 <= piles[i] <= 109`\"\"\"\n\n    n = len(arr)\n    max_length = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            left = i - 1\n            right = i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] > arr[right + 1]:\n                right += 1\n            max_length = max(max_length, right - left + 1)\n            i = right\n        else:\n            i += 1\n    return max_length"}}, "leetcode/leetcode_2357.txt": {"score": 0.9048478007316589, "content": {"text": "def minOperations(nums):\n    \"\"\"You are given a non-negative integer array `nums`. In one operation, you must:\n\n*   Choose a positive integer `x` such that `x` is less than or equal to the **smallest non-zero** element in `nums`.\n*   Subtract `x` from every **positive** element in `nums`.\n\nReturn _the **minimum** number of operations to make every element in_ `nums` _equal to_ `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,0,3,5\\]\n**Output:** 3\n**Explanation:**\nIn the first operation, choose x = 1. Now, nums = \\[0,4,0,2,4\\].\nIn the second operation, choose x = 2. Now, nums = \\[0,2,0,0,2\\].\nIn the third operation, choose x = 2. Now, nums = \\[0,0,0,0,0\\].\n\n**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** 0\n**Explanation:** Each element in nums is already 0 so no operations are needed.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`\"\"\"\n\n    count = 0\n    nums.sort()\n    i = 0\n\n    while i < len(nums):\n        if nums[i] > 0:\n            target = nums[i]\n            while i < len(nums) and nums[i] == target:\n                i += 1\n            count += 1\n        else:\n            i += 1\n\n    return count"}}, "leetcode/leetcode_2274.txt": {"score": 0.9039802551269531, "content": {"text": "def final_value(nums, original):\n    \"\"\"Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.\n\nYou are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.\n\nReturn _the **maximum** number of consecutive floors without a special floor_.\n\n**Example 1:**\n\n**Input:** bottom = 2, top = 9, special = \\[4,6\\]\n**Output:** 3\n**Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors.\n\n**Example 2:**\n\n**Input:** bottom = 6, top = 8, special = \\[7,6,8\\]\n**Output:** 0\n**Explanation:** Every floor rented is a special floor, so we return 0.\n\n**Constraints:**\n\n*   `1 <= special.length <= 105`\n*   `1 <= bottom <= special[i] <= top <= 109`\n*   All the values of `special` are **unique**.\"\"\"\n\n    while original in nums:\n        original += 1\n    return original"}}, "leetcode/leetcode_2420.txt": {"score": 0.913762629032135, "content": {"text": "def find_good_indices(nums, k):\n    \"\"\"You are given a **0-indexed** integer array `nums` of size `n` and a positive integer `k`.\n\nWe call an index `i` in the range `k <= i < n - k` **good** if the following conditions are satisfied:\n\n*   The `k` elements that are just **before** the index `i` are in **non-increasing** order.\n*   The `k` elements that are just **after** the index `i` are in **non-decreasing** order.\n\nReturn _an array of all good indices sorted in **increasing** order_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,1,1,1,3,4,1\\], k = 2\n**Output:** \\[2,3\\]\n**Explanation:** There are two good indices in the array:\n- Index 2. The subarray \\[2,1\\] is in non-increasing order, and the subarray \\[1,3\\] is in non-decreasing order.\n- Index 3. The subarray \\[1,1\\] is in non-increasing order, and the subarray \\[3,4\\] is in non-decreasing order.\nNote that the index 4 is not good because \\[4,1\\] is not non-decreasing.\n\n**Example 2:**\n\n**Input:** nums = \\[2,1,1,2\\], k = 2\n**Output:** \\[\\]\n**Explanation:** There are no good indices in this array.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `3 <= n <= 105`\n*   `1 <= nums[i] <= 106`\n*   `1 <= k <= n / 2`\"\"\"\n\n    good_indices = []\n    for i in range(k, len(nums) - k):\n        left_non_inc = all(nums[i - j - 1] >= nums[i - j - 2] for j in range(k - 1))\n        right_non_dec = all(nums[i + j + 1] >= nums[i + j + 2] for j in range(k - 1))\n\n        if left_non_inc and right_non_dec:\n            good_indices.append(i)\n\n    return good_indices"}}, "leetcode/leetcode_1224.txt": {"score": 0.9132547378540039, "content": {"text": "def minFallingPathSum(grid):\n    \"\"\"Given an array `nums` of positive integers, return the longest possible length of an array prefix of `nums`, such that it is possible to remove **exactly one** element from this prefix so that every number that has appeared in it will have the same number of occurrences.\n\nIf after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).\n\n**Example 1:**\n\n**Input:** nums = \\[2,2,1,1,5,3,3,5\\]\n**Output:** 7\n**Explanation:** For the subarray \\[2,2,1,1,5,3,3\\] of length 7, if we remove nums\\[4\\] = 5, we will get \\[2,2,1,1,3,3\\], so that each number will appear exactly twice.\n\n**Example 2:**\n\n**Input:** nums = \\[1,1,1,2,2,2,3,3,3,4,4,4,5\\]\n**Output:** 13\n\n**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`\"\"\"\n\n    n = len(grid)\n    for i in range(1, n):\n        for j in range(n):\n            minVal = float('inf')\n            for k in range(n):\n                if k == j:\n                    continue\n                minVal = min(minVal, grid[i - 1][k])\n            grid[i][j] += minVal\n    return min(grid[n - 1])"}}, "leetcode/leetcode_1475.txt": {"score": 0.910487174987793, "content": {"text": "class TreeNode:\n    \"\"\"You are given an integer array `prices` where `prices[i]` is the price of the `ith` item in a shop.\n\nThere is a special discount for items in the shop. If you buy the `ith` item, then you will receive a discount equivalent to `prices[j]` where `j` is the minimum index such that `j > i` and `prices[j] <= prices[i]`. Otherwise, you will not receive any discount at all.\n\nReturn an integer array `answer` where `answer[i]` is the final price you will pay for the `ith` item of the shop, considering the special discount.\n\n**Example 1:**\n\n**Input:** prices = \\[8,4,6,2,3\\]\n**Output:** \\[4,2,4,2,3\\]\n**Explanation:** \nFor item 0 with price\\[0\\]=8 you will receive a discount equivalent to prices\\[1\\]=4, therefore, the final price you will pay is 8 - 4 = 4.\nFor item 1 with price\\[1\\]=4 you will receive a discount equivalent to prices\\[3\\]=2, therefore, the final price you will pay is 4 - 2 = 2.\nFor item 2 with price\\[2\\]=6 you will receive a discount equivalent to prices\\[3\\]=2, therefore, the final price you will pay is 6 - 2 = 4.\nFor items 3 and 4 you will not receive any discount at all.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** \\[1,2,3,4,5\\]\n**Explanation:** In this case, for all items, you will not receive any discount at all.\n\n**Example 3:**\n\n**Input:** prices = \\[10,1,1,6\\]\n**Output:** \\[9,0,1,6\\]\n\n**Constraints:**\n\n*   `1 <= prices.length <= 500`\n*   `1 <= prices[i] <= 1000`\n\nThe left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees.\"\"\"\n\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef maxSumBST(root):\n    def helper(node):\n        if not node:\n            return float('inf'), float('-inf'), 0, True\n\n        left_min, left_max, left_sum, is_left_bst = helper(node.left)\n        right_min, right_max, right_sum, is_right_bst = helper(node.right)\n\n        if is_left_bst and is_right_bst and node.val > left_max and node.val < right_min:\n            sum_ = node.val + left_sum + right_sum\n            max_sum[0] = max(max_sum[0], sum_)\n            return min(node.val, left_min), max(node.val, right_max), sum_, True\n\n        return 0, 0, 0, False\n\n    max_sum = [0]\n    helper(root)\n    return max_sum[0]"}}, "leetcode/leetcode_1658.txt": {"score": 0.9058968424797058, "content": {"text": "def min_swaps(grid):\n    \"\"\"You are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn _the **minimum number** of operations to reduce_ `x` _to **exactly**_ `0` _if it is possible__, otherwise, return_ `-1`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,4,2,3\\], x = 5\n**Output:** 2\n**Explanation:** The optimal solution is to remove the last two elements to reduce x to zero.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,7,8,9\\], x = 4\n**Output:** -1\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,20,1,1,3\\], x = 10\n**Output:** 5\n**Explanation:** The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`\n*   `1 <= x <= 109`\"\"\"\n\n    n = len(grid)\n    row_zeros = [0] * n\n    \n    for i in range(n):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j] == 0:\n                row_zeros[i] += 1\n            else:\n                break\n    \n    steps = 0\n    for i in range(n):\n        target = n - i - 1\n        current_row = i\n        while current_row < n and row_zeros[current_row] < target:\n            current_row += 1\n        if current_row == n:\n            return -1\n        steps += current_row - i\n        row_zeros.pop(current_row)\n        row_zeros.insert(i, target)\n    \n    return steps"}}, "leetcode/leetcode_2100.txt": {"score": 0.9196183681488037, "content": {"text": "def minNonZeroProduct(p):\n    \"\"\"You and a gang of thieves are planning on robbing a bank. You are given a **0-indexed** integer array `security`, where `security[i]` is the number of guards on duty on the `ith` day. The days are numbered starting from `0`. You are also given an integer `time`.\n\nThe `ith` day is a good day to rob the bank if:\n\n*   There are at least `time` days before and after the `ith` day,\n*   The number of guards at the bank for the `time` days **before** `i` are **non-increasing**, and\n*   The number of guards at the bank for the `time` days **after** `i` are **non-decreasing**.\n\nMore formally, this means day `i` is a good day to rob the bank if and only if `security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time]`.\n\nReturn _a list of **all** days **(0-indexed)** that are good days to rob the bank_. _The order that the days are returned in does **not** matter._\n\n**Example 1:**\n\n**Input:** security = \\[5,3,3,3,5,6,2\\], time = 2\n**Output:** \\[2,3\\]\n**Explanation:**\nOn day 2, we have security\\[0\\] >= security\\[1\\] >= security\\[2\\] <= security\\[3\\] <= security\\[4\\].\nOn day 3, we have security\\[1\\] >= security\\[2\\] >= security\\[3\\] <= security\\[4\\] <= security\\[5\\].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.\n\n**Example 2:**\n\n**Input:** security = \\[1,1,1,1,1\\], time = 0\n**Output:** \\[0,1,2,3,4\\]\n**Explanation:**\nSince time equals 0, every day is a good day to rob the bank, so return every day.\n\n**Example 3:**\n\n**Input:** security = \\[1,2,3,4,5,6\\], time = 2\n**Output:** \\[\\]\n**Explanation:**\nNo day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list.\n\n**Constraints:**\n\n*   `1 <= security.length <= 105`\n*   `0 <= security[i], time <= 105`\"\"\"\n\n    MOD = 10**9 + 7\n    prod = 1\n    a = (1 << p) - 2\n    b = ((1 << p) - 1) % MOD\n       \n    while a > 0:\n        if a % 2:\n            prod = (prod * b) % MOD\n        b = (b * b) % MOD\n        a //= 2\n    return prod"}}, "leetcode/leetcode_1574.txt": {"score": 0.9207020998001099, "content": {"text": "def findLengthOfShortestSubarray(arr):\n    \"\"\"Given an integer array `arr`, remove a subarray (can be empty) from `arr` such that the remaining elements in `arr` are **non-decreasing**.\n\nReturn _the length of the shortest subarray to remove_.\n\nA **subarray** is a contiguous subsequence of the array.\n\n**Example 1:**\n\n**Input:** arr = \\[1,2,3,10,4,2,3,5\\]\n**Output:** 3\n**Explanation:** The shortest subarray we can remove is \\[10,4,2\\] of length 3. The remaining elements after that will be \\[1,2,3,3,5\\] which are sorted.\nAnother correct solution is to remove the subarray \\[3,10,4\\].\n\n**Example 2:**\n\n**Input:** arr = \\[5,4,3,2,1\\]\n**Output:** 4\n**Explanation:** Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either \\[5,4,3,2\\] or \\[4,3,2,1\\].\n\n**Example 3:**\n\n**Input:** arr = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** The array is already non-decreasing. We do not need to remove any elements.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `0 <= arr[i] <= 109`\"\"\"\n\n    n = len(arr)\n    left, right = 0, n - 1\n    while left < n - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n    if left == n - 1:\n        return 0\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n    result = min(n - left - 1, right)\n    i, j = 0, right\n    while i <= left and j < n:\n        if arr[i] <= arr[j]:\n            result = min(result, j - i - 1)\n            i += 1\n        else:\n            j += 1\n    return result"}}, "leetcode/leetcode_2110.txt": {"score": 0.9981932640075684, "content": {"text": "def num_smooth_descent_periods(prices):\n    \"\"\"You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day.\n\nA **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule.\n\nReturn _the number of **smooth descent periods**_.\n\n**Example 1:**\n\n**Input:** prices = \\[3,2,1,4\\]\n**Output:** 7\n**Explanation:** There are 7 smooth descent periods:\n\\[3\\], \\[2\\], \\[1\\], \\[4\\], \\[3,2\\], \\[2,1\\], and \\[3,2,1\\]\nNote that a period with one day is a smooth descent period by the definition.\n\n**Example 2:**\n\n**Input:** prices = \\[8,6,7,7\\]\n**Output:** 4\n**Explanation:** There are 4 smooth descent periods: \\[8\\], \\[6\\], \\[7\\], and \\[7\\]\nNote that \\[8,6\\] is not a smooth descent period as 8 - 6 \u2260 1.\n\n**Example 3:**\n\n**Input:** prices = \\[1\\]\n**Output:** 1\n**Explanation:** There is 1 smooth descent period: \\[1\\]\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `1 <= prices[i] <= 105`\"\"\"\n\n    result = 0\n    count = 0\n    for i in range(1, len(prices)):\n        if prices[i] == prices[i - 1] - 1:\n            count += 1\n        else:\n            count = 0\n        result += count + 1\n    return result + 1"}}}}, "106": {"gold": {"leetcode/leetcode_73.txt": 1}, "retrieved": {"leetcode/leetcode_959.txt": {"score": 0.9135220646858215, "content": {"text": "def threeSumMulti(arr, target):\n    \"\"\"An `n x n` grid is composed of `1 x 1` squares where each `1 x 1` square consists of a `'/'`, `'\\'`, or blank space `' '`. These characters divide the square into contiguous regions.\n\nGiven the grid `grid` represented as a string array, return _the number of regions_.\n\nNote that backslash characters are escaped, so a `'\\'` is represented as `'\\\\'`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \" / \", \"/  \"\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** grid = \\[ \" / \", \"   \"\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** grid = \\[ \"/\\\\\\\\ \", \"\\\\/ \"\\]\n**Output:** 5\n**Explanation:** Recall that because \\\\ characters are escaped,  \"\\\\/ \" refers to /, and  \"/\\\\\\\\ \" refers to /\\\\.\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 30`\n*   `grid[i][j]` is either `'/'`, `'\\'`, or `' '`.\"\"\"\n\n    MOD = 1000000007\n    ans = 0\n\n    arr.sort()\n    n = len(arr)\n\n    for i in range(n - 2):\n        j, k = i + 1, n - 1\n        while j < k:\n            s = arr[i] + arr[j] + arr[k]\n            if s > target:\n                k -= 1\n            elif s < target:\n                j += 1\n            else:\n                if arr[j] != arr[k]:\n                    left_count = right_count = 1\n\n                    while j < n - 1 and arr[j] == arr[j + 1]:\n                        left_count += 1\n                        j += 1\n\n                    while k > 0 and arr[k] == arr[k - 1]:\n                        right_count += 1\n                        k -= 1\n\n                    ans += left_count * right_count\n                    ans %= MOD\n                    j += 1\n                    k -= 1\n                else:\n                    ans += (k - j + 1) * (k - j) // 2\n                    ans %= MOD\n                    break\n\n    return ans"}}, "leetcode/leetcode_924.txt": {"score": 0.9137252569198608, "content": {"text": "def fair_candy_swap(aliceSizes, bobSizes):\n    \"\"\"You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.\n\nSome nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\nSuppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove **exactly one node** from `initial`.\n\nReturn the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with **the smallest index**.\n\nNote that if a node was removed from the `initial` list of infected nodes, it might still be infected later due to the malware spread.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[1,1,0\\],\\[1,1,0\\],\\[0,0,1\\]\\], initial = \\[0,1\\]\n**Output:** 0\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,0,0\\],\\[0,1,0\\],\\[0,0,1\\]\\], initial = \\[0,2\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** graph = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], initial = \\[1,2\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == graph.length`\n*   `n == graph[i].length`\n*   `2 <= n <= 300`\n*   `graph[i][j]` is `0` or `1`.\n*   `graph[i][j] == graph[j][i]`\n*   `graph[i][i] == 1`\n*   `1 <= initial.length <= n`\n*   `0 <= initial[i] <= n - 1`\n*   All the integers in `initial` are **unique**.\"\"\"\n\n    aliceTotal, bobTotal = sum(aliceSizes), sum(bobSizes)\n    delta = (bobTotal - aliceTotal) // 2\n    for a in aliceSizes:\n        for b in bobSizes:\n            if a + delta == b:\n                return [a, b]\n    return []"}}, "leetcode/leetcode_1901.txt": {"score": 0.9139572978019714, "content": {"text": "def min_operations(nums1, nums2):\n    \"\"\"A **peak** element in a 2D grid is an element that is **strictly greater** than all of its **adjacent** neighbors to the left, right, top, and bottom.\n\nGiven a **0-indexed** `m x n` matrix `mat` where **no two adjacent cells are equal**, find **any** peak element `mat[i][j]` and return _the length 2 array_ `[i,j]`.\n\nYou may assume that the entire matrix is surrounded by an **outer perimeter** with the value `-1` in each cell.\n\nYou must write an algorithm that runs in `O(m log(n))` or `O(n log(m))` time.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[1,4\\],\\[3,2\\]\\]\n**Output:** \\[0,1\\]\n**Explanation:** Both 3 and 4 are peak elements so \\[1,0\\] and \\[0,1\\] are both acceptable answers.\n\n**Example 2:**\n\n**Input:** mat = \\[\\[10,20,15\\],\\[21,30,14\\],\\[7,16,32\\]\\]\n**Output:** \\[1,1\\]\n**Explanation:** Both 30 and 32 are peak elements so \\[1,1\\] and \\[2,2\\] are both acceptable answers.\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 500`\n*   `1 <= mat[i][j] <= 105`\n*   No two adjacent cells are equal.\"\"\"\n\n    sum1, sum2 = sum(nums1), sum(nums2)\n    if sum1 == sum2: return 0\n    if sum1 < sum2: nums1, nums2 = nums2, nums1\n    nums1.sort(reverse=True)\n    nums2.sort()\n    diff, operations, i, j = abs(sum1 - sum2), 0, 0, 0\n    while diff > 0 and (i < len(nums1) or j < len(nums2)):\n        option1 = nums1[i] - 1 if i < len(nums1) else 0\n        option2 = 6 - nums2[j] if j < len(nums2) else 0\n        if option1 > option2:\n            diff -= option1\n            i += 1\n        else:\n            diff -= option2\n            j += 1\n        operations += 1\n    return operations if diff == 0 else -1"}}, "leetcode/leetcode_764.txt": {"score": 0.9166743755340576, "content": {"text": "from collections import deque\n    \"\"\"You are given an integer `n`. You have an `n x n` binary grid `grid` with all values initially `1`'s except for some indices given in the array `mines`. The `ith` element of the array `mines` is defined as `mines[i] = [xi, yi]` where `grid[xi][yi] == 0`.\n\nReturn _the order of the largest **axis-aligned** plus sign of_ 1_'s contained in_ `grid`. If there is none, return `0`.\n\nAn **axis-aligned plus sign** of `1`'s of order `k` has some center `grid[r][c] == 1` along with four arms of length `k - 1` going up, down, left, and right, and made of `1`'s. Note that there could be `0`'s or `1`'s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for `1`'s.\n\n**Example 1:**\n\n**Input:** n = 5, mines = \\[\\[4,2\\]\\]\n**Output:** 2\n**Explanation:** In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n**Example 2:**\n\n**Input:** n = 1, mines = \\[\\[0,0\\]\\]\n**Output:** 0\n**Explanation:** There is no plus sign, so return 0.\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n*   `1 <= mines.length <= 5000`\n*   `0 <= xi, yi < n`\n*   All the pairs `(xi, yi)` are **unique**.\"\"\"\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef levelOrder(root):\n    result = []\n\n    if not root:\n        return result\n\n    toVisit = deque([root])\n\n    while toVisit:\n        size = len(toVisit)\n        level = []\n\n        for _ in range(size):\n            currentNode = toVisit.popleft()\n            level.append(currentNode.val)\n\n            for child in currentNode.children:\n                toVisit.append(child)\n\n        result.append(level)\n\n    return result"}}, "leetcode/leetcode_2088.txt": {"score": 0.9205268025398254, "content": {"text": "def min_time_to_type(word: str) -> int:\n    \"\"\"A farmer has a **rectangular grid** of land with `m` rows and `n` columns that can be divided into unit cells. Each cell is either **fertile** (represented by a `1`) or **barren** (represented by a `0`). All cells outside the grid are considered barren.\n\nA **pyramidal plot** of land can be defined as a set of cells with the following criteria:\n\n1.  The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**.\n2.  The **apex** of a pyramid is the **topmost** cell of the pyramid. The **height** of a pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r <= i <= r + h - 1` **and** `c - (i - r) <= j <= c + (i - r)`.\n\nAn **inverse pyramidal plot** of land can be defined as a set of cells with similar criteria:\n\n1.  The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**.\n2.  The **apex** of an inverse pyramid is the **bottommost** cell of the inverse pyramid. The **height** of an inverse pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r - h + 1 <= i <= r` **and** `c - (r - i) <= j <= c + (r - i)`.\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n\nGiven a **0-indexed** `m x n` binary matrix `grid` representing the farmland, return _the **total number** of pyramidal and inverse pyramidal plots that can be found in_ `grid`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[1,1,1,1\\]\\]\n**Output:** 2\n**Explanation:** The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\]\\]\n**Output:** 2\n**Explanation:** The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1,0\\],\\[1,1,1,1,1\\],\\[1,1,1,1,1\\],\\[0,1,0,0,1\\]\\]\n**Output:** 13\n**Explanation:** There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    time, prev = 0, 0\n    for c in word:\n        pos = ord(c) - ord('a')\n        time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1\n        prev = pos\n    return time"}}, "leetcode/leetcode_2245.txt": {"score": 0.9264423847198486, "content": {"text": "def can_destroy_all_asteroids(mass, asteroids):\n    \"\"\"You are given a 2D integer array `grid` of size `m x n`, where each cell contains a positive integer.\n\nA **cornered path** is defined as a set of adjacent cells with **at most** one turn. More specifically, the path should exclusively move either **horizontally** or **vertically** up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the **alternate** direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\n\nThe **product** of a path is defined as the product of all the values in the path.\n\nReturn _the **maximum** number of **trailing zeros** in the product of a cornered path found in_ `grid`.\n\nNote:\n\n*   **Horizontal** movement means moving in either the left or right direction.\n*   **Vertical** movement means moving in either the up or down direction.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[23,17,15,3,20\\],\\[8,1,20,27,11\\],\\[9,4,6,2,21\\],\\[40,9,1,10,6\\],\\[22,7,4,5,3\\]\\]\n**Output:** 3\n**Explanation:** The grid on the left shows a valid cornered path.\nIt has a product of 15 \\* 20 \\* 6 \\* 1 \\* 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[4,3,2\\],\\[7,6,1\\],\\[8,8,8\\]\\]\n**Output:** 0\n**Explanation:** The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 1000`\"\"\"\n\n    asteroids.sort()\n    for asteroid in asteroids:\n        if mass >= asteroid:\n            mass += asteroid\n        else:\n            return False\n    return True"}}, "leetcode/leetcode_1072.txt": {"score": 0.9161858558654785, "content": {"text": "class ListNode:\n    \"\"\"You are given an `m x n` binary matrix `matrix`.\n\nYou can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from `0` to `1` or vice versa).\n\nReturn _the maximum number of rows that have all values equal after some number of flips_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[0,1\\],\\[1,1\\]\\]\n**Output:** 1\n**Explanation:** After flipping no values, 1 row has all values equal.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 2\n**Explanation:** After flipping values in the first column, both rows have equal values.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[0,0,0\\],\\[0,0,1\\],\\[1,1,0\\]\\]\n**Output:** 2\n**Explanation:** After flipping values in the first two columns, the last two rows have equal values.\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 300`\n*   `matrix[i][j]` is either `0` or `1`.\"\"\"\n\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef nextGreaterNodes(head):\n    result = []\n    stack = []\n    while head:\n        while stack and stack[-1] < head.val:\n            stack[-1] = head.val\n            stack.pop()\n        result.append(head.val)\n        stack.append(len(result) - 1)\n        head = head.next\n\n    while stack:\n        result[stack.pop()] = 0\n\n    return result"}}, "leetcode/leetcode_2125.txt": {"score": 0.9399282336235046, "content": {"text": "def can_sort_using_swap(nums):\n    \"\"\"Anti-theft security devices are activated inside a bank. You are given a **0-indexed** binary string array `bank` representing the floor plan of the bank, which is an `m x n` 2D matrix. `bank[i]` represents the `ith` row, consisting of `'0'`s and `'1'`s. `'0'` means the cell is empty, while`'1'` means the cell has a security device.\n\nThere is **one** laser beam between any **two** security devices **if both** conditions are met:\n\n*   The two devices are located on two **different rows**: `r1` and `r2`, where `r1 < r2`.\n*   For **each** row `i` where `r1 < i < r2`, there are **no security devices** in the `ith` row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\n\nReturn _the total number of laser beams in the bank_.\n\n**Example 1:**\n\n**Input:** bank = \\[ \"011001 \", \"000000 \", \"010100 \", \"001000 \"\\]\n**Output:** 8\n**Explanation:** Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n \\* bank\\[0\\]\\[1\\] -- bank\\[2\\]\\[1\\]\n \\* bank\\[0\\]\\[1\\] -- bank\\[2\\]\\[3\\]\n \\* bank\\[0\\]\\[2\\] -- bank\\[2\\]\\[1\\]\n \\* bank\\[0\\]\\[2\\] -- bank\\[2\\]\\[3\\]\n \\* bank\\[0\\]\\[5\\] -- bank\\[2\\]\\[1\\]\n \\* bank\\[0\\]\\[5\\] -- bank\\[2\\]\\[3\\]\n \\* bank\\[2\\]\\[1\\] -- bank\\[3\\]\\[2\\]\n \\* bank\\[2\\]\\[3\\] -- bank\\[3\\]\\[2\\]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.\n\n**Example 2:**\n\n**Input:** bank = \\[ \"000 \", \"111 \", \"000 \"\\]\n**Output:** 0\n**Explanation:** There does not exist two devices located on two different rows.\n\n**Constraints:**\n\n*   `m == bank.length`\n*   `n == bank[i].length`\n*   `1 <= m, n <= 500`\n*   `bank[i][j]` is either `'0'` or `'1'`.\"\"\"\n\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\n            if sorted(nums) == nums:\n                return True\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\n    return False"}}, "leetcode/leetcode_1284.txt": {"score": 0.9207150936126709, "content": {"text": "def sum_of_divisors_with_four_divisors(nums):\n    \"\"\"Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing `1` to `0` and `0` to `1`). A pair of cells are called neighbors if they share one edge.\n\nReturn the _minimum number of steps_ required to convert `mat` to a zero matrix or `-1` if you cannot.\n\nA **binary matrix** is a matrix with all cells equal to `0` or `1` only.\n\nA **zero matrix** is a matrix with all cells equal to `0`.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[0,0\\],\\[0,1\\]\\]\n**Output:** 3\n**Explanation:** One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n\n**Example 2:**\n\n**Input:** mat = \\[\\[0\\]\\]\n**Output:** 0\n**Explanation:** Given matrix is a zero matrix. We do not need to change it.\n\n**Example 3:**\n\n**Input:** mat = \\[\\[1,0,0\\],\\[1,0,0\\]\\]\n**Output:** -1\n**Explanation:** Given matrix cannot be a zero matrix.\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 3`\n*   `mat[i][j]` is either `0` or `1`.\"\"\"\n\n    total_sum = 0\n\n    for num in nums:\n        div_count = 0\n        div_sum = 0\n\n        for i in range(1, int(num ** 0.5) + 1):\n            if num % i == 0:\n                div_sum += i\n                div_count += 1\n\n                if num // i != i:\n                    div_sum += num // i\n                    div_count += 1\n\n            if div_count > 4:\n                break\n\n        if div_count == 4:\n            total_sum += div_sum\n\n    return total_sum"}}, "leetcode/leetcode_1267.txt": {"score": 0.9428613185882568, "content": {"text": "def remove_zero_sum_sublists(head):\n    \"\"\"You are given a map of a server center, represented as a `m * n` integer matrix `grid`, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.  \n  \nReturn the number of servers that communicate with any other server.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** 0\n**Explanation:** No servers can communicate with others.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0\\],\\[1,1\\]\\]\n**Output:** 3\n**Explanation:** All three servers can communicate with at least one other server.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,0,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,1\\]\\]\n**Output:** 4\n**Explanation:** The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m <= 250`\n*   `1 <= n <= 250`\n*   `grid[i][j] == 0 or 1`\"\"\"\n\n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n\n    while current:\n        sum = 0\n        while head:\n            sum += head.val\n            if sum == 0:\n                current.next = head.next\n            head = head.next\n        current = current.next\n        if current:\n            head = current.next\n\n    return dummy.next"}}}}, "107": {"gold": {"leetcode/leetcode_215.txt": 1, "leetcode/leetcode_1162.txt": 1, "leetcode/leetcode_2512.txt": 1}, "retrieved": {"leetcode/csn_python_train_274228.txt": {"score": 0.9227415919303894, "content": {"text": "def pick_next_boat_trip(node, m, c, frontier):\n    \"\"\" \n    based on current situation, pick who\n    gets transported next, and return the path\n    NOTE - improvement here as there are often\n    duplicate paths or backtracking, e.g.\n    \"\"\"\n    next_path = []\n    cur_path = []\n    boat, mult = boat_on_left_bank(node)\n    shore = 1 - boat\n    m1, c1, m2, c2 = parse_miss_cann(node, m, c)\n    if (m1 - 1 >= c1 or m1 == 1) and (m2 + 1 >= c2) and (m1 > 0):\n        cur_path = (node[0]-mult,node[1], shore)\n        if cur_path not in frontier:\n            next_path.append(cur_path)\n\n    if (m1 >= c1-1 or m1 == 0) and (m2 -1 >= c2 or m2 == 0) and ( c1 > 0):\n        cur_path = (node[0],node[1]-mult, shore)\n        if cur_path not in frontier:\n            next_path.append(cur_path)\n        \n    if (m1 >= c1) and (m2 >= c2) and (m1 > 0) and (c1 > 0):\n        cur_path = (node[0]-mult,node[1]-mult, shore)\n        if cur_path not in frontier:\n            next_path.append(cur_path)\n        \n    if (m1 - 2 >= c1 or m1 == 2) and (m2 >= c2 or m2 == 0) and (m1 > 1):\n        cur_path = (node[0]-(mult*2),node[1], shore)\n        if cur_path not in frontier:\n            next_path.append(cur_path)\n        \n    if (m1 >= c1 - 2 or m1 == 0) and (m2 >= c2 + 2 or m2 == 0) and (c1 > 1):\n        cur_path = (node[0],node[1]-(mult*2), shore)\n        if cur_path not in frontier:\n            next_path.append(cur_path)\n\n    #print(next_path)    \n    return next_path"}}, "leetcode/leetcode_1094.txt": {"score": 0.9240606427192688, "content": {"text": "def allCellsDistOrder(rows, cols, rCenter, cCenter):\n    \"\"\"There is a car with `capacity` empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).\n\nYou are given the integer `capacity` and an array `trips` where `trips[i] = [numPassengersi, fromi, toi]` indicates that the `ith` trip has `numPassengersi` passengers and the locations to pick them up and drop them off are `fromi` and `toi` respectively. The locations are given as the number of kilometers due east from the car's initial location.\n\nReturn `true` _if it is possible to pick up and drop off all passengers for all the given trips, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** trips = \\[\\[2,1,5\\],\\[3,3,7\\]\\], capacity = 4\n**Output:** false\n\n**Example 2:**\n\n**Input:** trips = \\[\\[2,1,5\\],\\[3,3,7\\]\\], capacity = 5\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= trips.length <= 1000`\n*   `trips[i].length == 3`\n*   `1 <= numPassengersi <= 100`\n*   `0 <= fromi < toi <= 1000`\n*   `1 <= capacity <= 105`\"\"\"\n\n    coordinates = [[i, j] for i in range(rows) for j in range(cols)]\n\n    coordinates.sort(key=lambda x: abs(x[0] - rCenter) + abs(x[1] - cCenter))\n\n    return coordinates"}}, "leetcode/leetcode_789.txt": {"score": 0.9254335761070251, "content": {"text": "import heapq\n    \"\"\"You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point `[0, 0]`, and you are given a destination point `target = [xtarget, ytarget]` that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array `ghosts`, where `ghosts[i] = [xi, yi]` represents the starting position of the `ith` ghost. All inputs are **integral coordinates**.\n\nEach turn, you and all the ghosts may independently choose to either **move 1 unit** in any of the four cardinal directions: north, east, south, or west, or **stay still**. All actions happen **simultaneously**.\n\nYou escape if and only if you can reach the target **before** any ghost reaches you. If you reach any square (including the target) at the **same time** as a ghost, it **does not** count as an escape.\n\nReturn `true` _if it is possible to escape regardless of how the ghosts move, otherwise return_ `false`_._\n\n**Example 1:**\n\n**Input:** ghosts = \\[\\[1,0\\],\\[0,3\\]\\], target = \\[0,1\\]\n**Output:** true\n**Explanation:** You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you.\n\n**Example 2:**\n\n**Input:** ghosts = \\[\\[1,0\\]\\], target = \\[2,0\\]\n**Output:** false\n**Explanation:** You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.\n\n**Example 3:**\n\n**Input:** ghosts = \\[\\[2,0\\]\\], target = \\[1,0\\]\n**Output:** false\n**Explanation:** The ghost can reach the target at the same time as you.\n\n**Constraints:**\n\n*   `1 <= ghosts.length <= 100`\n*   `ghosts[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   There can be **multiple ghosts** in the same location.\n*   `target.length == 2`\n*   `-104 <= xtarget, ytarget <= 104`\"\"\"\n\n\nclass KthLargest:\n\n    def __init__(self, k, nums):\n        self.heap = []\n        self.k = k\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.heap, val)\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        return self.heap[0]"}}, "leetcode/leetcode_2577.txt": {"score": 0.9360507726669312, "content": {"text": "from collections import deque\n    \"\"\"You are given a `m x n` matrix `grid` consisting of **non-negative** integers where `grid[row][col]` represents the **minimum** time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.\n\nYou are standing in the **top-left** cell of the matrix in the `0th` second, and you must move to **any** adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\nReturn _the **minimum** time required in which you can visit the bottom-right cell of the matrix_. If you cannot visit the bottom-right cell, then return `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,3,2\\],\\[5,1,2,5\\],\\[4,3,8,6\\]\\]\n**Output:** 7\n**Explanation:** One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid\\[0\\]\\[1\\] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid\\[1\\]\\[3\\] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid\\[2\\]\\[3\\] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,2,4\\],\\[3,2,1\\],\\[1,0,4\\]\\]\n**Output:** -1\n**Explanation:** There is no path from the top left to the bottom-right cell.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 1000`\n*   `4 <= m * n <= 105`\n*   `0 <= grid[i][j] <= 105`\n*   `grid[0][0] == 0`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n\ndef minTime(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    visited = [[1000000] * n for _ in range(m)]\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    visited[0][0] = 0\n\n    q = deque([(0, 0)])\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n\n            if 0 <= nx < m and 0 <= ny < n:\n                t = max(grid[nx][ny], visited[x][y] + 1)\n                if visited[nx][ny] > t:\n                    visited[nx][ny] = t\n                    q.append((nx, ny))\n\n    return visited[m - 1][n - 1] if visited[m - 1][n - 1] != 1000000 else -1"}}, "leetcode/leetcode_1162.txt": {"score": 0.9326545596122742, "content": {"text": "from collections import deque\n    \"\"\"Given an `n x n` `grid` containing only values `0` and `1`, where `0` represents water and `1` represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return `-1`.\n\nThe distance used in this problem is the Manhattan distance: the distance between two cells `(x0, y0)` and `(x1, y1)` is `|x0 - x1| + |y0 - y1|`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,1\\],\\[0,0,0\\],\\[1,0,1\\]\\]\n**Output:** 2\n**Explanation:** The cell (1, 1) is as far as possible from all the land with distance 2.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Output:** 4\n**Explanation:** The cell (2, 2) is as far as possible from all the land with distance 4.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 100`\n*   `grid[i][j]` is `0` or `1`\"\"\"\n\n\ndef maxDistance(grid):\n    distance = -1\n    water_cells = deque()\n    n = len(grid)\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                water_cells.append((i, j))\n\n    if not water_cells or len(water_cells) == n * n:\n        return distance\n\n    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while water_cells:\n        size = len(water_cells)\n        for _ in range(size):\n            x, y = water_cells.popleft()\n            for dx, dy in directions:\n                newX, newY = x + dx, y + dy\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    grid[newX][newY] = 1\n                    water_cells.append((newX, newY))\n        distance += 1\n        \n    return distance - 1"}}, "leetcode/leetcode_675.txt": {"score": 0.9619143009185791, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:\n\n*   `0` means the cell cannot be walked through.\n*   `1` represents an empty cell that can be walked through.\n*   A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).\n\nStarting from the point `(0, 0)`, return _the minimum steps you need to walk to cut off all the trees_. If you cannot cut off all the trees, return `-1`.\n\n**Note:** The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n**Example 1:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,4\\],\\[7,6,5\\]\\]\n**Output:** 6\n**Explanation:** Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n**Example 2:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,0\\],\\[7,6,5\\]\\]\n**Output:** -1\n**Explanation:** The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n**Example 3:**\n\n**Input:** forest = \\[\\[2,3,4\\],\\[0,0,5\\],\\[8,7,6\\]\\]\n**Output:** 6\n**Explanation:** You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n\n**Constraints:**\n\n*   `m == forest.length`\n*   `n == forest[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= forest[i][j] <= 109`\n*   Heights of all trees are **distinct**.\"\"\"\n\nfrom collections import deque\n\ndef cutOffTree(forest: List[List[int]]) -> int:\n    if not forest or not forest[0]: return 0\n    m, n = len(forest), len(forest[0])\n    trees = []\n    \n    for i in range(m):\n        for j in range(n):\n            if forest[i][j] > 1:\n                heappush(trees, (forest[i][j], i, j))\n    \n    startX, startY = 0, 0\n    totalSteps = 0\n    while trees:\n        tree, endX, endY = heappop(trees)\n        steps = bfs(forest, startX, startY, endX, endY)\n        if steps == -1:\n            return -1\n        totalSteps += steps\n        startX, startY = endX, endY\n    \n    return totalSteps\n\ndef bfs(forest, startX, startY, endX, endY):\n    if startX == endX and startY == endY:\n        return 0\n        \n    m, n = len(forest), len(forest[0])\n    visited = [[False] * n for _ in range(m)]\n    q = deque([(startX, startY, 0)])\n    visited[startX][startY] = True\n    dirs = [-1, 0, 1, 0, -1]\n    \n    while q:\n        x, y, steps = q.popleft()\n        for k in range(4):\n            newX, newY = x + dirs[k], y + dirs[k+1]\n            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:\n                if newX == endX and newY == endY:\n                    return steps + 1\n                q.append((newX, newY, steps + 1))\n                visited[newX][newY] = True\n    \n    return -1"}}, "leetcode/leetcode_2258.txt": {"score": 0.9310537576675415, "content": {"text": "from collections import deque\n    \"\"\"You are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:\n\n*   `0` represents grass,\n*   `1` represents fire,\n*   `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls.\n\nReturn _the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\nA cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2,0,0,0,0,0\\],\\[0,0,0,2,2,1,0\\],\\[0,2,0,0,1,2,0\\],\\[0,0,2,2,2,0,2\\],\\[0,0,0,0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[0,1,2,0\\],\\[0,2,0,0\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[2,2,0\\],\\[1,2,0\\]\\]\n**Output:** 1000000000\n**Explanation:** The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 300`\n*   `4 <= m * n <= 2 * 104`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`\"\"\"\n\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef getMaxSafeMinutes(grid):\n    m, n = len(grid), len(grid[0])\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n    q = deque()\n\n    if grid[m - 1][n - 1] != 1:\n        dist[m - 1][n - 1] = 0\n        q.append((m - 1, n - 1))\n\n    while q:\n        x, y = q.popleft()\n        for d in range(4):\n            nx, ny = x + dx[d], y + dy[d]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\n    if dist[0][0] == -1:\n        return -1\n\n    res = 0\n    for test in range(dist[0][0], int(1e9)):\n        ok = True\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    for d in range(4):\n                        nx, ny = x + dx[d], y + dy[d]\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:\n                            break\n                    else:\n                        ok = False\n                        break\n        if ok:\n            res = test\n        else:\n            break\n    return res"}}, "leetcode/leetcode_2146.txt": {"score": 0.9768475294113159, "content": {"text": "def can_place_word(board, word):\n    \"\"\"You are given a **0-indexed** 2D integer array `grid` of size `m x n` that represents a map of the items in a shop. The integers in the grid represent the following:\n\n*   `0` represents a wall that you cannot pass through.\n*   `1` represents an empty cell that you can freely move to and from.\n*   All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\n\nIt takes `1` step to travel between adjacent grid cells.\n\nYou are also given integer arrays `pricing` and `start` where `pricing = [low, high]` and `start = [row, col]` indicates that you start at the position `(row, col)` and are interested only in items with a price in the range of `[low, high]` (**inclusive**). You are further given an integer `k`.\n\nYou are interested in the **positions** of the `k` **highest-ranked** items whose prices are **within** the given price range. The rank is determined by the **first** of these criteria that is different:\n\n1.  Distance, defined as the length of the shortest path from the `start` (**shorter** distance has a higher rank).\n2.  Price (**lower** price has a higher rank, but it must be **in the price range**).\n3.  The row number (**smaller** row number has a higher rank).\n4.  The column number (**smaller** column number has a higher rank).\n\nReturn _the_ `k` _highest-ranked items within the price range **sorted** by their rank (highest to lowest)_. If there are fewer than `k` reachable items within the price range, return _**all** of them_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,2,0,1\\],\\[1,3,0,1\\],\\[0,2,5,1\\]\\], pricing = \\[2,5\\], start = \\[0,0\\], k = 3\n**Output:** \\[\\[0,1\\],\\[1,1\\],\\[2,1\\]\\]\n**Explanation:** You start at (0,0).\nWith a price range of \\[2,5\\], we can take items from (0,1), (1,1), (2,1) and (2,2).\nThe ranks of these items are:\n- (0,1) with distance 1\n- (1,1) with distance 2\n- (2,1) with distance 3\n- (2,2) with distance 4\nThus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,0,1\\],\\[1,3,3,1\\],\\[0,2,5,1\\]\\], pricing = \\[2,3\\], start = \\[2,3\\], k = 2\n**Output:** \\[\\[2,1\\],\\[1,2\\]\\]\n**Explanation:** You start at (2,3).\nWith a price range of \\[2,3\\], we can take items from (0,1), (1,1), (1,2) and (2,1).\nThe ranks of these items are:\n- (2,1) with distance 2, price 2\n- (1,2) with distance 2, price 3\n- (1,1) with distance 3\n- (0,1) with distance 4\nThus, the 2 highest ranked items in the price range are (2,1) and (1,2).\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[0,0,1\\],\\[2,3,4\\]\\], pricing = \\[2,3\\], start = \\[0,0\\], k = 3\n**Output:** \\[\\[2,1\\],\\[2,0\\]\\]\n**Explanation:** You start at (0,0).\nWith a price range of \\[2,3\\], we can take items from (2,0) and (2,1). \nThe ranks of these items are: \n- (2,1) with distance 5\n- (2,0) with distance 6\nThus, the 2 highest ranked items in the price range are (2,1) and (2,0). \nNote that k = 3 but there are only 2 reachable items within the price range.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `0 <= grid[i][j] <= 105`\n*   `pricing.length == 2`\n*   `2 <= low <= high <= 105`\n*   `start.length == 2`\n*   `0 <= row <= m - 1`\n*   `0 <= col <= n - 1`\n*   `grid[row][col] > 0`\n*   `1 <= k <= m * n`\"\"\"\n\n    m, n = len(board), len(board[0])\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == word[0]:\n                if check_word(board, word, i, j, 0, 1) or check_word(board, word, i, j, 1, 0):\n                    return True\n    return False\n\ndef check_word(board, word, i, j, di, dj):\n    m, n = len(board), len(board[0])\n    for k in range(len(word)):\n        i += di\n        j += dj\n        if i < 0 or i >= m or j < 0 or j >= n:\n            return False\n        if k == 0 or k == len(word) - 1:\n            if board[i][j] != word[k] and board[i][j] != ' ':\n                return False\n        if k > 0 and k < len(word) - 1:\n            if board[i][j] != word[k] and board[i][j] != ' ' and board[i][j] != '#':\n                return False\n    return True"}}, "leetcode/csn_python_train_321040.txt": {"score": 0.9420902729034424, "content": {"text": "def dist_grid(grid, source, target=None):\n    \"\"\"Distances in a grid by BFS\n\n    :param grid: matrix with 4-neighborhood\n    :param (int,int) source: pair of row, column indices\n    :param (int,int) target: exploration stops if target is reached\n    :complexity: linear in grid size\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dirs = [(0, +1, '>'), (0, -1, '<'), (+1, 0, 'v'), (-1, 0, '^')]\n    i, j = source\n    grid[i][j] = 's'\n    Q = deque()\n    Q.append(source)\n    while Q:\n        i1, j1 = Q.popleft()\n        for di, dj, symbol in dirs:   # explore all directions\n            i2 = i1 + di\n            j2 = j1 + dj\n            if not (0 <= i2 and i2 < rows and 0 <= j2 and j2 < cols):\n                continue              # reached the bounds of the grid\n            if grid[i2][j2] != ' ':   # inaccessible or already visited\n                continue\n            grid[i2][j2] = symbol     # mark visit\n            if (i2, j2) == target:\n                grid[i2][j2] = 't'    # goal is reached\n                return\n            Q.append((i2, j2))"}}, "leetcode/leetcode_1926.txt": {"score": 0.9360663890838623, "content": {"text": "from collections import deque\n    \"\"\"You are given an `m x n` matrix `maze` (**0-indexed**) with empty cells (represented as `'.'`) and walls (represented as `'+'`). You are also given the `entrance` of the maze, where `entrance = [entrancerow, entrancecol]` denotes the row and column of the cell you are initially standing at.\n\nIn one step, you can move one cell **up**, **down**, **left**, or **right**. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the **nearest exit** from the `entrance`. An **exit** is defined as an **empty cell** that is at the **border** of the `maze`. The `entrance` **does not count** as an exit.\n\nReturn _the **number of steps** in the shortest path from the_ `entrance` _to the nearest exit, or_ `-1` _if no such path exists_.\n\n**Example 1:**\n\n**Input:** maze = \\[\\[ \"+ \", \"+ \", \". \", \"+ \"\\],\\[ \". \", \". \", \". \", \"+ \"\\],\\[ \"+ \", \"+ \", \"+ \", \". \"\\]\\], entrance = \\[1,2\\]\n**Output:** 1\n**Explanation:** There are 3 exits in this maze at \\[1,0\\], \\[0,2\\], and \\[2,3\\].\nInitially, you are at the entrance cell \\[1,2\\].\n- You can reach \\[1,0\\] by moving 2 steps left.\n- You can reach \\[0,2\\] by moving 1 step up.\nIt is impossible to reach \\[2,3\\] from the entrance.\nThus, the nearest exit is \\[0,2\\], which is 1 step away.\n\n**Example 2:**\n\n**Input:** maze = \\[\\[ \"+ \", \"+ \", \"+ \"\\],\\[ \". \", \". \", \". \"\\],\\[ \"+ \", \"+ \", \"+ \"\\]\\], entrance = \\[1,0\\]\n**Output:** 2\n**Explanation:** There is 1 exit in this maze at \\[1,2\\].\n\\[1,0\\] does not count as an exit since it is the entrance cell.\nInitially, you are at the entrance cell \\[1,0\\].\n- You can reach \\[1,2\\] by moving 2 steps right.\nThus, the nearest exit is \\[1,2\\], which is 2 steps away.\n\n**Example 3:**\n\n**Input:** maze = \\[\\[ \". \", \"+ \"\\]\\], entrance = \\[0,0\\]\n**Output:** -1\n**Explanation:** There are no exits in this maze.\n\n**Constraints:**\n\n*   `maze.length == m`\n*   `maze[i].length == n`\n*   `1 <= m, n <= 100`\n*   `maze[i][j]` is either `'.'` or `'+'`.\n*   `entrance.length == 2`\n*   `0 <= entrancerow < m`\n*   `0 <= entrancecol < n`\n*   `entrance` will always be an empty cell.\"\"\"\n\n\ndef nearest_exit(maze, entrance):\n    m, n = len(maze), len(maze[0])\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    q = deque([tuple(entrance)])\n    \n    steps = -1\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            if maze[r][c] == '+': continue\n            if r == 0 or r == m-1 or c == 0 or c == n-1:\n                if r != entrance[0] or c != entrance[1]: return steps\n            maze[r][c] = '+'\n            for dr, dc in moves:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n:\n                    q.append((nr, nc))\n    return -1"}}}}, "108": {"gold": {"leetcode/leetcode_639.txt": 1, "leetcode/leetcode_1547.txt": 1, "leetcode/leetcode_1712.txt": 1}, "retrieved": {"leetcode/leetcode_552.txt": {"score": 0.9006813764572144, "content": {"text": "def checkRecord(n: int) -> int:\n    \"\"\"An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nAny student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nGiven an integer `n`, return _the **number** of possible attendance records of length_ `n` _that make a student eligible for an attendance award. The answer may be very large, so return it **modulo**_ `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 8\n**Explanation:** There are 8 records with length 2 that are eligible for an award:\n \"PP \",  \"AP \",  \"PA \",  \"LP \",  \"PL \",  \"AL \",  \"LA \",  \"LL \"\nOnly  \"AA \" is not eligible because there are 2 absences (there need to be fewer than 2).\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 3\n\n**Example 3:**\n\n**Input:** n = 10101\n**Output:** 183236316\n\n**Constraints:**\n\n*   `1 <= n <= 105`\"\"\"\n\n    M = 1000000007\n    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]\n    while n:\n        next_dp = [0] * 6\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M\n        next_dp[1] = dp[0]\n        next_dp[2] = dp[1]\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M\n        next_dp[4] = dp[3]\n        next_dp[5] = dp[4]\n        dp = next_dp\n        n -= 1\n    return sum(dp) % M"}}, "leetcode/leetcode_1955.txt": {"score": 0.9030902981758118, "content": {"text": "import heapq\n    \"\"\"A sequence is **special** if it consists of a **positive** number of `0`s, followed by a **positive** number of `1`s, then a **positive** number of `2`s.\n\n*   For example, `[0,1,2]` and `[0,0,1,1,1,2]` are special.\n*   In contrast, `[2,1,0]`, `[1]`, and `[0,1,2,0]` are not special.\n\nGiven an array `nums` (consisting of **only** integers `0`, `1`, and `2`), return _the **number of different subsequences** that are special_. Since the answer may be very large, **return it modulo** `109 + 7`.\n\nA **subsequence** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are **different** if the **set of indices** chosen are different.\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,2,2\\]\n**Output:** 3\n**Explanation:** The special subsequences are bolded \\[**0**,**1**,**2**,2\\], \\[**0**,**1**,2,**2**\\], and \\[**0**,**1**,**2**,**2**\\].\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,0,0\\]\n**Output:** 0\n**Explanation:** There are no special subsequences in \\[2,2,0,0\\].\n\n**Example 3:**\n\n**Input:** nums = \\[0,1,2,0,1,2\\]\n**Output:** 7\n**Explanation:** The special subsequences are bolded:\n- \\[**0**,**1**,**2**,0,1,2\\]\n- \\[**0**,**1**,2,0,1,**2**\\]\n- \\[**0**,**1**,**2**,0,1,**2**\\]\n- \\[**0**,**1**,2,0,**1**,**2**\\]\n- \\[**0**,1,2,**0**,**1**,**2**\\]\n- \\[**0**,1,2,0,**1**,**2**\\]\n- \\[0,1,2,**0**,**1**,**2**\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 2`\"\"\"\n\n\nclass SeatManager:\n    def __init__(self, n: int):\n        self.available_seats = [i for i in range(1, n + 1)]\n        heapq.heapify(self.available_seats)\n\n    def reserve(self) -> int:\n        return heapq.heappop(self.available_seats)\n\n    def unreserve(self, seatNumber: int) -> None:\n        heapq.heappush(self.available_seats, seatNumber)"}}, "leetcode/leetcode_2155.txt": {"score": 0.9056293964385986, "content": {"text": "from typing import List\n    \"\"\"You are given a **0-indexed** binary array `nums` of length `n`. `nums` can be divided at index `i` (where `0 <= i <= n)` into two arrays (possibly empty) `numsleft` and `numsright`:\n\n*   `numsleft` has all the elements of `nums` between index `0` and `i - 1` **(inclusive)**, while `numsright` has all the elements of nums between index `i` and `n - 1` **(inclusive)**.\n*   If `i == 0`, `numsleft` is **empty**, while `numsright` has all the elements of `nums`.\n*   If `i == n`, `numsleft` has all the elements of nums, while `numsright` is **empty**.\n\nThe **division score** of an index `i` is the **sum** of the number of `0`'s in `numsleft` and the number of `1`'s in `numsright`.\n\nReturn _**all distinct indices** that have the **highest** possible **division score**_. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** nums = \\[0,0,1,0\\]\n**Output:** \\[2,4\\]\n**Explanation:** Division at index\n- 0: numsleft is \\[\\]. numsright is \\[0,0,**1**,0\\]. The score is 0 + 1 = 1.\n- 1: numsleft is \\[**0**\\]. numsright is \\[0,**1**,0\\]. The score is 1 + 1 = 2.\n- 2: numsleft is \\[**0**,**0**\\]. numsright is \\[**1**,0\\]. The score is 2 + 1 = 3.\n- 3: numsleft is \\[**0**,**0**,1\\]. numsright is \\[0\\]. The score is 2 + 0 = 2.\n- 4: numsleft is \\[**0**,**0**,1,**0**\\]. numsright is \\[\\]. The score is 3 + 0 = 3.\nIndices 2 and 4 both have the highest possible division score 3.\nNote the answer \\[4,2\\] would also be accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[0,0,0\\]\n**Output:** \\[3\\]\n**Explanation:** Division at index\n- 0: numsleft is \\[\\]. numsright is \\[0,0,0\\]. The score is 0 + 0 = 0.\n- 1: numsleft is \\[**0**\\]. numsright is \\[0,0\\]. The score is 1 + 0 = 1.\n- 2: numsleft is \\[**0**,**0**\\]. numsright is \\[0\\]. The score is 2 + 0 = 2.\n- 3: numsleft is \\[**0**,**0**,**0**\\]. numsright is \\[\\]. The score is 3 + 0 = 3.\nOnly index 3 has the highest possible division score 3.\n\n**Example 3:**\n\n**Input:** nums = \\[1,1\\]\n**Output:** \\[0\\]\n**Explanation:** Division at index\n- 0: numsleft is \\[\\]. numsright is \\[**1**,**1**\\]. The score is 0 + 2 = 2.\n- 1: numsleft is \\[1\\]. numsright is \\[**1**\\]. The score is 0 + 1 = 1.\n- 2: numsleft is \\[1,1\\]. numsright is \\[\\]. The score is 0 + 0 = 0.\nOnly index 0 has the highest possible division score 2.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `nums[i]` is either `0` or `1`.\"\"\"\n\n\ndef missing_rolls(rolls: List[int], mean: int, n: int) -> List[int]:\n    m = len(rolls)\n    total_sum = mean * (n + m)\n    sum_m = sum(rolls)\n    \n    if total_sum - sum_m < n or total_sum - sum_m > 6 * n:\n        return []\n    \n    ans = [1] * n\n    total_sum -= sum_m + n\n    for i in range(n):\n        add = min(5, total_sum)\n        ans[i] += add\n        total_sum -= add\n    \n    return ans"}}, "leetcode/leetcode_1712.txt": {"score": 0.9299144744873047, "content": {"text": "def waysToSplit(nums):\n    \"\"\"A split of an integer array is **good** if:\n\n*   The array is split into three **non-empty** contiguous subarrays - named `left`, `mid`, `right` respectively from left to right.\n*   The sum of the elements in `left` is less than or equal to the sum of the elements in `mid`, and the sum of the elements in `mid` is less than or equal to the sum of the elements in `right`.\n\nGiven `nums`, an array of **non-negative** integers, return _the number of **good** ways to split_ `nums`. As the number may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 1\n**Explanation:** The only good way to split nums is \\[1\\] \\[1\\] \\[1\\].\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,2,2,5,0\\]\n**Output:** 3\n**Explanation:** There are three good ways of splitting nums:\n\\[1\\] \\[2\\] \\[2,2,5,0\\]\n\\[1\\] \\[2,2\\] \\[2,5,0\\]\n\\[1,2\\] \\[2,2\\] \\[5,0\\]\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 0\n**Explanation:** There is no good way to split nums.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 105`\n*   `0 <= nums[i] <= 104`\"\"\"\n\n    MOD = 10**9 + 7\n    n = len(nums)\n    prefixSum = [0] * (n + 1)\n    for i in range(n):\n        prefixSum[i + 1] = prefixSum[i] + nums[i]\n    \n    ans = 0\n    left, right = 0, 0\n    for mid in range(1, n - 1):\n        while left + 1 < mid and prefixSum[left + 1] * 2 <= prefixSum[mid]:\n            left += 1\n        while right < mid or (right + 1 < n and prefixSum[right + 1] - prefixSum[mid] <= prefixSum[n] - prefixSum[right + 1]):\n            right += 1\n        if right >= mid and prefixSum[mid] - prefixSum[left] <= prefixSum[right] - prefixSum[mid]:\n            ans = (ans + right - mid + 1) % MOD\n\n    return ans"}}, "leetcode/leetcode_1621.txt": {"score": 0.9072694182395935, "content": {"text": "def numSubseq(nums, target):\n    \"\"\"Given `n` points on a 1-D plane, where the `ith` point (from `0` to `n-1`) is at `x = i`, find the number of ways we can draw **exactly** `k` **non-overlapping** line segments such that each segment covers two or more points. The endpoints of each segment must have **integral coordinates**. The `k` line segments **do not** have to cover all `n` points, and they are **allowed** to share endpoints.\n\nReturn _the number of ways we can draw_ `k` _non-overlapping line segments__._ Since this number can be huge, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 4, k = 2\n**Output:** 5\n**Explanation:** The two line segments are shown in red and blue.\nThe image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.\n\n**Example 2:**\n\n**Input:** n = 3, k = 1\n**Output:** 3\n**Explanation:** The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.\n\n**Example 3:**\n\n**Input:** n = 30, k = 7\n**Output:** 796297179\n**Explanation:** The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 109 + 7 gives us 796297179.\n\n**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= k <= n-1`\"\"\"\n\n    nums.sort()\n    n = len(nums)\n    mod = 10**9 + 7\n\n    power = [1] * n\n    for i in range(1, n):\n        power[i] = (power[i - 1] * 2) % mod\n\n    ans = 0\n    r = n\n    for l in range(n):\n        while r > l and nums[l] + nums[r - 1] > target:\n            r -= 1\n\n        ans = (ans + power[r - l]) % mod\n\n    return ans"}}, "leetcode/leetcode_927.txt": {"score": 0.9073365330696106, "content": {"text": "def sum_of_widths(nums):\n    \"\"\"You are given an array `arr` which consists of only zeros and ones, divide the array into **three non-empty parts** such that all of these parts represent the same binary value.\n\nIf it is possible, return any `[i, j]` with `i + 1 < j`, such that:\n\n*   `arr[0], arr[1], ..., arr[i]` is the first part,\n*   `arr[i + 1], arr[i + 2], ..., arr[j - 1]` is the second part, and\n*   `arr[j], arr[j + 1], ..., arr[arr.length - 1]` is the third part.\n*   All three parts have equal binary values.\n\nIf it is not possible, return `[-1, -1]`.\n\nNote that the entire part is used when considering what binary value it represents. For example, `[1,1,0]` represents `6` in decimal, not `3`. Also, leading zeros **are allowed**, so `[0,1,1]` and `[1,1]` represent the same value.\n\n**Example 1:**\n\n**Input:** arr = \\[1,0,1,0,1\\]\n**Output:** \\[0,3\\]\n\n**Example 2:**\n\n**Input:** arr = \\[1,1,0,1,1\\]\n**Output:** \\[-1,-1\\]\n\n**Example 3:**\n\n**Input:** arr = \\[1,1,0,0,1\\]\n**Output:** \\[0,2\\]\n\n**Constraints:**\n\n*   `3 <= arr.length <= 3 * 104`\n*   `arr[i]` is `0` or `1`\"\"\"\n\n    MOD = 10**9 + 7\n    nums.sort()\n    c, res = 1, 0\n    n = len(nums)\n\n    for i in range(n):\n        res = (res + (nums[i] - nums[n - i - 1]) * c) % MOD\n        c = c * 2 % MOD\n\n    return res"}}, "leetcode/leetcode_2086.txt": {"score": 0.9102998375892639, "content": {"text": "def num_special_subsequences(nums):\n    \"\"\"You are given a **0-indexed** string `hamsters` where `hamsters[i]` is either:\n\n*   `'H'` indicating that there is a hamster at index `i`, or\n*   `'.'` indicating that index `i` is empty.\n\nYou will add some number of food buckets at the empty indices in order to feed the hamsters. A hamster can be fed if there is at least one food bucket to its left or to its right. More formally, a hamster at index `i` can be fed if you place a food bucket at index `i - 1` **and/or** at index `i + 1`.\n\nReturn _the minimum number of food buckets you should **place at empty indices** to feed all the hamsters or_ `-1` _if it is impossible to feed all of them_.\n\n**Example 1:**\n\n**Input:** hamsters =  \"H..H \"\n**Output:** 2\n**Explanation:** We place two food buckets at indices 1 and 2.\nIt can be shown that if we place only one food bucket, one of the hamsters will not be fed.\n\n**Example 2:**\n\n**Input:** hamsters =  \".H.H. \"\n**Output:** 1\n**Explanation:** We place one food bucket at index 2.\n\n**Example 3:**\n\n**Input:** hamsters =  \".HHH. \"\n**Output:** -1\n**Explanation:** If we place a food bucket at every empty index as shown, the hamster at index 2 will not be able to eat.\n\n**Constraints:**\n\n*   `1 <= hamsters.length <= 105`\n*   `hamsters[i]` is either`'H'` or `'.'`.\"\"\"\n\n    zeros, ones, twos = 0, 0, 0\n    mod = 1000000007\n    for num in nums:\n        if num == 0:\n            zeros = (zeros + 1) % mod\n        elif num == 1:\n            ones = (ones + zeros) % mod\n        else:\n            twos = (twos + ones) % mod\n    return twos"}}, "leetcode/leetcode_2147.txt": {"score": 0.9948039650917053, "content": {"text": "def sum_of_points(s, answers):\n    \"\"\"Along a long library corridor, there is a line of seats and decorative plants. You are given a **0-indexed** string `corridor` of length `n` consisting of letters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'` represents a plant.\n\nOne room divider has **already** been installed to the left of index `0`, and **another** to the right of index `n - 1`. Additional room dividers can be installed. For each position between indices `i - 1` and `i` (`1 <= i <= n - 1`), at most one divider can be installed.\n\nDivide the corridor into non-overlapping sections, where each section has **exactly two seats** with any number of plants. There may be multiple ways to perform the division. Two ways are **different** if there is a position with a room divider installed in the first way but not in the second way.\n\nReturn _the number of ways to divide the corridor_. Since the answer may be very large, return it **modulo** `109 + 7`. If there is no way, return `0`.\n\n**Example 1:**\n\n**Input:** corridor =  \"SSPPSPS \"\n**Output:** 3\n**Explanation:** There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, **each** section has exactly **two** seats.\n\n**Example 2:**\n\n**Input:** corridor =  \"PPSPSP \"\n**Output:** 1\n**Explanation:** There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.\n\n**Example 3:**\n\n**Input:** corridor =  \"S \"\n**Output:** 0\n**Explanation:** There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n\n**Constraints:**\n\n*   `n == corridor.length`\n*   `1 <= n <= 105`\n*   `corridor[i]` is either `'S'` or `'P'`.\"\"\"\n\n    total_points = 0\n    result = 0\n    term = 1\n    sign = \"+\"\n\n    for char in s:\n        if char.isdigit():\n            number = int(char)\n            if sign == \"+\":\n                result += term\n                term = number\n            elif sign == \"*\":\n                term *= number\n        else:\n            sign = char\n\n    result += term\n\n    for ans in answers:\n        total_points += (ans == result)\n\n    return total_points"}}, "leetcode/leetcode_1573.txt": {"score": 0.9305068254470825, "content": {"text": "def min_sum_of_lengths(arr, target):\n    \"\"\"Given a binary string `s`, you can split `s` into 3 **non-empty** strings `s1`, `s2`, and `s3` where `s1 + s2 + s3 = s`.\n\nReturn the number of ways `s` can be split such that the number of ones is the same in `s1`, `s2`, and `s3`. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** s =  \"10101 \"\n**Output:** 4\n**Explanation:** There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n \"1|010|1 \"\n \"1|01|01 \"\n \"10|10|1 \"\n \"10|1|01 \"\n\n**Example 2:**\n\n**Input:** s =  \"1001 \"\n**Output:** 0\n\n**Example 3:**\n\n**Input:** s =  \"0000 \"\n**Output:** 3\n**Explanation:** There are three ways to split s in 3 parts.\n \"0|0|00 \"\n \"0|00|0 \"\n \"00|0|0 \"\n\n**Constraints:**\n\n*   `3 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.\"\"\"\n\n    n = len(arr)\n    sum_, min_len, result = 0, float('inf'), float('inf')\n    mp = {0: -1}\n\n    for i in range(n):\n        sum_ += arr[i]\n        if sum_ >= target and (sum_ - target) in mp:\n            if mp[sum_ - target] > -1 and min_len != float('inf'):\n                result = min(result, i - mp[sum_ - target] + min_len)\n            min_len = min(min_len, i - mp[sum_ - target])\n        mp[sum_] = i\n\n    return result if result != float('inf') else -1"}}, "leetcode/leetcode_2478.txt": {"score": 0.945107638835907, "content": {"text": "def numBeautifulPartitions(s: str, k: int, minLength: int) -> int:\n    \"\"\"You are given a string `s` that consists of the digits `'1'` to `'9'` and two integers `k` and `minLength`.\n\nA partition of `s` is called **beautiful** if:\n\n*   `s` is partitioned into `k` non-intersecting substrings.\n*   Each substring has a length of **at least** `minLength`.\n*   Each substring starts with a **prime** digit and ends with a **non-prime** digit. Prime digits are `'2'`, `'3'`, `'5'`, and `'7'`, and the rest of the digits are non-prime.\n\nReturn _the number of **beautiful** partitions of_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n**Input:** s =  \"23542185131 \", k = 3, minLength = 2\n**Output:** 3\n**Explanation:** There exists three ways to create a beautiful partition:\n \"2354 | 218 | 5131 \"\n \"2354 | 21851 | 31 \"\n \"2354218 | 51 | 31 \"\n\n**Example 2:**\n\n**Input:** s =  \"23542185131 \", k = 3, minLength = 3\n**Output:** 1\n**Explanation:** There exists one way to create a beautiful partition:  \"2354 | 218 | 5131 \".\n\n**Example 3:**\n\n**Input:** s =  \"3312958 \", k = 3, minLength = 1\n**Output:** 1\n**Explanation:** There exists one way to create a beautiful partition:  \"331 | 29 | 58 \".\n\n**Constraints:**\n\n*   `1 <= k, minLength <= s.length <= 1000`\n*   `s` consists of the digits `'1'` to `'9'`.\"\"\"\n\n    MOD = 10**9 + 7\n    primes = {'2', '3', '5', '7'}\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for l in range(minLength, i + 1):\n                if i - l >= j - 1 and s[i - l] in primes and s[i - 1] not in primes:\n                    dp[i][j] += dp[i - l][j - 1]\n                    if dp[i][j] >= MOD:\n                        dp[i][j] -= MOD\n                        \n    return dp[n][k]"}}}}, "109": {"gold": {"leetcode/leetcode_539.txt": 1}, "retrieved": {"leetcode/leetcode_2383.txt": {"score": 0.9079611897468567, "content": {"text": "def min_training_hours(initial_energy, initial_experience, energy, experience):\n    \"\"\"You are entering a competition, and are given two **positive** integers `initialEnergy` and `initialExperience` denoting your initial energy and initial experience respectively.\n\nYou are also given two **0-indexed** integer arrays `energy` and `experience`, both of length `n`.\n\nYou will face `n` opponents **in order**. The energy and experience of the `ith` opponent is denoted by `energy[i]` and `experience[i]` respectively. When you face an opponent, you need to have both **strictly** greater experience and energy to defeat them and move to the next opponent if available.\n\nDefeating the `ith` opponent **increases** your experience by `experience[i]`, but **decreases** your energy by `energy[i]`.\n\nBefore starting the competition, you can train for some number of hours. After each hour of training, you can **either** choose to increase your initial experience by one, or increase your initial energy by one.\n\nReturn _the **minimum** number of training hours required to defeat all_ `n` _opponents_.\n\n**Example 1:**\n\n**Input:** initialEnergy = 5, initialExperience = 3, energy = \\[1,4,3,2\\], experience = \\[2,6,3,1\\]\n**Output:** 8\n**Explanation:** You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0th opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1st opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2nd opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3rd opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists.\n\n**Example 2:**\n\n**Input:** initialEnergy = 2, initialExperience = 4, energy = \\[1\\], experience = \\[3\\]\n**Output:** 0\n**Explanation:** You do not need any additional energy or experience to win the competition, so we return 0.\n\n**Constraints:**\n\n*   `n == energy.length == experience.length`\n*   `1 <= n <= 100`\n*   `1 <= initialEnergy, initialExperience, energy[i], experience[i] <= 100`\"\"\"\n\n    n = len(energy)\n    ans = int(1e9)\n    for exp_gain in range(initial_energy + initial_experience + 1):\n        training_hours = exp_gain\n        energy_left = initial_energy - exp_gain\n        curr_experience = initial_experience + exp_gain\n        \n        for i in range(n):\n            while curr_experience <= experience[i] or energy_left <= energy[i]:\n                energy_left -= 1\n                training_hours += 1\n            energy_left -= energy[i]\n            curr_experience += experience[i]\n        ans = min(ans, training_hours)\n    return ans"}}, "leetcode/leetcode_1883.txt": {"score": 0.909342885017395, "content": {"text": "def minSkips(dist, speed, hoursBefore):\n    \"\"\"You are given an integer `hoursBefore`, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through `n` roads. The road lengths are given as an integer array `dist` of length `n`, where `dist[i]` describes the length of the `ith` road in **kilometers**. In addition, you are given an integer `speed`, which is the speed (in **km/h**) you will travel at.\n\nAfter you travel road `i`, you must rest and wait for the **next integer hour** before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting.\n\n*   For example, if traveling a road takes `1.4` hours, you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours, you do not need to wait.\n\nHowever, you are allowed to **skip** some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks.\n\n*   For example, suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark, letting you start traveling the third road immediately.\n\nReturn _the **minimum number of skips required** to arrive at the meeting on time, or_ `-1` _if it is **impossible**_.\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,2\\], speed = 4, hoursBefore = 2\n**Output:** 1\n**Explanation:**\nWithout skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.\nYou can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.\nNote that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.\n\n**Example 2:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 2, hoursBefore = 10\n**Output:** 2\n**Explanation:**\nWithout skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.\nYou can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.\n\n**Example 3:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 1, hoursBefore = 10\n**Output:** -1\n**Explanation:** It is impossible to arrive at the meeting on time even if you skip all the rests.\n\n**Constraints:**\n\n*   `n == dist.length`\n*   `1 <= n <= 1000`\n*   `1 <= dist[i] <= 105`\n*   `1 <= speed <= 106`\n*   `1 <= hoursBefore <= 107`\"\"\"\n\n    n = len(dist)\n    dp = [[1e9] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for j in range(i+1):\n            t = dist[i] / speed + (1 if j else 0)\n            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)\n            skipped_t = -(-dist[i] / speed) - dp[i][j]\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)\n\n    for i in range(n + 1):\n        if dp[n][i] <= hoursBefore:\n            return i\n    return -1"}}, "leetcode/leetcode_1033.txt": {"score": 0.910061776638031, "content": {"text": "def broken_calc(startValue: int, target: int) -> int:\n    \"\"\"There are three stones in different positions on the X-axis. You are given three integers `a`, `b`, and `c`, the positions of the stones.\n\nIn one move, you pick up a stone at an endpoint (i.e., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. Formally, let's say the stones are currently at positions `x`, `y`, and `z` with `x < y < z`. You pick up the stone at either position `x` or position `z`, and move that stone to an integer position `k`, with `x < k < z` and `k != y`.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n\nReturn _an integer array_ `answer` _of length_ `2` _where_:\n\n*   `answer[0]` _is the minimum number of moves you can play, and_\n*   `answer[1]` _is the maximum number of moves you can play_.\n\n**Example 1:**\n\n**Input:** a = 1, b = 2, c = 5\n**Output:** \\[1,2\\]\n**Explanation:** Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.\n\n**Example 2:**\n\n**Input:** a = 4, b = 3, c = 2\n**Output:** \\[0,0\\]\n**Explanation:** We cannot make any moves.\n\n**Example 3:**\n\n**Input:** a = 3, b = 5, c = 1\n**Output:** \\[1,2\\]\n**Explanation:** Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.\n\n**Constraints:**\n\n*   `1 <= a, b, c <= 100`\n*   `a`, `b`, and `c` have different values.\"\"\"\n\n    operations = 0\n    while target > startValue:\n        target = target // 2 if target % 2 == 0 else target + 1\n        operations += 1\n    return operations + startValue - target"}}, "leetcode/leetcode_1217.txt": {"score": 0.9125732183456421, "content": {"text": "def sort_array(arr1, arr2):\n    \"\"\"We have `n` chips, where the position of the `ith` chip is `position[i]`.\n\nWe need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:\n\n*   `position[i] + 2` or `position[i] - 2` with `cost = 0`.\n*   `position[i] + 1` or `position[i] - 1` with `cost = 1`.\n\nReturn _the minimum cost_ needed to move all the chips to the same position.\n\n**Example 1:**\n\n**Input:** position = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n**Example 2:**\n\n**Input:** position = \\[2,2,2,3,3\\]\n**Output:** 2\n**Explanation:** We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n**Example 3:**\n\n**Input:** position = \\[1,1000000000\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= position.length <= 100`\n*   `1 <= position[i] <= 10^9`\"\"\"\n\n    counts = {}\n    result = []\n\n    for num in arr1:\n        counts[num] = counts.get(num, 0) + 1\n\n    for num in arr2:\n        if num in counts:\n            result.extend([num] * counts[num])\n            del counts[num]\n\n    for num in sorted(counts.keys()):\n        result.extend([num] * counts[num])\n\n    return result"}}, "leetcode/leetcode_991.txt": {"score": 0.9199040532112122, "content": {"text": "def can_reorder_array(arr):\n    \"\"\"There is a broken calculator that has the integer `startValue` on its display initially. In one operation, you can:\n\n*   multiply the number on display by `2`, or\n*   subtract `1` from the number on display.\n\nGiven two integers `startValue` and `target`, return _the minimum number of operations needed to display_ `target` _on the calculator_.\n\n**Example 1:**\n\n**Input:** startValue = 2, target = 3\n**Output:** 2\n**Explanation:** Use double operation and then decrement operation {2 -> 4 -> 3}.\n\n**Example 2:**\n\n**Input:** startValue = 5, target = 8\n**Output:** 2\n**Explanation:** Use decrement and then double {5 -> 4 -> 8}.\n\n**Example 3:**\n\n**Input:** startValue = 3, target = 10\n**Output:** 3\n**Explanation:** Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n\n**Constraints:**\n\n*   `1 <= startValue, target <= 109`\"\"\"\n\n    from collections import Counter\n    \n    count = Counter(arr)\n    arr = sorted(arr)\n    for x in arr:\n        if count[x] == 0:\n            continue\n        if count[2 * x] > 0:\n            count[x] -= 1\n            count[2 * x] -= 1\n        else:\n            return False\n    return True"}}, "leetcode/leetcode_2037.txt": {"score": 0.9105983972549438, "content": {"text": "def count_square_triples(n):\n    \"\"\"There are `n` seats and `n` students in a room. You are given an array `seats` of length `n`, where `seats[i]` is the position of the `ith` seat. You are also given the array `students` of length `n`, where `students[j]` is the position of the `jth` student.\n\nYou may perform the following move any number of times:\n\n*   Increase or decrease the position of the `ith` student by `1` (i.e., moving the `ith` student from position `x` to `x + 1` or `x - 1`)\n\nReturn _the **minimum number of moves** required to move each student to a seat_ _such that no two students are in the same seat._\n\nNote that there may be **multiple** seats or students in the **same** position at the beginning.\n\n**Example 1:**\n\n**Input:** seats = \\[3,1,5\\], students = \\[2,7,4\\]\n**Output:** 4\n**Explanation:** The students are moved as follows:\n- The first student is moved from from position 2 to position 1 using 1 move.\n- The second student is moved from from position 7 to position 5 using 2 moves.\n- The third student is moved from from position 4 to position 3 using 1 move.\nIn total, 1 + 2 + 1 = 4 moves were used.\n\n**Example 2:**\n\n**Input:** seats = \\[4,1,5,9\\], students = \\[1,3,2,6\\]\n**Output:** 7\n**Explanation:** The students are moved as follows:\n- The first student is not moved.\n- The second student is moved from from position 3 to position 4 using 1 move.\n- The third student is moved from from position 2 to position 5 using 3 moves.\n- The fourth student is moved from from position 6 to position 9 using 3 moves.\nIn total, 0 + 1 + 3 + 3 = 7 moves were used.\n\n**Example 3:**\n\n**Input:** seats = \\[2,2,6,6\\], students = \\[1,3,2,6\\]\n**Output:** 4\n**Explanation:** Note that there are two seats at position 2 and two seats at position 6.\nThe students are moved as follows:\n- The first student is moved from from position 1 to position 2 using 1 move.\n- The second student is moved from from position 3 to position 6 using 3 moves.\n- The third student is not moved.\n- The fourth student is not moved.\nIn total, 1 + 3 + 0 + 0 = 4 moves were used.\n\n**Constraints:**\n\n*   `n == seats.length == students.length`\n*   `1 <= n <= 100`\n*   `1 <= seats[i], students[j] <= 100`\"\"\"\n\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a, n + 1):\n            c = int((a * a + b * b)**0.5)\n            if c * c == a * a + b * b and c <= n:\n                count += 1\n    return count"}}, "leetcode/leetcode_1658.txt": {"score": 0.9106290340423584, "content": {"text": "def min_swaps(grid):\n    \"\"\"You are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn _the **minimum number** of operations to reduce_ `x` _to **exactly**_ `0` _if it is possible__, otherwise, return_ `-1`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,4,2,3\\], x = 5\n**Output:** 2\n**Explanation:** The optimal solution is to remove the last two elements to reduce x to zero.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,7,8,9\\], x = 4\n**Output:** -1\n\n**Example 3:**\n\n**Input:** nums = \\[3,2,20,1,1,3\\], x = 10\n**Output:** 5\n**Explanation:** The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`\n*   `1 <= x <= 109`\"\"\"\n\n    n = len(grid)\n    row_zeros = [0] * n\n    \n    for i in range(n):\n        for j in range(n - 1, -1, -1):\n            if grid[i][j] == 0:\n                row_zeros[i] += 1\n            else:\n                break\n    \n    steps = 0\n    for i in range(n):\n        target = n - i - 1\n        current_row = i\n        while current_row < n and row_zeros[current_row] < target:\n            current_row += 1\n        if current_row == n:\n            return -1\n        steps += current_row - i\n        row_zeros.pop(current_row)\n        row_zeros.insert(i, target)\n    \n    return steps"}}, "leetcode/leetcode_2162.txt": {"score": 0.9915307760238647, "content": {"text": "def min_partition_difference(nums):\n    \"\"\"A generic microwave supports cooking times for:\n\n*   at least `1` second.\n*   at most `99` minutes and `99` seconds.\n\nTo set the cooking time, you push **at most four digits**. The microwave normalizes what you push as four digits by **prepending zeroes**. It interprets the **first** two digits as the minutes and the **last** two digits as the seconds. It then **adds** them up as the cooking time. For example,\n\n*   You push `9` `5` `4` (three digits). It is normalized as `0954` and interpreted as `9` minutes and `54` seconds.\n*   You push `0` `0` `0` `8` (four digits). It is interpreted as `0` minutes and `8` seconds.\n*   You push `8` `0` `9` `0`. It is interpreted as `80` minutes and `90` seconds.\n*   You push `8` `1` `3` `0`. It is interpreted as `81` minutes and `30` seconds.\n\nYou are given integers `startAt`, `moveCost`, `pushCost`, and `targetSeconds`. **Initially**, your finger is on the digit `startAt`. Moving the finger above **any specific digit** costs `moveCost` units of fatigue. Pushing the digit below the finger **once** costs `pushCost` units of fatigue.\n\nThere can be multiple ways to set the microwave to cook for `targetSeconds` seconds but you are interested in the way with the minimum cost.\n\nReturn _the **minimum cost** to set_ `targetSeconds` _seconds of cooking time_.\n\nRemember that one minute consists of `60` seconds.\n\n**Example 1:**\n\n**Input:** startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600\n**Output:** 6\n**Explanation:** The following are the possible ways to set the cooking time.\n- 1 0 0 0, interpreted as 10 minutes and 0 seconds.\n  The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).\n  The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.\n- 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.\n  The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n  The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.\n- 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.\n  The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n  The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.\n\n**Example 2:**\n\n**Input:** startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76\n**Output:** 6\n**Explanation:** The optimal way is to push two digits: 7 6, interpreted as 76 seconds.\nThe finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6\nNote other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost.\n\n**Constraints:**\n\n*   `0 <= startAt <= 9`\n*   `1 <= moveCost, pushCost <= 105`\n*   `1 <= targetSeconds <= 6039`\"\"\"\n\n    n = len(nums) // 2\n    nums.sort(reverse=True)\n    return sum(nums[:n]) - sum(nums[n:])"}}, "leetcode/leetcode_1769.txt": {"score": 0.9174512028694153, "content": {"text": "def maximum_generated(n: int) -> int:\n    \"\"\"You have `n` boxes. You are given a binary string `boxes` of length `n`, where `boxes[i]` is `'0'` if the `ith` box is **empty**, and `'1'` if it contains **one** ball.\n\nIn one operation, you can move **one** ball from a box to an adjacent box. Box `i` is adjacent to box `j` if `abs(i - j) == 1`. Note that after doing so, there may be more than one ball in some boxes.\n\nReturn an array `answer` of size `n`, where `answer[i]` is the **minimum** number of operations needed to move all the balls to the `ith` box.\n\nEach `answer[i]` is calculated considering the **initial** state of the boxes.\n\n**Example 1:**\n\n**Input:** boxes =  \"110 \"\n**Output:** \\[1,1,3\\]\n**Explanation:** The answer for each box is as follows:\n1) First box: you will have to move one ball from the second box to the first box in one operation.\n2) Second box: you will have to move one ball from the first box to the second box in one operation.\n3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.\n\n**Example 2:**\n\n**Input:** boxes =  \"001011 \"\n**Output:** \\[11,8,5,4,3,4\\]\n\n**Constraints:**\n\n*   `n == boxes.length`\n*   `1 <= n <= 2000`\n*   `boxes[i]` is either `'0'` or `'1'`.\"\"\"\n\n    if n == 0:\n        return 0\n    nums = [0] * (n + 1)\n    nums[1] = 1\n    for i in range(2, n + 1):\n        nums[i] = nums[i // 2] if i % 2 == 0 else nums[i // 2] + nums[i // 2 + 1]\n    return max(nums)"}}, "leetcode/leetcode_2224.txt": {"score": 0.9366437792778015, "content": {"text": "def minimum_operations(current: str, correct: str) -> int:\n    \"\"\"You are given two strings `current` and `correct` representing two **24-hour times**.\n\n24-hour times are formatted as `\"HH:MM \"`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.\n\nIn one operation you can increase the time `current` by `1`, `5`, `15`, or `60` minutes. You can perform this operation **any** number of times.\n\nReturn _the **minimum number of operations** needed to convert_ `current` _to_ `correct`.\n\n**Example 1:**\n\n**Input:** current =  \"02:30 \", correct =  \"04:35 \"\n**Output:** 3\n**Explanation:**\nWe can convert current to correct in 3 operations as follows:\n- Add 60 minutes to current. current becomes  \"03:30 \".\n- Add 60 minutes to current. current becomes  \"04:30 \".\n- Add 5 minutes to current. current becomes  \"04:35 \".\nIt can be proven that it is not possible to convert current to correct in fewer than 3 operations.\n\n**Example 2:**\n\n**Input:** current =  \"11:00 \", correct =  \"11:01 \"\n**Output:** 1\n**Explanation:** We only have to add one minute to current, so the minimum number of operations needed is 1.\n\n**Constraints:**\n\n*   `current` and `correct` are in the format `\"HH:MM \"`\n*   `current <= correct`\"\"\"\n\n    ch, cm = map(int, current.split(':'))\n    th, tm = map(int, correct.split(':'))\n    ct = ch * 60 + cm\n    tt = th * 60 + tm\n\n    operations = 0\n    while ct < tt:\n        if tt - ct >= 60:\n            ct += 60\n        elif tt - ct >= 15:\n            ct += 15\n        elif tt - ct >= 5:\n            ct += 5\n        else:\n            ct += 1\n\n        operations += 1\n\n    return operations"}}}}, "110": {"gold": {"leetcode/leetcode_462.txt": 1, "leetcode/leetcode_1658.txt": 1}, "retrieved": {"leetcode/leetcode_2357.txt": {"score": 0.9268734455108643, "content": {"text": "def minOperations(nums):\n    \"\"\"You are given a non-negative integer array `nums`. In one operation, you must:\n\n*   Choose a positive integer `x` such that `x` is less than or equal to the **smallest non-zero** element in `nums`.\n*   Subtract `x` from every **positive** element in `nums`.\n\nReturn _the **minimum** number of operations to make every element in_ `nums` _equal to_ `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,0,3,5\\]\n**Output:** 3\n**Explanation:**\nIn the first operation, choose x = 1. Now, nums = \\[0,4,0,2,4\\].\nIn the second operation, choose x = 2. Now, nums = \\[0,2,0,0,2\\].\nIn the third operation, choose x = 2. Now, nums = \\[0,0,0,0,0\\].\n\n**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** 0\n**Explanation:** Each element in nums is already 0 so no operations are needed.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`\"\"\"\n\n    count = 0\n    nums.sort()\n    i = 0\n\n    while i < len(nums):\n        if nums[i] > 0:\n            target = nums[i]\n            while i < len(nums) and nums[i] == target:\n                i += 1\n            count += 1\n        else:\n            i += 1\n\n    return count"}}, "leetcode/leetcode_1509.txt": {"score": 0.9274203777313232, "content": {"text": "def minDifference(nums):\n    \"\"\"You are given an integer array `nums`.\n\nIn one move, you can choose one element of `nums` and change it to **any value**.\n\nReturn _the minimum difference between the largest and smallest value of `nums` **after performing at most three moves**_.\n\n**Example 1:**\n\n**Input:** nums = \\[5,3,2,4\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 2 to 3. nums becomes \\[5,3,3,4\\].\nIn the second move, change 4 to 3. nums becomes \\[5,3,3,3\\].\nIn the third move, change 5 to 3. nums becomes \\[3,3,3,3\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,0,10,14\\]\n**Output:** 1\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 5 to 0. nums becomes \\[1,0,0,10,14\\].\nIn the second move, change 10 to 0. nums becomes \\[1,0,0,0,14\\].\nIn the third move, change 14 to 1. nums becomes \\[1,0,0,0,1\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 0.\nIt can be shown that there is no way to make the difference 0 in 3 moves.\n\n**Example 3:**\n\n**Input:** nums = \\[3,100,20\\]\n**Output:** 0\n**Explanation:** We can make at most 3 moves.\nIn the first move, change 100 to 7. nums becomes \\[4,7,20\\].\nIn the second move, change 20 to 7. nums becomes \\[4,7,7\\].\nIn the third move, change 4 to 3. nums becomes \\[7,7,7\\].\nAfter performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\"\"\"\n\n    n = len(nums)\n    if n <= 4: return 0\n    nums.sort()\n    res = float('inf')\n    for i in range(4):\n        res = min(res, nums[n - 4 + i] - nums[i])\n    return res"}}, "leetcode/leetcode_2144.txt": {"score": 0.9302722811698914, "content": {"text": "def max_difference(nums):\n    \"\"\"A shop is selling candies at a discount. For **every two** candies sold, the shop gives a **third** candy for **free**.\n\nThe customer can choose **any** candy to take away for free as long as the cost of the chosen candy is less than or equal to the **minimum** cost of the two candies bought.\n\n*   For example, if there are `4` candies with costs `1`, `2`, `3`, and `4`, and the customer buys candies with costs `2` and `3`, they can take the candy with cost `1` for free, but not the candy with cost `4`.\n\nGiven a **0-indexed** integer array `cost`, where `cost[i]` denotes the cost of the `ith` candy, return _the **minimum cost** of buying **all** the candies_.\n\n**Example 1:**\n\n**Input:** cost = \\[1,2,3\\]\n**Output:** 5\n**Explanation:** We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.\nThe total cost of buying all candies is 2 + 3 = 5. This is the **only** way we can buy the candies.\nNote that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.\nThe cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.\n\n**Example 2:**\n\n**Input:** cost = \\[6,5,7,9,2,2\\]\n**Output:** 23\n**Explanation:** The way in which we can get the minimum cost is described below:\n- Buy candies with costs 9 and 7\n- Take the candy with cost 6 for free\n- We buy candies with costs 5 and 2\n- Take the last remaining candy with cost 2 for free\nHence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.\n\n**Example 3:**\n\n**Input:** cost = \\[5,5\\]\n**Output:** 10\n**Explanation:** Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.\nHence, the minimum cost to buy all candies is 5 + 5 = 10.\n\n**Constraints:**\n\n*   `1 <= cost.length <= 100`\n*   `1 <= cost[i] <= 100`\"\"\"\n\n    min_val = nums[0]\n    max_diff = -1\n\n    for i in range(1, len(nums)):\n        if nums[i] > min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n\n    return max_diff"}}, "leetcode/leetcode_1551.txt": {"score": 0.9339165091514587, "content": {"text": "def min_operations(n):\n    \"\"\"You have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e., `0 <= i < n`).\n\nIn one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e., perform `arr[x] -=1` and `arr[y] += 1`). The goal is to make all the elements of the array **equal**. It is **guaranteed** that all the elements of the array can be made equal using some operations.\n\nGiven an integer `n`, the length of the array, return _the minimum number of operations_ needed to make all the elements of arr equal.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** arr = \\[1, 3, 5\\]\nFirst operation choose x = 2 and y = 0, this leads arr to be \\[2, 3, 4\\]\nIn the second operation choose x = 2 and y = 0 again, thus arr = \\[3, 3, 3\\].\n\n**Example 2:**\n\n**Input:** n = 6\n**Output:** 9\n\n**Constraints:**\n\n*   `1 <= n <= 104`\"\"\"\n\n    return n * n // 4"}}, "leetcode/leetcode_1675.txt": {"score": 0.9445897936820984, "content": {"text": "from typing import List\n    \"\"\"You are given an array `nums` of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number of times:\n\n*   If the element is **even**, **divide** it by `2`.\n    *   For example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2].`\n*   If the element is **odd**, **multiply** it by `2`.\n    *   For example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4].`\n\nThe **deviation** of the array is the **maximum difference** between any two elements in the array.\n\nReturn _the **minimum deviation** the array can have after performing some number of operations._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 1\n**Explanation:** You can transform the array to \\[1,2,3,2\\], then to \\[2,2,3,2\\], then the deviation will be 3 - 2 = 1.\n\n**Example 2:**\n\n**Input:** nums = \\[4,1,5,20,3\\]\n**Output:** 3\n**Explanation:** You can transform the array after two operations to \\[4,2,5,5,3\\], then the deviation will be 5 - 2 = 3.\n\n**Example 3:**\n\n**Input:** nums = \\[2,10,8\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 5 * 104`\n*   `1 <= nums[i] <= 109`\"\"\"\n\n\ndef can_place_balls(force: int, position: List[int], m: int) -> bool:\n    last_position = position[0]\n    placed_balls = 1\n\n    for i in range(1, len(position)):\n        if position[i] - last_position >= force:\n            placed_balls += 1\n            last_position = position[i]\n\n            if placed_balls == m:\n                return True\n\n    return False\n\ndef max_distance(position: List[int], m: int) -> int:\n    position.sort()\n\n    left = 1\n    right = position[-1] - position[0]\n    ans = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_place_balls(mid, position, m):\n            ans = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return ans"}}, "leetcode/leetcode_1887.txt": {"score": 0.9456051588058472, "content": {"text": "from collections import defaultdict\n    \"\"\"Given an integer array `nums`, your goal is to make all elements in `nums` equal. To complete one operation, follow these steps:\n\n1.  Find the **largest** value in `nums`. Let its index be `i` (**0-indexed**) and its value be `largest`. If there are multiple elements with the largest value, pick the smallest `i`.\n2.  Find the **next largest** value in `nums` **strictly smaller** than `largest`. Let its value be `nextLargest`.\n3.  Reduce `nums[i]` to `nextLargest`.\n\nReturn _the number of operations to make all elements in_ `nums` _equal_.\n\n**Example 1:**\n\n**Input:** nums = \\[5,1,3\\]\n**Output:** 3\n**Explanation:** It takes 3 operations to make all elements in nums equal:\n1. largest = 5 at index 0. nextLargest = 3. Reduce nums\\[0\\] to 3. nums = \\[3,1,3\\].\n2. largest = 3 at index 0. nextLargest = 1. Reduce nums\\[0\\] to 1. nums = \\[1,1,3\\].\n3. largest = 3 at index 2. nextLargest = 1. Reduce nums\\[2\\] to 1. nums = \\[1,1,1\\].\n\n**Example 2:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 0\n**Explanation:** All elements in nums are already equal.\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,2,2,3\\]\n**Output:** 4\n**Explanation:** It takes 4 operations to make all elements in nums equal:\n1. largest = 3 at index 4. nextLargest = 2. Reduce nums\\[4\\] to 2. nums = \\[1,1,2,2,2\\].\n2. largest = 2 at index 2. nextLargest = 1. Reduce nums\\[2\\] to 1. nums = \\[1,1,1,2,2\\].\n3. largest = 2 at index 3. nextLargest = 1. Reduce nums\\[3\\] to 1. nums = \\[1,1,1,1,2\\].\n4. largest = 2 at index 4. nextLargest = 1. Reduce nums\\[4\\] to 1. nums = \\[1,1,1,1,1\\].\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `1 <= nums[i] <= 5 * 104`\"\"\"\n\n\ndef min_trio_degree(n, edges):\n    graph = defaultdict(dict)\n    degree = [0] * (n + 1)\n\n    for u, v in edges:\n        graph[u][v] = graph[v][u] = True\n        degree[u] += 1\n        degree[v] += 1\n\n    min_degree = float('inf')\n    for u, v in edges:\n        for w in range(1, n + 1):\n            if graph[u].get(w) and graph[v].get(w):\n                min_degree = min(min_degree, degree[u] + degree[v] + degree[w] - 6)\n\n    return min_degree if min_degree != float('inf') else -1"}}, "leetcode/leetcode_2064.txt": {"score": 0.9330706000328064, "content": {"text": "def minimum_maximum(n, quantities):\n    \"\"\"You are given an integer `n` indicating there are `n` specialty retail stores. There are `m` product types of varying amounts, which are given as a **0-indexed** integer array `quantities`, where `quantities[i]` represents the number of products of the `ith` product type.\n\nYou need to distribute **all products** to the retail stores following these rules:\n\n*   A store can only be given **at most one product type** but can be given **any** amount of it.\n*   After distribution, each store will have been given some number of products (possibly `0`). Let `x` represent the maximum number of products given to any store. You want `x` to be as small as possible, i.e., you want to **minimize** the **maximum** number of products that are given to any store.\n\nReturn _the minimum possible_ `x`.\n\n**Example 1:**\n\n**Input:** n = 6, quantities = \\[11,6\\]\n**Output:** 3\n**Explanation:** One optimal way is:\n- The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3\n- The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3\nThe maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) = 3.\n\n**Example 2:**\n\n**Input:** n = 7, quantities = \\[15,10,10\\]\n**Output:** 5\n**Explanation:** One optimal way is:\n- The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5\n- The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5\n- The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5\nThe maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) = 5.\n\n**Example 3:**\n\n**Input:** n = 1, quantities = \\[100000\\]\n**Output:** 100000\n**Explanation:** The only optimal way is:\n- The 100000 products of type 0 are distributed to the only store.\nThe maximum number of products given to any store is max(100000) = 100000.\n\n**Constraints:**\n\n*   `m == quantities.length`\n*   `1 <= m <= n <= 105`\n*   `1 <= quantities[i] <= 105`\"\"\"\n\n    sum_products = sum(quantities)\n    x = (sum_products + n - 1) // n\n    remaining_stores = n\n    for q in quantities:\n        remaining_stores -= (q + x - 1) // x\n        if remaining_stores < 0:\n            x = (sum_products + remaining_stores) // (n + remaining_stores)\n            remaining_stores = n\n    return x"}}, "leetcode/leetcode_2171.txt": {"score": 0.9938552975654602, "content": {"text": "import heapq\n    \"\"\"You are given an array of **positive** integers `beans`, where each integer represents the number of magic beans found in a particular magic bag.\n\n**Remove** any number of beans (**possibly none**) from each bag such that the number of beans in each remaining **non-empty** bag (still containing **at least one** bean) is **equal**. Once a bean has been removed from a bag, you are **not** allowed to return it to any of the bags.\n\nReturn _the **minimum** number of magic beans that you have to remove_.\n\n**Example 1:**\n\n**Input:** beans = \\[4,**1**,6,5\\]\n**Output:** 4\n**Explanation:** \n- We remove 1 bean from the bag with only 1 bean.\n  This results in the remaining bags: \\[4,**0**,6,5\\]\n- Then we remove 2 beans from the bag with 6 beans.\n  This results in the remaining bags: \\[4,0,**4**,5\\]\n- Then we remove 1 bean from the bag with 5 beans.\n  This results in the remaining bags: \\[4,0,4,**4**\\]\nWe removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that remove 4 beans or fewer.\n\n**Example 2:**\n\n**Input:** beans = \\[**2**,10,**3**,**2**\\]\n**Output:** 7\n**Explanation:**\n- We remove 2 beans from one of the bags with 2 beans.\n  This results in the remaining bags: \\[**0**,10,3,2\\]\n- Then we remove 2 beans from the other bag with 2 beans.\n  This results in the remaining bags: \\[0,10,3,**0**\\]\n- Then we remove 3 beans from the bag with 3 beans. \n  This results in the remaining bags: \\[0,10,**0**,0\\]\nWe removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that removes 7 beans or fewer.\n\n**Constraints:**\n\n*   `1 <= beans.length <= 105`\n*   `1 <= beans[i] <= 105`\"\"\"\n\n\ndef second_minimum(n: int, edges: List[List[int]], time: int, change: int) -> int:\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    dist = [-1] * (n + 1)\n    queue = [(0, 1)]\n    dist[1] = 0\n\n    while queue:\n        t1, v1 = heapq.heappop(queue)\n\n        if v1 == n:\n            return t1\n\n        for v2 in adj[v1]:\n            t2 = t1 + time\n            waiting = change - (t2 % change) if (t2 // change) % 2 == 1 else 0\n\n            if dist[v2] == -1 or dist[v2] > t2 + waiting:\n                if dist[v2] != -1:\n                    heapq.heappush(queue, (dist[v2], v2))\n                dist[v2] = t2 + waiting\n                heapq.heappush(queue, (dist[v2], v2))\n\n    return -1"}}, "leetcode/leetcode_2163.txt": {"score": 0.9410508871078491, "content": {"text": "def kth_distinct_string(arr, k):\n    \"\"\"You are given a **0-indexed** integer array `nums` consisting of `3 * n` elements.\n\nYou are allowed to remove any **subsequence** of elements of size **exactly** `n` from `nums`. The remaining `2 * n` elements will be divided into two **equal** parts:\n\n*   The first `n` elements belonging to the first part and their sum is `sumfirst`.\n*   The next `n` elements belonging to the second part and their sum is `sumsecond`.\n\nThe **difference in sums** of the two parts is denoted as `sumfirst - sumsecond`.\n\n*   For example, if `sumfirst = 3` and `sumsecond = 2`, their difference is `1`.\n*   Similarly, if `sumfirst = 2` and `sumsecond = 3`, their difference is `-1`.\n\nReturn _the **minimum difference** possible between the sums of the two parts after the removal of_ `n` _elements_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,1,2\\]\n**Output:** -1\n**Explanation:** Here, nums has 3 elements, so n = 1. \nThus we have to remove 1 element from nums and divide the array into two equal parts.\n- If we remove nums\\[0\\] = 3, the array will be \\[1,2\\]. The difference in sums of the two parts will be 1 - 2 = -1.\n- If we remove nums\\[1\\] = 1, the array will be \\[3,2\\]. The difference in sums of the two parts will be 3 - 2 = 1.\n- If we remove nums\\[2\\] = 2, the array will be \\[3,1\\]. The difference in sums of the two parts will be 3 - 1 = 2.\nThe minimum difference between sums of the two parts is min(-1,1,2) = -1. \n\n**Example 2:**\n\n**Input:** nums = \\[7,9,5,8,1,3\\]\n**Output:** 1\n**Explanation:** Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\nIf we remove nums\\[2\\] = 5 and nums\\[3\\] = 8, the resultant array will be \\[7,9,1,3\\]. The difference in sums will be (7+9) - (1+3) = 12.\nTo obtain the minimum difference, we should remove nums\\[1\\] = 9 and nums\\[4\\] = 1. The resultant array becomes \\[7,5,8,3\\]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\nIt can be shown that it is not possible to obtain a difference smaller than 1.\n\n**Constraints:**\n\n*   `nums.length == 3 * n`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 105`\"\"\"\n\n    frequency = {}\n    for s in arr:\n        frequency[s] = frequency.get(s, 0) + 1\n\n    count = 0\n    for s in arr:\n        if frequency[s] == 1:\n            count += 1\n            if count == k:\n                return s\n\n    return \"\""}}, "leetcode/leetcode_2448.txt": {"score": 0.9489925503730774, "content": {"text": "def minCost(nums, cost):\n    \"\"\"You are given two **0-indexed** arrays `nums` and `cost` consisting each of `n` **positive** integers.\n\nYou can do the following operation **any** number of times:\n\n*   Increase or decrease **any** element of the array `nums` by `1`.\n\nThe cost of doing one operation on the `ith` element is `cost[i]`.\n\nReturn _the **minimum** total cost such that all the elements of the array_ `nums` _become **equal**_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,5,2\\], cost = \\[2,3,1,14\\]\n**Output:** 8\n**Explanation:** We can make all the elements equal to 2 in the following way:\n- Increase the 0th element one time. The cost is 2.\n- Decrease the 1st element one time. The cost is 3.\n- Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3.\nThe total cost is 2 + 3 + 3 = 8.\nIt can be shown that we cannot make the array equal with a smaller cost.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\], cost = \\[4,2,8,1,3\\]\n**Output:** 0\n**Explanation:** All the elements are already equal, so no operations are needed.\n\n**Constraints:**\n\n*   `n == nums.length == cost.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i], cost[i] <= 106`\"\"\"\n\n    ans = float(\"inf\")\n    base = min(nums)\n    \n    for target in range(base, base + 2):\n        local_res = 0\n        for i in range(len(nums)):\n            local_res += abs(nums[i] - target) * cost[i]\n        ans = min(ans, local_res)\n    \n    return ans"}}}}, "111": {"gold": {"leetcode/leetcode_2002.txt": 1}, "retrieved": {"leetcode/leetcode_1431.txt": {"score": 0.9091336131095886, "content": {"text": "from collections import defaultdict\n    \"\"\"There are `n` kids with candies. You are given an integer array `candies`, where each `candies[i]` represents the number of candies the `ith` kid has, and an integer `extraCandies`, denoting the number of extra candies that you have.\n\nReturn _a boolean array_ `result` _of length_ `n`_, where_ `result[i]` _is_ `true` _if, after giving the_ `ith` _kid all the_ `extraCandies`_, they will have the **greatest** number of candies among all the kids__, or_ `false` _otherwise_.\n\nNote that **multiple** kids can have the **greatest** number of candies.\n\n**Example 1:**\n\n**Input:** candies = \\[2,3,5,1,3\\], extraCandies = 3\n**Output:** \\[true,true,true,false,true\\] \n**Explanation:** If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n\n**Example 2:**\n\n**Input:** candies = \\[4,2,1,1,2\\], extraCandies = 1\n**Output:** \\[true,false,false,false,false\\] \n**Explanation:** There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n\n**Example 3:**\n\n**Input:** candies = \\[12,1,12\\], extraCandies = 10\n**Output:** \\[true,false,true\\]\n\n**Constraints:**\n\n*   `n == candies.length`\n*   `2 <= n <= 100`\n*   `1 <= candies[i] <= 100`\n*   `1 <= extraCandies <= 50`\"\"\"\n\n\ndef find_ancestors(node, adj_list, visited, ans):\n    if visited[node]:\n        return\n    visited[node] = True\n    for ancestor in adj_list[node]:\n        ans.append(ancestor)\n        find_ancestors(ancestor, adj_list, visited, ans)\n\ndef find_ancestors_in_dag(n, edges):\n    adj_list = defaultdict(list)\n    for edge in edges:\n        adj_list[edge[1]].append(edge[0])\n    ans = []\n    for i in range(n):\n        visited = [False] * n\n        ancestors = []\n        find_ancestors(i, adj_list, visited, ancestors)\n        ans.append(sorted(ancestors))\n    return ans"}}, "leetcode/leetcode_1723.txt": {"score": 0.9113967418670654, "content": {"text": "def max_achievable_requests(n, requests, idx=0, counts=None):\n    \"\"\"You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`\"\"\"\n\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)"}}, "leetcode/leetcode_1770.txt": {"score": 0.9120101928710938, "content": {"text": "def min_deletions(s):\n    \"\"\"You are given two **0-indexed** integer arrays `nums` and `multipliers` of size `n` and `m` respectively, where `n >= m`.\n\nYou begin with a score of `0`. You want to perform **exactly** `m` operations. On the `ith` operation (**0-indexed**) you will:\n\n*   Choose one integer `x` from **either the start or the end** of the array `nums`.\n*   Add `multipliers[i] * x` to your score.\n    *   Note that `multipliers[0]` corresponds to the first operation, `multipliers[1]` to the second operation, and so on.\n*   Remove `x` from `nums`.\n\nReturn _the **maximum** score after performing_ `m` _operations._\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], multipliers = \\[3,2,1\\]\n**Output:** 14\n**Explanation:** An optimal solution is as follows:\n- Choose from the end, \\[1,2,**3**\\], adding 3 \\* 3 = 9 to the score.\n- Choose from the end, \\[1,**2**\\], adding 2 \\* 2 = 4 to the score.\n- Choose from the end, \\[**1**\\], adding 1 \\* 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14.\n\n**Example 2:**\n\n**Input:** nums = \\[-5,-3,-3,-2,7,1\\], multipliers = \\[-10,-5,3,4,6\\]\n**Output:** 102\n**Explanation:** An optimal solution is as follows:\n- Choose from the start, \\[**\\-5**,-3,-3,-2,7,1\\], adding -5 \\* -10 = 50 to the score.\n- Choose from the start, \\[**\\-3**,-3,-2,7,1\\], adding -3 \\* -5 = 15 to the score.\n- Choose from the start, \\[**\\-3**,-2,7,1\\], adding -3 \\* 3 = -9 to the score.\n- Choose from the end, \\[-2,7,**1**\\], adding 1 \\* 4 = 4 to the score.\n- Choose from the end, \\[-2,**7**\\], adding 7 \\* 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `m == multipliers.length`\n*   `1 <= m <= 300`\n*   `m <= n <= 105`\n*   `-1000 <= nums[i], multipliers[i] <= 1000`\"\"\"\n\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions"}}, "leetcode/leetcode_1792.txt": {"score": 0.9259178042411804, "content": {"text": "def most_competitive(nums, k):\n    \"\"\"There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array `classes`, where `classes[i] = [passi, totali]`. You know beforehand that in the `ith` class, there are `totali` total students, but only `passi` number of students will pass the exam.\n\nYou are also given an integer `extraStudents`. There are another `extraStudents` brilliant students that are **guaranteed** to pass the exam of any class they are assigned to. You want to assign each of the `extraStudents` students to a class in a way that **maximizes** the **average** pass ratio across **all** the classes.\n\nThe **pass ratio** of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The **average pass ratio** is the sum of pass ratios of all the classes divided by the number of the classes.\n\nReturn _the **maximum** possible average pass ratio after assigning the_ `extraStudents` _students._ Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** classes = \\[\\[1,2\\],\\[3,5\\],\\[2,2\\]\\], `extraStudents` = 2\n**Output:** 0.78333\n**Explanation:** You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.\n\n**Example 2:**\n\n**Input:** classes = \\[\\[2,4\\],\\[3,9\\],\\[4,5\\],\\[2,10\\]\\], `extraStudents` = 4\n**Output:** 0.53485\n\n**Constraints:**\n\n*   `1 <= classes.length <= 105`\n*   `classes[i].length == 2`\n*   `1 <= passi <= totali <= 105`\n*   `1 <= extraStudents <= 105`\"\"\"\n\n    stack = []\n    n = len(nums)\n\n    for i in range(n):\n        while stack and nums[i] < stack[-1] and len(stack) + n - i > k:\n            stack.pop()\n        if len(stack) < k:\n            stack.append(nums[i])\n\n    return stack"}}, "leetcode/leetcode_870.txt": {"score": 0.9114988446235657, "content": {"text": "from sortedcontainers import SortedList\n    \"\"\"You are given two integer arrays `nums1` and `nums2` both of the same length. The **advantage** of `nums1` with respect to `nums2` is the number of indices `i` for which `nums1[i] > nums2[i]`.\n\nReturn _any permutation of_ `nums1` _that maximizes its **advantage** with respect to_ `nums2`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,7,11,15\\], nums2 = \\[1,10,4,11\\]\n**Output:** \\[2,11,7,15\\]\n\n**Example 2:**\n\n**Input:** nums1 = \\[12,24,8,32\\], nums2 = \\[13,25,32,11\\]\n**Output:** \\[24,32,8,12\\]\n\n**Constraints:**\n\n*   `1 <= nums1.length <= 105`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 109`\"\"\"\n\n\ndef advantage_count(nums1, nums2):\n    nums1_sorted = SortedList(nums1)\n    result = []\n    for num in nums2:\n        index = nums1_sorted.bisect_right(num)\n        if index == len(nums1_sorted):\n            val = nums1_sorted.pop(0)\n        else:\n            val = nums1_sorted.pop(index)\n        result.append(val)\n    return result"}}, "leetcode/leetcode_1561.txt": {"score": 0.9135661721229553, "content": {"text": "def arrangeWords(text: str) -> str:\n    \"\"\"There are `3n` piles of coins of varying size, you and your friends will take piles of coins as follows:\n\n*   In each step, you will choose **any** `3` piles of coins (not necessarily consecutive).\n*   Of your choice, Alice will pick the pile with the maximum number of coins.\n*   You will pick the next pile with the maximum number of coins.\n*   Your friend Bob will pick the last pile.\n*   Repeat until there are no more piles of coins.\n\nGiven an array of integers `piles` where `piles[i]` is the number of coins in the `ith` pile.\n\nReturn the maximum number of coins that you can have.\n\n**Example 1:**\n\n**Input:** piles = \\[2,4,1,2,7,8\\]\n**Output:** 9\n**Explanation:** Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with **7** coins and Bob the last one.\nChoose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with **2** coins and Bob the last one.\nThe maximum number of coins which you can have are: 7 + 2 = 9.\nOn the other hand if we choose this arrangement (1, **2**, 8), (2, **4**, 7) you only get 2 + 4 = 6 coins which is not optimal.\n\n**Example 2:**\n\n**Input:** piles = \\[2,4,5\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** piles = \\[9,8,7,6,5,1,2,3,4\\]\n**Output:** 18\n\n**Constraints:**\n\n*   `3 <= piles.length <= 105`\n*   `piles.length % 3 == 0`\n*   `1 <= piles[i] <= 104`\"\"\"\n\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)"}}, "leetcode/leetcode_1140.txt": {"score": 0.9160241484642029, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`\"\"\"\n\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes"}}, "leetcode/leetcode_2212.txt": {"score": 0.9822486042976379, "content": {"text": "def min_deletions(nums):\n    \"\"\"Alice and Bob are opponents in an archery competition. The competition has set the following rules:\n\n1.  Alice first shoots `numArrows` arrows and then Bob shoots `numArrows` arrows.\n2.  The points are then calculated as follows:\n    1.  The target has integer scoring sections ranging from `0` to `11` **inclusive**.\n    2.  For **each** section of the target with score `k` (in between `0` to `11`), say Alice and Bob have shot `ak` and `bk` arrows on that section respectively. If `ak >= bk`, then Alice takes `k` points. If `ak < bk`, then Bob takes `k` points.\n    3.  However, if `ak == bk == 0`, then **nobody** takes `k` points.\n\n*   For example, if Alice and Bob both shot `2` arrows on the section with score `11`, then Alice takes `11` points. On the other hand, if Alice shot `0` arrows on the section with score `11` and Bob shot `2` arrows on that same section, then Bob takes `11` points.\n    \n\nYou are given the integer `numArrows` and an integer array `aliceArrows` of size `12`, which represents the number of arrows Alice shot on each scoring section from `0` to `11`. Now, Bob wants to **maximize** the total number of points he can obtain.\n\nReturn _the array_ `bobArrows` _which represents the number of arrows Bob shot on **each** scoring section from_ `0` _to_ `11`. The sum of the values in `bobArrows` should equal `numArrows`.\n\nIf there are multiple ways for Bob to earn the maximum total points, return **any** one of them.\n\n**Example 1:**\n\n**Input:** numArrows = 9, aliceArrows = \\[1,1,0,1,0,0,2,1,0,1,2,0\\]\n**Output:** \\[0,0,0,0,1,1,0,0,1,2,3,1\\]\n**Explanation:** The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points.\n\n**Example 2:**\n\n**Input:** numArrows = 3, aliceArrows = \\[0,0,1,0,0,0,0,0,0,0,0,2\\]\n**Output:** \\[0,0,0,0,0,0,0,0,1,1,1,0\\]\n**Explanation:** The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points.\n\n**Constraints:**\n\n*   `1 <= numArrows <= 105`\n*   `aliceArrows.length == bobArrows.length == 12`\n*   `0 <= aliceArrows[i], bobArrows[i] <= numArrows`\n*   `sum(aliceArrows[i]) == numArrows`\"\"\"\n\n    n = len(nums)\n    if n <= 2:\n        return 0\n        \n    min_idx, max_idx = 0, 0\n\n    for i in range(1, n):\n        if nums[i] < nums[min_idx]:\n            min_idx = i\n        if nums[i] > nums[max_idx]:\n            max_idx = i\n\n    return min(max(min_idx, max_idx), n - min(min_idx, max_idx) - 1, min_idx + n - max_idx - 1)"}}, "leetcode/leetcode_2279.txt": {"score": 0.9289675951004028, "content": {"text": "def max_unique_even_sum(final_sum):\n    \"\"\"You have `n` bags numbered from `0` to `n - 1`. You are given two **0-indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in **any** of the bags.\n\nReturn _the **maximum** number of bags that could have full capacity after placing the additional rocks in some bags._\n\n**Example 1:**\n\n**Input:** capacity = \\[2,3,4,5\\], rocks = \\[1,2,4,4\\], additionalRocks = 2\n**Output:** 3\n**Explanation:**\nPlace 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now \\[2,3,4,4\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3.\n\n**Example 2:**\n\n**Input:** capacity = \\[10,2,2\\], rocks = \\[2,2,0\\], additionalRocks = 100\n**Output:** 3\n**Explanation:**\nPlace 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now \\[10,2,2\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks.\n\n**Constraints:**\n\n*   `n == capacity.length == rocks.length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= capacity[i] <= 109`\n*   `0 <= rocks[i] <= capacity[i]`\n*   `1 <= additionalRocks <= 109`\"\"\"\n\n    result = []\n    current = 2\n    while final_sum > 0:\n        if final_sum >= current:\n            result.append(current)\n            final_sum -= current\n            current += 2\n        else:\n            break\n    return result"}}, "leetcode/leetcode_2611.txt": {"score": 0.9468451738357544, "content": {"text": "def maxPoints(reward1, reward2, k):\n    \"\"\"There are two mice and `n` different types of cheese, each type of cheese should be eaten by exactly one mouse.\n\nA point of the cheese with index `i` (**0-indexed**) is:\n\n*   `reward1[i]` if the first mouse eats it.\n*   `reward2[i]` if the second mouse eats it.\n\nYou are given a positive integer array `reward1`, a positive integer array `reward2`, and a non-negative integer `k`.\n\nReturn _**the maximum** points the mice can achieve if the first mouse eats exactly_ `k` _types of cheese._\n\n**Example 1:**\n\n**Input:** reward1 = \\[1,1,3,4\\], reward2 = \\[4,4,1,1\\], k = 2\n**Output:** 15\n**Explanation:** In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\n**Example 2:**\n\n**Input:** reward1 = \\[1,1\\], reward2 = \\[1,1\\], k = 2\n**Output:** 2\n**Explanation:** In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n**Constraints:**\n\n*   `1 <= n == reward1.length == reward2.length <= 105`\n*   `1 <= reward1[i], reward2[i] <= 1000`\n*   `0 <= k <= n`\"\"\"\n\n    gap = sorted([(reward2[i] - reward1[i], i) for i in range(len(reward1))], reverse=True)\n    firstMousePoints = sum(reward1[gap[i][1]] for i in range(k))\n    secondMousePoints = sum(reward2[gap[i][1]] for i in range(k, len(reward1)))\n    return firstMousePoints + secondMousePoints"}}}}, "112": {"gold": {"leetcode/leetcode_410.txt": 1}, "retrieved": {"leetcode/leetcode_2611.txt": {"score": 0.928898811340332, "content": {"text": "def maxPoints(reward1, reward2, k):\n    \"\"\"There are two mice and `n` different types of cheese, each type of cheese should be eaten by exactly one mouse.\n\nA point of the cheese with index `i` (**0-indexed**) is:\n\n*   `reward1[i]` if the first mouse eats it.\n*   `reward2[i]` if the second mouse eats it.\n\nYou are given a positive integer array `reward1`, a positive integer array `reward2`, and a non-negative integer `k`.\n\nReturn _**the maximum** points the mice can achieve if the first mouse eats exactly_ `k` _types of cheese._\n\n**Example 1:**\n\n**Input:** reward1 = \\[1,1,3,4\\], reward2 = \\[4,4,1,1\\], k = 2\n**Output:** 15\n**Explanation:** In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\n**Example 2:**\n\n**Input:** reward1 = \\[1,1\\], reward2 = \\[1,1\\], k = 2\n**Output:** 2\n**Explanation:** In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n**Constraints:**\n\n*   `1 <= n == reward1.length == reward2.length <= 105`\n*   `1 <= reward1[i], reward2[i] <= 1000`\n*   `0 <= k <= n`\"\"\"\n\n    gap = sorted([(reward2[i] - reward1[i], i) for i in range(len(reward1))], reverse=True)\n    firstMousePoints = sum(reward1[gap[i][1]] for i in range(k))\n    secondMousePoints = sum(reward2[gap[i][1]] for i in range(k, len(reward1)))\n    return firstMousePoints + secondMousePoints"}}, "leetcode/leetcode_2528.txt": {"score": 0.9346429705619812, "content": {"text": "def max_min_power(stations, r, k):\n    \"\"\"You are given a **0-indexed** integer array `stations` of length `n`, where `stations[i]` represents the number of power stations in the `ith` city.\n\nEach power station can provide power to every city in a fixed **range**. In other words, if the range is denoted by `r`, then a power station at city `i` can provide power to all cities `j` such that `|i - j| <= r` and `0 <= i, j <= n - 1`.\n\n*   Note that `|x|` denotes **absolute** value. For example, `|7 - 5| = 2` and `|3 - 10| = 7`.\n\nThe **power** of a city is the total number of power stations it is being provided power from.\n\nThe government has sanctioned building `k` more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\n\nGiven the two integers `r` and `k`, return _the **maximum possible minimum power** of a city, if the additional power stations are built optimally._\n\n**Note** that you can build the `k` power stations in multiple cities.\n\n**Example 1:**\n\n**Input:** stations = \\[1,2,4,5,0\\], r = 1, k = 2\n**Output:** 5\n**Explanation:** \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become \\[1,4,4,5,0\\].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.\n\n**Example 2:**\n\n**Input:** stations = \\[4,4,4,4\\], r = 0, k = 3\n**Output:** 4\n**Explanation:** \nIt can be proved that we cannot make the minimum power of a city greater than 4.\n\n**Constraints:**\n\n*   `n == stations.length`\n*   `1 <= n <= 105`\n*   `0 <= stations[i] <= 105`\n*   `0 <= r <= n - 1`\n*   `0 <= k <= 109`\"\"\"\n\n    n = len(stations)\n    total_power = [0] * n\n    for i in range(n):\n        for j in range(max(0, i - r), min(n, i + r + 1)):\n            total_power[j] += stations[i]\n\n    sumk = 0\n    min_power = float('inf')\n    for i in range(r, n - r):\n        sumk += stations[i]\n        min_power = min(min_power, total_power[i])\n\n    for j in range(2 * r):\n        i = n - 2 * r - 1 - j\n        sumk -= stations[i + r + 1]\n        min_power -= stations[j]\n        min_power += sumk\n        min_power += k\n        min_power = min(min_power, total_power[j])\n\n    return min_power"}}, "leetcode/leetcode_1648.txt": {"score": 0.9304491281509399, "content": {"text": "def minInsertions(s: str) -> int:\n    \"\"\"You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of **any** color.\n\nThe customer weirdly values the colored balls. Each colored ball's value is the number of balls **of that color** you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer).\n\nYou are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls **in any order**.\n\nReturn _the **maximum** total value that you can attain after selling_ `orders` _colored balls_. As the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** inventory = \\[2,5\\], orders = 4\n**Output:** 14\n**Explanation:** Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\nThe maximum total value is 2 + 5 + 4 + 3 = 14.\n\n**Example 2:**\n\n**Input:** inventory = \\[3,5\\], orders = 6\n**Output:** 19\n**Explanation:** Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\nThe maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n\n**Constraints:**\n\n*   `1 <= inventory.length <= 105`\n*   `1 <= inventory[i] <= 109`\n*   `1 <= orders <= min(sum(inventory[i]), 109)`\"\"\"\n\n    ans, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 2\n        else:\n            if s[i - 1] == '(':\n                depth -= 1\n            else:\n                depth -= 2\n            if depth < 0:\n                ans -= depth\n                depth = 0\n    return ans + depth"}}, "leetcode/leetcode_1723.txt": {"score": 0.935197651386261, "content": {"text": "def max_achievable_requests(n, requests, idx=0, counts=None):\n    \"\"\"You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`\"\"\"\n\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)"}}, "leetcode/leetcode_1431.txt": {"score": 0.9364895224571228, "content": {"text": "from collections import defaultdict\n    \"\"\"There are `n` kids with candies. You are given an integer array `candies`, where each `candies[i]` represents the number of candies the `ith` kid has, and an integer `extraCandies`, denoting the number of extra candies that you have.\n\nReturn _a boolean array_ `result` _of length_ `n`_, where_ `result[i]` _is_ `true` _if, after giving the_ `ith` _kid all the_ `extraCandies`_, they will have the **greatest** number of candies among all the kids__, or_ `false` _otherwise_.\n\nNote that **multiple** kids can have the **greatest** number of candies.\n\n**Example 1:**\n\n**Input:** candies = \\[2,3,5,1,3\\], extraCandies = 3\n**Output:** \\[true,true,true,false,true\\] \n**Explanation:** If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n\n**Example 2:**\n\n**Input:** candies = \\[4,2,1,1,2\\], extraCandies = 1\n**Output:** \\[true,false,false,false,false\\] \n**Explanation:** There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n\n**Example 3:**\n\n**Input:** candies = \\[12,1,12\\], extraCandies = 10\n**Output:** \\[true,false,true\\]\n\n**Constraints:**\n\n*   `n == candies.length`\n*   `2 <= n <= 100`\n*   `1 <= candies[i] <= 100`\n*   `1 <= extraCandies <= 50`\"\"\"\n\n\ndef find_ancestors(node, adj_list, visited, ans):\n    if visited[node]:\n        return\n    visited[node] = True\n    for ancestor in adj_list[node]:\n        ans.append(ancestor)\n        find_ancestors(ancestor, adj_list, visited, ans)\n\ndef find_ancestors_in_dag(n, edges):\n    adj_list = defaultdict(list)\n    for edge in edges:\n        adj_list[edge[1]].append(edge[0])\n    ans = []\n    for i in range(n):\n        visited = [False] * n\n        ancestors = []\n        find_ancestors(i, adj_list, visited, ancestors)\n        ans.append(sorted(ancestors))\n    return ans"}}, "leetcode/leetcode_2212.txt": {"score": 0.9429324269294739, "content": {"text": "def min_deletions(nums):\n    \"\"\"Alice and Bob are opponents in an archery competition. The competition has set the following rules:\n\n1.  Alice first shoots `numArrows` arrows and then Bob shoots `numArrows` arrows.\n2.  The points are then calculated as follows:\n    1.  The target has integer scoring sections ranging from `0` to `11` **inclusive**.\n    2.  For **each** section of the target with score `k` (in between `0` to `11`), say Alice and Bob have shot `ak` and `bk` arrows on that section respectively. If `ak >= bk`, then Alice takes `k` points. If `ak < bk`, then Bob takes `k` points.\n    3.  However, if `ak == bk == 0`, then **nobody** takes `k` points.\n\n*   For example, if Alice and Bob both shot `2` arrows on the section with score `11`, then Alice takes `11` points. On the other hand, if Alice shot `0` arrows on the section with score `11` and Bob shot `2` arrows on that same section, then Bob takes `11` points.\n    \n\nYou are given the integer `numArrows` and an integer array `aliceArrows` of size `12`, which represents the number of arrows Alice shot on each scoring section from `0` to `11`. Now, Bob wants to **maximize** the total number of points he can obtain.\n\nReturn _the array_ `bobArrows` _which represents the number of arrows Bob shot on **each** scoring section from_ `0` _to_ `11`. The sum of the values in `bobArrows` should equal `numArrows`.\n\nIf there are multiple ways for Bob to earn the maximum total points, return **any** one of them.\n\n**Example 1:**\n\n**Input:** numArrows = 9, aliceArrows = \\[1,1,0,1,0,0,2,1,0,1,2,0\\]\n**Output:** \\[0,0,0,0,1,1,0,0,1,2,3,1\\]\n**Explanation:** The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points.\n\n**Example 2:**\n\n**Input:** numArrows = 3, aliceArrows = \\[0,0,1,0,0,0,0,0,0,0,0,2\\]\n**Output:** \\[0,0,0,0,0,0,0,0,1,1,1,0\\]\n**Explanation:** The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points.\n\n**Constraints:**\n\n*   `1 <= numArrows <= 105`\n*   `aliceArrows.length == bobArrows.length == 12`\n*   `0 <= aliceArrows[i], bobArrows[i] <= numArrows`\n*   `sum(aliceArrows[i]) == numArrows`\"\"\"\n\n    n = len(nums)\n    if n <= 2:\n        return 0\n        \n    min_idx, max_idx = 0, 0\n\n    for i in range(1, n):\n        if nums[i] < nums[min_idx]:\n            min_idx = i\n        if nums[i] > nums[max_idx]:\n            max_idx = i\n\n    return min(max(min_idx, max_idx), n - min(min_idx, max_idx) - 1, min_idx + n - max_idx - 1)"}}, "leetcode/leetcode_2551.txt": {"score": 0.9311961531639099, "content": {"text": "def maximize_score(weights, k):\n    \"\"\"You have `k` bags. You are given a **0-indexed** integer array `weights` where `weights[i]` is the weight of the `ith` marble. You are also given the integer `k.`\n\nDivide the marbles into the `k` bags according to the following rules:\n\n*   No bag is empty.\n*   If the `ith` marble and `jth` marble are in a bag, then all marbles with an index between the `ith` and `jth` indices should also be in that same bag.\n*   If a bag consists of all the marbles with an index from `i` to `j` inclusively, then the cost of the bag is `weights[i] + weights[j]`.\n\nThe **score** after distributing the marbles is the sum of the costs of all the `k` bags.\n\nReturn _the **difference** between the **maximum** and **minimum** scores among marble distributions_.\n\n**Example 1:**\n\n**Input:** weights = \\[1,3,5,1\\], k = 2\n**Output:** 4\n**Explanation:** \nThe distribution \\[1\\],\\[3,5,1\\] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution \\[1,3\\],\\[5,1\\], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n\n**Example 2:**\n\n**Input:** weights = \\[1, 3\\], k = 2\n**Output:** 0\n**Explanation:** The only distribution possible is \\[1\\],\\[3\\]. \nSince both the maximal and minimal score are the same, we return 0.\n\n**Constraints:**\n\n*   `1 <= k <= weights.length <= 105`\n*   `1 <= weights[i] <= 109`\"\"\"\n\n    n = len(weights)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n    dp = [[-1000000000] * (k + 1) for _ in range(n)]\n\n    for i in range(n):\n        dp[i][1] = prefix_sum[i + 1]\n        if i > 0:\n            dp[i][i + 1] = prefix_sum[i + 1] - prefix_sum[1]\n        for j in range(2, min(i + 1, k) + 1):\n            for q in range(1, i - j + 3):\n                dp[i][j] = max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q])\n\n    return dp[n - 1][k] - dp[n - 1][1]"}}, "leetcode/leetcode_2234.txt": {"score": 0.9772892594337463, "content": {"text": "def min_operations_to_K_increasing(arr, k):\n    \"\"\"Alice is a caretaker of `n` gardens and she wants to plant flowers to maximize the total beauty of all her gardens.\n\nYou are given a **0-indexed** integer array `flowers` of size `n`, where `flowers[i]` is the number of flowers already planted in the `ith` garden. Flowers that are already planted **cannot** be removed. You are then given another integer `newFlowers`, which is the **maximum** number of flowers that Alice can additionally plant. You are also given the integers `target`, `full`, and `partial`.\n\nA garden is considered **complete** if it has **at least** `target` flowers. The **total beauty** of the gardens is then determined as the **sum** of the following:\n\n*   The number of **complete** gardens multiplied by `full`.\n*   The **minimum** number of flowers in any of the **incomplete** gardens multiplied by `partial`. If there are no incomplete gardens, then this value will be `0`.\n\nReturn _the **maximum** total beauty that Alice can obtain after planting at most_ `newFlowers` _flowers._\n\n**Example 1:**\n\n**Input:** flowers = \\[1,3,1,1\\], newFlowers = 7, target = 6, full = 12, partial = 1\n**Output:** 14\n**Explanation:** Alice can plant\n- 2 flowers in the 0th garden\n- 3 flowers in the 1st garden\n- 1 flower in the 2nd garden\n- 1 flower in the 3rd garden\nThe gardens will then be \\[3,6,2,2\\]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.\nThere is 1 garden that is complete.\nThe minimum number of flowers in the incomplete gardens is 2.\nThus, the total beauty is 1 \\* 12 + 2 \\* 1 = 12 + 2 = 14.\nNo other way of planting flowers can obtain a total beauty higher than 14.\n\n**Example 2:**\n\n**Input:** flowers = \\[2,4,5,3\\], newFlowers = 10, target = 5, full = 2, partial = 6\n**Output:** 30\n**Explanation:** Alice can plant\n- 3 flowers in the 0th garden\n- 0 flowers in the 1st garden\n- 0 flowers in the 2nd garden\n- 2 flowers in the 3rd garden\nThe gardens will then be \\[5,4,5,5\\]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.\nThere are 3 gardens that are complete.\nThe minimum number of flowers in the incomplete gardens is 4.\nThus, the total beauty is 3 \\* 2 + 4 \\* 6 = 6 + 24 = 30.\nNo other way of planting flowers can obtain a total beauty higher than 30.\nNote that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.\n\n**Constraints:**\n\n*   `1 <= flowers.length <= 105`\n*   `1 <= flowers[i], target <= 105`\n*   `1 <= newFlowers <= 1010`\n*   `1 <= full, partial <= 105`\"\"\"\n\n    operations = 0\n    for i in range(k, len(arr)):\n        if arr[i] <= arr[i - k]:\n            operations += (arr[i - k] - arr[i] + 1)\n            arr[i] = arr[i - k] + 1\n    return operations"}}, "leetcode/leetcode_2305.txt": {"score": 0.935562789440155, "content": {"text": "def min_append_k_sum(nums, k):\n    \"\"\"You are given an integer array `cookies`, where `cookies[i]` denotes the number of cookies in the `ith` bag. You are also given an integer `k` that denotes the number of children to distribute **all** the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.\n\nThe **unfairness** of a distribution is defined as the **maximum** **total** cookies obtained by a single child in the distribution.\n\nReturn _the **minimum** unfairness of all distributions_.\n\n**Example 1:**\n\n**Input:** cookies = \\[8,15,10,20,8\\], k = 2\n**Output:** 31\n**Explanation:** One optimal distribution is \\[8,15,8\\] and \\[10,20\\]\n- The 1st child receives \\[8,15,8\\] which has a total of 8 + 15 + 8 = 31 cookies.\n- The 2nd child receives \\[10,20\\] which has a total of 10 + 20 = 30 cookies.\nThe unfairness of the distribution is max(31,30) = 31.\nIt can be shown that there is no distribution with an unfairness less than 31.\n\n**Example 2:**\n\n**Input:** cookies = \\[6,1,3,2,2,4,1,2\\], k = 3\n**Output:** 7\n**Explanation:** One optimal distribution is \\[6,1\\], \\[3,2,2\\], and \\[4,1,2\\]\n- The 1st child receives \\[6,1\\] which has a total of 6 + 1 = 7 cookies.\n- The 2nd child receives \\[3,2,2\\] which has a total of 3 + 2 + 2 = 7 cookies.\n- The 3rd child receives \\[4,1,2\\] which has a total of 4 + 1 + 2 = 7 cookies.\nThe unfairness of the distribution is max(7,7,7) = 7.\nIt can be shown that there is no distribution with an unfairness less than 7.\n\n**Constraints:**\n\n*   `2 <= cookies.length <= 8`\n*   `1 <= cookies[i] <= 105`\n*   `2 <= k <= cookies.length`\"\"\"\n\n    max_elem = max(nums)\n    return sum(range(max_elem + 1, max_elem + k + 1))"}}, "leetcode/leetcode_2279.txt": {"score": 0.9592427015304565, "content": {"text": "def max_unique_even_sum(final_sum):\n    \"\"\"You have `n` bags numbered from `0` to `n - 1`. You are given two **0-indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in **any** of the bags.\n\nReturn _the **maximum** number of bags that could have full capacity after placing the additional rocks in some bags._\n\n**Example 1:**\n\n**Input:** capacity = \\[2,3,4,5\\], rocks = \\[1,2,4,4\\], additionalRocks = 2\n**Output:** 3\n**Explanation:**\nPlace 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now \\[2,3,4,4\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3.\n\n**Example 2:**\n\n**Input:** capacity = \\[10,2,2\\], rocks = \\[2,2,0\\], additionalRocks = 100\n**Output:** 3\n**Explanation:**\nPlace 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now \\[10,2,2\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks.\n\n**Constraints:**\n\n*   `n == capacity.length == rocks.length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= capacity[i] <= 109`\n*   `0 <= rocks[i] <= capacity[i]`\n*   `1 <= additionalRocks <= 109`\"\"\"\n\n    result = []\n    current = 2\n    while final_sum > 0:\n        if final_sum >= current:\n            result.append(current)\n            final_sum -= current\n            current += 2\n        else:\n            break\n    return result"}}}}, "113": {"gold": {"leetcode/leetcode_2177.txt": 1, "leetcode/leetcode_2180.txt": 1}, "retrieved": {"leetcode/leetcode_39.txt": {"score": 0.9005144238471985, "content": {"text": "def combinationSum(candidates, target):\n    \"\"\"Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.\n\nThe **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n\n**Example 1:**\n\n**Input:** candidates = \\[2,3,6,7\\], target = 7\n**Output:** \\[\\[2,2,3\\],\\[7\\]\\]\n**Explanation:**\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\n**Example 2:**\n\n**Input:** candidates = \\[2,3,5\\], target = 8\n**Output:** \\[\\[2,2,2,2\\],\\[2,3,3\\],\\[3,5\\]\\]\n\n**Example 3:**\n\n**Input:** candidates = \\[2\\], target = 1\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= candidates.length <= 30`\n*   `2 <= candidates[i] <= 40`\n*   All elements of `candidates` are **distinct**.\n*   `1 <= target <= 40`\"\"\"\n\n    def findCombinations(startIndex, remaining):\n        if remaining == 0:\n            return [[]]\n        if startIndex == len(candidates) or remaining < 0:\n            return []\n\n        result = []\n        result.extend(findCombinations(startIndex + 1, remaining))\n        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])\n        \n        return result\n\n    return findCombinations(0, target)"}}, "leetcode/leetcode_1798.txt": {"score": 0.9114450812339783, "content": {"text": "def maxOperations(nums, k):\n    \"\"\"You are given an integer array `coins` of length `n` which represents the `n` coins that you own. The value of the `ith` coin is `coins[i]`. You can **make** some value `x` if you can choose some of your `n` coins such that their values sum up to `x`.\n\nReturn the _maximum number of consecutive integer values that you **can** **make** with your coins **starting** from and **including**_ `0`.\n\nNote that you may have multiple coins of the same value.\n\n**Example 1:**\n\n**Input:** coins = \\[1,3\\]\n**Output:** 2\n**Explanation:** You can make the following values:\n- 0: take \\[\\]\n- 1: take \\[1\\]\nYou can make 2 consecutive integer values starting from 0.\n\n**Example 2:**\n\n**Input:** coins = \\[1,1,1,4\\]\n**Output:** 8\n**Explanation:** You can make the following values:\n- 0: take \\[\\]\n- 1: take \\[1\\]\n- 2: take \\[1,1\\]\n- 3: take \\[1,1,1\\]\n- 4: take \\[4\\]\n- 5: take \\[4,1\\]\n- 6: take \\[4,1,1\\]\n- 7: take \\[4,1,1,1\\]\nYou can make 8 consecutive integer values starting from 0.\n\n**Example 3:**\n\n**Input:** nums = \\[1,4,10,3,1\\]\n**Output:** 20\n\n**Constraints:**\n\n*   `coins.length == n`\n*   `1 <= n <= 4 * 104`\n*   `1 <= coins[i] <= 4 * 104`\"\"\"\n\n    count = {}\n    operations = 0\n\n    for num in nums:\n        if count.get(k - num, 0) > 0:\n            count[k - num] -= 1\n            operations += 1\n        else:\n            count[num] = count.get(num, 0) + 1\n\n    return operations"}}, "leetcode/leetcode_956.txt": {"score": 0.906105101108551, "content": {"text": "def numMusicPlaylists(n, goal, k):\n    \"\"\"You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\n\nYou are given a collection of `rods` that can be welded together. For example, if you have rods of lengths `1`, `2`, and `3`, you can weld them together to make a support of length `6`.\n\nReturn _the largest possible height of your billboard installation_. If you cannot support the billboard, return `0`.\n\n**Example 1:**\n\n**Input:** rods = \\[1,2,3,6\\]\n**Output:** 6\n**Explanation:** We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\n**Example 2:**\n\n**Input:** rods = \\[1,2,3,4,5,6\\]\n**Output:** 10\n**Explanation:** We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\n**Example 3:**\n\n**Input:** rods = \\[1,2\\]\n**Output:** 0\n**Explanation:** The billboard cannot be supported, so we return 0.\n\n**Constraints:**\n\n*   `1 <= rods.length <= 20`\n*   `1 <= rods[i] <= 1000`\n*   `sum(rods[i]) <= 5000`\"\"\"\n\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(goal + 1)]\n    dp[0][0] = 1\n    for i in range(1, goal + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * max(0, j - k) % MOD) % MOD\n    return dp[goal][n]"}}, "leetcode/leetcode_2591.txt": {"score": 0.9116876721382141, "content": {"text": "def maximum_children_with_eight_dollars(money, children):\n    \"\"\"You are given an integer `money` denoting the amount of money (in dollars) that you have and another integer `children` denoting the number of children that you must distribute the money to.\n\nYou have to distribute the money according to the following rules:\n\n*   All money must be distributed.\n*   Everyone must receive at least `1` dollar.\n*   Nobody receives `4` dollars.\n\nReturn _the **maximum** number of children who may receive **exactly**_ `8` _dollars if you distribute the money according to the aforementioned rules_. If there is no way to distribute the money, return `-1`.\n\n**Example 1:**\n\n**Input:** money = 20, children = 3\n**Output:** 1\n**Explanation:** \nThe maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is:\n- 8 dollars to the first child.\n- 9 dollars to the second child. \n- 3 dollars to the third child.\nIt can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1.\n\n**Example 2:**\n\n**Input:** money = 16, children = 2\n**Output:** 2\n**Explanation:** Each child can be given 8 dollars.\n\n**Constraints:**\n\n*   `1 <= money <= 200`\n*   `2 <= children <= 30`\"\"\"\n\n    if money < children * 1 or money > children * 8:\n        return -1\n    max_eights = (money - children) // 7\n    return children if max_eights >= children else max_eights"}}, "leetcode/leetcode_518.txt": {"score": 0.9594346284866333, "content": {"text": "def change(amount, coins):\n    \"\"\"You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the number of combinations that make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `0`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is **guaranteed** to fit into a signed **32-bit** integer.\n\n**Example 1:**\n\n**Input:** amount = 5, coins = \\[1,2,5\\]\n**Output:** 4\n**Explanation:** there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n\n**Example 2:**\n\n**Input:** amount = 3, coins = \\[2\\]\n**Output:** 0\n**Explanation:** the amount of 3 cannot be made up just with coins of 2.\n\n**Example 3:**\n\n**Input:** amount = 10, coins = \\[10\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= coins.length <= 300`\n*   `1 <= coins[i] <= 5000`\n*   All the values of `coins` are **unique**.\n*   `0 <= amount <= 5000`\"\"\"\n\n    dp = [1] + [0] * amount\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]"}}, "leetcode/leetcode_638.txt": {"score": 0.9423310160636902, "content": {"text": "from typing import List\n    \"\"\"In LeetCode Store, there are `n` items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\n\nYou are given an integer array `price` where `price[i]` is the price of the `ith` item, and an integer array `needs` where `needs[i]` is the number of pieces of the `ith` item you want to buy.\n\nYou are also given an array `special` where `special[i]` is of size `n + 1` where `special[i][j]` is the number of pieces of the `jth` item in the `ith` offer and `special[i][n]` (i.e., the last integer in the array) is the price of the `ith` offer.\n\nReturn _the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers_. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.\n\n**Example 1:**\n\n**Input:** price = \\[2,5\\], special = \\[\\[3,0,5\\],\\[1,2,10\\]\\], needs = \\[3,2\\]\n**Output:** 14\n**Explanation:** There are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n\n**Example 2:**\n\n**Input:** price = \\[2,3,4\\], special = \\[\\[1,1,0,4\\],\\[2,2,1,9\\]\\], needs = \\[1,2,1\\]\n**Output:** 11\n**Explanation:** The price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n\n**Constraints:**\n\n*   `n == price.length == needs.length`\n*   `1 <= n <= 6`\n*   `0 <= price[i], needs[i] <= 10`\n*   `1 <= special.length <= 100`\n*   `special[i].length == n + 1`\n*   `0 <= special[i][j] <= 50`\"\"\"\n\n\ndef shoppingOffers(price: List[int], special: List[List[int]], needs: List[int]) -> int:\n    def helper(index):\n        if index == len(special):\n            return sum(needs[i] * price[i] for i in range(len(needs)))\n\n        no_offer = helper(index + 1)\n        can_apply_offer = True\n        for i in range(len(needs)):\n            needs[i] -= special[index][i]\n            if needs[i] < 0:\n                can_apply_offer = False\n\n        with_offer = float('inf')\n        if can_apply_offer:\n            offer_cost = special[index][-1] + helper(index)\n            with_offer = min(no_offer, offer_cost)\n\n        for i in range(len(needs)):\n            needs[i] += special[index][i]\n        \n        return with_offer if can_apply_offer else no_offer\n\n    return helper(0)"}}, "leetcode/leetcode_377.txt": {"score": 0.9227902889251709, "content": {"text": "def combination_sum(nums, target):\n    \"\"\"Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`.\n\nThe test cases are generated so that the answer can fit in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], target = 4\n**Output:** 7\n**Explanation:**\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n\n**Example 2:**\n\n**Input:** nums = \\[9\\], target = 3\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 1000`\n*   All the elements of `nums` are **unique**.\n*   `1 <= target <= 1000`\n\n**Follow up:** What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?\"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]"}}, "leetcode/leetcode_2585.txt": {"score": 0.9444150924682617, "content": {"text": "def numberOfWays(target, types):\n    \"\"\"There is a test that has `n` types of questions. You are given an integer `target` and a **0-indexed** 2D integer array `types` where `types[i] = [counti, marksi]` indicates that there are `counti` questions of the `ith` type, and each one of them is worth `marksi` points.\n\nReturn _the number of ways you can earn **exactly**_ `target` _points in the exam_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n**Note** that questions of the same type are indistinguishable.\n\n*   For example, if there are `3` questions of the same type, then solving the `1st` and `2nd` questions is the same as solving the `1st` and `3rd` questions, or the `2nd` and `3rd` questions.\n\n**Example 1:**\n\n**Input:** target = 6, types = \\[\\[6,1\\],\\[3,2\\],\\[2,3\\]\\]\n**Output:** 7\n**Explanation:** You can earn 6 points in one of the seven ways:\n- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6\n- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6\n- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6\n- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6\n- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6\n- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6\n- Solve 2 questions of the 2nd type: 3 + 3 = 6\n\n**Example 2:**\n\n**Input:** target = 5, types = \\[\\[50,1\\],\\[50,2\\],\\[50,5\\]\\]\n**Output:** 4\n**Explanation:** You can earn 5 points in one of the four ways:\n- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5\n- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5\n- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5\n- Solve 1 question of the 2nd type: 5\n\n**Example 3:**\n\n**Input:** target = 18, types = \\[\\[6,1\\],\\[3,2\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:** You can only earn 18 points by answering all questions.\n\n**Constraints:**\n\n*   `1 <= target <= 1000`\n*   `n == types.length`\n*   `1 <= n <= 50`\n*   `types[i].length == 2`\n*   `1 <= counti, marksi <= 50`\"\"\"\n\n    MOD = 10**9 + 7\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for count, marks in types:\n        dptmp = [0] * (target + 1)\n        for i in range(target + 1):\n            for j in range(count + 1):\n                if j * marks + i <= target:\n                    dptmp[i + j * marks] = (dptmp[i + j * marks] + dp[i]) % MOD\n        dp = dptmp\n    return dp[target]"}}, "leetcode/leetcode_322.txt": {"score": 0.9313961267471313, "content": {"text": "def coinChange(coins, amount):\n    \"\"\"You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n**Example 1:**\n\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n\n**Example 2:**\n\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n\n**Example 3:**\n\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`\"\"\"\n\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1"}}, "leetcode/leetcode_2240.txt": {"score": 0.9860259294509888, "content": {"text": "from collections import defaultdict\n    \"\"\"You are given an integer `total` indicating the amount of money you have. You are also given two integers `cost1` and `cost2` indicating the price of a pen and pencil respectively. You can spend **part or all** of your money to buy multiple quantities (or none) of each kind of writing utensil.\n\nReturn _the **number of distinct ways** you can buy some number of pens and pencils._\n\n**Example 1:**\n\n**Input:** total = 20, cost1 = 10, cost2 = 5\n**Output:** 9\n**Explanation:** The price of a pen is 10 and the price of a pencil is 5.\n- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\n- If you buy 1 pen, you can buy 0, 1, or 2 pencils.\n- If you buy 2 pens, you cannot buy any pencils.\nThe total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\n\n**Example 2:**\n\n**Input:** total = 5, cost1 = 10, cost2 = 10\n**Output:** 1\n**Explanation:** The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils.\n\n**Constraints:**\n\n*   `1 <= total, cost1, cost2 <= 106`\"\"\"\n\n\ndef sum_of_intervals(arr):\n    n = len(arr)\n    indices = defaultdict(list)\n    intervals = [0] * n\n\n    for i in range(n):\n        indices[arr[i]].append(i)\n\n    for i in range(n):\n        for index in indices[arr[i]]:\n            intervals[i] += abs(index - i)\n\n    return intervals"}}}}, "114": {"gold": {"leetcode/leetcode_172.txt": 1, "leetcode/leetcode_2117.txt": 1}, "retrieved": {"leetcode/leetcode_892.txt": {"score": 0.9044426679611206, "content": {"text": "from collections import deque\n    \"\"\"You are given an `n x n` `grid` where you have placed some `1 x 1 x 1` cubes. Each value `v = grid[i][j]` represents a tower of `v` cubes placed on top of cell `(i, j)`.\n\nAfter placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes.\n\nReturn _the total surface area of the resulting shapes_.\n\n**Note:** The bottom face of each shape counts toward its surface area.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** 34\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 32\n\n**Example 3:**\n\n**Input:** grid = \\[\\[2,2,2\\],\\[2,1,2\\],\\[2,2,2\\]\\]\n**Output:** 46\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] <= 50`\"\"\"\n\n\ndef shortest_subarray(nums, k):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    res = n + 1\n    dq = deque()\n    for i in range(n + 1):\n        while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:\n            res = min(res, i - dq.popleft())\n        while dq and prefix_sum[i] <= prefix_sum[dq[-1]]:\n            dq.pop()\n        dq.append(i)\n\n    return res if res <= n else -1"}}, "leetcode/leetcode_2242.txt": {"score": 0.9044812321662903, "content": {"text": "def maxScore(scores, edges):\n    \"\"\"There is an **undirected** graph with `n` nodes, numbered from `0` to `n - 1`.\n\nYou are given a **0-indexed** integer array `scores` of length `n` where `scores[i]` denotes the score of node `i`. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nA node sequence is **valid** if it meets the following conditions:\n\n*   There is an edge connecting every pair of **adjacent** nodes in the sequence.\n*   No node appears more than once in the sequence.\n\nThe score of a node sequence is defined as the **sum** of the scores of the nodes in the sequence.\n\nReturn _the **maximum score** of a valid node sequence with a length of_ `4`_._ If no such sequence exists, return `-1`.\n\n**Example 1:**\n\n**Input:** scores = \\[5,2,9,8,4\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[0,2\\],\\[1,3\\],\\[2,4\\]\\]\n**Output:** 24\n**Explanation:** The figure above shows the graph and the chosen node sequence \\[0,1,2,3\\].\nThe score of the node sequence is 5 + 2 + 9 + 8 = 24.\nIt can be shown that no other node sequence has a score of more than 24.\nNote that the sequences \\[3,1,2,0\\] and \\[1,0,2,3\\] are also valid and have a score of 24.\nThe sequence \\[0,3,2,4\\] is not valid since no edge connects nodes 0 and 3.\n\n**Example 2:**\n\n**Input:** scores = \\[9,20,6,4,11,12\\], edges = \\[\\[0,3\\],\\[5,3\\],\\[2,4\\],\\[1,3\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the graph.\nThere are no valid node sequences of length 4, so we return -1.\n\n**Constraints:**\n\n*   `n == scores.length`\n*   `4 <= n <= 5 * 104`\n*   `1 <= scores[i] <= 108`\n*   `0 <= edges.length <= 5 * 104`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\n*   There are no duplicate edges.\"\"\"\n\n    adj_list = [[] for _ in range(len(scores))]\n    result = -1\n\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    for edge in edges:\n        for neighbor in adj_list[edge[0]]:\n            for next in adj_list[edge[1]]:\n                if next != neighbor and next != edge[0]:\n                    result = max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next])\n\n    return result"}}, "leetcode/leetcode_1878.txt": {"score": 0.9057443737983704, "content": {"text": "def check(nums):\n    \"\"\"You are given an `m x n` integer matrix `grid`\u200b\u200b\u200b.\n\nA **rhombus sum** is the sum of the elements that form **the** **border** of a regular rhombus shape in `grid`\u200b\u200b\u200b. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each **rhombus sum**:\n\nNote that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.\n\nReturn _the biggest three **distinct rhombus sums** in the_ `grid` _in **descending order**__. If there are less than three distinct values, return all of them_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[3,4,5,1,3\\],\\[3,3,4,2,3\\],\\[20,30,200,40,10\\],\\[1,5,5,4,1\\],\\[4,3,2,2,5\\]\\]\n**Output:** \\[228,216,211\\]\n**Explanation:** The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 20 + 3 + 200 + 5 = 228\n- Red: 200 + 2 + 10 + 4 = 216\n- Green: 5 + 200 + 4 + 2 = 211\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[20,9,8\\]\n**Explanation:** The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n- Blue: 4 + 2 + 6 + 8 = 20\n- Red: 9 (area 0 rhombus in the bottom right corner)\n- Green: 8 (area 0 rhombus in the bottom middle)\n\n**Example 3:**\n\n**Input:** grid = \\[\\[7,7,7\\]\\]\n**Output:** \\[7\\]\n**Explanation:** All three possible rhombus sums are the same, so return \\[7\\].\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `1 <= grid[i][j] <= 105`\"\"\"\n\n    count = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            count += 1\n        if count > 1:\n            return False\n    return count == 1 or nums[0] >= nums[-1]"}}, "leetcode/leetcode_1267.txt": {"score": 0.9058704376220703, "content": {"text": "def remove_zero_sum_sublists(head):\n    \"\"\"You are given a map of a server center, represented as a `m * n` integer matrix `grid`, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.  \n  \nReturn the number of servers that communicate with any other server.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** 0\n**Explanation:** No servers can communicate with others.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0\\],\\[1,1\\]\\]\n**Output:** 3\n**Explanation:** All three servers can communicate with at least one other server.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,0,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,1\\]\\]\n**Output:** 4\n**Explanation:** The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m <= 250`\n*   `1 <= n <= 250`\n*   `grid[i][j] == 0 or 1`\"\"\"\n\n    dummy = ListNode(0)\n    dummy.next = head\n    current = dummy\n\n    while current:\n        sum = 0\n        while head:\n            sum += head.val\n            if sum == 0:\n                current.next = head.next\n            head = head.next\n        current = current.next\n        if current:\n            head = current.next\n\n    return dummy.next"}}, "leetcode/leetcode_1496.txt": {"score": 0.9072458744049072, "content": {"text": "def lucky_numbers(matrix):\n    \"\"\"Given a string `path`, where `path[i] = 'N'`, `'S'`, `'E'` or `'W'`, each representing moving one unit north, south, east, or west, respectively. You start at the origin `(0, 0)` on a 2D plane and walk on the path specified by `path`.\n\nReturn `true` _if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited_. Return `false` otherwise.\n\n**Example 1:**\n\n**Input:** path =  \"NES \"\n**Output:** false \n**Explanation:** Notice that the path doesn't cross any point more than once.\n\n**Example 2:**\n\n**Input:** path =  \"NESWW \"\n**Output:** true\n**Explanation:** Notice that the path visits the origin twice.\n\n**Constraints:**\n\n*   `1 <= path.length <= 104`\n*   `path[i]` is either `'N'`, `'S'`, `'E'`, or `'W'`.\"\"\"\n\n    m, n = len(matrix), len(matrix[0])\n    lucky_numbers = []\n\n    for i in range(m):\n        min_row = min(matrix[i])\n        min_row_idx = matrix[i].index(min_row)\n        is_lucky = all(matrix[k][min_row_idx] <= min_row for k in range(m))\n\n        if is_lucky:\n            lucky_numbers.append(min_row)\n\n    return lucky_numbers"}}, "leetcode/leetcode_2088.txt": {"score": 0.9160858988761902, "content": {"text": "def min_time_to_type(word: str) -> int:\n    \"\"\"A farmer has a **rectangular grid** of land with `m` rows and `n` columns that can be divided into unit cells. Each cell is either **fertile** (represented by a `1`) or **barren** (represented by a `0`). All cells outside the grid are considered barren.\n\nA **pyramidal plot** of land can be defined as a set of cells with the following criteria:\n\n1.  The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**.\n2.  The **apex** of a pyramid is the **topmost** cell of the pyramid. The **height** of a pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r <= i <= r + h - 1` **and** `c - (i - r) <= j <= c + (i - r)`.\n\nAn **inverse pyramidal plot** of land can be defined as a set of cells with similar criteria:\n\n1.  The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**.\n2.  The **apex** of an inverse pyramid is the **bottommost** cell of the inverse pyramid. The **height** of an inverse pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r - h + 1 <= i <= r` **and** `c - (r - i) <= j <= c + (r - i)`.\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n\nGiven a **0-indexed** `m x n` binary matrix `grid` representing the farmland, return _the **total number** of pyramidal and inverse pyramidal plots that can be found in_ `grid`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[1,1,1,1\\]\\]\n**Output:** 2\n**Explanation:** The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\]\\]\n**Output:** 2\n**Explanation:** The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1,0\\],\\[1,1,1,1,1\\],\\[1,1,1,1,1\\],\\[0,1,0,0,1\\]\\]\n**Output:** 13\n**Explanation:** There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `grid[i][j]` is either `0` or `1`.\"\"\"\n\n    time, prev = 0, 0\n    for c in word:\n        pos = ord(c) - ord('a')\n        time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1\n        prev = pos\n    return time"}}, "leetcode/leetcode_959.txt": {"score": 0.9058364629745483, "content": {"text": "def threeSumMulti(arr, target):\n    \"\"\"An `n x n` grid is composed of `1 x 1` squares where each `1 x 1` square consists of a `'/'`, `'\\'`, or blank space `' '`. These characters divide the square into contiguous regions.\n\nGiven the grid `grid` represented as a string array, return _the number of regions_.\n\nNote that backslash characters are escaped, so a `'\\'` is represented as `'\\\\'`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \" / \", \"/  \"\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** grid = \\[ \" / \", \"   \"\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** grid = \\[ \"/\\\\\\\\ \", \"\\\\/ \"\\]\n**Output:** 5\n**Explanation:** Recall that because \\\\ characters are escaped,  \"\\\\/ \" refers to /, and  \"/\\\\\\\\ \" refers to /\\\\.\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 30`\n*   `grid[i][j]` is either `'/'`, `'\\'`, or `' '`.\"\"\"\n\n    MOD = 1000000007\n    ans = 0\n\n    arr.sort()\n    n = len(arr)\n\n    for i in range(n - 2):\n        j, k = i + 1, n - 1\n        while j < k:\n            s = arr[i] + arr[j] + arr[k]\n            if s > target:\n                k -= 1\n            elif s < target:\n                j += 1\n            else:\n                if arr[j] != arr[k]:\n                    left_count = right_count = 1\n\n                    while j < n - 1 and arr[j] == arr[j + 1]:\n                        left_count += 1\n                        j += 1\n\n                    while k > 0 and arr[k] == arr[k - 1]:\n                        right_count += 1\n                        k -= 1\n\n                    ans += left_count * right_count\n                    ans %= MOD\n                    j += 1\n                    k -= 1\n                else:\n                    ans += (k - j + 1) * (k - j) // 2\n                    ans %= MOD\n                    break\n\n    return ans"}}, "leetcode/leetcode_2245.txt": {"score": 0.9966079592704773, "content": {"text": "def can_destroy_all_asteroids(mass, asteroids):\n    \"\"\"You are given a 2D integer array `grid` of size `m x n`, where each cell contains a positive integer.\n\nA **cornered path** is defined as a set of adjacent cells with **at most** one turn. More specifically, the path should exclusively move either **horizontally** or **vertically** up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the **alternate** direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\n\nThe **product** of a path is defined as the product of all the values in the path.\n\nReturn _the **maximum** number of **trailing zeros** in the product of a cornered path found in_ `grid`.\n\nNote:\n\n*   **Horizontal** movement means moving in either the left or right direction.\n*   **Vertical** movement means moving in either the up or down direction.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[23,17,15,3,20\\],\\[8,1,20,27,11\\],\\[9,4,6,2,21\\],\\[40,9,1,10,6\\],\\[22,7,4,5,3\\]\\]\n**Output:** 3\n**Explanation:** The grid on the left shows a valid cornered path.\nIt has a product of 15 \\* 20 \\* 6 \\* 1 \\* 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[4,3,2\\],\\[7,6,1\\],\\[8,8,8\\]\\]\n**Output:** 0\n**Explanation:** The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 1000`\"\"\"\n\n    asteroids.sort()\n    for asteroid in asteroids:\n        if mass >= asteroid:\n            mass += asteroid\n        else:\n            return False\n    return True"}}, "leetcode/leetcode_1444.txt": {"score": 0.9105831980705261, "content": {"text": "def number_of_steps(num):\n    \"\"\"Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.\n\n**Example 1:**\n\n**Input:** pizza = \\[ \"A.. \", \"AAA \", \"... \"\\], k = 3\n**Output:** 3 \n**Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n**Example 2:**\n\n**Input:** pizza = \\[ \"A.. \", \"AA. \", \"... \"\\], k = 3\n**Output:** 1\n\n**Example 3:**\n\n**Input:** pizza = \\[ \"A.. \", \"A.. \", \"... \"\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 50`\n*   `rows == pizza.length`\n*   `cols == pizza[i].length`\n*   `1 <= k <= 10`\n*   `pizza` consists of characters `'A'` and `'.'` only.\"\"\"\n\n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    return steps - 1"}}, "leetcode/leetcode_764.txt": {"score": 0.9158844351768494, "content": {"text": "from collections import deque\n    \"\"\"You are given an integer `n`. You have an `n x n` binary grid `grid` with all values initially `1`'s except for some indices given in the array `mines`. The `ith` element of the array `mines` is defined as `mines[i] = [xi, yi]` where `grid[xi][yi] == 0`.\n\nReturn _the order of the largest **axis-aligned** plus sign of_ 1_'s contained in_ `grid`. If there is none, return `0`.\n\nAn **axis-aligned plus sign** of `1`'s of order `k` has some center `grid[r][c] == 1` along with four arms of length `k - 1` going up, down, left, and right, and made of `1`'s. Note that there could be `0`'s or `1`'s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for `1`'s.\n\n**Example 1:**\n\n**Input:** n = 5, mines = \\[\\[4,2\\]\\]\n**Output:** 2\n**Explanation:** In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n**Example 2:**\n\n**Input:** n = 1, mines = \\[\\[0,0\\]\\]\n**Output:** 0\n**Explanation:** There is no plus sign, so return 0.\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n*   `1 <= mines.length <= 5000`\n*   `0 <= xi, yi < n`\n*   All the pairs `(xi, yi)` are **unique**.\"\"\"\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef levelOrder(root):\n    result = []\n\n    if not root:\n        return result\n\n    toVisit = deque([root])\n\n    while toVisit:\n        size = len(toVisit)\n        level = []\n\n        for _ in range(size):\n            currentNode = toVisit.popleft()\n            level.append(currentNode.val)\n\n            for child in currentNode.children:\n                toVisit.append(child)\n\n        result.append(level)\n\n    return result"}}}}, "115": {"gold": {"leetcode/leetcode_543.txt": 1}, "retrieved": {"leetcode/leetcode_2538.txt": {"score": 0.916351854801178, "content": {"text": "from typing import List\n    \"\"\"There exists an undirected and initially unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given the integer `n` and a 2D integer array `edges` of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nEach node has an associated price. You are given an integer array `price`, where `price[i]` is the price of the `ith` node.\n\nThe **price sum** of a given path is the sum of the prices of all nodes lying on that path.\n\nThe tree can be rooted at any node `root` of your choice. The incurred **cost** after choosing `root` is the difference between the maximum and minimum **price sum** amongst all paths starting at `root`.\n\nReturn _the **maximum** possible **cost**_ _amongst all possible root choices_.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\],\\[3,5\\]\\], price = \\[9,8,7,6,10,5\\]\n**Output:** 24\n**Explanation:** The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes \\[2,1,3,4\\]: the prices are \\[7,8,6,10\\], and the sum of the prices is 31.\n- The second path contains the node \\[2\\] with the price \\[7\\].\nThe difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\]\\], price = \\[1,1,1\\]\n**Output:** 2\n**Explanation:** The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes \\[0,1,2\\]: the prices are \\[1,1,1\\], and the sum of the prices is 3.\n- The second path contains node \\[0\\] with a price \\[1\\].\nThe difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi <= n - 1`\n*   `edges` represents a valid tree.\n*   `price.length == n`\n*   `1 <= price[i] <= 105`\"\"\"\n\n\ndef dfs(u, p, adj, price, dp):\n    dp[u] = [[price[u], 0], [price[u], 0]]\n\n    for v in adj[u]:\n        if v == p:\n            continue\n        dfs(v, u, adj, price, dp)\n        tmpF = sorted([dp[v][0][0] + price[u] - dp[v][1][0], dp[v][0][1]])\n        tmpS = sorted([dp[v][1][0] + price[u] - dp[v][0][0], dp[v][1][1]])\n\n        dp[u][0] = tmpF\n        dp[u][1] = tmpS\n\ndef getMaxCost(n: int, edges: List[List[int]], price: List[int]) -> int:\n    adj = [[] for _ in range(n)]\n    dp = [None] * n\n\n    for e in edges:\n        adj[e[0]].append(e[1])\n        adj[e[1]].append(e[0])\n\n    dfs(0, -1, adj, price, dp)\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, dp[i][0][1] - dp[i][1][1])\n\n    return ans"}}, "leetcode/leetcode_1493.txt": {"score": 0.9176618456840515, "content": {"text": "from collections import defaultdict\n    \"\"\"Given a binary array `nums`, you should delete one element from it.\n\nReturn _the size of the longest non-empty subarray containing only_ `1`_'s in the resulting array_. Return `0` if there is no such subarray.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,0,1\\]\n**Output:** 3\n**Explanation:** After deleting the number in position 2, \\[1,1,1\\] contains 3 numbers with value of 1's.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,1,1,0,1,1,0,1\\]\n**Output:** 5\n**Explanation:** After deleting the number in position 4, \\[0,1,1,1,1,1,0,1\\] longest subarray with value of 1's is \\[1,1,1,1,1\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 2\n**Explanation:** You must delete one element.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.\"\"\"\n\n\ndef frogPosition(n, edges, t, target):\n    graph = defaultdict(list)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    return dfs(1, -1, t, target, graph)\n\ndef dfs(node, parent, t, target, graph):\n    if t == 0:\n        return 1.0 if node == target else 0.0\n    probability = 0.0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            probability += dfs(neighbor, node, t - 1, target, graph)\n    return probability / (len(graph[node]) - (0 if parent == -1 else 1))"}}, "leetcode/leetcode_2049.txt": {"score": 0.921342134475708, "content": {"text": "def eliminate_monsters(dist, speed):\n    \"\"\"There is a **binary** tree rooted at `0` consisting of `n` nodes. The nodes are labeled from `0` to `n - 1`. You are given a **0-indexed** integer array `parents` representing the tree, where `parents[i]` is the parent of node `i`. Since node `0` is the root, `parents[0] == -1`.\n\nEach node has a **score**. To find the score of a node, consider if the node and the edges connected to it were **removed**. The tree would become one or more **non-empty** subtrees. The **size** of a subtree is the number of the nodes in it. The **score** of the node is the **product of the sizes** of all those subtrees.\n\nReturn _the **number** of nodes that have the **highest score**_.\n\n**Example 1:**\n\n**Input:** parents = \\[-1,2,0,2,0\\]\n**Output:** 3\n**Explanation:**\n- The score of node 0 is: 3 \\* 1 = 3\n- The score of node 1 is: 4 = 4\n- The score of node 2 is: 1 \\* 1 \\* 2 = 2\n- The score of node 3 is: 4 = 4\n- The score of node 4 is: 4 = 4\nThe highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.\n\n**Example 2:**\n\n**Input:** parents = \\[-1,2,0\\]\n**Output:** 2\n**Explanation:**\n- The score of node 0 is: 2 = 2\n- The score of node 1 is: 2 = 2\n- The score of node 2 is: 1 \\* 1 = 1\nThe highest score is 2, and two nodes (node 0 and node 1) have the highest score.\n\n**Constraints:**\n\n*   `n == parents.length`\n*   `2 <= n <= 105`\n*   `parents[0] == -1`\n*   `0 <= parents[i] <= n - 1` for `i != 0`\n*   `parents` represents a valid binary tree.\"\"\"\n\n    n = len(dist)\n    time_to_reach = sorted(dist[i] / speed[i] for i in range(n))\n    monsters_eliminated = 0\n    for time in time_to_reach:\n        if monsters_eliminated < time:\n            monsters_eliminated += 1\n    return monsters_eliminated"}}, "leetcode/leetcode_1617.txt": {"score": 0.9387285709381104, "content": {"text": "def winnerSquareGame(n: int) -> bool:\n    \"\"\"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.\"\"\"\n\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]"}}, "leetcode/csn_python_train_3804.txt": {"score": 0.9265623092651367, "content": {"text": "def longest_consecutive(root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    max_len = 0\n    dfs(root, 0, root.val, max_len)\n    return max_len"}}, "leetcode/leetcode_1519.txt": {"score": 0.9313274025917053, "content": {"text": "def min_subsequence(nums):\n    \"\"\"You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` `edges`. The **root** of the tree is the node `0`, and each node of the tree has **a label** which is a lower-case character given in the string `labels` (i.e. The node with the number `i` has the label `labels[i]`).\n\nThe `edges` array is given on the form `edges[i] = [ai, bi]`, which means there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn _an array of size `n`_ where `ans[i]` is the number of nodes in the subtree of the `ith` node which have the same label as node `i`.\n\nA subtree of a tree `T` is the tree consisting of a node in `T` and all of its descendant nodes.\n\n**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,4\\],\\[1,5\\],\\[2,3\\],\\[2,6\\]\\], labels =  \"abaedcd \"\n**Output:** \\[2,1,1,1,1,1,1\\]\n**Explanation:** Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.\nNode 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).\n\n**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,3\\]\\], labels =  \"bbbb \"\n**Output:** \\[4,2,1,1\\]\n**Explanation:** The sub-tree of node 2 contains only node 2, so the answer is 1.\nThe sub-tree of node 3 contains only node 3, so the answer is 1.\nThe sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.\nThe sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.\n\n**Example 3:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[0,4\\]\\], labels =  \"aabab \"\n**Output:** \\[3,2,1,1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `labels.length == n`\n*   `labels` is consisting of only of lowercase English letters.\"\"\"\n\n    nums.sort(reverse=True)\n    total_sum, current_sum = sum(nums), 0\n    result = []\n    for num in nums:\n        current_sum += num\n        result.append(num)\n        if current_sum > total_sum - current_sum:\n            break\n    return result"}}, "leetcode/leetcode_1129.txt": {"score": 0.9285872578620911, "content": {"text": "def longestStrChain(words):\n    \"\"\"You are given an integer `n`, the number of nodes in a directed graph where the nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n\nYou are given two arrays `redEdges` and `blueEdges` where:\n\n*   `redEdges[i] = [ai, bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph, and\n*   `blueEdges[j] = [uj, vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.\n\nReturn an array `answer` of length `n`, where each `answer[x]` is the length of the shortest path from node `0` to node `x` such that the edge colors alternate along the path, or `-1` if such a path does not exist.\n\n**Example 1:**\n\n**Input:** n = 3, redEdges = \\[\\[0,1\\],\\[1,2\\]\\], blueEdges = \\[\\]\n**Output:** \\[0,1,-1\\]\n\n**Example 2:**\n\n**Input:** n = 3, redEdges = \\[\\[0,1\\]\\], blueEdges = \\[\\[2,1\\]\\]\n**Output:** \\[0,1,-1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= redEdges.length, blueEdges.length <= 400`\n*   `redEdges[i].length == blueEdges[j].length == 2`\n*   `0 <= ai, bi, uj, vj < n`\"\"\"\n\n    words.sort(key=lambda x: len(x))\n    dp = {}\n\n    max_len = 0\n    for word in words:\n        for i in range(len(word)):\n            pre = word[:i] + word[i + 1:]\n            dp[word] = max(dp.get(word, 0), dp.get(pre, 0) + 1)\n        max_len = max(max_len, dp[word])\n\n    return max_len"}}, "leetcode/leetcode_2421.txt": {"score": 0.9476823210716248, "content": {"text": "from collections import defaultdict\n    \"\"\"There is a tree (i.e. a connected, undirected graph with no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges.\n\nYou are given a **0-indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nA **good path** is a simple path that satisfies the following conditions:\n\n1.  The starting node and the ending node have the **same** value.\n2.  All nodes between the starting node and the ending node have values **less than or equal to** the starting node (i.e. the starting node's value should be the maximum value along the path).\n\nReturn _the number of distinct good paths_.\n\nNote that a path and its reverse are counted as the **same** path. For example, `0 -> 1` is considered to be the same as `1 -> 0`. A single node is also considered as a valid path.\n\n**Example 1:**\n\n**Input:** vals = \\[1,3,2,1,3\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 6\n**Explanation:** There are 5 good paths consisting of a single node.\nThere is 1 additional good path: 1 -> 0 -> 2 -> 4.\n(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\nNote that 0 -> 2 -> 3 is not a good path because vals\\[2\\] > vals\\[0\\].\n\n**Example 2:**\n\n**Input:** vals = \\[1,1,2,2,3\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 7\n**Explanation:** There are 5 good paths consisting of a single node.\nThere are 2 additional good paths: 0 -> 1 and 2 -> 3.\n\n**Example 3:**\n\n**Input:** vals = \\[1\\], edges = \\[\\]\n**Output:** 1\n**Explanation:** The tree consists of only one node, so there is one good path.\n\n**Constraints:**\n\n*   `n == vals.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= vals[i] <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef dfs(node, parent, adj, vals, cur_max, count):\n    if vals[node] >= cur_max:\n        if vals[node] > cur_max:\n            count[0] += 1\n            cur_max = vals[node]\n        for next in adj[node]:\n            if next != parent:\n                dfs(next, node, adj, vals, cur_max, count)\n\ndef number_of_good_paths(vals, edges):\n    n = len(vals)\n    adj = defaultdict(list)\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    count = [0]\n    for i in range(n):\n        dfs(i, -1, adj, vals, -1, count)\n    return count[0]"}}, "leetcode/leetcode_2368.txt": {"score": 0.9388697147369385, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an undirected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an integer array `restricted` which represents **restricted** nodes.\n\nReturn _the **maximum** number of nodes you can reach from node_ `0` _without visiting a restricted node._\n\nNote that node `0` will **not** be a restricted node.\n\n**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,1\\],\\[4,0\\],\\[0,5\\],\\[5,6\\]\\], restricted = \\[4,5\\]\n**Output:** 4\n**Explanation:** The diagram above shows the tree.\nWe have that \\[0,1,2,3\\] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[0,2\\],\\[0,5\\],\\[0,4\\],\\[3,2\\],\\[6,5\\]\\], restricted = \\[4,2,1\\]\n**Output:** 3\n**Explanation:** The diagram above shows the tree.\nWe have that \\[0,5,6\\] are the only nodes that can be reached from node 0 without visiting a restricted node.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\n*   `1 <= restricted.length < n`\n*   `1 <= restricted[i] < n`\n*   All the values of `restricted` are **unique**.\"\"\"\n\n\ndef max_nodes_without_restricted(n, edges, restricted):\n    tree = defaultdict(list)\n    blocked_nodes = set(restricted)\n\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    max_nodes = [0]\n\n    def dfs(node, depth, parent):\n        if node in blocked_nodes:\n            return\n        max_nodes[0] = max(max_nodes[0], depth)\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, depth + 1, node)\n\n    dfs(0, 1, -1)\n    return max_nodes[0]"}}, "leetcode/leetcode_2246.txt": {"score": 0.9980119466781616, "content": {"text": "def max_invites(favorite):\n    \"\"\"You are given a **tree** (i.e. a connected, undirected graph that has no cycles) **rooted** at node `0` consisting of `n` nodes numbered from `0` to `n - 1`. The tree is represented by a **0-indexed** array `parent` of size `n`, where `parent[i]` is the parent of node `i`. Since node `0` is the root, `parent[0] == -1`.\n\nYou are also given a string `s` of length `n`, where `s[i]` is the character assigned to node `i`.\n\nReturn _the length of the **longest path** in the tree such that no pair of **adjacent** nodes on the path have the same character assigned to them._\n\n**Example 1:**\n\n**Input:** parent = \\[-1,0,0,1,1,2\\], s =  \"abacbe \"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\nIt can be proven that there is no longer path that satisfies the conditions. \n\n**Example 2:**\n\n**Input:** parent = \\[-1,0,0,0\\], s =  \"aabc \"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.\n\n**Constraints:**\n\n*   `n == parent.length == s.length`\n*   `1 <= n <= 105`\n*   `0 <= parent[i] <= n - 1` for all `i >= 1`\n*   `parent[0] == -1`\n*   `parent` represents a valid tree.\n*   `s` consists of only lowercase English letters.\"\"\"\n\n    n = len(favorite)\n    dp = [0] * n\n    max_invites = 0\n\n    for i in range(n):\n        dp[i] = 2 if i == favorite[favorite[i]] else 1\n        max_invites = max(max_invites, dp[i])\n\n    return max_invites"}}}}, "116": {"gold": {"leetcode/leetcode_1828.txt": 1}, "retrieved": {"leetcode/leetcode_1954.txt": {"score": 0.8904551863670349, "content": {"text": "def replace_digits(s: str) -> str:\n    \"\"\"In a garden represented as an infinite 2D grid, there is an apple tree planted at **every** integer coordinate. The apple tree planted at an integer coordinate `(i, j)` has `|i| + |j|` apples growing on it.\n\nYou will buy an axis-aligned **square plot** of land that is centered at `(0, 0)`.\n\nGiven an integer `neededApples`, return _the **minimum perimeter** of a plot such that **at least**_ `neededApples` _apples are **inside or on** the perimeter of that plot_.\n\nThe value of `|x|` is defined as:\n\n*   `x` if `x >= 0`\n*   `-x` if `x < 0`\n\n**Example 1:**\n\n**Input:** neededApples = 1\n**Output:** 8\n**Explanation:** A square plot of side length 1 does not contain any apples.\nHowever, a square plot of side length 2 has 12 apples inside (as depicted in the image above).\nThe perimeter is 2 \\* 4 = 8.\n\n**Example 2:**\n\n**Input:** neededApples = 13\n**Output:** 16\n\n**Example 3:**\n\n**Input:** neededApples = 1000000000\n**Output:** 5040\n\n**Constraints:**\n\n*   `1 <= neededApples <= 1015`\"\"\"\n\n    s = list(s)\n    for i in range(1, len(s), 2):\n        s[i] = chr(ord(s[i - 1]) + int(s[i]))\n    return ''.join(s)"}}, "leetcode/leetcode_850.txt": {"score": 0.8925575613975525, "content": {"text": "def rectangleArea(rectangles):\n    \"\"\"You are given a 2D array of axis-aligned `rectangles`. Each `rectangle[i] = [xi1, yi1, xi2, yi2]` denotes the `ith` rectangle where `(xi1, yi1)` are the coordinates of the **bottom-left corner**, and `(xi2, yi2)` are the coordinates of the **top-right corner**.\n\nCalculate the **total area** covered by all `rectangles` in the plane. Any area covered by two or more rectangles should only be counted **once**.\n\nReturn _the **total area**_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[0,0,2,2\\],\\[1,0,2,3\\],\\[1,0,3,1\\]\\]\n**Output:** 6\n**Explanation:** A total area of 6 is covered by all three rectangles, as illustrated in the picture.\nFrom (1,1) to (2,2), the green and red rectangles overlap.\nFrom (1,0) to (2,3), all three rectangles overlap.\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[0,0,1000000000,1000000000\\]\\]\n**Output:** 49\n**Explanation:** The answer is 1018 modulo (109 + 7), which is 49.\n\n**Constraints:**\n\n*   `1 <= rectangles.length <= 200`\n*   `rectanges[i].length == 4`\n*   `0 <= xi1, yi1, xi2, yi2 <= 109`\n*   `xi1 <= xi2`\n*   `yi1 <= yi2`\"\"\"\n\n    mod = 10**9 + 7\n    n = len(rectangles)\n    X, Y = set(), set()\n    for rect in rectangles:\n        X.add(rect[0])\n        X.add(rect[2])\n        Y.add(rect[1])\n        Y.add(rect[3])\n    sorted_x = sorted(X)\n    sorted_y = sorted(Y)\n    cnt = [[0 for _ in range(len(Y) - 1)] for _ in range(len(X) - 1)]\n\n    for rect in rectangles:\n        x1_idx = sorted_x.index(rect[0])\n        x2_idx = sorted_x.index(rect[2]) - 1\n        y1_idx = sorted_y.index(rect[1])\n        y2_idx = sorted_y.index(rect[3]) - 1\n        for i in range(x1_idx, x2_idx + 1):\n            for j in range(y1_idx, y2_idx + 1):\n                cnt[i][j] = 1\n\n    total_area = 0\n    for i in range(len(X) - 1):\n        for j in range(len(Y) - 1):\n            if cnt[i][j]:\n                total_area += (sorted_x[i + 1] - sorted_x[i]) * (sorted_y[j + 1] - sorted_y[j])\n                total_area %= mod\n\n    return total_area"}}, "leetcode/leetcode_335.txt": {"score": 0.8916667699813843, "content": {"text": "def is_path_crossing(distance):\n    \"\"\"You are given an array of integers `distance`.\n\nYou start at the point `(0, 0)` on an **X-Y plane,** and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\n\nReturn `true` _if your path crosses itself or_ `false` _if it does not_.\n\n**Example 1:**\n\n**Input:** distance = \\[2,1,1,2\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 1).\n\n**Example 2:**\n\n**Input:** distance = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** The path does not cross itself at any point.\n\n**Example 3:**\n\n**Input:** distance = \\[1,1,1,2,1\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 0).\n\n**Constraints:**\n\n*   `1 <= distance.length <= 105`\n*   `1 <= distance[i] <= 105`\"\"\"\n\n    visited = set([(0, 0)])\n    x, y = 0, 0\n    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n    \n    for i, d in enumerate(distance):\n        dx, dy = directions[i % 4]\n        for _ in range(d):\n            x += dx\n            y += dy\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n    return False"}}, "leetcode/leetcode_1779.txt": {"score": 0.8938711881637573, "content": {"text": "def nearestValidPoint(x: int, y: int, points: List[List[int]]) -> int:\n    \"\"\"You are given two integers, `x` and `y`, which represent your current location on a Cartesian grid: `(x, y)`. You are also given an array `points` where each `points[i] = [ai, bi]` represents that a point exists at `(ai, bi)`. A point is **valid** if it shares the same x-coordinate or the same y-coordinate as your location.\n\nReturn _the index **(0-indexed)** of the **valid** point with the smallest **Manhattan distance** from your current location_. If there are multiple, return _the valid point with the **smallest** index_. If there are no valid points, return `-1`.\n\nThe **Manhattan distance** between two points `(x1, y1)` and `(x2, y2)` is `abs(x1 - x2) + abs(y1 - y2)`.\n\n**Example 1:**\n\n**Input:** x = 3, y = 4, points = \\[\\[1,2\\],\\[3,1\\],\\[2,4\\],\\[2,3\\],\\[4,4\\]\\]\n**Output:** 2\n**Explanation:** Of all the points, only \\[3,1\\], \\[2,4\\] and \\[4,4\\] are valid. Of the valid points, \\[2,4\\] and \\[4,4\\] have the smallest Manhattan distance from your current location, with a distance of 1. \\[2,4\\] has the smallest index, so return 2.\n\n**Example 2:**\n\n**Input:** x = 3, y = 4, points = \\[\\[3,4\\]\\]\n**Output:** 0\n**Explanation:** The answer is allowed to be on the same location as your current location.\n\n**Example 3:**\n\n**Input:** x = 3, y = 4, points = \\[\\[2,3\\]\\]\n**Output:** -1\n**Explanation:** There are no valid points.\n\n**Constraints:**\n\n*   `1 <= points.length <= 104`\n*   `points[i].length == 2`\n*   `1 <= x, y, ai, bi <= 104`\"\"\"\n\n    min_distance = float(\"inf\")\n    index = -1\n    for i, point in enumerate(points):\n        if x == point[0] or y == point[1]:\n            distance = abs(x - point[0]) + abs(y - point[1])\n            if distance < min_distance:\n                min_distance = distance\n                index = i\n    return index"}}, "leetcode/leetcode_1610.txt": {"score": 0.8943206667900085, "content": {"text": "def xor_operation(n, start):\n    \"\"\"You are given an array `points`, an integer `angle`, and your `location`, where `location = [posx, posy]` and `points[i] = [xi, yi]` both denote **integral coordinates** on the X-Y plane.\n\nInitially, you are facing directly east from your position. You **cannot move** from your position, but you can **rotate**. In other words, `posx` and `posy` cannot be changed. Your field of view in **degrees** is represented by `angle`, determining how wide you can see from any given view direction. Let `d` be the amount in degrees that you rotate counterclockwise. Then, your field of view is the **inclusive** range of angles `[d - angle/2, d + angle/2]`.\n\nYour browser does not support the video tag or this video format.\n\nYou can **see** some set of points if, for each point, the **angle** formed by the point, your position, and the immediate east direction from your position is **in your field of view**.\n\nThere can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.\n\nReturn _the maximum number of points you can see_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[2,1\\],\\[2,2\\],\\[3,3\\]\\], angle = 90, location = \\[1,1\\]\n**Output:** 3\n**Explanation:** The shaded region represents your field of view. All points can be made visible in your field of view, including \\[3,3\\] even though \\[2,2\\] is in front and in the same line of sight.\n\n**Example 2:**\n\n**Input:** points = \\[\\[2,1\\],\\[2,2\\],\\[3,4\\],\\[1,1\\]\\], angle = 90, location = \\[1,1\\]\n**Output:** 4\n**Explanation:** All points can be made visible in your field of view, including the one at your location.\n\n**Example 3:**\n\n**Input:** points = \\[\\[1,0\\],\\[2,1\\]\\], angle = 13, location = \\[1,1\\]\n**Output:** 1\n**Explanation:** You can only see one of the two points, as shown above.\n\n**Constraints:**\n\n*   `1 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `location.length == 2`\n*   `0 <= angle < 360`\n*   `0 <= posx, posy, xi, yi <= 100`\"\"\"\n\n    xor_result = 0\n    for i in range(n):\n        xor_result ^= (start + 2 * i)\n    return xor_result"}}, "leetcode/leetcode_2250.txt": {"score": 0.9139382243156433, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are given a 2D integer array `rectangles` where `rectangles[i] = [li, hi]` indicates that `ith` rectangle has a length of `li` and a height of `hi`. You are also given a 2D integer array `points` where `points[j] = [xj, yj]` is a point with coordinates `(xj, yj)`.\n\nThe `ith` rectangle has its **bottom-left corner** point at the coordinates `(0, 0)` and its **top-right corner** point at `(li, hi)`.\n\nReturn _an integer array_ `count` _of length_ `points.length` _where_ `count[j]` _is the number of rectangles that **contain** the_ `jth` _point._\n\nThe `ith` rectangle **contains** the `jth` point if `0 <= xj <= li` and `0 <= yj <= hi`. Note that points that lie on the **edges** of a rectangle are also considered to be contained by that rectangle.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[1,2\\],\\[2,3\\],\\[2,5\\]\\], points = \\[\\[2,1\\],\\[1,4\\]\\]\n**Output:** \\[2,1\\]\n**Explanation:** \nThe first rectangle contains no points.\nThe second rectangle contains only the point (2, 1).\nThe third rectangle contains the points (2, 1) and (1, 4).\nThe number of rectangles that contain the point (2, 1) is 2.\nThe number of rectangles that contain the point (1, 4) is 1.\nTherefore, we return \\[2, 1\\].\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\], points = \\[\\[1,3\\],\\[1,1\\]\\]\n**Output:** \\[1,3\\]\n**Explanation:**\nThe first rectangle contains only the point (1, 1).\nThe second rectangle contains only the point (1, 1).\nThe third rectangle contains the points (1, 3) and (1, 1).\nThe number of rectangles that contain the point (1, 3) is 1.\nThe number of rectangles that contain the point (1, 1) is 3.\nTherefore, we return \\[1, 3\\].\n\n**Constraints:**\n\n*   `1 <= rectangles.length, points.length <= 5 * 104`\n*   `rectangles[i].length == points[j].length == 2`\n*   `1 <= li, xj <= 109`\n*   `1 <= hi, yj <= 100`\n*   All the `rectangles` are **unique**.\n*   All the `points` are **unique**.\"\"\"\n\n\ndef kHighestRankedItems(grid, pricing, start, k):\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = []\n    pq = []\n    visited = [[False for _ in range(n)] for _ in range(m)]\n\n    heappush(pq, (0, -grid[start[0]][start[1]], start[0], start[1]))\n    visited[start[0]][start[1]] = True\n\n    while pq and k > 0:\n        size = len(pq)\n        for _ in range(size):\n            curr = heappop(pq)\n            steps, price, row, col = curr\n\n            if pricing[0] <= -price <= pricing[1]:\n                res.append([row, col])\n                k -= 1\n\n            for dr, dc in directions:\n                newRow, newCol = row + dr, col + dc\n                if 0 <= newRow < m and 0 <= newCol < n and not visited[newRow][newCol]:\n                    visited[newRow][newCol] = True\n                    heappush(pq, (steps + 1, -grid[newRow][newCol], newRow, newCol))\n\n    return res"}}, "leetcode/leetcode_1453.txt": {"score": 0.8927870392799377, "content": {"text": "def numPoints(darts, r):\n    \"\"\"Alice is throwing `n` darts on a very large wall. You are given an array `darts` where `darts[i] = [xi, yi]` is the position of the `ith` dart that Alice threw on the wall.\n\nBob knows the positions of the `n` darts on the wall. He wants to place a dartboard of radius `r` on the wall so that the maximum number of darts that Alice throws lies on the dartboard.\n\nGiven the integer `r`, return _the maximum number of darts that can lie on the dartboard_.\n\n**Example 1:**\n\n**Input:** darts = \\[\\[-2,0\\],\\[2,0\\],\\[0,2\\],\\[0,-2\\]\\], r = 2\n**Output:** 4\n**Explanation:** Circle dartboard with center in (0,0) and radius = 2 contain all points.\n\n**Example 2:**\n\n**Input:** darts = \\[\\[-3,0\\],\\[3,0\\],\\[2,6\\],\\[5,4\\],\\[0,9\\],\\[7,8\\]\\], r = 5\n**Output:** 5\n**Explanation:** Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n\n**Constraints:**\n\n*   `1 <= darts.length <= 100`\n*   `darts[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `darts` are unique\n*   `1 <= r <= 5000`\"\"\"\n\n    n = len(darts)\n    result = 1\n    \n    for i in range(n):\n        for j in range(n):\n            cnt = 0\n            for k in range(n):\n                dx = darts[i][0] - darts[k][0]\n                dy = darts[i][1] - darts[k][1]\n                if (dx * dx + dy * dy) ** 0.5 <= r:\n                    cnt += 1\n                    \n            if cnt > result:\n                result = cnt\n                \n    return result"}}, "leetcode/leetcode_1620.txt": {"score": 0.916095495223999, "content": {"text": "def canArrange(arr, k):\n    \"\"\"You are given an array of network towers `towers`, where `towers[i] = [xi, yi, qi]` denotes the `ith` network tower with location `(xi, yi)` and quality factor `qi`. All the coordinates are **integral coordinates** on the X-Y plane, and the distance between the two coordinates is the **Euclidean distance**.\n\nYou are also given an integer `radius` where a tower is **reachable** if the distance is **less than or equal to** `radius`. Outside that distance, the signal becomes garbled, and the tower is **not reachable**.\n\nThe signal quality of the `ith` tower at a coordinate `(x, y)` is calculated with the formula `\u230aqi / (1 + d)\u230b`, where `d` is the distance between the tower and the coordinate. The **network quality** at a coordinate is the sum of the signal qualities from all the **reachable** towers.\n\nReturn _the array_ `[cx, cy]` _representing the **integral** coordinate_ `(cx, cy)` _where the **network quality** is maximum. If there are multiple coordinates with the same **network quality**, return the lexicographically minimum **non-negative** coordinate._\n\n**Note:**\n\n*   A coordinate `(x1, y1)` is lexicographically smaller than `(x2, y2)` if either:\n    *   `x1 < x2`, or\n    *   `x1 == x2` and `y1 < y2`.\n*   `\u230aval\u230b` is the greatest integer less than or equal to `val` (the floor function).\n\n**Example 1:**\n\n**Input:** towers = \\[\\[1,2,5\\],\\[2,1,7\\],\\[3,1,9\\]\\], radius = 2\n**Output:** \\[2,1\\]\n**Explanation:** At coordinate (2, 1) the total quality is 13.\n- Quality of 7 from (2, 1) results in \u230a7 / (1 + sqrt(0)\u230b = \u230a7\u230b = 7\n- Quality of 5 from (1, 2) results in \u230a5 / (1 + sqrt(2)\u230b = \u230a2.07\u230b = 2\n- Quality of 9 from (3, 1) results in \u230a9 / (1 + sqrt(1)\u230b = \u230a4.5\u230b = 4\nNo other coordinate has a higher network quality.\n\n**Example 2:**\n\n**Input:** towers = \\[\\[23,11,21\\]\\], radius = 9\n**Output:** \\[23,11\\]\n**Explanation:** Since there is only one tower, the network quality is highest right at the tower's location.\n\n**Example 3:**\n\n**Input:** towers = \\[\\[1,2,13\\],\\[2,1,7\\],\\[0,1,9\\]\\], radius = 2\n**Output:** \\[1,2\\]\n**Explanation:** Coordinate (1, 2) has the highest network quality.\n\n**Constraints:**\n\n*   `1 <= towers.length <= 50`\n*   `towers[i].length == 3`\n*   `0 <= xi, yi, qi <= 50`\n*   `1 <= radius <= 50`\"\"\"\n\n    counts = [0] * k\n    for num in arr:\n        counts[(num % k + k) % k] += 1\n    if counts[0] % 2 != 0:\n        return False\n    for i in range(1, k // 2 + 1):\n        if counts[i] != counts[k - i]:\n            return False\n    return True"}}, "leetcode/leetcode_1828.txt": {"score": 0.8946033716201782, "content": {"text": "def countPoints(points, queries):\n    \"\"\"You are given an array `points` where `points[i] = [xi, yi]` is the coordinates of the `ith` point on a 2D plane. Multiple points can have the **same** coordinates.\n\nYou are also given an array `queries` where `queries[j] = [xj, yj, rj]` describes a circle centered at `(xj, yj)` with a radius of `rj`.\n\nFor each query `queries[j]`, compute the number of points **inside** the `jth` circle. Points **on the border** of the circle are considered **inside**.\n\nReturn _an array_ `answer`_, where_ `answer[j]` _is the answer to the_ `jth` _query_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,3\\],\\[3,3\\],\\[5,3\\],\\[2,2\\]\\], queries = \\[\\[2,3,1\\],\\[4,3,1\\],\\[1,1,2\\]\\]\n**Output:** \\[3,2,2\\]\n**Explanation:** The points and circles are shown above.\nqueries\\[0\\] is the green circle, queries\\[1\\] is the red circle, and queries\\[2\\] is the blue circle.\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\],\\[5,5\\]\\], queries = \\[\\[1,2,2\\],\\[2,2,2\\],\\[4,3,2\\],\\[4,3,3\\]\\]\n**Output:** \\[2,3,2,4\\]\n**Explanation:** The points and circles are shown above.\nqueries\\[0\\] is green, queries\\[1\\] is red, queries\\[2\\] is blue, and queries\\[3\\] is purple.\n\n**Constraints:**\n\n*   `1 <= points.length <= 500`\n*   `points[i].length == 2`\n*   `0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500`\n*   `1 <= queries.length <= 500`\n*   `queries[j].length == 3`\n*   `0 <= xj, yj <= 500`\n*   `1 <= rj <= 500`\n*   All coordinates are integers.\n\n**Follow up:** Could you find the answer for each query in better complexity than `O(n)`?\"\"\"\n\n    answer = []\n    for query in queries:\n        inside = 0\n        for point in points:\n            dx = point[0] - query[0]\n            dy = point[1] - query[1]\n            if dx * dx + dy * dy <= query[2] * query[2]:\n                inside += 1\n        answer.append(inside)\n    return answer"}}, "leetcode/leetcode_2249.txt": {"score": 0.9882805943489075, "content": {"text": "def count_sequences(differences, lower, upper):\n    \"\"\"Given a 2D integer array `circles` where `circles[i] = [xi, yi, ri]` represents the center `(xi, yi)` and radius `ri` of the `ith` circle drawn on a grid, return _the **number of lattice points**_ _that are present inside **at least one** circle_.\n\n**Note:**\n\n*   A **lattice point** is a point with integer coordinates.\n*   Points that lie **on the circumference of a circle** are also considered to be inside it.\n\n**Example 1:**\n\n**Input:** circles = \\[\\[2,2,1\\]\\]\n**Output:** 5\n**Explanation:**\nThe figure above shows the given circle.\nThe lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.\nOther points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.\nHence, the number of lattice points present inside at least one circle is 5.\n\n**Example 2:**\n\n**Input:** circles = \\[\\[2,2,2\\],\\[3,4,1\\]\\]\n**Output:** 16\n**Explanation:**\nThe figure above shows the given circles.\nThere are exactly 16 lattice points which are present inside at least one circle. \nSome of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).\n\n**Constraints:**\n\n*   `1 <= circles.length <= 200`\n*   `circles[i].length == 3`\n*   `1 <= xi, yi <= 100`\n*   `1 <= ri <= min(xi, yi)`\"\"\"\n\n    count = 0\n    n = len(differences)\n    hidden = [0] * (n + 1)\n\n    hidden[0] = lower\n    while True:\n        valid = True\n        for i in range(1, n + 1):\n            hidden[i] = hidden[i - 1] + differences[i - 1]\n            if hidden[i] < lower or hidden[i] > upper:\n                valid = False\n                break\n        if valid: count += 1\n\n        if hidden[0] == upper: break\n        hidden[0] += 1\n    \n    return count"}}}}, "117": {"gold": {"leetcode/leetcode_1828.txt": 1}, "retrieved": {"leetcode/csn_python_train_308093.txt": {"score": 0.9022920727729797, "content": {"text": "def ranges_intersect(rset):\n    \"\"\"\n    Recursively calls the range_intersect() - pairwise version.\n\n    >>> ranges_intersect([(48, 65), (45, 55), (50, 56)])\n    [50, 55]\n    \"\"\"\n    if not rset:\n        return None\n\n    a = rset[0]\n    for b in rset[1:]:\n        if not a:\n            return None\n        a = range_intersect(a, b)\n\n    return a"}}, "leetcode/leetcode_223.txt": {"score": 0.9057375192642212, "content": {"text": "def total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    \"\"\"Given the coordinates of two **rectilinear** rectangles in a 2D plane, return _the total area covered by the two rectangles_.\n\nThe first rectangle is defined by its **bottom-left** corner `(ax1, ay1)` and its **top-right** corner `(ax2, ay2)`.\n\nThe second rectangle is defined by its **bottom-left** corner `(bx1, by1)` and its **top-right** corner `(bx2, by2)`.\n\n**Example 1:**\n\n**Input:** ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n**Output:** 45\n\n**Example 2:**\n\n**Input:** ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n**Output:** 16\n\n**Constraints:**\n\n*   `-104 <= ax1 <= ax2 <= 104`\n*   `-104 <= ay1 <= ay2 <= 104`\n*   `-104 <= bx1 <= bx2 <= 104`\n*   `-104 <= by1 <= by2 <= 104`\"\"\"\n\n    area1 = (ax2 - ax1) * (ay2 - ay1)\n    area2 = (bx2 - bx1) * (by2 - by1)\n\n    overlap_width = min(ax2, bx2) - max(ax1, bx1)\n    overlap_height = min(ay2, by2) - max(ay1, by1)\n\n    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)\n\n    return area1 + area2 - overlap_area"}}, "leetcode/leetcode_1996.txt": {"score": 0.9097506999969482, "content": {"text": "def numberOfSticks(n, k):\n    \"\"\"You are playing a game that contains multiple characters, and each of the characters has **two** main properties: **attack** and **defense**. You are given a 2D integer array `properties` where `properties[i] = [attacki, defensei]` represents the properties of the `ith` character in the game.\n\nA character is said to be **weak** if any other character has **both** attack and defense levels **strictly greater** than this character's attack and defense levels. More formally, a character `i` is said to be **weak** if there exists another character `j` where `attackj > attacki` and `defensej > defensei`.\n\nReturn _the number of **weak** characters_.\n\n**Example 1:**\n\n**Input:** properties = \\[\\[5,5\\],\\[6,3\\],\\[3,6\\]\\]\n**Output:** 0\n**Explanation:** No character has strictly greater attack and defense than the other.\n\n**Example 2:**\n\n**Input:** properties = \\[\\[2,2\\],\\[3,3\\]\\]\n**Output:** 1\n**Explanation:** The first character is weak because the second character has a strictly greater attack and defense.\n\n**Example 3:**\n\n**Input:** properties = \\[\\[1,5\\],\\[10,4\\],\\[4,3\\]\\]\n**Output:** 1\n**Explanation:** The third character is weak because the second character has a strictly greater attack and defense.\n\n**Constraints:**\n\n*   `2 <= properties.length <= 105`\n*   `properties[i].length == 2`\n*   `1 <= attacki, defensei <= 105`\"\"\"\n\n    MOD = 10**9 + 7\n    if n < k: return 0\n    dp = [[0] * (n+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        dp[i][1] = 1\n        for j in range(2, i+1):\n            dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % MOD\n\n    return dp[n][k]"}}, "leetcode/leetcode_1893.txt": {"score": 0.9166191816329956, "content": {"text": "def isCovered(ranges: List[List[int]], left: int, right: int) -> bool:\n    \"\"\"You are given a 2D integer array `ranges` and two integers `left` and `right`. Each `ranges[i] = [starti, endi]` represents an **inclusive** interval between `starti` and `endi`.\n\nReturn `true` _if each integer in the inclusive range_ `[left, right]` _is covered by **at least one** interval in_ `ranges`. Return `false` _otherwise_.\n\nAn integer `x` is covered by an interval `ranges[i] = [starti, endi]` if `starti <= x <= endi`.\n\n**Example 1:**\n\n**Input:** ranges = \\[\\[1,2\\],\\[3,4\\],\\[5,6\\]\\], left = 2, right = 5\n**Output:** true\n**Explanation:** Every integer between 2 and 5 is covered:\n- 2 is covered by the first range.\n- 3 and 4 are covered by the second range.\n- 5 is covered by the third range.\n\n**Example 2:**\n\n**Input:** ranges = \\[\\[1,10\\],\\[10,20\\]\\], left = 21, right = 21\n**Output:** false\n**Explanation:** 21 is not covered by any range.\n\n**Constraints:**\n\n*   `1 <= ranges.length <= 50`\n*   `1 <= starti <= endi <= 50`\n*   `1 <= left <= right <= 50`\"\"\"\n\n    for i in range(left, right + 1):\n        found = False\n        for _range in ranges:\n            if _range[0] <= i <= _range[1]:\n                found = True\n                break\n        if not found:\n            return False\n    return True"}}, "leetcode/leetcode_1620.txt": {"score": 0.9227061867713928, "content": {"text": "def canArrange(arr, k):\n    \"\"\"You are given an array of network towers `towers`, where `towers[i] = [xi, yi, qi]` denotes the `ith` network tower with location `(xi, yi)` and quality factor `qi`. All the coordinates are **integral coordinates** on the X-Y plane, and the distance between the two coordinates is the **Euclidean distance**.\n\nYou are also given an integer `radius` where a tower is **reachable** if the distance is **less than or equal to** `radius`. Outside that distance, the signal becomes garbled, and the tower is **not reachable**.\n\nThe signal quality of the `ith` tower at a coordinate `(x, y)` is calculated with the formula `\u230aqi / (1 + d)\u230b`, where `d` is the distance between the tower and the coordinate. The **network quality** at a coordinate is the sum of the signal qualities from all the **reachable** towers.\n\nReturn _the array_ `[cx, cy]` _representing the **integral** coordinate_ `(cx, cy)` _where the **network quality** is maximum. If there are multiple coordinates with the same **network quality**, return the lexicographically minimum **non-negative** coordinate._\n\n**Note:**\n\n*   A coordinate `(x1, y1)` is lexicographically smaller than `(x2, y2)` if either:\n    *   `x1 < x2`, or\n    *   `x1 == x2` and `y1 < y2`.\n*   `\u230aval\u230b` is the greatest integer less than or equal to `val` (the floor function).\n\n**Example 1:**\n\n**Input:** towers = \\[\\[1,2,5\\],\\[2,1,7\\],\\[3,1,9\\]\\], radius = 2\n**Output:** \\[2,1\\]\n**Explanation:** At coordinate (2, 1) the total quality is 13.\n- Quality of 7 from (2, 1) results in \u230a7 / (1 + sqrt(0)\u230b = \u230a7\u230b = 7\n- Quality of 5 from (1, 2) results in \u230a5 / (1 + sqrt(2)\u230b = \u230a2.07\u230b = 2\n- Quality of 9 from (3, 1) results in \u230a9 / (1 + sqrt(1)\u230b = \u230a4.5\u230b = 4\nNo other coordinate has a higher network quality.\n\n**Example 2:**\n\n**Input:** towers = \\[\\[23,11,21\\]\\], radius = 9\n**Output:** \\[23,11\\]\n**Explanation:** Since there is only one tower, the network quality is highest right at the tower's location.\n\n**Example 3:**\n\n**Input:** towers = \\[\\[1,2,13\\],\\[2,1,7\\],\\[0,1,9\\]\\], radius = 2\n**Output:** \\[1,2\\]\n**Explanation:** Coordinate (1, 2) has the highest network quality.\n\n**Constraints:**\n\n*   `1 <= towers.length <= 50`\n*   `towers[i].length == 3`\n*   `0 <= xi, yi, qi <= 50`\n*   `1 <= radius <= 50`\"\"\"\n\n    counts = [0] * k\n    for num in arr:\n        counts[(num % k + k) % k] += 1\n    if counts[0] % 2 != 0:\n        return False\n    for i in range(1, k // 2 + 1):\n        if counts[i] != counts[k - i]:\n            return False\n    return True"}}, "leetcode/leetcode_850.txt": {"score": 0.9347443580627441, "content": {"text": "def rectangleArea(rectangles):\n    \"\"\"You are given a 2D array of axis-aligned `rectangles`. Each `rectangle[i] = [xi1, yi1, xi2, yi2]` denotes the `ith` rectangle where `(xi1, yi1)` are the coordinates of the **bottom-left corner**, and `(xi2, yi2)` are the coordinates of the **top-right corner**.\n\nCalculate the **total area** covered by all `rectangles` in the plane. Any area covered by two or more rectangles should only be counted **once**.\n\nReturn _the **total area**_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[0,0,2,2\\],\\[1,0,2,3\\],\\[1,0,3,1\\]\\]\n**Output:** 6\n**Explanation:** A total area of 6 is covered by all three rectangles, as illustrated in the picture.\nFrom (1,1) to (2,2), the green and red rectangles overlap.\nFrom (1,0) to (2,3), all three rectangles overlap.\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[0,0,1000000000,1000000000\\]\\]\n**Output:** 49\n**Explanation:** The answer is 1018 modulo (109 + 7), which is 49.\n\n**Constraints:**\n\n*   `1 <= rectangles.length <= 200`\n*   `rectanges[i].length == 4`\n*   `0 <= xi1, yi1, xi2, yi2 <= 109`\n*   `xi1 <= xi2`\n*   `yi1 <= yi2`\"\"\"\n\n    mod = 10**9 + 7\n    n = len(rectangles)\n    X, Y = set(), set()\n    for rect in rectangles:\n        X.add(rect[0])\n        X.add(rect[2])\n        Y.add(rect[1])\n        Y.add(rect[3])\n    sorted_x = sorted(X)\n    sorted_y = sorted(Y)\n    cnt = [[0 for _ in range(len(Y) - 1)] for _ in range(len(X) - 1)]\n\n    for rect in rectangles:\n        x1_idx = sorted_x.index(rect[0])\n        x2_idx = sorted_x.index(rect[2]) - 1\n        y1_idx = sorted_y.index(rect[1])\n        y2_idx = sorted_y.index(rect[3]) - 1\n        for i in range(x1_idx, x2_idx + 1):\n            for j in range(y1_idx, y2_idx + 1):\n                cnt[i][j] = 1\n\n    total_area = 0\n    for i in range(len(X) - 1):\n        for j in range(len(Y) - 1):\n            if cnt[i][j]:\n                total_area += (sorted_x[i + 1] - sorted_x[i]) * (sorted_y[j + 1] - sorted_y[j])\n                total_area %= mod\n\n    return total_area"}}, "leetcode/leetcode_2249.txt": {"score": 0.9165046811103821, "content": {"text": "def count_sequences(differences, lower, upper):\n    \"\"\"Given a 2D integer array `circles` where `circles[i] = [xi, yi, ri]` represents the center `(xi, yi)` and radius `ri` of the `ith` circle drawn on a grid, return _the **number of lattice points**_ _that are present inside **at least one** circle_.\n\n**Note:**\n\n*   A **lattice point** is a point with integer coordinates.\n*   Points that lie **on the circumference of a circle** are also considered to be inside it.\n\n**Example 1:**\n\n**Input:** circles = \\[\\[2,2,1\\]\\]\n**Output:** 5\n**Explanation:**\nThe figure above shows the given circle.\nThe lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.\nOther points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.\nHence, the number of lattice points present inside at least one circle is 5.\n\n**Example 2:**\n\n**Input:** circles = \\[\\[2,2,2\\],\\[3,4,1\\]\\]\n**Output:** 16\n**Explanation:**\nThe figure above shows the given circles.\nThere are exactly 16 lattice points which are present inside at least one circle. \nSome of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).\n\n**Constraints:**\n\n*   `1 <= circles.length <= 200`\n*   `circles[i].length == 3`\n*   `1 <= xi, yi <= 100`\n*   `1 <= ri <= min(xi, yi)`\"\"\"\n\n    count = 0\n    n = len(differences)\n    hidden = [0] * (n + 1)\n\n    hidden[0] = lower\n    while True:\n        valid = True\n        for i in range(1, n + 1):\n            hidden[i] = hidden[i - 1] + differences[i - 1]\n            if hidden[i] < lower or hidden[i] > upper:\n                valid = False\n                break\n        if valid: count += 1\n\n        if hidden[0] == upper: break\n        hidden[0] += 1\n    \n    return count"}}, "leetcode/leetcode_2250.txt": {"score": 0.9843388199806213, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are given a 2D integer array `rectangles` where `rectangles[i] = [li, hi]` indicates that `ith` rectangle has a length of `li` and a height of `hi`. You are also given a 2D integer array `points` where `points[j] = [xj, yj]` is a point with coordinates `(xj, yj)`.\n\nThe `ith` rectangle has its **bottom-left corner** point at the coordinates `(0, 0)` and its **top-right corner** point at `(li, hi)`.\n\nReturn _an integer array_ `count` _of length_ `points.length` _where_ `count[j]` _is the number of rectangles that **contain** the_ `jth` _point._\n\nThe `ith` rectangle **contains** the `jth` point if `0 <= xj <= li` and `0 <= yj <= hi`. Note that points that lie on the **edges** of a rectangle are also considered to be contained by that rectangle.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[1,2\\],\\[2,3\\],\\[2,5\\]\\], points = \\[\\[2,1\\],\\[1,4\\]\\]\n**Output:** \\[2,1\\]\n**Explanation:** \nThe first rectangle contains no points.\nThe second rectangle contains only the point (2, 1).\nThe third rectangle contains the points (2, 1) and (1, 4).\nThe number of rectangles that contain the point (2, 1) is 2.\nThe number of rectangles that contain the point (1, 4) is 1.\nTherefore, we return \\[2, 1\\].\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\], points = \\[\\[1,3\\],\\[1,1\\]\\]\n**Output:** \\[1,3\\]\n**Explanation:**\nThe first rectangle contains only the point (1, 1).\nThe second rectangle contains only the point (1, 1).\nThe third rectangle contains the points (1, 3) and (1, 1).\nThe number of rectangles that contain the point (1, 3) is 1.\nThe number of rectangles that contain the point (1, 1) is 3.\nTherefore, we return \\[1, 3\\].\n\n**Constraints:**\n\n*   `1 <= rectangles.length, points.length <= 5 * 104`\n*   `rectangles[i].length == points[j].length == 2`\n*   `1 <= li, xj <= 109`\n*   `1 <= hi, yj <= 100`\n*   All the `rectangles` are **unique**.\n*   All the `points` are **unique**.\"\"\"\n\n\ndef kHighestRankedItems(grid, pricing, start, k):\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = []\n    pq = []\n    visited = [[False for _ in range(n)] for _ in range(m)]\n\n    heappush(pq, (0, -grid[start[0]][start[1]], start[0], start[1]))\n    visited[start[0]][start[1]] = True\n\n    while pq and k > 0:\n        size = len(pq)\n        for _ in range(size):\n            curr = heappop(pq)\n            steps, price, row, col = curr\n\n            if pricing[0] <= -price <= pricing[1]:\n                res.append([row, col])\n                k -= 1\n\n            for dr, dc in directions:\n                newRow, newCol = row + dr, col + dc\n                if 0 <= newRow < m and 0 <= newCol < n and not visited[newRow][newCol]:\n                    visited[newRow][newCol] = True\n                    heappush(pq, (steps + 1, -grid[newRow][newCol], newRow, newCol))\n\n    return res"}}, "leetcode/leetcode_986.txt": {"score": 0.9179108142852783, "content": {"text": "from itertools import permutations\n    \"\"\"You are given two lists of closed intervals, `firstList` and `secondList`, where `firstList[i] = [starti, endi]` and `secondList[j] = [startj, endj]`. Each list of intervals is pairwise **disjoint** and in **sorted order**.\n\nReturn _the intersection of these two interval lists_.\n\nA **closed interval** `[a, b]` (with `a <= b`) denotes the set of real numbers `x` with `a <= x <= b`.\n\nThe **intersection** of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of `[1, 3]` and `[2, 4]` is `[2, 3]`.\n\n**Example 1:**\n\n**Input:** firstList = \\[\\[0,2\\],\\[5,10\\],\\[13,23\\],\\[24,25\\]\\], secondList = \\[\\[1,5\\],\\[8,12\\],\\[15,24\\],\\[25,26\\]\\]\n**Output:** \\[\\[1,2\\],\\[5,5\\],\\[8,10\\],\\[15,23\\],\\[24,24\\],\\[25,25\\]\\]\n\n**Example 2:**\n\n**Input:** firstList = \\[\\[1,3\\],\\[5,9\\]\\], secondList = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `0 <= firstList.length, secondList.length <= 1000`\n*   `firstList.length + secondList.length >= 1`\n*   `0 <= starti < endi <= 109`\n*   `endi < starti+1`\n*   `0 <= startj < endj <= 109`\n*   `endj < startj+1`\"\"\"\n\n\ndef largestTimeFromDigits(arr):\n    max_time = -1\n    for h, i, j, k in permutations(arr):\n        hour = h * 10 + i\n        minute = j * 10 + k\n        time = hour * 60 + minute\n        if hour < 24 and minute < 60 and time > max_time:\n            max_time = time\n\n    if max_time == -1:\n        return \"\"\n    else:\n        return \"{:02d}:{:02d}\".format(max_time // 60, max_time % 60)"}}, "leetcode/leetcode_836.txt": {"score": 0.9290505647659302, "content": {"text": "def racecar(target: int) -> int:\n    \"\"\"An axis-aligned rectangle is represented as a list `[x1, y1, x2, y2]`, where `(x1, y1)` is the coordinate of its bottom-left corner, and `(x2, y2)` is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n\nTwo rectangles overlap if the area of their intersection is **positive**. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n\nGiven two axis-aligned rectangles `rec1` and `rec2`, return `true` _if they overlap, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** rec1 = \\[0,0,2,2\\], rec2 = \\[1,1,3,3\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** rec1 = \\[0,0,1,1\\], rec2 = \\[1,0,2,1\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** rec1 = \\[0,0,1,1\\], rec2 = \\[2,2,3,3\\]\n**Output:** false\n\n**Constraints:**\n\n*   `rec1.length == 4`\n*   `rec2.length == 4`\n*   `-109 <= rec1[i], rec2[i] <= 109`\n*   `rec1` and `rec2` represent a valid rectangle with a non-zero area.\"\"\"\n\n    memo = {}\n\n    def dp(pos: int, speed: int) -> int:\n        if pos == target:\n            return 0\n        if abs(pos) > 2 * target:\n            return float('inf')\n\n        key = (pos, speed)\n        if key in memo:\n            return memo[key]\n\n        op1 = dp(pos + speed, speed * 2) + 1\n        op2 = dp(pos, -speed) + 2\n\n        ans = min(op1, op2)\n        memo[key] = ans\n        return ans\n\n    return dp(0, 1)"}}}}, "118": {"gold": {"leetcode/leetcode_1851.txt": 1}, "retrieved": {"leetcode/leetcode_1977.txt": {"score": 0.9135679006576538, "content": {"text": "def intervalFinding(intervals, queries):\n    \"\"\"You wrote down many **positive** integers in a string called `num`. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was **non-decreasing** and that **no** integer had leading zeros.\n\nReturn _the **number of possible lists of integers** that you could have written down to get the string_ `num`. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** num =  \"327 \"\n**Output:** 2\n**Explanation:** You could have written down the numbers:\n3, 27\n327\n\n**Example 2:**\n\n**Input:** num =  \"094 \"\n**Output:** 0\n**Explanation:** No numbers can have leading zeros and all numbers must be positive.\n\n**Example 3:**\n\n**Input:** num =  \"0 \"\n**Output:** 0\n**Explanation:** No numbers can have leading zeros and all numbers must be positive.\n\n**Constraints:**\n\n*   `1 <= num.length <= 3500`\n*   `num` consists of digits `'0'` through `'9'`.\"\"\"\n\n    intervals.sort(key=lambda x: x[0])\n    ans = []\n    for q in queries:\n        min_size = float('inf')\n        for interval in intervals:\n            if interval[0] <= q <= interval[1]:\n                min_size = min(min_size, interval[1] - interval[0] + 1)\n        ans.append(-1 if min_size == float('inf') else min_size)\n    return ans"}}, "leetcode/leetcode_986.txt": {"score": 0.9198277592658997, "content": {"text": "from itertools import permutations\n    \"\"\"You are given two lists of closed intervals, `firstList` and `secondList`, where `firstList[i] = [starti, endi]` and `secondList[j] = [startj, endj]`. Each list of intervals is pairwise **disjoint** and in **sorted order**.\n\nReturn _the intersection of these two interval lists_.\n\nA **closed interval** `[a, b]` (with `a <= b`) denotes the set of real numbers `x` with `a <= x <= b`.\n\nThe **intersection** of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of `[1, 3]` and `[2, 4]` is `[2, 3]`.\n\n**Example 1:**\n\n**Input:** firstList = \\[\\[0,2\\],\\[5,10\\],\\[13,23\\],\\[24,25\\]\\], secondList = \\[\\[1,5\\],\\[8,12\\],\\[15,24\\],\\[25,26\\]\\]\n**Output:** \\[\\[1,2\\],\\[5,5\\],\\[8,10\\],\\[15,23\\],\\[24,24\\],\\[25,25\\]\\]\n\n**Example 2:**\n\n**Input:** firstList = \\[\\[1,3\\],\\[5,9\\]\\], secondList = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `0 <= firstList.length, secondList.length <= 1000`\n*   `firstList.length + secondList.length >= 1`\n*   `0 <= starti < endi <= 109`\n*   `endi < starti+1`\n*   `0 <= startj < endj <= 109`\n*   `endj < startj+1`\"\"\"\n\n\ndef largestTimeFromDigits(arr):\n    max_time = -1\n    for h, i, j, k in permutations(arr):\n        hour = h * 10 + i\n        minute = j * 10 + k\n        time = hour * 60 + minute\n        if hour < 24 and minute < 60 and time > max_time:\n            max_time = time\n\n    if max_time == -1:\n        return \"\"\n    else:\n        return \"{:02d}:{:02d}\".format(max_time // 60, max_time % 60)"}}, "leetcode/leetcode_2070.txt": {"score": 0.9197784662246704, "content": {"text": "from bisect import bisect_right\n    \"\"\"You are given a 2D integer array `items` where `items[i] = [pricei, beautyi]` denotes the **price** and **beauty** of an item respectively.\n\nYou are also given a **0-indexed** integer array `queries`. For each `queries[j]`, you want to determine the **maximum beauty** of an item whose **price** is **less than or equal** to `queries[j]`. If no such item exists, then the answer to this query is `0`.\n\nReturn _an array_ `answer` _of the same length as_ `queries` _where_ `answer[j]` _is the answer to the_ `jth` _query_.\n\n**Example 1:**\n\n**Input:** items = \\[\\[1,2\\],\\[3,2\\],\\[2,4\\],\\[5,6\\],\\[3,5\\]\\], queries = \\[1,2,3,4,5,6\\]\n**Output:** \\[2,4,5,5,6,6\\]\n**Explanation:**\n- For queries\\[0\\]=1, \\[1,2\\] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries\\[1\\]=2, the items which can be considered are \\[1,2\\] and \\[2,4\\]. \n  The maximum beauty among them is 4.\n- For queries\\[2\\]=3 and queries\\[3\\]=4, the items which can be considered are \\[1,2\\], \\[3,2\\], \\[2,4\\], and \\[3,5\\].\n  The maximum beauty among them is 5.\n- For queries\\[4\\]=5 and queries\\[5\\]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.\n\n**Example 2:**\n\n**Input:** items = \\[\\[1,2\\],\\[1,2\\],\\[1,3\\],\\[1,4\\]\\], queries = \\[1\\]\n**Output:** \\[4\\]\n**Explanation:** \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.  \n\n**Example 3:**\n\n**Input:** items = \\[\\[10,1000\\]\\], queries = \\[5\\]\n**Output:** \\[0\\]\n**Explanation:**\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0.\n\n**Constraints:**\n\n*   `1 <= items.length, queries.length <= 105`\n*   `items[i].length == 2`\n*   `1 <= pricei, beautyi, queries[j] <= 109`\"\"\"\n\n\ndef maxPrices(items, queries):\n    answer = []\n    sorted_items = [item[0] for item in items]\n    sorted_items.sort()\n\n    max_beauty = 0\n    for i, price in enumerate(sorted_items):\n        max_beauty = max(max_beauty, items[i][1])\n        sorted_items[i] = max_beauty\n\n    for query in queries:\n        idx = bisect_right(sorted_items, query) - 1\n        answer.append(sorted_items[idx] if idx >= 0 else 0)\n\n    return answer"}}, "leetcode/leetcode_1854.txt": {"score": 0.9312829375267029, "content": {"text": "def maxAliveYear(logs):\n    \"\"\"You are given a 2D integer array `logs` where each `logs[i] = [birthi, deathi]` indicates the birth and death years of the `ith` person.\n\nThe **population** of some year `x` is the number of people alive during that year. The `ith` person is counted in year `x`'s population if `x` is in the **inclusive** range `[birthi, deathi - 1]`. Note that the person is **not** counted in the year that they die.\n\nReturn _the **earliest** year with the **maximum population**_.\n\n**Example 1:**\n\n**Input:** logs = \\[\\[1993,1999\\],\\[2000,2010\\]\\]\n**Output:** 1993\n**Explanation:** The maximum population is 1, and 1993 is the earliest year with this population.\n\n**Example 2:**\n\n**Input:** logs = \\[\\[1950,1961\\],\\[1960,1971\\],\\[1970,1981\\]\\]\n**Output:** 1960\n**Explanation:** \nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960.\n\n**Constraints:**\n\n*   `1 <= logs.length <= 100`\n*   `1950 <= birthi < deathi <= 2050`\"\"\"\n\n    years = [0] * 101\n    for log in logs:\n        years[log[0] - 1950] += 1\n        years[log[1] - 1950] -= 1\n    max_population = years[0]\n    max_year = 1950\n    for i in range(1, 101):\n        years[i] += years[i - 1]\n        if years[i] > max_population:\n            max_population = years[i]\n            max_year = i + 1950\n    return max_year"}}, "leetcode/leetcode_1109.txt": {"score": 0.9200735092163086, "content": {"text": "def corpFlightBookings(bookings, n):\n    \"\"\"There are `n` flights that are labeled from `1` to `n`.\n\nYou are given an array of flight bookings `bookings`, where `bookings[i] = [firsti, lasti, seatsi]` represents a booking for flights `firsti` through `lasti` (**inclusive**) with `seatsi` seats reserved for **each flight** in the range.\n\nReturn _an array_ `answer` _of length_ `n`_, where_ `answer[i]` _is the total number of seats reserved for flight_ `i`.\n\n**Example 1:**\n\n**Input:** bookings = \\[\\[1,2,10\\],\\[2,3,20\\],\\[2,5,25\\]\\], n = 5\n**Output:** \\[10,55,45,25,25\\]\n**Explanation:**\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = \\[10,55,45,25,25\\]\n\n**Example 2:**\n\n**Input:** bookings = \\[\\[1,2,10\\],\\[2,2,15\\]\\], n = 2\n**Output:** \\[10,25\\]\n**Explanation:**\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = \\[10,25\\]\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `1 <= bookings.length <= 2 * 104`\n*   `bookings[i].length == 3`\n*   `1 <= firsti <= lasti <= n`\n*   `1 <= seatsi <= 104`\"\"\"\n\n    seats = [0] * n\n    for booking in bookings:\n        seats[booking[0] - 1] += booking[2]\n        if booking[1] < n:\n            seats[booking[1]] -= booking[2]\n    for i in range(1, n):\n        seats[i] += seats[i - 1]\n    return seats"}}, "leetcode/leetcode_1893.txt": {"score": 0.9221784472465515, "content": {"text": "def isCovered(ranges: List[List[int]], left: int, right: int) -> bool:\n    \"\"\"You are given a 2D integer array `ranges` and two integers `left` and `right`. Each `ranges[i] = [starti, endi]` represents an **inclusive** interval between `starti` and `endi`.\n\nReturn `true` _if each integer in the inclusive range_ `[left, right]` _is covered by **at least one** interval in_ `ranges`. Return `false` _otherwise_.\n\nAn integer `x` is covered by an interval `ranges[i] = [starti, endi]` if `starti <= x <= endi`.\n\n**Example 1:**\n\n**Input:** ranges = \\[\\[1,2\\],\\[3,4\\],\\[5,6\\]\\], left = 2, right = 5\n**Output:** true\n**Explanation:** Every integer between 2 and 5 is covered:\n- 2 is covered by the first range.\n- 3 and 4 are covered by the second range.\n- 5 is covered by the third range.\n\n**Example 2:**\n\n**Input:** ranges = \\[\\[1,10\\],\\[10,20\\]\\], left = 21, right = 21\n**Output:** false\n**Explanation:** 21 is not covered by any range.\n\n**Constraints:**\n\n*   `1 <= ranges.length <= 50`\n*   `1 <= starti <= endi <= 50`\n*   `1 <= left <= right <= 50`\"\"\"\n\n    for i in range(left, right + 1):\n        found = False\n        for _range in ranges:\n            if _range[0] <= i <= _range[1]:\n                found = True\n                break\n        if not found:\n            return False\n    return True"}}, "leetcode/leetcode_1450.txt": {"score": 0.929093599319458, "content": {"text": "def removeLeafNodes(root, target):\n    \"\"\"Given two integer arrays `startTime` and `endTime` and given an integer `queryTime`.\n\nThe `ith` student started doing their homework at the time `startTime[i]` and finished it at time `endTime[i]`.\n\nReturn _the number of students_ doing their homework at time `queryTime`. More formally, return the number of students where `queryTime` lays in the interval `[startTime[i], endTime[i]]` inclusive.\n\n**Example 1:**\n\n**Input:** startTime = \\[1,2,3\\], endTime = \\[3,2,7\\], queryTime = 4\n**Output:** 1\n**Explanation:** We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\n\n**Example 2:**\n\n**Input:** startTime = \\[4\\], endTime = \\[4\\], queryTime = 4\n**Output:** 1\n**Explanation:** The only student was doing their homework at the queryTime.\n\n**Constraints:**\n\n*   `startTime.length == endTime.length`\n*   `1 <= startTime.length <= 100`\n*   `1 <= startTime[i] <= endTime[i] <= 1000`\n*   `1 <= queryTime <= 1000`\"\"\"\n\n    if not root:\n        return None\n    root.left = removeLeafNodes(root.left, target)\n    root.right = removeLeafNodes(root.right, target)\n    if not root.left and not root.right and root.val == target:\n        return None\n    return root"}}, "leetcode/leetcode_1851.txt": {"score": 0.9371775388717651, "content": {"text": "from bisect import bisect_left\n    \"\"\"You are given a 2D integer array `intervals`, where `intervals[i] = [lefti, righti]` describes the `ith` interval starting at `lefti` and ending at `righti` **(inclusive)**. The **size** of an interval is defined as the number of integers it contains, or more formally `righti - lefti + 1`.\n\nYou are also given an integer array `queries`. The answer to the `jth` query is the **size of the smallest interval** `i` such that `lefti <= queries[j] <= righti`. If no such interval exists, the answer is `-1`.\n\nReturn _an array containing the answers to the queries_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[2,4\\],\\[3,6\\],\\[4,4\\]\\], queries = \\[2,3,4,5\\]\n**Output:** \\[3,3,1,4\\]\n**Explanation:** The queries are processed as follows:\n- Query = 2: The interval \\[2,4\\] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n- Query = 3: The interval \\[2,4\\] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n- Query = 4: The interval \\[4,4\\] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n- Query = 5: The interval \\[3,6\\] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[2,3\\],\\[2,5\\],\\[1,8\\],\\[20,25\\]\\], queries = \\[2,19,5,22\\]\n**Output:** \\[2,-1,4,6\\]\n**Explanation:** The queries are processed as follows:\n- Query = 2: The interval \\[2,3\\] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval \\[2,5\\] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n- Query = 22: The interval \\[20,25\\] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `1 <= queries.length <= 105`\n*   `intervals[i].length == 2`\n*   `1 <= lefti <= righti <= 107`\n*   `1 <= queries[j] <= 107`\"\"\"\n\n\ndef maxValue(events, k):\n    events.sort(key=lambda x: x[1])\n    n = len(events)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        start = -1\n        for j in range(i - 1, 0, -1):\n            if events[j - 1][1] < events[i - 1][0]:\n                start = j\n                break\n\n        for j in range(1, k + 1):\n            if start == -1:\n                dp[i][j] = max(dp[i - 1][j], events[i - 1][2])\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[start][j - 1] + events[i - 1][2])\n\n    return dp[n][k]"}}, "leetcode/leetcode_1707.txt": {"score": 0.9409387707710266, "content": {"text": "def can_transform(s, t):\n    \"\"\"You are given an array `nums` consisting of non-negative integers. You are also given a `queries` array, where `queries[i] = [xi, mi]`.\n\nThe answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and any element of `nums` that does not exceed `mi`. In other words, the answer is `max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements in `nums` are larger than `mi`, then the answer is `-1`.\n\nReturn _an integer array_ `answer` _where_ `answer.length == queries.length` _and_ `answer[i]` _is the answer to the_ `ith` _query._\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,2,3,4\\], queries = \\[\\[3,1\\],\\[1,3\\],\\[5,6\\]\\]\n**Output:** \\[3,3,7\\]\n**Explanation:**\n1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.\n\n**Example 2:**\n\n**Input:** nums = \\[5,2,4,6,6,3\\], queries = \\[\\[12,4\\],\\[8,1\\],\\[6,3\\]\\]\n**Output:** \\[15,-1,5\\]\n\n**Constraints:**\n\n*   `1 <= nums.length, queries.length <= 105`\n*   `queries[i].length == 2`\n*   `0 <= nums[j], xi, mi <= 109`\"\"\"\n\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    return j == len(t)"}}, "leetcode/leetcode_2251.txt": {"score": 0.9863754510879517, "content": {"text": "MOD = 10**9 + 7\n    \"\"\"You are given a **0-indexed** 2D integer array `flowers`, where `flowers[i] = [starti, endi]` means the `ith` flower will be in **full bloom** from `starti` to `endi` (**inclusive**). You are also given a **0-indexed** integer array `people` of size `n`, where `poeple[i]` is the time that the `ith` person will arrive to see the flowers.\n\nReturn _an integer array_ `answer` _of size_ `n`_, where_ `answer[i]` _is the **number** of flowers that are in full bloom when the_ `ith` _person arrives._\n\n**Example 1:**\n\n**Input:** flowers = \\[\\[1,6\\],\\[3,7\\],\\[9,12\\],\\[4,13\\]\\], poeple = \\[2,3,7,11\\]\n**Output:** \\[1,2,2,2\\]\n**Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n**Example 2:**\n\n**Input:** flowers = \\[\\[1,10\\],\\[3,3\\]\\], poeple = \\[3,3,2\\]\n**Output:** \\[2,2,1\\]\n**Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n**Constraints:**\n\n*   `1 <= flowers.length <= 5 * 104`\n*   `flowers[i].length == 2`\n*   `1 <= starti <= endi <= 109`\n*   `1 <= people.length <= 5 * 104`\n*   `1 <= people[i] <= 109`\"\"\"\n\n\ndef corridor_ways(corridor):\n    n = len(corridor)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    seats = 0\n    for i in range(n):\n        if corridor[i] == 'S':\n            seats += 1\n            if seats % 2 == 0:\n                dp[i + 1] = dp[max(0, i - 1)]\n            dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        else:\n            dp[i + 1] = dp[i]\n\n    return dp[n]"}}}}, "119": {"gold": {"leetcode/leetcode_999.txt": 1}, "retrieved": {"leetcode/leetcode_419.txt": {"score": 0.9257559776306152, "content": {"text": "def countBattleships(board):\n    \"\"\"Given an `m x n` matrix `board` where each cell is a battleship `'X'` or empty `'.'`, return _the number of the **battleships** on_ `board`.\n\n**Battleships** can only be placed horizontally or vertically on `board`. In other words, they can only be made of the shape `1 x k` (`1` row, `k` columns) or `k x 1` (`k` rows, `1` column), where `k` can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"X \", \". \", \". \", \"X \"\\],\\[ \". \", \". \", \". \", \"X \"\\],\\[ \". \", \". \", \". \", \"X \"\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \". \"\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 200`\n*   `board[i][j]` is either `'.'` or `'X'`.\n\n**Follow up:** Could you do it in one-pass, using only `O(1)` extra memory and without modifying the values `board`?\"\"\"\n\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count"}}, "leetcode/csn_python_train_333701.txt": {"score": 0.9316285252571106, "content": {"text": "def discover_region(self, move_x, move_y):\n        \"\"\"Discover region from given location.\"\"\"\n        field_list = deque([(move_y, move_x)])\n\n        while len(field_list) != 0:\n            field = field_list.popleft()\n\n            (tl_idx, br_idx, region_sum) = self.get_region(field[1], field[0])\n            if region_sum == 0:\n                self.info_map[field[0], field[1]] = region_sum\n                # get surrounding to queue\n                region_mat = self.info_map[tl_idx[0]:br_idx[0]+1,\n                                           tl_idx[1]:br_idx[1]+1]\n                x_list, y_list = np.nonzero(region_mat == 11)\n\n                for x_idx, y_idx in zip(x_list, y_list):\n                    field_temp = (x_idx+max(field[0]-1, 0),\n                                  y_idx+max(field[1]-1, 0))\n                    if field_temp not in field_list:\n                        field_list.append(field_temp)\n            elif region_sum > 0:\n                self.info_map[field[0], field[1]] = region_sum"}}, "leetcode/leetcode_1992.txt": {"score": 0.9306030869483948, "content": {"text": "def findFarmland(land):\n    \"\"\"You are given a **0-indexed** `m x n` binary matrix `land` where a `0` represents a hectare of forested land and a `1` represents a hectare of farmland.\n\nTo keep the land organized, there are designated rectangular areas of hectares that consist **entirely** of farmland. These rectangular areas are called **groups**. No two groups are adjacent, meaning farmland in one group is **not** four-directionally adjacent to another farmland in a different group.\n\n`land` can be represented by a coordinate system where the top left corner of `land` is `(0, 0)` and the bottom right corner of `land` is `(m-1, n-1)`. Find the coordinates of the top left and bottom right corner of each **group** of farmland. A **group** of farmland with a top left corner at `(r1, c1)` and a bottom right corner at `(r2, c2)` is represented by the 4-length array `[r1, c1, r2, c2].`\n\nReturn _a 2D array containing the 4-length arrays described above for each **group** of farmland in_ `land`_. If there are no groups of farmland, return an empty array. You may return the answer in **any order**_.\n\n**Example 1:**\n\n**Input:** land = \\[\\[1,0,0\\],\\[0,1,1\\],\\[0,1,1\\]\\]\n**Output:** \\[\\[0,0,0,0\\],\\[1,1,2,2\\]\\]\n**Explanation:**\nThe first group has a top left corner at land\\[0\\]\\[0\\] and a bottom right corner at land\\[0\\]\\[0\\].\nThe second group has a top left corner at land\\[1\\]\\[1\\] and a bottom right corner at land\\[2\\]\\[2\\].\n\n**Example 2:**\n\n**Input:** land = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** \\[\\[0,0,1,1\\]\\]\n**Explanation:**\nThe first group has a top left corner at land\\[0\\]\\[0\\] and a bottom right corner at land\\[1\\]\\[1\\].\n\n**Example 3:**\n\n**Input:** land = \\[\\[0\\]\\]\n**Output:** \\[\\]\n**Explanation:**\nThere are no groups of farmland.\n\n**Constraints:**\n\n*   `m == land.length`\n*   `n == land[i].length`\n*   `1 <= m, n <= 300`\n*   `land` consists of only `0`'s and `1`'s.\n*   Groups of farmland are **rectangular** in shape.\"\"\"\n\n    m, n = len(land), len(land[0])\n    groups = []\n    \n    for i in range(m):\n        for j in range(n):\n            if land[i][j] == 1:\n                r1, c1 = i, j\n                while j + 1 < n and land[i][j + 1] == 1:\n                    j += 1\n                r2, c2 = i, j\n                while r2 + 1 < m and land[r2 + 1][j] == 1:\n                    r2 += 1\n                for r in range(r1, r2 + 1):\n                    for c in range(c1, c2 + 1):\n                        land[r][c] = 0\n                groups.append([r1, c1, r2, c2])\n\n    return groups"}}, "leetcode/leetcode_2258.txt": {"score": 0.9326162934303284, "content": {"text": "from collections import deque\n    \"\"\"You are given a **0-indexed** 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:\n\n*   `0` represents grass,\n*   `1` represents fire,\n*   `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an **adjacent** grass cell. **After** your move, every fire cell will spread to all **adjacent** cells that are not walls.\n\nReturn _the **maximum** number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can **always** reach the safehouse regardless of the minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\n\nA cell is **adjacent** to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2,0,0,0,0,0\\],\\[0,0,0,2,2,1,0\\],\\[0,2,0,0,1,2,0\\],\\[0,0,2,2,2,0,2\\],\\[0,0,0,0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[0,1,2,0\\],\\[0,2,0,0\\]\\]\n**Output:** -1\n**Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[2,2,0\\],\\[1,2,0\\]\\]\n**Output:** 1000000000\n**Explanation:** The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 109 is returned.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 300`\n*   `4 <= m * n <= 2 * 104`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`\"\"\"\n\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef getMaxSafeMinutes(grid):\n    m, n = len(grid), len(grid[0])\n    dist = [[-1 for _ in range(n)] for _ in range(m)]\n    q = deque()\n\n    if grid[m - 1][n - 1] != 1:\n        dist[m - 1][n - 1] = 0\n        q.append((m - 1, n - 1))\n\n    while q:\n        x, y = q.popleft()\n        for d in range(4):\n            nx, ny = x + dx[d], y + dy[d]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[x][y] + 1\n                q.append((nx, ny))\n\n    if dist[0][0] == -1:\n        return -1\n\n    res = 0\n    for test in range(dist[0][0], int(1e9)):\n        ok = True\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    for d in range(4):\n                        nx, ny = x + dx[d], y + dy[d]\n                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:\n                            break\n                    else:\n                        ok = False\n                        break\n        if ok:\n            res = test\n        else:\n            break\n    return res"}}, "leetcode/leetcode_749.txt": {"score": 0.9378354549407959, "content": {"text": "def shortest_completing_word(license_plate, words):\n    \"\"\"A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as an `m x n` binary grid `isInfected`, where `isInfected[i][j] == 0` represents uninfected cells, and `isInfected[i][j] == 1` represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two **4-directionally** adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There **will never be a tie**.\n\nReturn _the number of walls used to quarantine all the infected regions_. If the world will become fully infected, return the number of walls used.\n\n**Example 1:**\n\n**Input:** isInfected = \\[\\[0,1,0,0,0,0,0,1\\],\\[0,1,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 10\n**Explanation:** There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n \nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n \n\n**Example 2:**\n\n**Input:** isInfected = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 4\n**Explanation:** Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n**Example 3:**\n\n**Input:** isInfected = \\[\\[1,1,1,0,0,0,0,0,0\\],\\[1,0,1,0,1,1,1,1,1\\],\\[1,1,1,0,0,0,0,0,0\\]\\]\n**Output:** 13\n**Explanation:** The region on the left only builds two new walls.\n\n**Constraints:**\n\n*   `m == isInfected.length`\n*   `n == isInfected[i].length`\n*   `1 <= m, n <= 50`\n*   `isInfected[i][j]` is either `0` or `1`.\n*   There is always a contiguous viral region throughout the described process that will **infect strictly more uncontaminated squares** in the next round.\"\"\"\n\n    target = [0] * 26\n    for c in license_plate:\n        if c.isalpha():\n            target[ord(c.lower()) - ord('a')] += 1\n\n    result = \"\"\n    for word in words:\n        current = [0] * 26\n        for c in word:\n            if c.isalpha():\n                current[ord(c.lower()) - ord('a')] += 1\n\n        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):\n            result = word\n\n    return result"}}, "leetcode/leetcode_1036.txt": {"score": 0.9391379952430725, "content": {"text": "from collections import deque\n    \"\"\"There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are `(x, y)`.\n\nWe start at the `source = [sx, sy]` square and want to reach the `target = [tx, ty]` square. There is also an array of `blocked` squares, where each `blocked[i] = [xi, yi]` represents a blocked square with coordinates `(xi, yi)`.\n\nEach move, we can walk one square north, east, south, or west if the square is **not** in the array of `blocked` squares. We are also not allowed to walk outside of the grid.\n\nReturn `true` _if and only if it is possible to reach the_ `target` _square from the_ `source` _square through a sequence of valid moves_.\n\n**Example 1:**\n\n**Input:** blocked = \\[\\[0,1\\],\\[1,0\\]\\], source = \\[0,0\\], target = \\[0,2\\]\n**Output:** false\n**Explanation:** The target square is inaccessible starting from the source square because we cannot move.\nWe cannot move north or east because those squares are blocked.\nWe cannot move south or west because we cannot go outside of the grid.\n\n**Example 2:**\n\n**Input:** blocked = \\[\\], source = \\[0,0\\], target = \\[999999,999999\\]\n**Output:** true\n**Explanation:** Because there are no blocked cells, it is possible to reach the target square.\n\n**Constraints:**\n\n*   `0 <= blocked.length <= 200`\n*   `blocked[i].length == 2`\n*   `0 <= xi, yi < 106`\n*   `source.length == target.length == 2`\n*   `0 <= sx, sy, tx, ty < 106`\n*   `source != target`\n*   It is guaranteed that `source` and `target` are not blocked.\"\"\"\n\n\ndef orangesRotting(grid):\n    m, n = len(grid), len(grid[0])\n    fresh_oranges = sum(row.count(1) for row in grid)\n    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])\n    \n    minutes = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while rotten and fresh_oranges:\n        for _ in range(len(rotten)):\n            x, y = rotten.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh_oranges -= 1\n                    rotten.append((nx, ny))\n        minutes += 1\n\n    return minutes if fresh_oranges == 0 else -1"}}, "leetcode/leetcode_1970.txt": {"score": 0.9319608211517334, "content": {"text": "def sort_sentence(s: str) -> str:\n    \"\"\"There is a **1-based** binary matrix where `0` represents land and `1` represents water. You are given integers `row` and `col` representing the number of rows and columns in the matrix, respectively.\n\nInitially on day `0`, the **entire** matrix is **land**. However, each day a new cell becomes flooded with **water**. You are given a **1-based** 2D array `cells`, where `cells[i] = [ri, ci]` represents that on the `ith` day, the cell on the `rith` row and `cith` column (**1-based** coordinates) will be covered with **water** (i.e., changed to `1`).\n\nYou want to find the **last** day that it is possible to walk from the **top** to the **bottom** by only walking on land cells. You can start from **any** cell in the top row and end at **any** cell in the bottom row. You can only travel in the **four** cardinal directions (left, right, up, and down).\n\nReturn _the **last** day where it is possible to walk from the **top** to the **bottom** by only walking on land cells_.\n\n**Example 1:**\n\n**Input:** row = 2, col = 2, cells = \\[\\[1,1\\],\\[2,1\\],\\[1,2\\],\\[2,2\\]\\]\n**Output:** 2\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 2.\n\n**Example 2:**\n\n**Input:** row = 2, col = 2, cells = \\[\\[1,1\\],\\[1,2\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:** 1\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 1.\n\n**Example 3:**\n\n**Input:** row = 3, col = 3, cells = \\[\\[1,2\\],\\[2,1\\],\\[3,3\\],\\[2,2\\],\\[1,1\\],\\[1,3\\],\\[2,3\\],\\[3,2\\],\\[3,1\\]\\]\n**Output:** 3\n**Explanation:** The above image depicts how the matrix changes each day starting from day 0.\nThe last day where it is possible to cross from top to bottom is on day 3.\n\n**Constraints:**\n\n*   `2 <= row, col <= 2 * 104`\n*   `4 <= row * col <= 2 * 104`\n*   `cells.length == row * col`\n*   `1 <= ri <= row`\n*   `1 <= ci <= col`\n*   All the values of `cells` are **unique**.\"\"\"\n\n    tokens = s.split()\n    words = [''] * len(tokens)\n    \n    for token in tokens:\n        pos = int(token[-1]) - 1\n        words[pos] = token[:-1]\n    \n    return ' '.join(words)"}}, "leetcode/leetcode_999.txt": {"score": 0.9481748342514038, "content": {"text": "def regionsBySlashes(grid):\n    \"\"\"On an `8 x 8` chessboard, there is **exactly one** white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered **attacking** a pawn if the rook can capture the pawn on the rook's turn. The **number of available captures** for the white rook is the number of pawns that the rook is **attacking**.\n\nReturn _the **number of available captures** for the white rook_.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"R \", \". \", \". \", \". \", \"p \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** In this example, the rook is attacking all the pawns.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"B \", \"R \", \"B \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 0\n**Explanation:** The bishops are blocking the rook from attacking any of the pawns.\n\n**Example 3:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \"p \", \"p \", \". \", \"R \", \". \", \"p \", \"B \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** The rook is attacking the pawns at positions b5, d6, and f5.\n\n**Constraints:**\n\n*   `board.length == 8`\n*   `board[i].length == 8`\n*   `board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`\n*   There is exactly one cell with `board[i][j] == 'R'`\"\"\"\n\n    n = len(grid)\n    graph = [[0] * (n * 3) for _ in range(n * 3)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '/':\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1\n            if grid[i][j] == '\\\\':\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1\n\n    regions = 0\n    for i in range(n * 3):\n        for j in range(n * 3):\n            if not graph[i][j]:\n                regions += 1\n                dfs(graph, i, j)\n\n    return regions\n\ndef dfs(graph, i, j):\n    n = len(graph)\n    if i < 0 or j < 0 or i >= n or j >= n or graph[i][j]:\n        return\n\n    graph[i][j] = 1\n    dfs(graph, i - 1, j)\n    dfs(graph, i + 1, j)\n    dfs(graph, i, j - 1)\n    dfs(graph, i, j + 1)"}}, "leetcode/leetcode_1020.txt": {"score": 0.9327875375747681, "content": {"text": "def maxTurbulenceSize(arr):\n    \"\"\"You are given an `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell.\n\nA **move** consists of walking from one land cell to another adjacent (**4-directionally**) land cell or walking off the boundary of the `grid`.\n\nReturn _the number of land cells in_ `grid` _for which we cannot walk off the boundary of the grid in any number of **moves**_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0,0\\],\\[1,0,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 3\n**Explanation:** There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,0,1,0\\],\\[0,0,1,0\\],\\[0,0,0,0\\]\\]\n**Output:** 0\n**Explanation:** All 1s are either on the boundary or can reach the boundary.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `0` or `1`.\n\nFor i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is odd, and arr\\[k\\] < arr\\[k + 1\\] when k is even. OR For i <= k < j, arr\\[k\\] > arr\\[k + 1\\] when k is even, and arr\\[k\\] < arr\\[k + 1\\] when k is odd.\"\"\"\n\n    n = len(arr)\n    result = 1\n    i = 0\n\n    while i < n - 1:\n        if arr[i] == arr[i + 1]:\n            i += 1\n            continue\n\n        j = i + 1\n        while j < n - 1 and ((arr[j] > arr[j + 1]) != (arr[j - 1] > arr[j])):\n            j += 1\n        \n        result = max(result, j - i + 1)\n        i = j\n\n    return result"}}, "leetcode/leetcode_2257.txt": {"score": 0.9918091893196106, "content": {"text": "def earliest_blooming_day(plant_time, grow_time):\n    \"\"\"You are given two integers `m` and `n` representing a **0-indexed** `m x n` grid. You are also given two 2D integer arrays `guards` and `walls` where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `ith` guard and `jth` wall respectively.\n\nA guard can see **every** cell in the four cardinal directions (north, east, south, or west) starting from their position unless **obstructed** by a wall or another guard. A cell is **guarded** if there is **at least** one guard that can see it.\n\nReturn _the number of unoccupied cells that are **not** **guarded**._\n\n**Example 1:**\n\n**Input:** m = 4, n = 6, guards = \\[\\[0,0\\],\\[1,1\\],\\[2,3\\]\\], walls = \\[\\[0,1\\],\\[2,2\\],\\[1,4\\]\\]\n**Output:** 7\n**Explanation:** The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\n**Example 2:**\n\n**Input:** m = 3, n = 3, guards = \\[\\[1,1\\]\\], walls = \\[\\[0,1\\],\\[1,0\\],\\[2,1\\],\\[1,2\\]\\]\n**Output:** 4\n**Explanation:** The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\n**Constraints:**\n\n*   `1 <= m, n <= 105`\n*   `2 <= m * n <= 105`\n*   `1 <= guards.length, walls.length <= 5 * 104`\n*   `2 <= guards.length + walls.length <= m * n`\n*   `guards[i].length == walls[j].length == 2`\n*   `0 <= rowi, rowj < m`\n*   `0 <= coli, colj < n`\n*   All the positions in `guards` and `walls` are **unique**.\"\"\"\n\n    bloom_time = [plant_time[i] + grow_time[i] for i in range(len(plant_time))]\n    bloom_time.sort()\n    earliest_day = 0\n    for i in bloom_time:\n        earliest_day = max(earliest_day, i)\n        earliest_day += 1\n    return earliest_day"}}}}, "120": {"gold": {"leetcode/leetcode_1456.txt": 1}, "retrieved": {"leetcode/leetcode_1052.txt": {"score": 0.924959659576416, "content": {"text": "def maxSatisfied(customers, grumpy, minutes):\n    \"\"\"There is a bookstore owner that has a store open for `n` minutes. Every minute, some number of customers enter the store. You are given an integer array `customers` of length `n` where `customers[i]` is the number of the customer that enters the store at the start of the `ith` minute and all those customers leave after the end of that minute.\n\nOn some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where `grumpy[i]` is `1` if the bookstore owner is grumpy during the `ith` minute, and is `0` otherwise.\n\nWhen the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\n\nThe bookstore owner knows a secret technique to keep themselves not grumpy for `minutes` consecutive minutes, but can only use it once.\n\nReturn _the maximum number of customers that can be satisfied throughout the day_.\n\n**Example 1:**\n\n**Input:** customers = \\[1,0,1,2,1,1,7,5\\], grumpy = \\[0,1,0,1,0,1,0,1\\], minutes = 3\n**Output:** 16\n**Explanation:** The bookstore owner keeps themselves not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\n**Example 2:**\n\n**Input:** customers = \\[1\\], grumpy = \\[0\\], minutes = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `n == customers.length == grumpy.length`\n*   `1 <= minutes <= n <= 2 * 104`\n*   `0 <= customers[i] <= 1000`\n*   `grumpy[i]` is either `0` or `1`.\"\"\"\n\n    total_customers = 0\n    max_extra_customers = 0\n    extra_customers = 0\n    for i in range(len(customers)):\n        if grumpy[i] == 0:\n            total_customers += customers[i]\n        if i < minutes:\n            extra_customers += customers[i] * grumpy[i]\n        else:\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes])\n        max_extra_customers = max(max_extra_customers, extra_customers)\n    return total_customers + max_extra_customers"}}, "leetcode/leetcode_2274.txt": {"score": 0.9262337684631348, "content": {"text": "def final_value(nums, original):\n    \"\"\"Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.\n\nYou are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.\n\nReturn _the **maximum** number of consecutive floors without a special floor_.\n\n**Example 1:**\n\n**Input:** bottom = 2, top = 9, special = \\[4,6\\]\n**Output:** 3\n**Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors.\n\n**Example 2:**\n\n**Input:** bottom = 6, top = 8, special = \\[7,6,8\\]\n**Output:** 0\n**Explanation:** Every floor rented is a special floor, so we return 0.\n\n**Constraints:**\n\n*   `1 <= special.length <= 105`\n*   `1 <= bottom <= special[i] <= top <= 109`\n*   All the values of `special` are **unique**.\"\"\"\n\n    while original in nums:\n        original += 1\n    return original"}}, "leetcode/leetcode_1793.txt": {"score": 0.9256662726402283, "content": {"text": "def min_moves(nums, limit):\n    \"\"\"You are given an array of integers `nums` **(0-indexed)** and an integer `k`.\n\nThe **score** of a subarray `(i, j)` is defined as `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)`. A **good** subarray is a subarray where `i <= k <= j`.\n\nReturn _the maximum possible **score** of a **good** subarray._\n\n**Example 1:**\n\n**Input:** nums = \\[1,4,3,7,4,5\\], k = 3\n**Output:** 15\n**Explanation:** The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) \\* (5-1+1) = 3 \\* 5 = 15. \n\n**Example 2:**\n\n**Input:** nums = \\[5,5,4,5,4,1,1,1\\], k = 0\n**Output:** 20\n**Explanation:** The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) \\* (4-0+1) = 4 \\* 5 = 20.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 2 * 104`\n*   `0 <= k < nums.length`\"\"\"\n\n    n = len(nums)\n    delta = [0] * (2 * limit + 2)\n\n    for i in range(n // 2):\n        lo = min(nums[i], nums[n - 1 - i]) + 1\n        hi = max(nums[i], nums[n - 1 - i]) + limit\n        delta[lo] -= 1\n        delta[nums[i] + nums[n - 1 - i]] -= 1\n        delta[hi + 1] += 1\n\n    moves, current = n, n\n    for i in range(2, 2 * limit + 1):\n        current += delta[i]\n        moves = min(moves, current)\n\n    return moves"}}, "leetcode/leetcode_1031.txt": {"score": 0.9326314330101013, "content": {"text": "def add_to_array_form(num, k):\n    \"\"\"Given an integer array `nums` and two integers `firstLen` and `secondLen`, return _the maximum sum of elements in two non-overlapping **subarrays** with lengths_ `firstLen` _and_ `secondLen`.\n\nThe array with length `firstLen` could occur before or after the array with length `secondLen`, but they have to be non-overlapping.\n\nA **subarray** is a **contiguous** part of an array.\n\n**Example 1:**\n\n**Input:** nums = \\[0,6,5,2,2,5,1,9,4\\], firstLen = 1, secondLen = 2\n**Output:** 20\n**Explanation:** One choice of subarrays is \\[9\\] with length 1, and \\[6,5\\] with length 2.\n\n**Example 2:**\n\n**Input:** nums = \\[3,8,1,3,2,1,8,9,0\\], firstLen = 3, secondLen = 2\n**Output:** 29\n**Explanation:** One choice of subarrays is \\[3,8,1\\] with length 3, and \\[8,9\\] with length 2.\n\n**Example 3:**\n\n**Input:** nums = \\[2,1,5,6,0,9,5,0,3,8\\], firstLen = 4, secondLen = 3\n**Output:** 31\n**Explanation:** One choice of subarrays is \\[5,6,0,9\\] with length 4, and \\[0,3,8\\] with length 3.\n\n**Constraints:**\n\n*   `1 <= firstLen, secondLen <= 1000`\n*   `2 <= firstLen + secondLen <= 1000`\n*   `firstLen + secondLen <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\"\"\"\n\n    for i in range(len(num) - 1, -1, -1):\n        k, num[i] = divmod(num[i] + k, 10)\n        if k == 0:\n            break\n    while k:\n        k, digit = divmod(k, 10)\n        num.insert(0, digit)\n    return num"}}, "leetcode/leetcode_1546.txt": {"score": 0.9305543303489685, "content": {"text": "def maxNonOverlapping(nums, target):\n    \"\"\"Given an array `nums` and an integer `target`, return _the maximum number of **non-empty** **non-overlapping** subarrays such that the sum of values in each subarray is equal to_ `target`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,1,1,1\\], target = 2\n**Output:** 2\n**Explanation:** There are 2 non-overlapping subarrays \\[**1,1**,1,**1,1**\\] with sum equals to target(2).\n\n**Example 2:**\n\n**Input:** nums = \\[-1,3,5,1,4,2,-9\\], target = 6\n**Output:** 2\n**Explanation:** There are 3 subarrays with sum equal to 6.\n(\\[5,1\\], \\[4,2\\], \\[3,5,1,4,2,-9\\]) but only the first 2 are non-overlapping.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n*   `0 <= target <= 106`\"\"\"\n\n    prefix_sum = {0: 0}\n    sum, count = 0, 0\n    for num in nums:\n        sum += num\n        if sum - target in prefix_sum:\n            count = max(count, 1 + prefix_sum[sum - target])\n        prefix_sum[sum] = count\n    return count"}}, "leetcode/leetcode_1235.txt": {"score": 0.9279770255088806, "content": {"text": "from bisect import bisect_left\n    \"\"\"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.\n\nYou're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\nIf you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.\n\n**Example 1:**\n\n**Input:** startTime = \\[1,2,3,3\\], endTime = \\[3,4,5,6\\], profit = \\[50,10,40,70\\]\n**Output:** 120\n**Explanation:** The subset chosen is the first and fourth job. \nTime range \\[1-3\\]+\\[3-6\\] , we get profit of 120 = 50 + 70.\n\n**Example 2:**\n\n**Input:** startTime = \\[1,2,3,4,6\\], endTime = \\[3,5,10,6,9\\], profit = \\[20,20,100,70,60\\]\n**Output:** 150\n**Explanation:** The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n**Example 3:**\n\n**Input:** startTime = \\[1,1,1\\], endTime = \\[2,3,4\\], profit = \\[5,6,4\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`\n*   `1 <= startTime[i] < endTime[i] <= 109`\n*   `1 <= profit[i] <= 104`\"\"\"\n\n\ndef jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(endTime, startTime, profit))\n    dp = [jobs[0][2]]\n    \n    def latestNonConflict(index):\n        startTimeToFind = jobs[index][1]\n        index = bisect_left([job[0] for job in jobs], startTimeToFind)\n        if index:\n            return index - 1\n        return -1\n\n    for i in range(1, len(jobs)):\n        L = latestNonConflict(i)\n        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))\n\n    return dp[-1]"}}, "leetcode/leetcode_2551.txt": {"score": 0.9292562007904053, "content": {"text": "def maximize_score(weights, k):\n    \"\"\"You have `k` bags. You are given a **0-indexed** integer array `weights` where `weights[i]` is the weight of the `ith` marble. You are also given the integer `k.`\n\nDivide the marbles into the `k` bags according to the following rules:\n\n*   No bag is empty.\n*   If the `ith` marble and `jth` marble are in a bag, then all marbles with an index between the `ith` and `jth` indices should also be in that same bag.\n*   If a bag consists of all the marbles with an index from `i` to `j` inclusively, then the cost of the bag is `weights[i] + weights[j]`.\n\nThe **score** after distributing the marbles is the sum of the costs of all the `k` bags.\n\nReturn _the **difference** between the **maximum** and **minimum** scores among marble distributions_.\n\n**Example 1:**\n\n**Input:** weights = \\[1,3,5,1\\], k = 2\n**Output:** 4\n**Explanation:** \nThe distribution \\[1\\],\\[3,5,1\\] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution \\[1,3\\],\\[5,1\\], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n\n**Example 2:**\n\n**Input:** weights = \\[1, 3\\], k = 2\n**Output:** 0\n**Explanation:** The only distribution possible is \\[1\\],\\[3\\]. \nSince both the maximal and minimal score are the same, we return 0.\n\n**Constraints:**\n\n*   `1 <= k <= weights.length <= 105`\n*   `1 <= weights[i] <= 109`\"\"\"\n\n    n = len(weights)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n    dp = [[-1000000000] * (k + 1) for _ in range(n)]\n\n    for i in range(n):\n        dp[i][1] = prefix_sum[i + 1]\n        if i > 0:\n            dp[i][i + 1] = prefix_sum[i + 1] - prefix_sum[1]\n        for j in range(2, min(i + 1, k) + 1):\n            for q in range(1, i - j + 3):\n                dp[i][j] = max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q])\n\n    return dp[n - 1][k] - dp[n - 1][1]"}}, "leetcode/leetcode_2555.txt": {"score": 0.9571771025657654, "content": {"text": "from bisect import bisect_left, bisect_right\n    \"\"\"There are some prizes on the **X-axis**. You are given an integer array `prizePositions` that is **sorted in non-decreasing order**, where `prizePositions[i]` is the position of the `ith` prize. There could be different prizes at the same position on the line. You are also given an integer `k`.\n\nYou are allowed to select two segments with integer endpoints. The length of each segment must be `k`. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n\n*   For example if `k = 2`, you can choose segments `[1, 3]` and `[2, 4]`, and you will win any prize i that satisfies `1 <= prizePositions[i] <= 3` or `2 <= prizePositions[i] <= 4`.\n\nReturn _the **maximum** number of prizes you can win if you choose the two segments optimally_.\n\n**Example 1:**\n\n**Input:** prizePositions = \\[1,1,2,2,3,3,5\\], k = 2\n**Output:** 7\n**Explanation:** In this example, you can win all 7 prizes by selecting two segments \\[1, 3\\] and \\[3, 5\\].\n\n**Example 2:**\n\n**Input:** prizePositions = \\[1,2,3,4\\], k = 0\n**Output:** 2\n**Explanation:** For this example, **one choice** for the segments is `[3, 3]` and `[4, 4],` and you will be able to get `2` prizes. \n\n**Constraints:**\n\n*   `1 <= prizePositions.length <= 105`\n*   `1 <= prizePositions[i] <= 109`\n*   `0 <= k <= 109`\n*   `prizePositions` is sorted in non-decreasing order.\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n\ndef max_prizes(prize_positions, k):\n    n = len(prize_positions)\n    ans = 0\n    for i in range(n):\n        left_segment_end = prize_positions[i] + k\n        right_segment_start = bisect_right(prize_positions, left_segment_end)\n        right_segment_end = prize_positions[right_segment_start] + k\n        ans = max(ans, bisect_right(prize_positions, right_segment_end) - bisect_left(prize_positions, prize_positions[i]))\n    return ans"}}, "leetcode/leetcode_1326.txt": {"score": 0.9328407645225525, "content": {"text": "def sum_of_floored_pairs(nums):\n    \"\"\"There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).\n\nThere are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.\n\nGiven an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.\n\nReturn _the minimum number of taps_ that should be open to water the whole garden, If the garden cannot be watered return **\\-1**.\n\n**Example 1:**\n\n**Input:** n = 5, ranges = \\[3,4,1,1,0,0\\]\n**Output:** 1\n**Explanation:** The tap at point 0 can cover the interval \\[-3,3\\]\nThe tap at point 1 can cover the interval \\[-3,5\\]\nThe tap at point 2 can cover the interval \\[1,3\\]\nThe tap at point 3 can cover the interval \\[2,4\\]\nThe tap at point 4 can cover the interval \\[4,4\\]\nThe tap at point 5 can cover the interval \\[5,5\\]\nOpening Only the second tap will water the whole garden \\[0,5\\]\n\n**Example 2:**\n\n**Input:** n = 3, ranges = \\[0,0,0,0\\]\n**Output:** -1\n**Explanation:** Even if you activate all the four taps you cannot water the whole garden.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `ranges.length == n + 1`\n*   `0 <= ranges[i] <= 100`\"\"\"\n\n    mod = 10**9 + 7\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    pref_sum = [0] * (max_val + 1)\n\n    for num in nums:\n        count[num] += 1\n\n    for i in range(1, max_val + 1):\n        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod\n\n    res = 0\n    for x in range(1, max_val + 1):\n        nx = x\n        k = 1\n        while nx <= max_val:\n            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod\n            k += 1\n            nx += x\n    return res"}}, "leetcode/leetcode_2271.txt": {"score": 0.9896247982978821, "content": {"text": "def rearrange_array(nums):\n    \"\"\"You are given a 2D integer array `tiles` where `tiles[i] = [li, ri]` represents that every tile `j` in the range `li <= j <= ri` is colored white.\n\nYou are also given an integer `carpetLen`, the length of a single carpet that can be placed **anywhere**.\n\nReturn _the **maximum** number of white tiles that can be covered by the carpet_.\n\n**Example 1:**\n\n**Input:** tiles = \\[\\[1,5\\],\\[10,11\\],\\[12,18\\],\\[20,25\\],\\[30,32\\]\\], carpetLen = 10\n**Output:** 9\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles.\n\n**Example 2:**\n\n**Input:** tiles = \\[\\[10,11\\],\\[1,1\\]\\], carpetLen = 2\n**Output:** 2\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2.\n\n**Constraints:**\n\n*   `1 <= tiles.length <= 5 * 104`\n*   `tiles[i].length == 2`\n*   `1 <= li <= ri <= 109`\n*   `1 <= carpetLen <= 109`\n*   The `tiles` are **non-overlapping**.\"\"\"\n\n    nums.sort()\n    half = len(nums) // 2\n    result = [0] * len(nums)\n    j = 0\n    for i in range(half):\n        result[j] = nums[i]\n        result[j + 1] = nums[half + i]\n        j += 2\n    return result"}}}}, "121": {"gold": {"leetcode/leetcode_128.txt": 1, "leetcode/leetcode_164.txt": 1}, "retrieved": {"leetcode/leetcode_1936.txt": {"score": 0.9276765584945679, "content": {"text": "def numberOfNiceDivisors(primeFactors):\n    \"\"\"You are given a **strictly increasing** integer array `rungs` that represents the **height** of rungs on a ladder. You are currently on the **floor** at height `0`, and you want to reach the last rung.\n\nYou are also given an integer `dist`. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is **at most** `dist`. You are able to insert rungs at any positive **integer** height if a rung is not already there.\n\nReturn _the **minimum** number of rungs that must be added to the ladder in order for you to climb to the last rung._\n\n**Example 1:**\n\n**Input:** rungs = \\[1,3,5,10\\], dist = 2\n**Output:** 2\n**Explanation:**\nYou currently cannot reach the last rung.\nAdd rungs at heights 7 and 8 to climb this ladder. \nThe ladder will now have rungs at \\[1,3,5,7,8,10\\].\n\n**Example 2:**\n\n**Input:** rungs = \\[3,6,8,10\\], dist = 3\n**Output:** 0\n**Explanation:**\nThis ladder can be climbed without adding additional rungs.\n\n**Example 3:**\n\n**Input:** rungs = \\[3,4,6,7\\], dist = 2\n**Output:** 1\n**Explanation:**\nYou currently cannot reach the first rung from the ground.\nAdd a rung at height 1 to climb this ladder.\nThe ladder will now have rungs at \\[1,3,4,6,7\\].\n\n**Constraints:**\n\n*   `1 <= rungs.length <= 105`\n*   `1 <= rungs[i] <= 109`\n*   `1 <= dist <= 109`\n*   `rungs` is **strictly increasing**.\"\"\"\n\n    MOD = 1000000007\n    result = 1\n    p = 2\n    while p <= primeFactors:\n        if primeFactors % p == 0:\n            count = 0\n            while primeFactors % p == 0:\n                primeFactors //= p\n                count += 1\n            result = (result * (count * 2 + 1)) % MOD\n        p += 1\n    return result"}}, "leetcode/leetcode_1052.txt": {"score": 0.9289760589599609, "content": {"text": "def maxSatisfied(customers, grumpy, minutes):\n    \"\"\"There is a bookstore owner that has a store open for `n` minutes. Every minute, some number of customers enter the store. You are given an integer array `customers` of length `n` where `customers[i]` is the number of the customer that enters the store at the start of the `ith` minute and all those customers leave after the end of that minute.\n\nOn some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where `grumpy[i]` is `1` if the bookstore owner is grumpy during the `ith` minute, and is `0` otherwise.\n\nWhen the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\n\nThe bookstore owner knows a secret technique to keep themselves not grumpy for `minutes` consecutive minutes, but can only use it once.\n\nReturn _the maximum number of customers that can be satisfied throughout the day_.\n\n**Example 1:**\n\n**Input:** customers = \\[1,0,1,2,1,1,7,5\\], grumpy = \\[0,1,0,1,0,1,0,1\\], minutes = 3\n**Output:** 16\n**Explanation:** The bookstore owner keeps themselves not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\n**Example 2:**\n\n**Input:** customers = \\[1\\], grumpy = \\[0\\], minutes = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `n == customers.length == grumpy.length`\n*   `1 <= minutes <= n <= 2 * 104`\n*   `0 <= customers[i] <= 1000`\n*   `grumpy[i]` is either `0` or `1`.\"\"\"\n\n    total_customers = 0\n    max_extra_customers = 0\n    extra_customers = 0\n    for i in range(len(customers)):\n        if grumpy[i] == 0:\n            total_customers += customers[i]\n        if i < minutes:\n            extra_customers += customers[i] * grumpy[i]\n        else:\n            extra_customers += (customers[i] * grumpy[i]) - (customers[i - minutes] * grumpy[i - minutes])\n        max_extra_customers = max(max_extra_customers, extra_customers)\n    return total_customers + max_extra_customers"}}, "leetcode/leetcode_1855.txt": {"score": 0.9279488921165466, "content": {"text": "def maxDistance(nums1, nums2):\n    \"\"\"You are given two **non-increasing 0-indexed** integer arrays `nums1`\u200b\u200b\u200b\u200b\u200b\u200b and `nums2`\u200b\u200b\u200b\u200b\u200b\u200b.\n\nA pair of indices `(i, j)`, where `0 <= i < nums1.length` and `0 <= j < nums2.length`, is **valid** if both `i <= j` and `nums1[i] <= nums2[j]`. The **distance** of the pair is `j - i`\u200b\u200b\u200b\u200b.\n\nReturn _the **maximum distance** of any **valid** pair_ `(i, j)`_. If there are no valid pairs, return_ `0`.\n\nAn array `arr` is **non-increasing** if `arr[i-1] >= arr[i]` for every `1 <= i < arr.length`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[55,30,5,4,2\\], nums2 = \\[100,20,10,10,5\\]\n**Output:** 2\n**Explanation:** The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).\nThe maximum distance is 2 with pair (2,4).\n\n**Example 2:**\n\n**Input:** nums1 = \\[2,2,2\\], nums2 = \\[10,10,1\\]\n**Output:** 1\n**Explanation:** The valid pairs are (0,0), (0,1), and (1,1).\nThe maximum distance is 1 with pair (0,1).\n\n**Example 3:**\n\n**Input:** nums1 = \\[30,29,19,5\\], nums2 = \\[25,25,25,25,25\\]\n**Output:** 2\n**Explanation:** The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).\nThe maximum distance is 2 with pair (2,4).\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[j] <= 105`\n*   Both `nums1` and `nums2` are **non-increasing**.\"\"\"\n\n    i, j, maxDist = 0, 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] > nums2[j]:\n            i += 1\n        else:\n            maxDist = max(maxDist, j - i)\n            j += 1\n    return maxDist"}}, "leetcode/leetcode_2560.txt": {"score": 0.938249409198761, "content": {"text": "def minimumCapability(nums, k):\n    \"\"\"There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he **refuses to steal from adjacent homes**.\n\nThe **capability** of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\n\nYou are given an integer array `nums` representing how much money is stashed in each house. More formally, the `ith` house from the left has `nums[i]` dollars.\n\nYou are also given an integer `k`, representing the **minimum** number of houses the robber will steal from. It is always possible to steal at least `k` houses.\n\nReturn _the **minimum** capability of the robber out of all the possible ways to steal at least_ `k` _houses_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,5,9\\], k = 2\n**Output:** 5\n**Explanation:** \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums\\[0\\], nums\\[2\\]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums\\[0\\], nums\\[3\\]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums\\[1\\], nums\\[3\\]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\], k = 2\n**Output:** 2\n**Explanation:** There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums\\[0\\], nums\\[4\\]) = 2.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `1 <= k <= (nums.length + 1)/2`\"\"\"\n\n    n, l, r = len(nums), 1, 10**9\n    while l < r:\n        mid = l + (r - l) // 2\n        i, cnt = 0, 0\n        for j in range(n):\n            if nums[j] <= mid:\n                cnt += 1\n                i = j + 2\n                while i + 1 < n and (i == j + 1 or nums[i] > mid):\n                    i += 1\n        if cnt < k:\n            l = mid + 1\n        else:\n            r = mid\n    return l"}}, "leetcode/leetcode_1124.txt": {"score": 0.9331104755401611, "content": {"text": "def longestWellPerformingInterval(hours):\n    \"\"\"We are given `hours`, a list of the number of hours worked per day for a given employee.\n\nA day is considered to be a _tiring day_ if and only if the number of hours worked is (strictly) greater than `8`.\n\nA _well-performing interval_ is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\n\nReturn the length of the longest well-performing interval.\n\n**Example 1:**\n\n**Input:** hours = \\[9,9,6,0,6,6,9\\]\n**Output:** 3\n**Explanation:** The longest well-performing interval is \\[9,9,6\\].\n\n**Example 2:**\n\n**Input:** hours = \\[6,6,6\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= hours.length <= 104`\n*   `0 <= hours[i] <= 16`\"\"\"\n\n    sum = 0\n    longest = 0\n    first_sum_index = {}\n\n    for i, hour in enumerate(hours):\n        sum += 1 if hour > 8 else -1\n        if sum > 0:\n            longest = i + 1\n        else:\n            if sum - 1 in first_sum_index:\n                longest = max(longest, i - first_sum_index[sum - 1])\n            if sum not in first_sum_index:\n                first_sum_index[sum] = i\n\n    return longest"}}, "leetcode/leetcode_1438.txt": {"score": 0.9337641000747681, "content": {"text": "from collections import deque\n    \"\"\"Given an array of integers `nums` and an integer `limit`, return the size of the longest **non-empty** subarray such that the absolute difference between any two elements of this subarray is less than or equal to `limit`_._\n\n**Example 1:**\n\n**Input:** nums = \\[8,2,4,7\\], limit = 4\n**Output:** 2 \n**Explanation:** All subarrays are: \n\\[8\\] with maximum absolute diff |8-8| = 0 <= 4.\n\\[8,2\\] with maximum absolute diff |8-2| = 6 > 4. \n\\[8,2,4\\] with maximum absolute diff |8-2| = 6 > 4.\n\\[8,2,4,7\\] with maximum absolute diff |8-2| = 6 > 4.\n\\[2\\] with maximum absolute diff |2-2| = 0 <= 4.\n\\[2,4\\] with maximum absolute diff |2-4| = 2 <= 4.\n\\[2,4,7\\] with maximum absolute diff |2-7| = 5 > 4.\n\\[4\\] with maximum absolute diff |4-4| = 0 <= 4.\n\\[4,7\\] with maximum absolute diff |4-7| = 3 <= 4.\n\\[7\\] with maximum absolute diff |7-7| = 0 <= 4. \nTherefore, the size of the longest subarray is 2.\n\n**Example 2:**\n\n**Input:** nums = \\[10,1,2,4,7,2\\], limit = 5\n**Output:** 4 \n**Explanation:** The subarray \\[2,4,7,2\\] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\n\n**Example 3:**\n\n**Input:** nums = \\[4,2,2,2,4,4,2,2\\], limit = 0\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `0 <= limit <= 109`\"\"\"\n\ndef longestSubarray(nums, limit):\n    max_deque = deque()\n    min_deque = deque()\n    left, right, longest = 0, 0, 0\n    \n    while right < len(nums):\n        while max_deque and nums[right] > max_deque[-1]: max_deque.pop()\n        while min_deque and nums[right] < min_deque[-1]: min_deque.pop()\n        \n        max_deque.append(nums[right])\n        min_deque.append(nums[right])\n        \n        while max_deque[0] - min_deque[0] > limit:\n            if max_deque[0] == nums[left]: max_deque.popleft()\n            if min_deque[0] == nums[left]: min_deque.popleft()\n            left += 1\n        \n        longest = max(longest, right - left + 1)\n        right += 1\n    \n    return longest"}}, "leetcode/leetcode_1248.txt": {"score": 0.9295206069946289, "content": {"text": "class TreeNode:\n    \"\"\"Given an array of integers `nums` and an integer `k`. A continuous subarray is called **nice** if there are `k` odd numbers on it.\n\nReturn _the number of **nice** sub-arrays_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,2,1,1\\], k = 3\n**Output:** 2\n**Explanation:** The only sub-arrays with 3 odd numbers are \\[1,1,2,1\\] and \\[1,2,1,1\\].\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,6\\], k = 1\n**Output:** 0\n**Explanation:** There is no odd numbers in the array.\n\n**Example 3:**\n\n**Input:** nums = \\[2,2,2,1,2,2,1,2,2,2\\], k = 2\n**Output:** 16\n\n**Constraints:**\n\n*   `1 <= nums.length <= 50000`\n*   `1 <= nums[i] <= 10^5`\n*   `1 <= k <= nums.length`\"\"\"\n\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef can_win(root, x):\n    if not root:\n        return False\n    if root.val == x:\n        left_nodes = 1 + can_win(root.left, x) if root.left else 0\n        right_nodes = 1 + can_win(root.right, x) if root.right else 0\n        return left_nodes % 2 != 0 or right_nodes % 2 != 0\n    return can_win(root.left, x) or can_win(root.right, x)"}}, "leetcode/leetcode_849.txt": {"score": 0.9446859359741211, "content": {"text": "def maxDistToClosest(seats):\n    \"\"\"You are given an array representing a row of `seats` where `seats[i] = 1` represents a person sitting in the `ith` seat, and `seats[i] = 0` represents that the `ith` seat is empty **(0-indexed)**.\n\nThere is at least one empty seat, and at least one person sitting.\n\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized.\n\nReturn _that maximum distance to the closest person_.\n\n**Example 1:**\n\n**Input:** seats = \\[1,0,0,0,1,0,1\\]\n**Output:** 2\n**Explanation:** \nIf Alex sits in the second open seat (i.e. seats\\[2\\]), then the closest person has distance 2.\nIf Alex sits in any other open seat, the closest person has distance 1.\nThus, the maximum distance to the closest person is 2.\n\n**Example 2:**\n\n**Input:** seats = \\[1,0,0,0\\]\n**Output:** 3\n**Explanation:** \nIf Alex sits in the last seat (i.e. seats\\[3\\]), the closest person is 3 seats away.\nThis is the maximum distance possible, so the answer is 3.\n\n**Example 3:**\n\n**Input:** seats = \\[0,1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `2 <= seats.length <= 2 * 104`\n*   `seats[i]` is `0` or `1`.\n*   At least one seat is **empty**.\n*   At least one seat is **occupied**.\"\"\"\n\n    n = len(seats)\n    maxDist = 0\n    lastPerson = -1\n\n    for i in range(n):\n        if seats[i] == 1:\n            if lastPerson == -1:\n                maxDist = i\n            else:\n                maxDist = max(maxDist, (i - lastPerson) // 2)\n            lastPerson = i\n\n    maxDist = max(maxDist, n - 1 - lastPerson)\n    return maxDist"}}, "leetcode/leetcode_875.txt": {"score": 0.9450686573982239, "content": {"text": "def longest_mountain(arr):\n    \"\"\"Koko loves to eat bananas. There are `n` piles of bananas, the `ith` pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses some pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn _the minimum integer_ `k` _such that she can eat all the bananas within_ `h` _hours_.\n\n**Example 1:**\n\n**Input:** piles = \\[3,6,7,11\\], h = 8\n**Output:** 4\n\n**Example 2:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 5\n**Output:** 30\n\n**Example 3:**\n\n**Input:** piles = \\[30,11,23,4,20\\], h = 6\n**Output:** 23\n\n**Constraints:**\n\n*   `1 <= piles.length <= 104`\n*   `piles.length <= h <= 109`\n*   `1 <= piles[i] <= 109`\"\"\"\n\n    n = len(arr)\n    max_length = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            left = i - 1\n            right = i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] > arr[right + 1]:\n                right += 1\n            max_length = max(max_length, right - left + 1)\n            i = right\n        else:\n            i += 1\n    return max_length"}}, "leetcode/leetcode_2274.txt": {"score": 0.9883633255958557, "content": {"text": "def final_value(nums, original):\n    \"\"\"Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.\n\nYou are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.\n\nReturn _the **maximum** number of consecutive floors without a special floor_.\n\n**Example 1:**\n\n**Input:** bottom = 2, top = 9, special = \\[4,6\\]\n**Output:** 3\n**Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors.\n\n**Example 2:**\n\n**Input:** bottom = 6, top = 8, special = \\[7,6,8\\]\n**Output:** 0\n**Explanation:** Every floor rented is a special floor, so we return 0.\n\n**Constraints:**\n\n*   `1 <= special.length <= 105`\n*   `1 <= bottom <= special[i] <= top <= 109`\n*   All the values of `special` are **unique**.\"\"\"\n\n    while original in nums:\n        original += 1\n    return original"}}}}, "122": {"gold": {"leetcode/leetcode_149.txt": 1}, "retrieved": {"leetcode/leetcode_1395.txt": {"score": 0.8718889355659485, "content": {"text": "def minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    \"\"\"There are `n` soldiers standing in a line. Each soldier is assigned a **unique** `rating` value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\n*   Choose 3 soldiers with index (`i`, `j`, `k`) with rating (`rating[i]`, `rating[j]`, `rating[k]`).\n*   A team is valid if: (`rating[i] < rating[j] < rating[k]`) or (`rating[i] > rating[j] > rating[k]`) where (`0 <= i < j < k < n`).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\n**Example 1:**\n\n**Input:** rating = \\[2,5,3,4,1\\]\n**Output:** 3\n**Explanation:** We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\n**Example 2:**\n\n**Input:** rating = \\[2,1,3\\]\n**Output:** 0\n**Explanation:** We can't form any team given the conditions.\n\n**Example 3:**\n\n**Input:** rating = \\[1,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `n == rating.length`\n*   `3 <= n <= 1000`\n*   `1 <= rating[i] <= 105`\n*   All the integers in `rating` are **unique**.\n\nIn one second, you can either: - Move vertically by one unit, - Move horizontally by one unit, or - Move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in one second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points, but they do not count as visited unless you stop on them.\"\"\"\n\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        time += max(dx, dy)\n    return time"}}, "leetcode/leetcode_452.txt": {"score": 0.8738144636154175, "content": {"text": "def findMinArrowShots(points):\n    \"\"\"There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` if `xstart <= x <= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array `points`, return _the **minimum** number of arrows that must be shot to burst all balloons_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[10,16\\],\\[2,8\\],\\[1,6\\],\\[7,12\\]\\]\n**Output:** 2\n**Explanation:** The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons \\[2,8\\] and \\[1,6\\].\n- Shoot an arrow at x = 11, bursting the balloons \\[10,16\\] and \\[7,12\\].\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,2\\],\\[3,4\\],\\[5,6\\],\\[7,8\\]\\]\n**Output:** 4\n**Explanation:** One arrow needs to be shot for each balloon for a total of 4 arrows.\n\n**Example 3:**\n\n**Input:** points = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons \\[1,2\\] and \\[2,3\\].\n- Shoot an arrow at x = 4, bursting the balloons \\[3,4\\] and \\[4,5\\].\n\n**Constraints:**\n\n*   `1 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `-231 <= xstart < xend <= 231 - 1`\"\"\"\n\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows"}}, "leetcode/leetcode_228.txt": {"score": 0.8742948770523071, "content": {"text": "from typing import List\n    \"\"\"You are given a **sorted unique** integer array `nums`.\n\nA **range** `[a,b]` is the set of all integers from `a` to `b` (inclusive).\n\nReturn _the **smallest sorted** list of ranges that **cover all the numbers in the array exactly**_. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.\n\nEach range `[a,b]` in the list should be output as:\n\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,2,4,5,7\\]\n**Output:** \\[ \"0->2 \", \"4->5 \", \"7 \"\\]\n**Explanation:** The ranges are:\n\\[0,2\\] -->  \"0->2 \"\n\\[4,5\\] -->  \"4->5 \"\n\\[7,7\\] -->  \"7 \"\n\n**Example 2:**\n\n**Input:** nums = \\[0,2,3,4,6,8,9\\]\n**Output:** \\[ \"0 \", \"2->4 \", \"6 \", \"8->9 \"\\]\n**Explanation:** The ranges are:\n\\[0,0\\] -->  \"0 \"\n\\[2,4\\] -->  \"2->4 \"\n\\[6,6\\] -->  \"6 \"\n\\[8,9\\] -->  \"8->9 \"\n\n**Constraints:**\n\n*   `0 <= nums.length <= 20`\n*   `-231 <= nums[i] <= 231 - 1`\n*   All the values of `nums` are **unique**.\n*   `nums` is sorted in ascending order.\"\"\"\n\n\ndef find_ranges(nums: List[int]) -> List[str]:\n    result = []\n    n = len(nums)\n    if n == 0: \n        return result\n\n    start = nums[0]\n    for i in range(1, n):\n        if nums[i] > nums[i-1] + 1:\n            if start == nums[i-1]:\n                result.append(str(start))\n            else:\n                result.append(str(start) + \"->\" + str(nums[i-1]))\n            start = nums[i]\n\n    if start == nums[n-1]:\n        result.append(str(start))\n    else:\n        result.append(str(start) + \"->\" + str(nums[n-1]))\n\n    return result"}}, "leetcode/leetcode_2498.txt": {"score": 0.8829876184463501, "content": {"text": "def minimum_path_cost(stones):\n    \"\"\"You are given a **0-indexed** integer array `stones` sorted in **strictly increasing order** representing the positions of stones in a river.\n\nA frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone **at most once**.\n\nThe **length** of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.\n\n*   More formally, if the frog is at `stones[i]` and is jumping to `stones[j]`, the length of the jump is `|stones[i] - stones[j]|`.\n\nThe **cost** of a path is the **maximum length of a jump** among all jumps in the path.\n\nReturn _the **minimum** cost of a path for the frog_.\n\n**Example 1:**\n\n**Input:** stones = \\[0,2,5,6,7\\]\n**Output:** 5\n**Explanation:** The above figure represents one of the optimal paths the frog can take.\nThe cost of this path is 5, which is the maximum length of a jump.\nSince it is not possible to achieve a cost of less than 5, we return it.\n\n**Example 2:**\n\n**Input:** stones = \\[0,3,9\\]\n**Output:** 9\n**Explanation:** \nThe frog can jump directly to the last stone and come back to the first stone. \nIn this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.\nIt can be shown that this is the minimum achievable cost.\n\n**Constraints:**\n\n*   `2 <= stones.length <= 105`\n*   `0 <= stones[i] <= 109`\n*   `stones[0] == 0`\n*   `stones` is sorted in a strictly increasing order.\"\"\"\n\n    n = len(stones)\n    max_cost = stones[n-1]\n    for i in range(1, n-1):\n        max_cost = min(max_cost, max(stones[i], stones[n-1]-stones[i]))\n    return max_cost"}}, "leetcode/leetcode_1232.txt": {"score": 0.8957118988037109, "content": {"text": "def findBestValue(arr, target):\n    \"\"\"You are given an array `coordinates`, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the XY plane.\n\n**Example 1:**\n\n**Input:** coordinates = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[6,7\\]\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** coordinates = \\[\\[1,1\\],\\[2,2\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[7,7\\]\\]\n**Output:** false\n\n**Constraints:**\n\n*   `2 <= coordinates.length <= 1000`\n*   `coordinates[i].length == 2`\n*   `-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4`\n*   `coordinates` contains no duplicate point.\"\"\"\n\n    left = 0\n    right = max(arr)\n    result = -1\n    min_diff = float('inf')\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        total_sum = sum(min(x, mid) for x in arr)\n        if total_sum == target:\n            return mid\n        elif total_sum > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n        if abs(target - total_sum) < min_diff or (\n                abs(target - total_sum) == min_diff and mid < result):\n            min_diff = abs(target - total_sum)\n            result = mid\n\n    return result"}}, "leetcode/leetcode_1024.txt": {"score": 0.8759382367134094, "content": {"text": "def count_and_triples(nums):\n    \"\"\"You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n*   For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** clips = \\[\\[0,2\\],\\[4,6\\],\\[8,10\\],\\[1,9\\],\\[1,5\\],\\[5,9\\]\\], time = 10\n**Output:** 3\n**Explanation:** We take the clips \\[0,2\\], \\[8,10\\], \\[1,9\\]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut \\[1,9\\] into segments \\[1,2\\] + \\[2,8\\] + \\[8,9\\].\nNow we have segments \\[0,2\\] + \\[2,8\\] + \\[8,10\\] which cover the sporting event \\[0, 10\\].\n\n**Example 2:**\n\n**Input:** clips = \\[\\[0,1\\],\\[1,2\\]\\], time = 5\n**Output:** -1\n**Explanation:** We cannot cover \\[0,5\\] with only \\[0,1\\] and \\[1,2\\].\n\n**Example 3:**\n\n**Input:** clips = \\[\\[0,1\\],\\[6,8\\],\\[0,2\\],\\[5,6\\],\\[0,4\\],\\[0,3\\],\\[6,7\\],\\[1,3\\],\\[4,7\\],\\[1,4\\],\\[2,5\\],\\[2,6\\],\\[3,4\\],\\[4,5\\],\\[5,7\\],\\[6,9\\]\\], time = 9\n**Output:** 3\n**Explanation:** We can take clips \\[0,4\\], \\[4,7\\], and \\[6,9\\].\n\n**Constraints:**\n\n*   `1 <= clips.length <= 100`\n*   `0 <= starti <= endi <= 100`\n*   `1 <= time <= 100`\n\n0 <= i < j < k < nums.length, and nums\\[i\\] & nums\\[j\\] & nums\\[k\\] != 0. (\\`&\\` represents the bitwise AND operation.)\"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count"}}, "leetcode/csn_python_train_126432.txt": {"score": 0.878196120262146, "content": {"text": "def find_shape(bottom_lines, max_len):\n    \"\"\"\n    Finds a shape of lowest horizontal lines with step=1\n    :param bottom_lines:\n    :param max_len:\n    :return: list of levels (row values), list indexes are columns\n    \"\"\"\n    shape = [1] * max_len\n    for i in range(max_len):\n        for line in bottom_lines:\n            if line[0] <= i + 1 < line[2]:\n                shape[i] = line[1]\n                break\n    return shape"}}, "leetcode/leetcode_2294.txt": {"score": 0.8866080641746521, "content": {"text": "def minimum_time_for_trips(time, total_trips):\n    \"\"\"You are given an integer array `nums` and an integer `k`. You may partition `nums` into one or more **subsequences** such that each element in `nums` appears in **exactly** one of the subsequences.\n\nReturn _the **minimum** number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is **at most**_ `k`_._\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,1,2,5\\], k = 2\n**Output:** 2\n**Explanation:**\nWe can partition nums into the two subsequences \\[3,1,2\\] and \\[6,5\\].\nThe difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\nThe difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\nSince two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3\\], k = 1\n**Output:** 2\n**Explanation:**\nWe can partition nums into the two subsequences \\[1,2\\] and \\[3\\].\nThe difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\nThe difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\nSince two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences \\[1\\] and \\[2,3\\].\n\n**Example 3:**\n\n**Input:** nums = \\[2,2,4,5\\], k = 0\n**Output:** 3\n**Explanation:**\nWe can partition nums into the three subsequences \\[2,2\\], \\[4\\], and \\[5\\].\nThe difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\nThe difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\nThe difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\nSince three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 105`\n*   `0 <= k <= 105`\"\"\"\n\n    time.sort()\n\n    start, end = 0, time[-1] * total_trips\n    while start < end:\n        mid = start + (end - start) // 2\n        trips = sum(mid // t for t in time)\n        if trips < total_trips:\n            start = mid + 1\n        else:\n            end = mid\n\n    return start"}}, "leetcode/leetcode_1266.txt": {"score": 0.887758731842041, "content": {"text": "def minTimeToVisitAllPoints(points):\n    \"\"\"On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi, yi]`. Return _the **minimum time** in seconds to visit all the points in the order given by_ `points`.\n\nYou can move according to these rules:\n\n*   In `1` second, you can either:\n    *   move vertically by one unit,\n    *   move horizontally by one unit, or\n    *   move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second).\n*   You have to visit the points in the same order as they appear in the array.\n*   You are allowed to pass through points that appear later in the order, but these do not count as visits.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,4\\],\\[-1,0\\]\\]\n**Output:** 7\n**Explanation:** One optimal path is **\\[1,1\\]** -> \\[2,2\\] -> \\[3,3\\] -> **\\[3,4\\]** \\-> \\[2,3\\] -> \\[1,2\\] -> \\[0,1\\] -> **\\[-1,0\\]**   \nTime from \\[1,1\\] to \\[3,4\\] = 3 seconds \nTime from \\[3,4\\] to \\[-1,0\\] = 4 seconds\nTotal time = 7 seconds\n\n**Example 2:**\n\n**Input:** points = \\[\\[3,2\\],\\[-2,2\\]\\]\n**Output:** 5\n\n**Constraints:**\n\n*   `points.length == n`\n*   `1 <= n <= 100`\n*   `points[i].length == 2`\n*   `-1000 <= points[i][0], points[i][1] <= 1000`\"\"\"\n\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i - 1][0])\n        dy = abs(points[i][1] - points[i - 1][1])\n        time += max(dx, dy)\n    return time"}}, "leetcode/leetcode_2280.txt": {"score": 0.992218017578125, "content": {"text": "def count_good_triplets(nums1: list, nums2: list) -> int:\n    \"\"\"You are given a 2D integer array `stockPrices` where `stockPrices[i] = [dayi, pricei]` indicates the price of the stock on day `dayi` is `pricei`. A **line chart** is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:\n\nReturn _the **minimum number of lines** needed to represent the line chart_.\n\n**Example 1:**\n\n**Input:** stockPrices = \\[\\[1,7\\],\\[2,6\\],\\[3,5\\],\\[4,4\\],\\[5,4\\],\\[6,3\\],\\[7,2\\],\\[8,1\\]\\]\n**Output:** 3\n**Explanation:**\nThe diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.\nThe following 3 lines can be drawn to represent the line chart:\n- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).\n- Line 2 (in blue) from (4,4) to (5,4).\n- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).\nIt can be shown that it is not possible to represent the line chart using less than 3 lines.\n\n**Example 2:**\n\n**Input:** stockPrices = \\[\\[3,4\\],\\[1,2\\],\\[7,8\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:**\nAs shown in the diagram above, the line chart can be represented with a single line.\n\n**Constraints:**\n\n*   `1 <= stockPrices.length <= 105`\n*   `stockPrices[i].length == 2`\n*   `1 <= dayi, pricei <= 109`\n*   All `dayi` are **distinct**.\"\"\"\n\n    n = len(nums1)\n    pos1 = [0] * n\n    pos2 = [0] * n\n    for i in range(n):\n        pos1[nums1[i]] = i\n        pos2[nums2[i]] = i\n    count = 0\n    for x in range(n):\n        for y in range(x + 1, n):\n            for z in range(y + 1, n):\n                if pos1[x] < pos1[y] < pos1[z] and pos2[x] < pos2[y] < pos2[z]:\n                    count += 1\n    return count"}}}}, "123": {"gold": {"leetcode/leetcode_1293.txt": 1}, "retrieved": {"leetcode/leetcode_542.txt": {"score": 0.9107895493507385, "content": {"text": "from collections import deque\n    \"\"\"Given an `m x n` binary matrix `mat`, return _the distance of the nearest_ `0` _for each cell_.\n\nThe distance between two adjacent cells is `1`.\n\n**Example 1:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n\n**Example 2:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,2,1\\]\\]\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 104`\n*   `1 <= m * n <= 104`\n*   `mat[i][j]` is either `0` or `1`.\n*   There is at least one `0` in `mat`.\"\"\"\n\n\ndef updateMatrix(mat):\n    m, n = len(mat), len(mat[0])\n    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]\n    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            newX, newY = x + dx, y + dy\n            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:\n                distance[newX][newY] = distance[x][y] + 1\n                queue.append((newX, newY))\n\n    return distance"}}, "leetcode/leetcode_1368.txt": {"score": 0.9110512137413025, "content": {"text": "from collections import deque\n    \"\"\"Given an `m x n` grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:\n\n*   `1` which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)\n*   `2` which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)\n*   `3` which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)\n*   `4` which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\n\nYou will initially start at the upper left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path does not have to be the shortest.\n\nYou can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell **one time only**.\n\nReturn _the minimum cost to make the grid have at least one valid path_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1,1\\],\\[2,2,2,2\\],\\[1,1,1,1\\],\\[2,2,2,2\\]\\]\n**Output:** 3\n**Explanation:** You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,3\\],\\[3,2,2\\],\\[1,1,4\\]\\]\n**Output:** 0\n**Explanation:** You can follow the path from (0, 0) to (2, 2).\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,2\\],\\[4,3\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `1 <= grid[i][j] <= 4`\"\"\"\n\n\ndef minCost(grid):\n    m, n = len(grid), len(grid[0])\n    cost = 0\n\n    visited = [[1000000] * n for _ in range(m)]\n    q = deque([(0, 0)])\n    visited[0][0] = 0\n\n    while q:\n        y, x = q.popleft()\n        if y == m - 1 and x == n - 1:\n            cost = visited[y][x]\n            break\n\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n\n        for dir in range(4):\n            newY, newX = y + dy[dir], x + dx[dir]\n            if 0 <= newY < m and 0 <= newX < n:\n                newCost = visited[y][x] + (1 if dir + 1 != grid[y][x] else 0)\n                if newCost < visited[newY][newX]:\n                    visited[newY][newX] = newCost\n                    q.append((newY, newX))\n\n    return cost"}}, "leetcode/leetcode_2087.txt": {"score": 0.9137504696846008, "content": {"text": "def minTotalCost(startPos, homePos, rowCosts, colCosts):\n    \"\"\"There is an `m x n` grid, where `(0, 0)` is the top-left cell and `(m - 1, n - 1)` is the bottom-right cell. You are given an integer array `startPos` where `startPos = [startrow, startcol]` indicates that **initially**, a **robot** is at the cell `(startrow, startcol)`. You are also given an integer array `homePos` where `homePos = [homerow, homecol]` indicates that its **home** is at the cell `(homerow, homecol)`.\n\nThe robot needs to go to its home. It can move one cell in four directions: **left**, **right**, **up**, or **down**, and it can not move outside the boundary. Every move incurs some cost. You are further given two **0-indexed** integer arrays: `rowCosts` of length `m` and `colCosts` of length `n`.\n\n*   If the robot moves **up** or **down** into a cell whose **row** is `r`, then this move costs `rowCosts[r]`.\n*   If the robot moves **left** or **right** into a cell whose **column** is `c`, then this move costs `colCosts[c]`.\n\nReturn _the **minimum total cost** for this robot to return home_.\n\n**Example 1:**\n\n**Input:** startPos = \\[1, 0\\], homePos = \\[2, 3\\], rowCosts = \\[5, 4, 3\\], colCosts = \\[8, 2, 6, 7\\]\n**Output:** 18\n**Explanation:** One optimal path is that:\nStarting from (1, 0)\n-> It goes down to (**2**, 0). This move costs rowCosts\\[2\\] = 3.\n-> It goes right to (2, **1**). This move costs colCosts\\[1\\] = 2.\n-> It goes right to (2, **2**). This move costs colCosts\\[2\\] = 6.\n-> It goes right to (2, **3**). This move costs colCosts\\[3\\] = 7.\nThe total cost is 3 + 2 + 6 + 7 = 18\n\n**Example 2:**\n\n**Input:** startPos = \\[0, 0\\], homePos = \\[0, 0\\], rowCosts = \\[5\\], colCosts = \\[26\\]\n**Output:** 0\n**Explanation:** The robot is already at its home. Since no moves occur, the total cost is 0.\n\n**Constraints:**\n\n*   `m == rowCosts.length`\n*   `n == colCosts.length`\n*   `1 <= m, n <= 105`\n*   `0 <= rowCosts[r], colCosts[c] <= 104`\n*   `startPos.length == 2`\n*   `homePos.length == 2`\n*   `0 <= startrow, homerow < m`\n*   `0 <= startcol, homecol < n`\"\"\"\n\n    row_difference = abs(startPos[0] - homePos[0])\n    col_difference = abs(startPos[1] - homePos[1])\n\n    row_cost = sum(rowCosts[min(startPos[0], homePos[0]):min(startPos[0], homePos[0]) + row_difference])\n    col_cost = sum(colCosts[min(startPos[1], homePos[1]):min(startPos[1], homePos[1]) + col_difference])\n\n    return row_cost + col_cost"}}, "leetcode/leetcode_1926.txt": {"score": 0.9334466457366943, "content": {"text": "from collections import deque\n    \"\"\"You are given an `m x n` matrix `maze` (**0-indexed**) with empty cells (represented as `'.'`) and walls (represented as `'+'`). You are also given the `entrance` of the maze, where `entrance = [entrancerow, entrancecol]` denotes the row and column of the cell you are initially standing at.\n\nIn one step, you can move one cell **up**, **down**, **left**, or **right**. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the **nearest exit** from the `entrance`. An **exit** is defined as an **empty cell** that is at the **border** of the `maze`. The `entrance` **does not count** as an exit.\n\nReturn _the **number of steps** in the shortest path from the_ `entrance` _to the nearest exit, or_ `-1` _if no such path exists_.\n\n**Example 1:**\n\n**Input:** maze = \\[\\[ \"+ \", \"+ \", \". \", \"+ \"\\],\\[ \". \", \". \", \". \", \"+ \"\\],\\[ \"+ \", \"+ \", \"+ \", \". \"\\]\\], entrance = \\[1,2\\]\n**Output:** 1\n**Explanation:** There are 3 exits in this maze at \\[1,0\\], \\[0,2\\], and \\[2,3\\].\nInitially, you are at the entrance cell \\[1,2\\].\n- You can reach \\[1,0\\] by moving 2 steps left.\n- You can reach \\[0,2\\] by moving 1 step up.\nIt is impossible to reach \\[2,3\\] from the entrance.\nThus, the nearest exit is \\[0,2\\], which is 1 step away.\n\n**Example 2:**\n\n**Input:** maze = \\[\\[ \"+ \", \"+ \", \"+ \"\\],\\[ \". \", \". \", \". \"\\],\\[ \"+ \", \"+ \", \"+ \"\\]\\], entrance = \\[1,0\\]\n**Output:** 2\n**Explanation:** There is 1 exit in this maze at \\[1,2\\].\n\\[1,0\\] does not count as an exit since it is the entrance cell.\nInitially, you are at the entrance cell \\[1,0\\].\n- You can reach \\[1,2\\] by moving 2 steps right.\nThus, the nearest exit is \\[1,2\\], which is 2 steps away.\n\n**Example 3:**\n\n**Input:** maze = \\[\\[ \". \", \"+ \"\\]\\], entrance = \\[0,0\\]\n**Output:** -1\n**Explanation:** There are no exits in this maze.\n\n**Constraints:**\n\n*   `maze.length == m`\n*   `maze[i].length == n`\n*   `1 <= m, n <= 100`\n*   `maze[i][j]` is either `'.'` or `'+'`.\n*   `entrance.length == 2`\n*   `0 <= entrancerow < m`\n*   `0 <= entrancecol < n`\n*   `entrance` will always be an empty cell.\"\"\"\n\n\ndef nearest_exit(maze, entrance):\n    m, n = len(maze), len(maze[0])\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    q = deque([tuple(entrance)])\n    \n    steps = -1\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            if maze[r][c] == '+': continue\n            if r == 0 or r == m-1 or c == 0 or c == n-1:\n                if r != entrance[0] or c != entrance[1]: return steps\n            maze[r][c] = '+'\n            for dr, dc in moves:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n:\n                    q.append((nr, nc))\n    return -1"}}, "leetcode/leetcode_675.txt": {"score": 0.9374130964279175, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:\n\n*   `0` means the cell cannot be walked through.\n*   `1` represents an empty cell that can be walked through.\n*   A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).\n\nStarting from the point `(0, 0)`, return _the minimum steps you need to walk to cut off all the trees_. If you cannot cut off all the trees, return `-1`.\n\n**Note:** The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n**Example 1:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,4\\],\\[7,6,5\\]\\]\n**Output:** 6\n**Explanation:** Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n**Example 2:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,0\\],\\[7,6,5\\]\\]\n**Output:** -1\n**Explanation:** The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n**Example 3:**\n\n**Input:** forest = \\[\\[2,3,4\\],\\[0,0,5\\],\\[8,7,6\\]\\]\n**Output:** 6\n**Explanation:** You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n\n**Constraints:**\n\n*   `m == forest.length`\n*   `n == forest[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= forest[i][j] <= 109`\n*   Heights of all trees are **distinct**.\"\"\"\n\nfrom collections import deque\n\ndef cutOffTree(forest: List[List[int]]) -> int:\n    if not forest or not forest[0]: return 0\n    m, n = len(forest), len(forest[0])\n    trees = []\n    \n    for i in range(m):\n        for j in range(n):\n            if forest[i][j] > 1:\n                heappush(trees, (forest[i][j], i, j))\n    \n    startX, startY = 0, 0\n    totalSteps = 0\n    while trees:\n        tree, endX, endY = heappop(trees)\n        steps = bfs(forest, startX, startY, endX, endY)\n        if steps == -1:\n            return -1\n        totalSteps += steps\n        startX, startY = endX, endY\n    \n    return totalSteps\n\ndef bfs(forest, startX, startY, endX, endY):\n    if startX == endX and startY == endY:\n        return 0\n        \n    m, n = len(forest), len(forest[0])\n    visited = [[False] * n for _ in range(m)]\n    q = deque([(startX, startY, 0)])\n    visited[startX][startY] = True\n    dirs = [-1, 0, 1, 0, -1]\n    \n    while q:\n        x, y, steps = q.popleft()\n        for k in range(4):\n            newX, newY = x + dirs[k], y + dirs[k+1]\n            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:\n                if newX == endX and newY == endY:\n                    return steps + 1\n                q.append((newX, newY, steps + 1))\n                visited[newX][newY] = True\n    \n    return -1"}}, "leetcode/leetcode_2577.txt": {"score": 0.9387987852096558, "content": {"text": "from collections import deque\n    \"\"\"You are given a `m x n` matrix `grid` consisting of **non-negative** integers where `grid[row][col]` represents the **minimum** time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.\n\nYou are standing in the **top-left** cell of the matrix in the `0th` second, and you must move to **any** adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\n\nReturn _the **minimum** time required in which you can visit the bottom-right cell of the matrix_. If you cannot visit the bottom-right cell, then return `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,3,2\\],\\[5,1,2,5\\],\\[4,3,8,6\\]\\]\n**Output:** 7\n**Explanation:** One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid\\[0\\]\\[1\\] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid\\[1\\]\\[1\\] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid\\[1\\]\\[2\\] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid\\[1\\]\\[3\\] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid\\[2\\]\\[3\\] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,2,4\\],\\[3,2,1\\],\\[1,0,4\\]\\]\n**Output:** -1\n**Explanation:** There is no path from the top left to the bottom-right cell.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 1000`\n*   `4 <= m * n <= 105`\n*   `0 <= grid[i][j] <= 105`\n*   `grid[0][0] == 0`\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n\ndef minTime(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    visited = [[1000000] * n for _ in range(m)]\n\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    visited[0][0] = 0\n\n    q = deque([(0, 0)])\n\n    while q:\n        x, y = q.popleft()\n\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n\n            if 0 <= nx < m and 0 <= ny < n:\n                t = max(grid[nx][ny], visited[x][y] + 1)\n                if visited[nx][ny] > t:\n                    visited[nx][ny] = t\n                    q.append((nx, ny))\n\n    return visited[m - 1][n - 1] if visited[m - 1][n - 1] != 1000000 else -1"}}, "leetcode/leetcode_1824.txt": {"score": 0.9187230467796326, "content": {"text": "import heapq\n    \"\"\"There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** lane and wants to jump to point `n`. However, there could be obstacles along the way.\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n*   For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n*   For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn _the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n**Example 1:**\n\n**Input:** obstacles = \\[0,1,2,3,0\\]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n**Example 2:**\n\n**Input:** obstacles = \\[0,1,1,3,3,0\\]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n**Example 3:**\n\n**Input:** obstacles = \\[0,2,1,0,3,0\\]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n**Constraints:**\n\n*   `obstacles.length == n + 1`\n*   `1 <= n <= 5 * 105`\n*   `0 <= obstacles[i] <= 3`\n*   `obstacles[0] == obstacles[n] == 0`\"\"\"\n\n\ndef eatenApples(apples, days):\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans"}}, "leetcode/leetcode_1293.txt": {"score": 0.9775481820106506, "content": {"text": "from collections import deque\n    \"\"\"You are given an `m x n` integer matrix `grid` where each cell is either `0` (empty) or `1` (obstacle). You can move up, down, left, or right from and to an empty cell in **one step**.\n\nReturn _the minimum number of **steps** to walk from the upper left corner_ `(0, 0)` _to the lower right corner_ `(m - 1, n - 1)` _given that you can eliminate **at most**_ `k` _obstacles_. If it is not possible to find such walk return `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[1,1,0\\],\\[0,0,0\\],\\[0,1,1\\],\\[0,0,0\\]\\], k = 1\n**Output:** 6\n**Explanation:** \nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> **(3,2)** -> (4,2).\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,1\\],\\[1,1,1\\],\\[1,0,0\\]\\], k = 1\n**Output:** -1\n**Explanation:** We need to eliminate at least two obstacles to find such a walk.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 40`\n*   `1 <= k <= m * n`\n*   `grid[i][j]` is either `0` **or** `1`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`\"\"\"\n\n\ndef shortestPath(grid, k):\n    m, n = len(grid), len(grid[0])\n    visited = [[[False for _ in range(k + 1)] for _ in range(n)] for _ in range(m)]\n    q = deque([(0, 0, 0, k)])\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    steps = 0\n\n    while q:\n        for _ in range(len(q)):\n            x, y, steps, k_remaining = q.popleft()\n            if x == m - 1 and y == n - 1:\n                return steps\n            for dx, dy in moves:\n                new_x, new_y, = x + dx, y + dy\n                if 0 <= new_x < m and 0 <= new_y < n:\n                    new_k_remaining = k_remaining - grid[new_x][new_y]\n                    if new_k_remaining >= 0 and not visited[new_x][new_y][new_k_remaining]:\n                        visited[new_x][new_y][new_k_remaining] = True\n                        q.append((new_x, new_y, steps + 1, new_k_remaining))\n        steps += 1\n\n    return -1"}}, "leetcode/leetcode_1091.txt": {"score": 0.9419034719467163, "content": {"text": "from collections import deque\n    \"\"\"Given an `n x n` binary matrix `grid`, return _the length of the shortest **clear path** in the matrix_. If there is no clear path, return `-1`.\n\nA **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell (i.e., `(n - 1, n - 1)`) such that:\n\n*   All the visited cells of the path are `0`.\n*   All the adjacent cells of the path are **8-directionally** connected (i.e., they are different and they share an edge or a corner).\n\nThe **length of a clear path** is the number of visited cells of this path.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0,0\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** -1\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 100`\n*   `grid[i][j] is 0 or 1`\"\"\"\n\n\ndef shortestPathBinaryMatrix(grid):\n    n = len(grid)\n    if grid[0][0] or grid[n - 1][n - 1]: return -1\n\n    dir = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    q = deque([(0, 0)])\n    grid[0][0] = 1\n\n    pathLength = 1\n\n    while q:\n        qlen = len(q)\n        for _ in range(qlen):\n            x, y = q.popleft()\n\n            if x == n - 1 and y == n - 1: return pathLength\n\n            for d in dir:\n                newX, newY = x + d[0], y + d[1]\n\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    q.append((newX, newY))\n                    grid[newX][newY] = 1\n        pathLength += 1\n\n    return -1"}}, "leetcode/leetcode_2290.txt": {"score": 0.997564435005188, "content": {"text": "def min_number_of_beans_to_remove(beans):\n    \"\"\"You are given a **0-indexed** 2D integer array `grid` of size `m x n`. Each cell has one of two values:\n\n*   `0` represents an **empty** cell,\n*   `1` represents an **obstacle** that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\n\nReturn _the **minimum** number of **obstacles** to **remove** so you can move from the upper left corner_ `(0, 0)` _to the lower right corner_ `(m - 1, n - 1)`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 2\n**Explanation:** We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,0,0,0\\],\\[0,1,0,1,0\\],\\[0,0,0,1,0\\]\\]\n**Output:** 0\n**Explanation:** We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `2 <= m * n <= 105`\n*   `grid[i][j]` is either `0` **or** `1`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`\"\"\"\n\n    count = {}\n    for bean in beans:\n        if bean not in count:\n            count[bean] = 0\n        count[bean] += 1\n\n    min_remove = len(beans)\n    for key, value in count.items():\n        remove = 0\n        for other_key, other_value in count.items():\n            if other_key != key:\n                remove += other_value * max(0, other_key - key)\n        min_remove = min(min_remove, remove)\n\n    return min_remove"}}}}, "124": {"gold": {"leetcode/leetcode_1240.txt": 1, "leetcode/leetcode_1444.txt": 1}, "retrieved": {"leetcode/leetcode_1575.txt": {"score": 0.886195719242096, "content": {"text": "def maxArea(h, w, horizontalCuts, verticalCuts):\n    \"\"\"You are given an array of **distinct** positive integers locations where `locations[i]` represents the position of city `i`. You are also given integers `start`, `finish` and `fuel` representing the starting city, ending city, and the initial amount of fuel you have, respectively.\n\nAt each step, if you are at city `i`, you can pick any city `j` such that `j != i` and `0 <= j < locations.length` and move to city `j`. Moving from city `i` to city `j` reduces the amount of fuel you have by `|locations[i] - locations[j]|`. Please notice that `|x|` denotes the absolute value of `x`.\n\nNotice that `fuel` **cannot** become negative at any point in time, and that you are **allowed** to visit any city more than once (including `start` and `finish`).\n\nReturn _the count of all possible routes from_ `start` _to_ `finish`. Since the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** locations = \\[2,3,6,8,4\\], start = 1, finish = 3, fuel = 5\n**Output:** 4\n**Explanation:** The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n\n**Example 2:**\n\n**Input:** locations = \\[4,3,1\\], start = 1, finish = 0, fuel = 6\n**Output:** 5\n**Explanation:** The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n\n**Example 3:**\n\n**Input:** locations = \\[5,2,1\\], start = 0, finish = 2, fuel = 3\n**Output:** 0\n**Explanation:** It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\n\n**Constraints:**\n\n*   `2 <= locations.length <= 100`\n*   `1 <= locations[i] <= 109`\n*   All integers in `locations` are **distinct**.\n*   `0 <= start, finish < locations.length`\n*   `1 <= fuel <= 200`\"\"\"\n\n    horizontalCuts.sort()\n    verticalCuts.sort()\n\n    maxH = max(horizontalCuts[0], h - horizontalCuts[-1])\n    maxV = max(verticalCuts[0], w - verticalCuts[-1])\n\n    for i in range(1, len(horizontalCuts)):\n        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1])\n\n    for i in range(1, len(verticalCuts)):\n        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1])\n\n    return (maxH * maxV) % (10**9 + 7)"}}, "leetcode/leetcode_1240.txt": {"score": 0.891287624835968, "content": {"text": "from functools import lru_cache\n    \"\"\"Given a rectangle of size `n` x `m`, return _the minimum number of integer-sided squares that tile the rectangle_.\n\n**Example 1:**\n\n**Input:** n = 2, m = 3\n**Output:** 3\n**Explanation:** `3` squares are necessary to cover the rectangle.\n`2` (squares of `1x1`)\n`1` (square of `2x2`)\n\n**Example 2:**\n\n**Input:** n = 5, m = 8\n**Output:** 5\n\n**Example 3:**\n\n**Input:** n = 11, m = 13\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= n, m <= 13`\"\"\"\n\n\ndef stoneGameII(piles):\n    n = len(piles)\n    for i in range(n - 2, -1, -1):\n        piles[i] += piles[i + 1]\n\n    @lru_cache(None)\n    def search(idx, M):\n        if idx + 2 * M >= n:\n            return piles[idx]\n        return max(piles[idx] - search(idx + x, max(M, x)) for x in range(1, 2 * M + 1))\n\n    return search(0, 1)"}}, "leetcode/leetcode_354.txt": {"score": 0.886686384677887, "content": {"text": "from bisect import bisect_left\n    \"\"\"You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll (i.e., put one inside the other)_.\n\n**Note:** You cannot rotate an envelope.\n\n**Example 1:**\n\n**Input:** envelopes = \\[\\[5,4\\],\\[6,4\\],\\[6,7\\],\\[2,3\\]\\]\n**Output:** 3\n**Explanation:** The maximum number of envelopes you can Russian doll is `3` (\\[2,3\\] => \\[5,4\\] => \\[6,7\\]).\n\n**Example 2:**\n\n**Input:** envelopes = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= envelopes.length <= 105`\n*   `envelopes[i].length == 2`\n*   `1 <= wi, hi <= 105`\"\"\"\n\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)"}}, "leetcode/leetcode_1725.txt": {"score": 0.8964820504188538, "content": {"text": "def numberOfSets(n, k):\n    \"\"\"You are given an array `rectangles` where `rectangles[i] = [li, wi]` represents the `ith` rectangle of length `li` and width `wi`.\n\nYou can cut the `ith` rectangle to form a square with a side length of `k` if both `k <= li` and `k <= wi`. For example, if you have a rectangle `[4,6]`, you can cut it to get a square with a side length of at most `4`.\n\nLet `maxLen` be the side length of the **largest** square you can obtain from any of the given rectangles.\n\nReturn _the **number** of rectangles that can make a square with a side length of_ `maxLen`.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[5,8\\],\\[3,9\\],\\[5,12\\],\\[16,5\\]\\]\n**Output:** 3\n**Explanation:** The largest squares you can get from each rectangle are of lengths \\[5,3,5,5\\].\nThe largest possible square is of length 5, and you can get it out of 3 rectangles.\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[2,3\\],\\[3,7\\],\\[4,3\\],\\[3,7\\]\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= rectangles.length <= 1000`\n*   `rectangles[i].length == 2`\n*   `1 <= li, wi <= 109`\n*   `li != wi`\"\"\"\n\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n)]\n    presum = [1] * n\n    \n    for j in range(1, k + 1):\n        for i in range(n):\n            dp[i][j] = presum[i]\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= mod\n            presum[i] = (presum[i] + dp[i][j - 1]) % mod\n    \n    return dp[n - 1][k]"}}, "leetcode/leetcode_813.txt": {"score": 0.9050580263137817, "content": {"text": "from typing import List\n    \"\"\"You are given an integer array `nums` and an integer `k`. You can partition the array into **at most** `k` non-empty adjacent subarrays. The **score** of a partition is the sum of the averages of each subarray.\n\nNote that the partition must use every integer in `nums`, and that the score is not necessarily an integer.\n\nReturn _the maximum **score** you can achieve of all the possible partitions_. Answers within `10-6` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** nums = \\[9,1,2,3,9\\], k = 3\n**Output:** 20.00000\n**Explanation:** \nThe best choice is to partition nums into \\[9\\], \\[1, 2, 3\\], \\[9\\]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could have also partitioned nums into \\[9, 1\\], \\[2\\], \\[3, 9\\], for example.\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7\\], k = 4\n**Output:** 20.50000\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 104`\n*   `1 <= k <= nums.length`\"\"\"\n\n\ndef allPathsSourceTarget(graph: List[List[int]]) -> List[List[int]]:\n    def DFS(currentNode, path):\n        path.append(currentNode)\n        if currentNode == len(graph) - 1:\n            result.append(path[:])\n        else:\n            for neighbor in graph[currentNode]:\n                DFS(neighbor, path)\n        path.pop()\n\n    result = []\n    DFS(0, [])\n    return result"}}, "leetcode/leetcode_1465.txt": {"score": 0.9313473701477051, "content": {"text": "class TreeNode:\n    \"\"\"You are given a rectangular cake of size `h x w` and two arrays of integers `horizontalCuts` and `verticalCuts` where:\n\n*   `horizontalCuts[i]` is the distance from the top of the rectangular cake to the `ith` horizontal cut and similarly, and\n*   `verticalCuts[j]` is the distance from the left of the rectangular cake to the `jth` vertical cut.\n\nReturn _the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays_ `horizontalCuts` _and_ `verticalCuts`. Since the answer can be a large number, return this **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[1,2,4\\], verticalCuts = \\[1,3\\]\n**Output:** 4 \n**Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.\n\n**Example 2:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[3,1\\], verticalCuts = \\[1\\]\n**Output:** 6\n**Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.\n\n**Example 3:**\n\n**Input:** h = 5, w = 4, horizontalCuts = \\[3\\], verticalCuts = \\[3\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `2 <= h, w <= 109`\n*   `1 <= horizontalCuts.length <= min(h - 1, 105)`\n*   `1 <= verticalCuts.length <= min(w - 1, 105)`\n*   `1 <= horizontalCuts[i] < h`\n*   `1 <= verticalCuts[i] < w`\n*   All the elements in `horizontalCuts` are distinct.\n*   All the elements in `verticalCuts` are distinct.\"\"\"\n\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def maxProduct(self, root: TreeNode) -> int:\n        def dfs(node):\n            if not node:\n                return 0\n            return node.val + dfs(node.left) + dfs(node.right)\n\n        def dfs2(node, half):\n            nonlocal result\n\n            if not node:\n                return 0\n            cur_sum = node.val + dfs2(node.left, half) + dfs2(node.right, half)\n            result = max(result, (total - cur_sum) * cur_sum)\n            return cur_sum\n\n        total = dfs(root)\n        result = 0\n        dfs2(root, total / 2)\n        return result % (10**9 + 7)"}}, "leetcode/leetcode_1937.txt": {"score": 0.8879258632659912, "content": {"text": "def maxPoints(points):\n    \"\"\"You are given an `m x n` integer matrix `points` (**0-indexed**). Starting with `0` points, you want to **maximize** the number of points you can get from the matrix.\n\nTo gain points, you must pick one cell in **each row**. Picking the cell at coordinates `(r, c)` will **add** `points[r][c]` to your score.\n\nHowever, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows `r` and `r + 1` (where `0 <= r < m - 1`), picking cells at coordinates `(r, c1)` and `(r + 1, c2)` will **subtract** `abs(c1 - c2)` from your score.\n\nReturn _the **maximum** number of points you can achieve_.\n\n`abs(x)` is defined as:\n\n*   `x` for `x >= 0`.\n*   `-x` for `x < 0`.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,2,3\\],\\[1,5,1\\],\\[3,1,1\\]\\]\n**Output:** 9\n**Explanation:**\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\nYou add 3 + 5 + 3 = 11 to your score.\nHowever, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\nYour final score is 11 - 2 = 9.\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,5\\],\\[2,3\\],\\[4,2\\]\\]\n**Output:** 11\n**Explanation:**\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\nYou add 5 + 3 + 4 = 12 to your score.\nHowever, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\nYour final score is 12 - 1 = 11.\n\n**Constraints:**\n\n*   `m == points.length`\n*   `n == points[r].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `0 <= points[r][c] <= 105`\"\"\"\n\n    m, n = len(points), len(points[0])\n    dp = [0] * n\n    for row in points:\n        next_dp = [0] * n\n        for c1 in range(n):\n            score = dp[c1] + row[c1] - c1\n            for c2 in range(n):\n                next_dp[c2] = max(next_dp[c2], score - row[c1] + c2)\n        dp = next_dp\n    return max(dp)"}}, "leetcode/leetcode_2312.txt": {"score": 0.9959794282913208, "content": {"text": "def max_count_target(nums, key):\n    \"\"\"You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars.\n\nTo cut a piece of wood, you must make a vertical or horizontal cut across the **entire** height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you **cannot** rotate a piece to swap its height and width.\n\nReturn _the **maximum** money you can earn after cutting an_ `m x n` _piece of wood_.\n\nNote that you can cut the piece of wood as many times as you want.\n\n**Example 1:**\n\n**Input:** m = 3, n = 5, prices = \\[\\[1,4,2\\],\\[2,2,7\\],\\[2,1,3\\]\\]\n**Output:** 19\n**Explanation:** The diagram above shows a possible scenario. It consists of:\n- 2 pieces of wood shaped 2 x 2, selling for a price of 2 \\* 7 = 14.\n- 1 piece of wood shaped 2 x 1, selling for a price of 1 \\* 3 = 3.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 \\* 2 = 2.\nThis obtains a total of 14 + 3 + 2 = 19 money earned.\nIt can be shown that 19 is the maximum amount of money that can be earned.\n\n**Example 2:**\n\n**Input:** m = 4, n = 6, prices = \\[\\[3,2,10\\],\\[1,4,2\\],\\[4,1,3\\]\\]\n**Output:** 32\n**Explanation:** The diagram above shows a possible scenario. It consists of:\n- 3 pieces of wood shaped 3 x 2, selling for a price of 3 \\* 10 = 30.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 \\* 2 = 2.\nThis obtains a total of 30 + 2 = 32 money earned.\nIt can be shown that 32 is the maximum amount of money that can be earned.\nNotice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.\n\n**Constraints:**\n\n*   `1 <= m, n <= 200`\n*   `1 <= prices.length <= 2 * 104`\n*   `prices[i].length == 3`\n*   `1 <= hi <= m`\n*   `1 <= wi <= n`\n*   `1 <= pricei <= 106`\n*   All the shapes of wood `(hi, wi)` are pairwise **distinct**.\"\"\"\n\n    count = {}\n    max_count = 0\n    max_target = -1\n    for i in range(1, len(nums)):\n        if nums[i - 1] == key:\n            count[nums[i]] = count.get(nums[i], 0) + 1\n            if count[nums[i]] > max_count:\n                max_count = count[nums[i]]\n                max_target = nums[i]\n    return max_target"}}, "leetcode/leetcode_1444.txt": {"score": 0.8980942368507385, "content": {"text": "def number_of_steps(num):\n    \"\"\"Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.\n\n**Example 1:**\n\n**Input:** pizza = \\[ \"A.. \", \"AAA \", \"... \"\\], k = 3\n**Output:** 3 \n**Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n**Example 2:**\n\n**Input:** pizza = \\[ \"A.. \", \"AA. \", \"... \"\\], k = 3\n**Output:** 1\n\n**Example 3:**\n\n**Input:** pizza = \\[ \"A.. \", \"A.. \", \"... \"\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 50`\n*   `rows == pizza.length`\n*   `cols == pizza[i].length`\n*   `1 <= k <= 10`\n*   `pizza` consists of characters `'A'` and `'.'` only.\"\"\"\n\n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    return steps - 1"}}, "leetcode/leetcode_1563.txt": {"score": 0.9170046448707581, "content": {"text": "from math import acos, cos, sin, sqrt\n    \"\"\"There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially **zero**.\n\nReturn _the maximum score that Alice can obtain_.\n\n**Example 1:**\n\n**Input:** stoneValue = \\[6,2,3,4,5,5\\]\n**Output:** 18\n**Explanation:** In the first round, Alice divides the row to \\[6,2,3\\], \\[4,5,5\\]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to \\[6\\], \\[2,3\\]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is \\[2\\], \\[3\\]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\n**Example 2:**\n\n**Input:** stoneValue = \\[7,7,7,7,7,7,7\\]\n**Output:** 28\n\n**Example 3:**\n\n**Input:** stoneValue = \\[4\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 500`\n*   `1 <= stoneValue[i] <= 106`\"\"\"\n\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts"}}}}, "125": {"gold": {"leetcode/leetcode_1223.txt": 1, "leetcode/leetcode_1473.txt": 1}, "retrieved": {"leetcode/leetcode_878.txt": {"score": 0.9079745411872864, "content": {"text": "def shiftingLetters(s: str, shifts: list[int]) -> str:\n    \"\"\"A positive integer is _magical_ if it is divisible by either `a` or `b`.\n\nGiven the three integers `n`, `a`, and `b`, return the `nth` magical number. Since the answer may be very large, **return it modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 1, a = 2, b = 3\n**Output:** 2\n\n**Example 2:**\n\n**Input:** n = 4, a = 2, b = 3\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= n <= 109`\n*   `2 <= a, b <= 4 * 104`\"\"\"\n\n    n = len(s)\n    for i in range(n - 2, -1, -1):\n        shifts[i] = (shifts[i] + shifts[i + 1]) % 26\n    \n    result = []\n    for i in range(n):\n        result.append(chr(((ord(s[i]) - ord('a')) + shifts[i]) % 26 + ord('a')))\n    \n    return \"\".join(result)"}}, "leetcode/leetcode_2549.txt": {"score": 0.9202778935432434, "content": {"text": "def distinct_numbers(n):\n    \"\"\"You are given a positive integer `n`, that is initially placed on a board. Every day, for `109` days, you perform the following procedure:\n\n*   For each number `x` present on the board, find all numbers `1 <= i <= n` such that `x % i == 1`.\n*   Then, place those numbers on the board.\n\nReturn _the number of **distinct** integers present on the board after_ `109` _days have elapsed_.\n\n**Note:**\n\n*   Once a number is placed on the board, it will remain on it until the end.\n*   `%` stands for the modulo operation. For example, `14 % 3` is `2`.\n\n**Example 1:**\n\n**Input:** n = 5\n**Output:** 4\n**Explanation:** Initially, 5 is present on the board. \nThe next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. \nAfter that day, 3 will be added to the board because 4 % 3 == 1. \nAt the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. \n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** \nSince 3 % 2 == 1, 2 will be added to the board. \nAfter a billion days, the only two distinct numbers on the board are 2 and 3. \n\n**Constraints:**\n\n*   `1 <= n <= 100`\"\"\"\n\n    return n - 1"}}, "leetcode/leetcode_1735.txt": {"score": 0.9097912907600403, "content": {"text": "MOD = 10**9 + 7\n    \"\"\"You are given a 2D integer array, `queries`. For each `queries[i]`, where `queries[i] = [ni, ki]`, find the number of different ways you can place positive integers into an array of size `ni` such that the product of the integers is `ki`. As the number of ways may be too large, the answer to the `ith` query is the number of ways **modulo** `109 + 7`.\n\nReturn _an integer array_ `answer` _where_ `answer.length == queries.length`_, and_ `answer[i]` _is the answer to the_ `ith` _query._\n\n**Example 1:**\n\n**Input:** queries = \\[\\[2,6\\],\\[5,1\\],\\[73,660\\]\\]\n**Output:** \\[4,1,50734910\\]\n**Explanation:** Each query is independent.\n\\[2,6\\]: There are 4 ways to fill an array of size 2 that multiply to 6: \\[1,6\\], \\[2,3\\], \\[3,2\\], \\[6,1\\].\n\\[5,1\\]: There is 1 way to fill an array of size 5 that multiply to 1: \\[1,1,1,1,1\\].\n\\[73,660\\]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.\n\n**Example 2:**\n\n**Input:** queries = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\],\\[5,5\\]\\]\n**Output:** \\[1,2,3,10,5\\]\n\n**Constraints:**\n\n*   `1 <= queries.length <= 104`\n*   `1 <= ni, ki <= 104`\"\"\"\n\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef ways(n, k, mem):\n    if n == 1:\n        return k\n    if (n_tuple := (n, k)) in mem:\n        return mem[n_tuple]\n    if k == 1:\n        mem[n_tuple] = 1\n        return 1\n    if n > k:\n        mem[n_tuple] = 0\n        return 0\n    res = mul(ways(n, k - 1, mem), n)\n    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD\n    mem[n_tuple] = res\n    return res\n\ndef waysToFillArray(queries):\n    mem = {}\n    ans = []\n    for q in queries:\n        ans.append(ways(q[0], q[1], mem))\n    return ans"}}, "leetcode/leetcode_1223.txt": {"score": 0.9291852116584778, "content": {"text": "def areConnected(n, threshold, queries):\n    \"\"\"A die simulator generates a random number from `1` to `6` for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (**1-indexed**) consecutive times.\n\nGiven an array of integers `rollMax` and an integer `n`, return _the number of distinct sequences that can be obtained with exact_ `n` _rolls_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\nTwo sequences are considered different if at least one element differs from each other.\n\n**Example 1:**\n\n**Input:** n = 2, rollMax = \\[1,1,2,2,2,3\\]\n**Output:** 34\n**Explanation:** There will be 2 rolls of die, if there are no constraints on the die, there are 6 \\* 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n\n**Example 2:**\n\n**Input:** n = 2, rollMax = \\[1,1,1,1,1,1\\]\n**Output:** 30\n\n**Example 3:**\n\n**Input:** n = 3, rollMax = \\[1,1,1,2,2,3\\]\n**Output:** 181\n\n**Constraints:**\n\n*   `1 <= n <= 5000`\n*   `rollMax.length == 6`\n*   `1 <= rollMax[i] <= 15`\"\"\"\n\n    answer = [False] * len(queries)\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def unite(x, y):\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                rootx, rooty = rooty, rootx\n            parent[rootx] = rooty\n            if rank[rootx] == rank[rooty]:\n                rank[rooty] += 1\n\n    for i in range(threshold + 1, n + 1):\n        for j in range(i * 2, n + 1, i):\n            unite(i, j)\n\n    for i, query in enumerate(queries):\n        answer[i] = find(query[0]) == find(query[1])\n\n    return answer"}}, "leetcode/leetcode_1922.txt": {"score": 0.9213406443595886, "content": {"text": "def goodDigitStrings(n: int) -> int:\n    \"\"\"A digit string is **good** if the digits **(0-indexed)** at **even** indices are **even** and the digits at **odd** indices are **prime** (`2`, `3`, `5`, or `7`).\n\n*   For example, `\"2582 \"` is good because the digits (`2` and `8`) at even positions are even and the digits (`5` and `2`) at odd positions are prime. However, `\"3245 \"` is **not** good because `3` is at an even index but is not even.\n\nGiven an integer `n`, return _the **total** number of good digit strings of length_ `n`. Since the answer may be large, **return it modulo** `109 + 7`.\n\nA **digit string** is a string consisting of digits `0` through `9` that may contain leading zeros.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 5\n**Explanation:** The good numbers of length 1 are  \"0 \",  \"2 \",  \"4 \",  \"6 \",  \"8 \".\n\n**Example 2:**\n\n**Input:** n = 4\n**Output:** 400\n\n**Example 3:**\n\n**Input:** n = 50\n**Output:** 564908303\n\n**Constraints:**\n\n*   `1 <= n <= 1015`\"\"\"\n\n    MOD = 1000000007\n    even_count, prime_count = 1, 1\n    for i in range(n):\n        if i % 2 == 0:\n            even_count = (even_count * 5) % MOD\n        else:\n            prime_count = (prime_count * 4) % MOD\n    return (even_count * prime_count) % MOD"}}, "leetcode/leetcode_2572.txt": {"score": 0.91554194688797, "content": {"text": "def countSquareFreeSubsets(nums):\n    \"\"\"You are given a positive integer **0-indexed** array `nums`.\n\nA subset of the array `nums` is **square-free** if the product of its elements is a **square-free integer**.\n\nA **square-free integer** is an integer that is divisible by no square number other than `1`.\n\nReturn _the number of square-free non-empty subsets of the array_ **nums**. Since the answer may be too large, return it **modulo** `109 + 7`.\n\nA **non-empty** **subset** of `nums` is an array that can be obtained by deleting some (possibly none but not all) elements from `nums`. Two subsets are different if and only if the chosen indices to delete are different.\n\n**Example 1:**\n\n**Input:** nums = \\[3,4,4,5\\]\n**Output:** 3\n**Explanation:** There are 3 square-free subsets in this example:\n- The subset consisting of the 0th element \\[3\\]. The product of its elements is 3, which is a square-free integer.\n- The subset consisting of the 3rd element \\[5\\]. The product of its elements is 5, which is a square-free integer.\n- The subset consisting of 0th and 3rd elements \\[3,5\\]. The product of its elements is 15, which is a square-free integer.\nIt can be proven that there are no more than 3 square-free subsets in the given array.\n\n**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:** There is 1 square-free subset in this example:\n- The subset consisting of the 0th element \\[1\\]. The product of its elements is 1, which is a square-free integer.\nIt can be proven that there is no more than 1 square-free subset in the given array.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 30`\"\"\"\n\n    from collections import Counter\n    counter = Counter(nums)\n    MOD = 10**9 + 7\n\n    dp = [[0] * 1001 for _ in range(61)]\n    dp[0][0] = 1\n    idx = 0\n    for num, freq in counter.items():\n        idx += 1\n        for sq in range(61):\n            for ns in range(1001 - freq):\n                dp[idx][ns + freq] += dp[idx - 1][ns] * ((1 << freq) - 1) % MOD\n                dp[idx][ns + freq] %= MOD\n                dp[idx][ns] += dp[idx - 1][ns]\n                dp[idx][ns] %= MOD\n\n                if (sq // num) % 2 == 1:\n                    dp[idx][ns + freq] -= dp[idx - 1][ns] * ((1 << (freq - 1)) - 1) % MOD\n                    if dp[idx][ns + freq] < 0:\n                        dp[idx][ns + freq] += MOD\n    return dp[idx][0]"}}, "leetcode/leetcode_526.txt": {"score": 0.9276317954063416, "content": {"text": "def countArrangement(n: int) -> int:\n    \"\"\"Suppose you have `n` integers labeled `1` through `n`. A permutation of those `n` integers `perm` (**1-indexed**) is considered a **beautiful arrangement** if for every `i` (`1 <= i <= n`), **either** of the following is true:\n\n*   `perm[i]` is divisible by `i`.\n*   `i` is divisible by `perm[i]`.\n\nGiven an integer `n`, return _the **number** of the **beautiful arrangements** that you can construct_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** \nThe first beautiful arrangement is \\[1,2\\]:\n    - perm\\[1\\] = 1 is divisible by i = 1\n    - perm\\[2\\] = 2 is divisible by i = 2\nThe second beautiful arrangement is \\[2,1\\]:\n    - perm\\[1\\] = 2 is divisible by i = 1\n    - i = 2 is divisible by perm\\[2\\] = 1\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 15`\"\"\"\n\n    def helper(idx: int, visited: List[bool], n: int) -> int:\n        if idx > n:\n            return 1\n\n        count = 0\n        for i in range(1, n+1):\n            if not visited[i] and (idx % i == 0 or i % idx == 0):\n                visited[i] = True\n                count += helper(idx+1, visited, n)\n                visited[i] = False\n\n        return count\n\n    visited = [False] * (n+1)\n    return helper(1, visited, n)"}}, "leetcode/leetcode_2338.txt": {"score": 0.9541763067245483, "content": {"text": "def numOfArrays(n: int, maxValue: int) -> int:\n    \"\"\"You are given two integers `n` and `maxValue`, which are used to describe an **ideal** array.\n\nA **0-indexed** integer array `arr` of length `n` is considered **ideal** if the following conditions hold:\n\n*   Every `arr[i]` is a value from `1` to `maxValue`, for `0 <= i < n`.\n*   Every `arr[i]` is divisible by `arr[i - 1]`, for `0 < i < n`.\n\nReturn _the number of **distinct** ideal arrays of length_ `n`. Since the answer may be very large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 2, maxValue = 5\n**Output:** 10\n**Explanation:** The following are the possible ideal arrays:\n- Arrays starting with the value 1 (5 arrays): \\[1,1\\], \\[1,2\\], \\[1,3\\], \\[1,4\\], \\[1,5\\]\n- Arrays starting with the value 2 (2 arrays): \\[2,2\\], \\[2,4\\]\n- Arrays starting with the value 3 (1 array): \\[3,3\\]\n- Arrays starting with the value 4 (1 array): \\[4,4\\]\n- Arrays starting with the value 5 (1 array): \\[5,5\\]\nThere are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.\n\n**Example 2:**\n\n**Input:** n = 5, maxValue = 3\n**Output:** 11\n**Explanation:** The following are the possible ideal arrays:\n- Arrays starting with the value 1 (9 arrays): \n   - With no other distinct values (1 array): \\[1,1,1,1,1\\] \n   - With 2nd distinct value 2 (4 arrays): \\[1,1,1,1,2\\], \\[1,1,1,2,2\\], \\[1,1,2,2,2\\], \\[1,2,2,2,2\\]\n   - With 2nd distinct value 3 (4 arrays): \\[1,1,1,1,3\\], \\[1,1,1,3,3\\], \\[1,1,3,3,3\\], \\[1,3,3,3,3\\]\n- Arrays starting with the value 2 (1 array): \\[2,2,2,2,2\\]\n- Arrays starting with the value 3 (1 array): \\[3,3,3,3,3\\]\nThere are a total of 9 + 1 + 1 = 11 distinct ideal arrays.\n\n**Constraints:**\n\n*   `2 <= n <= 104`\n*   `1 <= maxValue <= 104`\"\"\"\n\n    mod = 10**9 + 7\n    dp = [0] * (maxValue + 1)\n    \n    for i in range(1, maxValue + 1):\n        dp[i] = i\n        \n    for i in range(1, n):\n        for j in range(maxValue, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1]) % mod\n            \n    return dp[maxValue]"}}, "leetcode/leetcode_920.txt": {"score": 0.936011791229248, "content": {"text": "def uncommon_from_sentences(s1, s2):\n    \"\"\"Your music player contains `n` different songs. You want to listen to `goal` songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n\n*   Every song is played **at least once**.\n*   A song can only be played again only if `k` other songs have been played.\n\nGiven `n`, `goal`, and `k`, return _the number of possible playlists that you can create_. Since the answer can be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 3, goal = 3, k = 1\n**Output:** 6\n**Explanation:** There are 6 possible playlists: \\[1, 2, 3\\], \\[1, 3, 2\\], \\[2, 1, 3\\], \\[2, 3, 1\\], \\[3, 1, 2\\], and \\[3, 2, 1\\].\n\n**Example 2:**\n\n**Input:** n = 2, goal = 3, k = 0\n**Output:** 6\n**Explanation:** There are 6 possible playlists: \\[1, 1, 2\\], \\[1, 2, 1\\], \\[2, 1, 1\\], \\[2, 2, 1\\], \\[2, 1, 2\\], and \\[1, 2, 2\\].\n\n**Example 3:**\n\n**Input:** n = 2, goal = 3, k = 1\n**Output:** 2\n**Explanation:** There are 2 possible playlists: \\[1, 2, 1\\] and \\[2, 1, 2\\].\n\n**Constraints:**\n\n*   `0 <= k < n <= goal <= 100`\"\"\"\n\n    word_count = {}\n    for word in (s1 + \" \" + s2).split():\n        word_count[word] = word_count.get(word, 0) + 1\n\n    return [key for key, val in word_count.items() if val == 1]"}}, "leetcode/leetcode_2318.txt": {"score": 0.9981292486190796, "content": {"text": "def bob_arrows(num_arrows, alice_arrows):\n    \"\"\"You are given an integer `n`. You roll a fair 6-sided dice `n` times. Determine the total number of **distinct** sequences of rolls possible such that the following conditions are satisfied:\n\n1.  The **greatest common divisor** of any **adjacent** values in the sequence is equal to `1`.\n2.  There is **at least** a gap of `2` rolls between **equal** valued rolls. More formally, if the value of the `ith` roll is **equal** to the value of the `jth` roll, then `abs(i - j) > 2`.\n\nReturn _the **total number** of distinct sequences possible_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nTwo sequences are considered distinct if at least one element is different.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 184\n**Explanation:** Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.\nSome invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).\n(1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).\n(1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.\nThere are a total of 184 distinct sequences possible, so we return 184.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 22\n**Explanation:** Some of the possible sequences are (1, 2), (2, 1), (3, 2).\nSome invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.\nThere are a total of 22 distinct sequences possible, so we return 22.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\"\"\"\n\n    bob = [0] * 12\n    for i in range(11, -1, -1):\n        if num_arrows > 0 and alice_arrows[i] == 0:\n            shot = min(num_arrows, i+1)\n            bob[i] = shot\n            num_arrows -= shot\n    return bob"}}}}, "126": {"gold": {"leetcode/leetcode_329.txt": 1, "leetcode/leetcode_797.txt": 1}, "retrieved": {"leetcode/leetcode_2304.txt": {"score": 0.8993070721626282, "content": {"text": "def excel_sheet_cells(s: str):\n    \"\"\"You are given a **0-indexed** `m x n` integer matrix `grid` consisting of **distinct** integers from `0` to `m * n - 1`. You can move in this matrix from a cell to any other cell in the **next** row. That is, if you are in cell `(x, y)` such that `x < m - 1`, you can move to any of the cells `(x + 1, 0)`, `(x + 1, 1)`, ..., `(x + 1, n - 1)`. **Note** that it is not possible to move from cells in the last row.\n\nEach possible move has a cost given by a **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row. The cost of moving from cells in the last row of `grid` can be ignored.\n\nThe cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made. Return _the **minimum** cost of a path that starts from any cell in the **first** row and ends at any cell in the **last** row._\n\n**Example 1:**\n\n**Input:** grid = \\[\\[5,3\\],\\[4,0\\],\\[2,1\\]\\], moveCost = \\[\\[9,8\\],\\[1,5\\],\\[10,12\\],\\[18,6\\],\\[2,4\\],\\[14,3\\]\\]\n**Output:** 17\n**Explanation:** The path with the minimum possible cost is the path 5 -> 0 -> 1.\n- The sum of the values of cells visited is 5 + 0 + 1 = 6.\n- The cost of moving from 5 to 0 is 3.\n- The cost of moving from 0 to 1 is 8.\nSo the total cost of the path is 6 + 3 + 8 = 17.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[5,1,2\\],\\[4,0,3\\]\\], moveCost = \\[\\[12,10,15\\],\\[20,23,8\\],\\[21,7,1\\],\\[8,1,13\\],\\[9,10,25\\],\\[5,3,2\\]\\]\n**Output:** 6\n**Explanation:** The path with the minimum possible cost is the path 2 -> 3.\n- The sum of the values of cells visited is 2 + 3 = 5.\n- The cost of moving from 2 to 3 is 1.\nSo the total cost of this path is 5 + 1 = 6.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 50`\n*   `grid` consists of distinct integers from `0` to `m * n - 1`.\n*   `moveCost.length == m * n`\n*   `moveCost[i].length == n`\n*   `1 <= moveCost[i][j] <= 100`\"\"\"\n\n    c1, r1, c2, r2 = s.split(':')\n    r1, r2 = int(r1[1:]), int(r2[1:])\n    c1, c2 = ord(c1[0]), ord(c2[0])\n    result = []\n\n    for c in range(c1, c2 + 1):\n        for r in range(r1, r2 + 1):\n            result.append(chr(c) + str(r))\n\n    return result"}}, "leetcode/leetcode_62.txt": {"score": 0.899356484413147, "content": {"text": "def uniquePaths(m, n):\n    \"\"\"There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.\n\n**Example 1:**\n\n**Input:** m = 3, n = 7\n**Output:** 28\n\n**Example 2:**\n\n**Input:** m = 3, n = 2\n**Output:** 3\n**Explanation:** From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n**Constraints:**\n\n*   `1 <= m, n <= 100`\"\"\"\n\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]"}}, "leetcode/leetcode_63.txt": {"score": 0.9023116827011108, "content": {"text": "def uniquePathsWithObstacles(grid):\n    \"\"\"You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.\n\n**Example 1:**\n\n**Input:** obstacleGrid = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** 2\n**Explanation:** There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n**Example 2:**\n\n**Input:** obstacleGrid = \\[\\[0,1\\],\\[0,0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == obstacleGrid.length`\n*   `n == obstacleGrid[i].length`\n*   `1 <= m, n <= 100`\n*   `obstacleGrid[i][j]` is `0` or `1`.\"\"\"\n\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]"}}, "leetcode/leetcode_576.txt": {"score": 0.9078347682952881, "content": {"text": "def findPaths(m, n, maxMove, startRow, startColumn):               \n    \"\"\"There is an `m x n` grid with a ball. The ball is initially at the position `[startRow, startColumn]`. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply **at most** `maxMove` moves to the ball.\n\nGiven the five integers `m`, `n`, `maxMove`, `startRow`, `startColumn`, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n**Output:** 6\n\n**Example 2:**\n\n**Input:** m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n**Output:** 12\n\n**Constraints:**\n\n*   `1 <= m, n <= 50`\n*   `0 <= maxMove <= 50`\n*   `0 <= startRow < m`\n*   `0 <= startColumn < n`\"\"\"\n\n    MOD = 10**9 + 7                     \n    dp = [[[0]* n for _ in range(m)] for _ in range(maxMove + 1)]\n    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for k in range(1, maxMove + 1):                                \n        for i in range(m):                                         \n            for j in range(n):                                           \n                for move in moves:              \n                    ni, nj = i + move[0], j + move[1]\n                    if ni < 0 or ni >= m or nj < 0 or nj >= n:                                 \n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          \n                    else:\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD\n\n    return dp[maxMove][startRow][startColumn]"}}, "leetcode/leetcode_741.txt": {"score": 0.9058093428611755, "content": {"text": "def cherryPickup(self, grid: List[List[int]]) -> int:\n    \"\"\"You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.\n\n*   `0` means the cell is empty, so you can pass through,\n*   `1` means the cell contains a cherry that you can pick up and pass through, or\n*   `-1` means the cell contains a thorn that blocks your way.\n\nReturn _the maximum number of cherries you can collect by following the rules below_:\n\n*   Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).\n*   After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.\n*   When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.\n*   If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,-1\\],\\[1,0,-1\\],\\[1,1,1\\]\\]\n**Output:** 5\n**Explanation:** The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes \\[\\[0,1,-1\\],\\[0,0,-1\\],\\[0,0,0\\]\\].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,-1\\],\\[1,-1,1\\],\\[-1,1,1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `grid[i][j]` is `-1`, `0`, or `1`.\n*   `grid[0][0] != -1`\n*   `grid[n - 1][n - 1] != -1`\"\"\"\n\n    def dp(r1, c1, c2):\n        r2 = r1 + c1 - c2\n        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or\n            grid[r1][c1] == -1 or grid[r2][c2] == -1):\n            return float('-inf')\n        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:\n            return grid[r1][c1]\n        elif memo[r1][c1][c2] != float('-inf'):\n            return memo[r1][c1][c2]\n        else:\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]\n            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),\n                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))\n            memo[r1][c1][c2] += max_cherries\n        \n        return memo[r1][c1][c2]\n    \n    N = len(grid)\n    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]\n    return max(0, dp(0, 0, 0))"}}, "leetcode/leetcode_1463.txt": {"score": 0.9064007997512817, "content": {"text": "from typing import List\n    \"\"\"You are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.\n\nYou have two robots that can collect cherries for you:\n\n*   **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n*   **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\n\nReturn _the maximum number of cherries collection using both robots by following the rules below_:\n\n*   From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.\n*   When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n*   When both robots stay in the same cell, only one takes the cherries.\n*   Both robots cannot move outside of the grid at any moment.\n*   Both robots should reach the bottom row in `grid`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[3,1,1\\],\\[2,5,1\\],\\[1,5,5\\],\\[2,1,1\\]\\]\n**Output:** 24\n**Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0,0,0,1\\],\\[2,0,0,0,0,3,0\\],\\[2,0,9,0,0,0,0\\],\\[0,3,0,5,4,0,0\\],\\[1,0,2,3,0,0,6\\]\\]\n**Output:** 28\n**Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n\n**Constraints:**\n\n*   `rows == grid.length`\n*   `cols == grid[i].length`\n*   `2 <= rows, cols <= 70`\n*   `0 <= grid[i][j] <= 100`\"\"\"\n\nimport heapq\n\ndef kWeakestRows(mat: List[List[int]], k: int) -> List[int]:\n    soldier_rows = [(row.count(1), i) for i, row in enumerate(mat)]\n    heapq.heapify(soldier_rows)\n    return [heapq.heappop(soldier_rows)[1] for _ in range(k)]"}}, "leetcode/leetcode_2328.txt": {"score": 0.9932219982147217, "content": {"text": "def add_parentheses(expression: str) -> str:\n    \"\"\"You are given an `m x n` integer matrix `grid`, where you can move from a cell to any adjacent cell in all `4` directions.\n\nReturn _the number of **strictly** **increasing** paths in the grid such that you can start from **any** cell and end at **any** cell._ Since the answer may be very large, return it **modulo** `109 + 7`.\n\nTwo paths are considered different if they do not have exactly the same sequence of visited cells.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1\\],\\[3,4\\]\\]\n**Output:** 8\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[1\\], \\[3\\], \\[4\\].\n- Paths with length 2: \\[1 -> 3\\], \\[1 -> 4\\], \\[3 -> 4\\].\n- Paths with length 3: \\[1 -> 3 -> 4\\].\nThe total number of paths is 4 + 3 + 1 = 8.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1\\],\\[2\\]\\]\n**Output:** 3\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[2\\].\n- Paths with length 2: \\[1 -> 2\\].\nThe total number of paths is 2 + 1 = 3.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 105`\"\"\"\n\n    return f\"({expression})\""}}, "leetcode/leetcode_2503.txt": {"score": 0.9186927676200867, "content": {"text": "from typing import List\n    \"\"\"You are given an `m x n` integer matrix `grid` and an array `queries` of size `k`.\n\nFind an array `answer` of size `k` such that for each integer `queries[i]` you start in the **top left** cell of the matrix and repeat the following process:\n\n*   If `queries[i]` is **strictly** greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any **adjacent** cell in all `4` directions: up, down, left, and right.\n*   Otherwise, you do not get any points, and you end this process.\n\nAfter the process, `answer[i]` is the **maximum** number of points you can get. **Note** that for each query you are allowed to visit the same cell **multiple** times.\n\nReturn _the resulting array_ `answer`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[2,5,7\\],\\[3,5,1\\]\\], queries = \\[5,6,2\\]\n**Output:** \\[5,8,1\\]\n**Explanation:** The diagrams above show which cells we visit to get points for each query.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[5,2,1\\],\\[1,1,2\\]\\], queries = \\[3\\]\n**Output:** \\[0\\]\n**Explanation:** We can not get any points because the value of the top left cell is already greater than or equal to 3.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `2 <= m, n <= 1000`\n*   `4 <= m * n <= 105`\n*   `k == queries.length`\n*   `1 <= k <= 104`\n*   `1 <= grid[i][j], queries[i] <= 106`\"\"\"\n\n\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    m, n = len(grid), len(grid[0])\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n\n    def dfs(x: int, y: int, q: int, visited: set) -> int:\n        if 0 <= x < m and 0 <= y < n and grid[x][y] < q and (x, y) not in visited:\n            visited.add((x, y))\n            points = 1\n            for i in range(4):\n                nx, ny = x + dx[i], y + dy[i]\n                points += dfs(nx, ny, q, visited)\n            return points\n        return 0\n\n    return [dfs(0, 0, query, set()) for query in queries]"}}, "leetcode/leetcode_329.txt": {"score": 0.9188042879104614, "content": {"text": "dx = (0, 0, 1, -1)\n    \"\"\"Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[9,9,4\\],\\[6,6,8\\],\\[2,1,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[1, 2, 6, 9]`.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[3,4,5\\],\\[3,2,6\\],\\[2,2,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= matrix[i][j] <= 231 - 1`\"\"\"\n\ndy = (1, -1, 0, 0)\n\ndef dfs(matrix, memo, i, j):\n    if memo[i][j] != 0:\n        return memo[i][j]\n    \n    max_len = 0\n    for k in range(4):\n        ni, nj = i + dx[k], j + dy[k]\n        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):\n            max_len = max(max_len, dfs(matrix, memo, ni, nj))\n    \n    memo[i][j] = max_len + 1\n    return memo[i][j]\n\ndef longest_increasing_path(matrix):\n    m, n = len(matrix), len(matrix[0])\n    \n    memo = [[0] * n for _ in range(m)]\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans = max(ans, dfs(matrix, memo, i, j))\n    \n    return ans"}}, "leetcode/leetcode_1301.txt": {"score": 0.934683084487915, "content": {"text": "from typing import List\n    \"\"\"You are given a square `board` of characters. You can move on the board starting at the bottom right square marked with the character `'S'`.\n\nYou need to reach the top left square marked with the character `'E'`. The rest of the squares are labeled either with a numeric character `1, 2, ..., 9` or with an obstacle `'X'`. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.\n\nReturn a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, **taken modulo `10^9 + 7`**.\n\nIn case there is no path, return `[0, 0]`.\n\n**Example 1:**\n\n**Input:** board = \\[\"E23\",\"2X2\",\"12S\"\\]\n**Output:** \\[7,1\\]\n\n**Example 2:**\n\n**Input:** board = \\[\"E12\",\"1X1\",\"21S\"\\]\n**Output:** \\[4,2\\]\n\n**Example 3:**\n\n**Input:** board = \\[\"E11\",\"XXX\",\"11S\"\\]\n**Output:** \\[0,0\\]\n\n**Constraints:**\n\n*   `2 <= board.length == board[i].length <= 100`\"\"\"\n\n\nMOD = 10**9 + 7\n\ndef pathsWithMaxScore(board: List[str]) -> List[int]:\n    n = len(board)\n    dp = [[0] * n for _ in range(n)]\n    cnt = [[0] * n for _ in range(n)]\n\n    board[0] = list(board[0])\n    board[0][0] = '0'\n    board[n-1] = list(board[n-1])\n    board[n-1][n-1] = '0'\n    cnt[n-1][n-1] = 1\n\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if board[i][j] != 'X':\n                neighbors = [(i-1, j), (i, j-1), (i-1, j-1)]\n                for x, y in neighbors:\n                    if x >= 0 and y >= 0:\n                        if dp[i][j] < dp[x][y] + int(board[i][j]):\n                            dp[i][j] = dp[x][y] + int(board[i][j])\n                            cnt[i][j] = cnt[x][y]\n                        elif dp[i][j] == dp[x][y] + int(board[i][j]):\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD\n\n    return [dp[0][0], cnt[0][0]]"}}}}, "127": {"gold": {"leetcode/leetcode_2525.txt": 1}, "retrieved": {"leetcode/csn_python_train_72558.txt": {"score": 0.846980094909668, "content": {"text": "def score_large_straight_yatzy(dice: List[int]) -> int:\n    \"\"\"\n    Large straight scoring according to yatzy rules\n    \"\"\"\n    dice_set = set(dice)\n    if _are_two_sets_equal({2, 3, 4, 5, 6}, dice_set):\n        return sum(dice)\n    return 0"}}, "leetcode/csn_python_train_202103.txt": {"score": 0.8513606190681458, "content": {"text": "def sort(self, ranks=None):\n        \"\"\"\n        Sorts the stack, either by poker ranks, or big two ranks.\n\n        :arg dict ranks:\n            The rank dict to reference for sorting. If ``None``, it will\n            default to ``DEFAULT_RANKS``.\n\n        :returns:\n            The sorted cards.\n\n        \"\"\"\n        ranks = ranks or self.ranks\n        self.cards = sort_cards(self.cards, ranks)"}}, "leetcode/csn_python_train_202304.txt": {"score": 0.8511670827865601, "content": {"text": "def sort_card_indices(cards, indices, ranks=None):\n    \"\"\"\n    Sorts the given Deck indices by the given ranks. Must also supply the\n    ``Stack``, ``Deck``, or ``list`` that the indices are from.\n\n    :arg cards:\n        The cards the indices are from. Can be a ``Stack``, ``Deck``, or\n        ``list``\n    :arg list indices:\n        The indices to sort.\n    :arg dict ranks:\n        The rank dict to reference for sorting. If ``None``, it will\n        default to ``DEFAULT_RANKS``.\n\n    :returns:\n        The sorted indices.\n\n    \"\"\"\n    ranks = ranks or DEFAULT_RANKS\n\n    if ranks.get(\"suits\"):\n        indices = sorted(\n            indices,\n            key=lambda x: ranks[\"suits\"][cards[x].suit] if\n                cards[x].suit != None else 0\n        )\n    if ranks.get(\"values\"):\n        indices = sorted(\n            indices,\n            key=lambda x: ranks[\"values\"][cards[x].value]\n        )\n\n    return indices"}}, "leetcode/csn_python_train_72554.txt": {"score": 0.8577622771263123, "content": {"text": "def score_x_of_a_kind_yatzy(dice: List[int], min_same_faces: int) -> int:\n    \"\"\"Similar to yahtzee, but only return the sum of the dice that satisfy min_same_faces\n    \"\"\"\n    for die, count in Counter(dice).most_common(1):\n        if count >= min_same_faces:\n            return die * min_same_faces\n    return 0"}}, "leetcode/csn_python_train_313626.txt": {"score": 0.8620074391365051, "content": {"text": "def find_pairs(self, tiles_34, first_index=0, second_index=33):\n        \"\"\"\n        Find all possible pairs in the hand and return their indices\n        :return: array of pair indices\n        \"\"\"\n        pair_indices = []\n        for x in range(first_index, second_index + 1):\n            # ignore pon of honor tiles, because it can't be a part of pair\n            if x in HONOR_INDICES and tiles_34[x] != 2:\n                continue\n\n            if tiles_34[x] >= 2:\n                pair_indices.append(x)\n\n        return pair_indices"}}, "leetcode/csn_python_train_313624.txt": {"score": 0.8602257370948792, "content": {"text": "def is_condition_met(self, hand, *args):\n        \"\"\"\n        Hand composed entirely of honour tiles.\n        :param hand: list of hand's sets\n        :return: boolean\n        \"\"\"\n        indices = reduce(lambda z, y: z + y, hand)\n        return all(x in HONOR_INDICES for x in indices)"}}, "leetcode/csn_python_train_202299.txt": {"score": 0.8594744801521301, "content": {"text": "def compare_stacks(cards_x, cards_y, sorted=False):\n    \"\"\"\n    Checks whether two given ``Stack``, ``Deck``, or ``list`` instances,\n    contain the same cards (based on value & suit, not instance). Does not\n    take into account the ordering.\n\n    :arg cards_x:\n        The first stack to check. Can be a ``Stack``, ``Deck``, or ``list``\n        instance.\n    :arg cards_y:\n        The second stack to check. Can be a ``Stack``, ``Deck``, or ``list``\n        instance.\n    :arg bool sorted:\n        Whether or not the cards are already sorted. If ``True``, then\n        ``compare_stacks`` will skip the sorting process.\n\n    :returns:\n        ``True`` or ``False``.\n\n    \"\"\"\n    if len(cards_x) == len(cards_y):\n        if not sorted:\n            cards_x = sort_cards(cards_x, DEFAULT_RANKS)\n            cards_y = sort_cards(cards_y, DEFAULT_RANKS)\n        for i, c in enumerate(cards_x):\n            if c != cards_y[i]:\n                return False\n        return True\n    else:\n        return False"}}, "leetcode/leetcode_2347.txt": {"score": 0.9980034828186035, "content": {"text": "def best_poker_hand(ranks, suits):\n    \"\"\"You are given an integer array `ranks` and a character array `suits`. You have `5` cards where the `ith` card has a rank of `ranks[i]` and a suit of `suits[i]`.\n\nThe following are the types of **poker hands** you can make from best to worst:\n\n1.  `\"Flush \"`: Five cards of the same suit.\n2.  `\"Three of a Kind \"`: Three cards of the same rank.\n3.  `\"Pair \"`: Two cards of the same rank.\n4.  `\"High Card \"`: Any single card.\n\nReturn _a string representing the **best** type of **poker hand** you can make with the given cards._\n\n**Note** that the return values are **case-sensitive**.\n\n**Example 1:**\n\n**Input:** ranks = \\[13,2,3,1,9\\], suits = \\[ \"a \", \"a \", \"a \", \"a \", \"a \"\\]\n**Output:**  \"Flush \"\n**Explanation:** The hand with all the cards consists of 5 cards with the same suit, so we have a  \"Flush \".\n\n**Example 2:**\n\n**Input:** ranks = \\[4,4,2,4,4\\], suits = \\[ \"d \", \"a \", \"a \", \"b \", \"c \"\\]\n**Output:**  \"Three of a Kind \"\n**Explanation:** The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a  \"Three of a Kind \".\nNote that we could also make a  \"Pair \" hand but  \"Three of a Kind \" is a better hand.\nAlso note that other cards could be used to make the  \"Three of a Kind \" hand.\n\n**Example 3:**\n\n**Input:** ranks = \\[10,10,2,12,9\\], suits = \\[ \"a \", \"b \", \"c \", \"a \", \"d \"\\]\n**Output:**  \"Pair \"\n**Explanation:** The hand with the first and second card consists of 2 cards with the same rank, so we have a  \"Pair \".\nNote that we cannot make a  \"Flush \" or a  \"Three of a Kind \".\n\n**Constraints:**\n\n*   `ranks.length == suits.length == 5`\n*   `1 <= ranks[i] <= 13`\n*   `'a' <= suits[i] <= 'd'`\n*   No two cards have the same rank and suit.\"\"\"\n\n    rank_count = {}\n    suit_count = {}\n    for rank, suit in zip(ranks, suits):\n        rank_count[rank] = rank_count.get(rank, 0) + 1\n        suit_count[suit] = suit_count.get(suit, 0) + 1\n    if len(suit_count) == 1:\n        return \"Flush \"\n    if len(rank_count) == 3:\n        return \"Three of a Kind \"\n    for value in rank_count.values():\n        if value == 2:\n            return \"Pair \"\n    return \"High Card \""}}, "leetcode/csn_python_train_202305.txt": {"score": 0.8803592324256897, "content": {"text": "def sort_cards(cards, ranks=None):\n    \"\"\"\n    Sorts a given list of cards, either by poker ranks, or big two ranks.\n\n    :arg cards:\n        The cards to sort.\n    :arg dict ranks:\n        The rank dict to reference for sorting. If ``None``, it will\n        default to ``DEFAULT_RANKS``.\n\n    :returns:\n        The sorted cards.\n\n    \"\"\"\n    ranks = ranks or DEFAULT_RANKS\n\n    if ranks.get(\"suits\"):\n        cards = sorted(\n            cards,\n            key=lambda x: ranks[\"suits\"][x.suit] if x.suit != None else 0\n        )\n    if ranks.get(\"values\"):\n        cards = sorted(\n            cards,\n            key=lambda x: ranks[\"values\"][x.value]\n        )\n\n    return cards"}}, "leetcode/csn_python_train_72553.txt": {"score": 0.864881157875061, "content": {"text": "def score_x_of_a_kind_yahtzee(dice: List[int], min_same_faces: int) -> int:\n    \"\"\"Return sum of dice if there are a minimum of equal min_same_faces dice, otherwise\n    return zero. Only works for 3 or more min_same_faces.\n    \"\"\"\n    for die, count in Counter(dice).most_common(1):\n        if count >= min_same_faces:\n            return sum(dice)\n    return 0"}}}}, "128": {"gold": {"leetcode/leetcode_56.txt": 1, "leetcode/leetcode_1419.txt": 1}, "retrieved": {"leetcode/leetcode_2322.txt": {"score": 0.8946515917778015, "content": {"text": "def dfs(node, parent, xor_values, tree):\n    \"\"\"There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nRemove two **distinct** edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n\n1.  Get the XOR of all the values of the nodes for **each** of the three components respectively.\n2.  The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair.\n\n*   For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = **6**`, `1 ^ 9 = **8**`, and `3 ^ 3 ^ 3 = **3**`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn _the **minimum** score of any possible pair of edge removals on the given tree_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,5,4,11\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\]\n**Output:** 9\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[1,3,4\\] with values \\[5,4,11\\]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2nd component has node \\[0\\] with value \\[1\\]. Its XOR value is 1 = 1.\n- The 3rd component has node \\[2\\] with value \\[5\\]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9.\n\n**Example 2:**\n\n**Input:** nums = \\[5,5,2,4,4,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[5,2\\],\\[4,3\\],\\[1,3\\]\\]\n**Output:** 0\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[3,4\\] with values \\[4,4\\]. Its XOR value is 4 ^ 4 = 0.\n- The 2nd component has nodes \\[1,0\\] with values \\[5,5\\]. Its XOR value is 5 ^ 5 = 0.\n- The 3rd component has nodes \\[2,5\\] with values \\[2,2\\]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `3 <= n <= 1000`\n*   `1 <= nums[i] <= 108`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n    xor_value = xor_values[node]\n    for child in tree[node]:\n        if child != parent:\n            xor_value ^= dfs(child, node, xor_values, tree)\n    return xor_value\n\n\ndef minimumScore(nums, edges):\n    n = len(nums)\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]\n    \n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor1 = xor_values[i]\n            xor2 = xor_values[j] ^ nums[i]\n            xor3 = nums[i] ^ nums[j]\n            max_xor = max(xor1, xor2, xor3)\n            min_xor = min(xor1, xor2, xor3)\n            ans = min(ans, max_xor - min_xor)\n    \n    return ans"}}, "leetcode/leetcode_886.txt": {"score": 0.8952893614768982, "content": {"text": "def scoreOfParentheses(s):\n    \"\"\"We want to split a group of `n` people (labeled from `1` to `n`) into two groups of **any size**. Each person may dislike some other people, and they should not go into the same group.\n\nGiven the integer `n` and the array `dislikes` where `dislikes[i] = [ai, bi]` indicates that the person labeled `ai` does not like the person labeled `bi`, return `true` _if it is possible to split everyone into two groups in this way_.\n\n**Example 1:**\n\n**Input:** n = 4, dislikes = \\[\\[1,2\\],\\[1,3\\],\\[2,4\\]\\]\n**Output:** true\n**Explanation:** The first group has \\[1,4\\], and the second group has \\[2,3\\].\n\n**Example 2:**\n\n**Input:** n = 3, dislikes = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** false\n**Explanation:** We need at least 3 groups to divide them. We cannot put them in two groups.\n\n**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `0 <= dislikes.length <= 104`\n*   `dislikes[i].length == 2`\n*   `1 <= ai < bi <= n`\n*   All the pairs of `dislikes` are **unique**.\"\"\"\n\n    score, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 1\n        else:\n            depth -= 1\n            if s[i - 1] == '(':\n                score += 1 << depth\n    return score"}}, "leetcode/leetcode_56.txt": {"score": 0.9020681977272034, "content": {"text": "def merge(intervals):\n    \"\"\"Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[2,6\\],\\[8,10\\],\\[15,18\\]\\]\n**Output:** \\[\\[1,6\\],\\[8,10\\],\\[15,18\\]\\]\n**Explanation:** Since intervals \\[1,3\\] and \\[2,6\\] overlap, merge them into \\[1,6\\].\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[4,5\\]\\]\n**Output:** \\[\\[1,5\\]\\]\n**Explanation:** Intervals \\[1,4\\] and \\[4,5\\] are considered overlapping.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti <= endi <= 104`\"\"\"\n\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result"}}, "leetcode/csn_python_train_76002.txt": {"score": 0.9012068510055542, "content": {"text": "def _add_interval(all_intervals, new_interval):\n        \"\"\"\n        Adds a new interval to a set of none overlapping intervals.\n\n        :param set[(int,int)] all_intervals: The set of distinct intervals.\n        :param (int,int) new_interval: The new interval.\n        \"\"\"\n        intervals = None\n        old_interval = None\n        for old_interval in all_intervals:\n            intervals = Type2CondenseHelper._distinct(new_interval, old_interval)\n            if intervals:\n                break\n\n        if intervals is None:\n            all_intervals.add(new_interval)\n        else:\n            if old_interval:\n                all_intervals.remove(old_interval)\n            for distinct_interval in intervals:\n                Type2CondenseHelper._add_interval(all_intervals, distinct_interval)"}}, "leetcode/leetcode_2157.txt": {"score": 0.9040006399154663, "content": {"text": "from heapq import heappop, heappush\n    \"\"\"You are given a **0-indexed** array of strings `words`. Each string consists of **lowercase English letters** only. No letter occurs more than once in any string of `words`.\n\nTwo strings `s1` and `s2` are said to be **connected** if the set of letters of `s2` can be obtained from the set of letters of `s1` by any **one** of the following operations:\n\n*   Adding exactly one letter to the set of the letters of `s1`.\n*   Deleting exactly one letter from the set of the letters of `s1`.\n*   Replacing exactly one letter from the set of the letters of `s1` with any letter, **including** itself.\n\nThe array `words` can be divided into one or more non-intersecting **groups**. A string belongs to a group if any **one** of the following is true:\n\n*   It is connected to **at least one** other string of the group.\n*   It is the **only** string present in the group.\n\nNote that the strings in `words` should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.\n\nReturn _an array_ `ans` _of size_ `2` _where:_\n\n*   `ans[0]` _is the **maximum number** of groups_ `words` _can be divided into, and_\n*   `ans[1]` _is the **size of the largest** group_.\n\n**Example 1:**\n\n**Input:** words = \\[ \"a \", \"b \", \"ab \", \"cde \"\\]\n**Output:** \\[2,3\\]\n**Explanation:**\n- words\\[0\\] can be used to obtain words\\[1\\] (by replacing 'a' with 'b'), and words\\[2\\] (by adding 'b'). So words\\[0\\] is connected to words\\[1\\] and words\\[2\\].\n- words\\[1\\] can be used to obtain words\\[0\\] (by replacing 'b' with 'a'), and words\\[2\\] (by adding 'a'). So words\\[1\\] is connected to words\\[0\\] and words\\[2\\].\n- words\\[2\\] can be used to obtain words\\[0\\] (by deleting 'b'), and words\\[1\\] (by deleting 'a'). So words\\[2\\] is connected to words\\[0\\] and words\\[1\\].\n- words\\[3\\] is not connected to any string in words.\nThus, words can be divided into 2 groups \\[ \"a \", \"b \", \"ab \"\\] and \\[ \"cde \"\\]. The size of the largest group is 3.  \n\n**Example 2:**\n\n**Input:** words = \\[ \"a \", \"ab \", \"abc \"\\]\n**Output:** \\[1,3\\]\n**Explanation:**\n- words\\[0\\] is connected to words\\[1\\].\n- words\\[1\\] is connected to words\\[0\\] and words\\[2\\].\n- words\\[2\\] is connected to words\\[1\\].\nSince all strings are connected to each other, they should be grouped together.\nThus, the size of the largest group is 3.\n\n**Constraints:**\n\n*   `1 <= words.length <= 2 * 104`\n*   `1 <= words[i].length <= 26`\n*   `words[i]` consists of lowercase English letters only.\n*   No letter occurs more than once in `words[i]`.\"\"\"\n\n\ndef smallest_subsequence(s, k, letter, repetition):\n    result = []\n    letter_count = s.count(letter)\n\n    pq = []\n    for c in s:\n        if c <= letter or letter_count > repetition:\n            while pq and pq[0] > c:\n                if heappop(pq) == letter:\n                    letter_count -= 1\n            heappush(pq, c)\n            if len(pq) > k:\n                heappop(pq)\n        if k - len(pq) == repetition:\n            letter_count -= 1\n        repetition = max(0, repetition)\n\n    return \"\".join(pq)"}}, "leetcode/leetcode_1943.txt": {"score": 0.9394266605377197, "content": {"text": "def splitPainting(segments):\n    \"\"\"There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a **unique** color. You are given a 2D integer array `segments`, where `segments[i] = [starti, endi, colori]` represents the **half-closed segment** `[starti, endi)` with `colori` as the color.\n\nThe colors in the overlapping segments of the painting were **mixed** when it was painted. When two or more colors mix, they form a new color that can be represented as a **set** of mixed colors.\n\n*   For example, if colors `2`, `4`, and `6` are mixed, then the resulting mixed color is `{2,4,6}`.\n\nFor the sake of simplicity, you should only output the **sum** of the elements in the set rather than the full set.\n\nYou want to **describe** the painting with the **minimum** number of non-overlapping **half-closed segments** of these mixed colors. These segments can be represented by the 2D array `painting` where `painting[j] = [leftj, rightj, mixj]` describes a **half-closed segment** `[leftj, rightj)` with the mixed color **sum** of `mixj`.\n\n*   For example, the painting created with `segments = [[1,4,5],[1,7,7]]` can be described by `painting = [[1,4,12],[4,7,7]]` because:\n    *   `[1,4)` is colored `{5,7}` (with a sum of `12`) from both the first and second segments.\n    *   `[4,7)` is colored `{7}` from only the second segment.\n\nReturn _the 2D array_ `painting` _describing the finished painting (excluding any parts that are **not** painted). You may return the segments in **any order**_.\n\nA **half-closed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`.\n\n**Example 1:**\n\n**Input:** segments = \\[\\[1,4,5\\],\\[4,7,7\\],\\[1,7,9\\]\\]\n**Output:** \\[\\[1,4,14\\],\\[4,7,16\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,4) is colored {5,9} (with a sum of 14) from the first and third segments.\n- \\[4,7) is colored {7,9} (with a sum of 16) from the second and third segments.\n\n**Example 2:**\n\n**Input:** segments = \\[\\[1,7,9\\],\\[6,8,15\\],\\[8,10,7\\]\\]\n**Output:** \\[\\[1,6,9\\],\\[6,7,24\\],\\[7,8,15\\],\\[8,10,7\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,6) is colored 9 from the first segment.\n- \\[6,7) is colored {9,15} (with a sum of 24) from the first and second segments.\n- \\[7,8) is colored 15 from the second segment.\n- \\[8,10) is colored 7 from the third segment.\n\n**Example 3:**\n\n**Input:** segments = \\[\\[1,4,5\\],\\[1,4,7\\],\\[4,7,1\\],\\[4,7,11\\]\\]\n**Output:** \\[\\[1,4,12\\],\\[4,7,12\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,4) is colored {5,7} (with a sum of 12) from the first and second segments.\n- \\[4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.\nNote that returning a single segment \\[1,7) is incorrect because the mixed color sets are different.\n\n**Constraints:**\n\n*   `1 <= segments.length <= 2 * 104`\n*   `segments[i].length == 3`\n*   `1 <= starti < endi <= 105`\n*   `1 <= colori <= 109`\n*   Each `colori` is distinct.\"\"\"\n\n    line = {}\n    for s in segments:\n        start, end, color = s\n        if start not in line:\n            line[start] = 0\n        if end not in line:\n            line[end] = 0\n        line[start] += color\n        line[end] -= color\n    res = []\n    pre = 0\n    sum = 0\n    for key in sorted(line.keys()):\n        if pre > 0:\n            if sum > 0:\n                res.append([pre, key, sum])\n        pre = key\n        sum += line[key]\n    return res"}}, "leetcode/csn_python_train_320943.txt": {"score": 0.9032358527183533, "content": {"text": "def intervals_union(S):\n    \"\"\"Union of intervals\n\n    :param S: list of pairs (low, high) defining intervals [low, high)\n    :returns: ordered list of disjoint intervals with the same union as S\n    :complexity: O(n log n)\n    \"\"\"\n    E = [(low, -1) for (low, high) in S]\n    E += [(high, +1) for (low, high) in S]\n    nb_open = 0\n    last = None\n    retval = []\n    for x, _dir in sorted(E):\n        if _dir == -1:\n            if nb_open == 0:\n                last = x\n            nb_open += 1\n        else:\n            nb_open -= 1\n            if nb_open == 0:\n                retval.append((last, x))\n    return retval"}}, "leetcode/leetcode_2580.txt": {"score": 0.9398429989814758, "content": {"text": "def total_ways_to_split_ranges(ranges):\n    \"\"\"You are given a 2D integer array `ranges` where `ranges[i] = [starti, endi]` denotes that all integers between `starti` and `endi` (both **inclusive**) are contained in the `ith` range.\n\nYou are to split `ranges` into **two** (possibly empty) groups such that:\n\n*   Each range belongs to exactly one group.\n*   Any two **overlapping** ranges must belong to the **same** group.\n\nTwo ranges are said to be **overlapping** if there exists at least **one** integer that is present in both ranges.\n\n*   For example, `[1, 3]` and `[2, 5]` are overlapping because `2` and `3` occur in both ranges.\n\nReturn _the **total number** of ways to split_ `ranges` _into two groups_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** ranges = \\[\\[6,10\\],\\[5,15\\]\\]\n**Output:** 2\n**Explanation:** \nThe two ranges are overlapping, so they must be in the same group.\nThus, there are two possible ways:\n- Put both the ranges together in group 1.\n- Put both the ranges together in group 2.\n\n**Example 2:**\n\n**Input:** ranges = \\[\\[1,3\\],\\[10,20\\],\\[2,5\\],\\[4,8\\]\\]\n**Output:** 4\n**Explanation:** \nRanges \\[1,3\\], and \\[2,5\\] are overlapping. So, they must be in the same group.\nAgain, ranges \\[2,5\\] and \\[4,8\\] are also overlapping. So, they must also be in the same group. \nThus, there are four possible ways to group them:\n- All the ranges in group 1.\n- All the ranges in group 2.\n- Ranges \\[1,3\\], \\[2,5\\], and \\[4,8\\] in group 1 and \\[10,20\\] in group 2.\n- Ranges \\[1,3\\], \\[2,5\\], and \\[4,8\\] in group 2 and \\[10,20\\] in group 1.\n\n**Constraints:**\n\n*   `1 <= ranges.length <= 105`\n*   `ranges[i].length == 2`\n*   `0 <= starti <= endi <= 109`\"\"\"\n\n    MOD = 10**9 + 7\n    ranges.sort(key=lambda x: x[1])\n    overlapping, non_overlapping, prev_end = 0, 1, -1\n\n    for start, end in ranges:\n        if start <= prev_end:\n            overlapping += 1\n        else:\n            non_overlapping += 1\n        prev_end = max(prev_end, end)\n\n    result = 1\n    for i in range(1, overlapping + 1):\n        result = (result * 2) % MOD\n\n    return result"}}, "leetcode/leetcode_1024.txt": {"score": 0.9014577865600586, "content": {"text": "def count_and_triples(nums):\n    \"\"\"You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n*   For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** clips = \\[\\[0,2\\],\\[4,6\\],\\[8,10\\],\\[1,9\\],\\[1,5\\],\\[5,9\\]\\], time = 10\n**Output:** 3\n**Explanation:** We take the clips \\[0,2\\], \\[8,10\\], \\[1,9\\]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut \\[1,9\\] into segments \\[1,2\\] + \\[2,8\\] + \\[8,9\\].\nNow we have segments \\[0,2\\] + \\[2,8\\] + \\[8,10\\] which cover the sporting event \\[0, 10\\].\n\n**Example 2:**\n\n**Input:** clips = \\[\\[0,1\\],\\[1,2\\]\\], time = 5\n**Output:** -1\n**Explanation:** We cannot cover \\[0,5\\] with only \\[0,1\\] and \\[1,2\\].\n\n**Example 3:**\n\n**Input:** clips = \\[\\[0,1\\],\\[6,8\\],\\[0,2\\],\\[5,6\\],\\[0,4\\],\\[0,3\\],\\[6,7\\],\\[1,3\\],\\[4,7\\],\\[1,4\\],\\[2,5\\],\\[2,6\\],\\[3,4\\],\\[4,5\\],\\[5,7\\],\\[6,9\\]\\], time = 9\n**Output:** 3\n**Explanation:** We can take clips \\[0,4\\], \\[4,7\\], and \\[6,9\\].\n\n**Constraints:**\n\n*   `1 <= clips.length <= 100`\n*   `0 <= starti <= endi <= 100`\n*   `1 <= time <= 100`\n\n0 <= i < j < k < nums.length, and nums\\[i\\] & nums\\[j\\] & nums\\[k\\] != 0. (\\`&\\` represents the bitwise AND operation.)\"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count"}}, "leetcode/leetcode_2406.txt": {"score": 0.9948969483375549, "content": {"text": "import heapq\n    \"\"\"You are given a 2D integer array `intervals` where `intervals[i] = [lefti, righti]` represents the **inclusive** interval `[lefti, righti]`.\n\nYou have to divide the intervals into one or more **groups** such that each interval is in **exactly** one group, and no two intervals that are in the same group **intersect** each other.\n\nReturn _the **minimum** number of groups you need to make_.\n\nTwo intervals **intersect** if there is at least one common number between them. For example, the intervals `[1, 5]` and `[5, 8]` intersect.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[5,10\\],\\[6,8\\],\\[1,5\\],\\[2,3\\],\\[1,10\\]\\]\n**Output:** 3\n**Explanation:** We can divide the intervals into the following groups:\n- Group 1: \\[1, 5\\], \\[6, 8\\].\n- Group 2: \\[2, 3\\], \\[5, 10\\].\n- Group 3: \\[1, 10\\].\nIt can be proven that it is not possible to divide the intervals into fewer than 3 groups.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[5,6\\],\\[8,10\\],\\[11,13\\]\\]\n**Output:** 1\n**Explanation:** None of the intervals overlap, so we can put all of them in one group.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `intervals[i].length == 2`\n*   `1 <= lefti <= righti <= 106`\"\"\"\n\n\ndef min_groups(intervals):\n    intervals.sort()\n    pq = []\n    for interval in intervals:\n        if pq and pq[0] < interval[0]:\n            heapq.heappop(pq)\n        heapq.heappush(pq, interval[1])\n    return len(pq)"}}}}, "129": {"gold": {"leetcode/leetcode_1360.txt": 1, "leetcode/leetcode_2224.txt": 1}, "retrieved": {"leetcode/csn_python_train_147478.txt": {"score": 0.8753155469894409, "content": {"text": "def n_weekends(self) -> int:\n        \"\"\"\n        Returns the number of weekends that the intervals collectively touch\n        (where \"touching a weekend\" means \"including time on a Saturday or a\n        Sunday\").\n        \"\"\"\n        saturdays = set()\n        for interval in self.intervals:\n            saturdays.update(interval.saturdays_of_weekends())\n        return len(saturdays)"}}, "leetcode/csn_python_train_283693.txt": {"score": 0.8789966106414795, "content": {"text": "def genInterval(self,\n                    month=(),\n                    day=(),\n                    week=(),\n                    weekday=(),\n                    hour=(),\n                    minute=()):\n        '''Generate list of config dictionarie(s) that represent a interval of time. Used to be passed into add() or remove().\n        For example::\n\n            genInterval(month=(1,4), week(1,4))\n            # generate list contains from first to third week in from January to March\n\n        Args:\n            month (tuple): (start, end) month in a year, from 1 to 12\n            week (tuple): (start, end) week in a month, from 1 to 4\n            day (tuple): (start, end) day in a month, from 1 to 31\n            weekday (tuple): (start, end) weekday in a week, from 0 to 7. 0 and 7 both represent Sunday\n            hour (tuple): (start, end) hour in a day, from 0 to 24\n            minute (tuple): (start, end) minute in an hour, from 0 to 59\n\n        Returns:\n            list: a list of dictionarie(s) with form [{'Day':12, 'Month':3}, {}, etc]\n        '''\n        dic = {\n            'Month': month,\n            'Day': day,\n            'Week': week,\n            'Weekday': weekday,\n            'Day': day,\n            'Hour': hour,\n            'Minute': minute\n        }\n        dic = {k: v for k, v in dic.items() if v != ()}\n        # e.g. dic: {'month': (1,5), 'day': (2,4)}\n        grandList = []\n        for k in dic:\n            # e.g. k: 'month', dic[k]: (1,5)\n            l = []\n            # rangeTuple = (dic[k][0], dic[k][1] + 1)  # e.g. (1,6)\n            rangeTuple = dic[k]\n            for num in range(rangeTuple[0],\n                             rangeTuple[1]):  # e.g. 1, 2, 3, 4, 5\n                l.append({k: num})  # e.g. [{'month': 1}, {'month': 2}]\n            grandList.append(l)  # e.g. [[list of month], [list of day]]\n        print(grandList)\n        # grandList: [[list of month], [list of day]]\n        # l: [[a,a1,a2,...], [b,b1,b2,...]]\n        # combineDict return: [{a,b}, {a,b1}, {a,b2}, {a1,b}, {a1,b1}, {a1, b2}, {a2,b}, {a2,b1}, {a2,b2}]\n        return crossCombine(grandList)"}}, "leetcode/csn_python_train_98458.txt": {"score": 0.8841041922569275, "content": {"text": "def GetServicePeriodsActiveEachDate(self, date_start, date_end):\n    \"\"\"Return a list of tuples (date, [period1, period2, ...]).\n\n    For each date in the range [date_start, date_end) make list of each\n    ServicePeriod object which is active.\n\n    Args:\n      date_start: The first date in the list, a date object\n      date_end: The first date after the list, a date object\n\n    Returns:\n      A list of tuples. Each tuple contains a date object and a list of zero or\n      more ServicePeriod objects.\n    \"\"\"\n    date_it = date_start\n    one_day = datetime.timedelta(days=1)\n    date_service_period_list = []\n    while date_it < date_end:\n      periods_today = []\n      date_it_string = date_it.strftime(\"%Y%m%d\")\n      for service in self.GetServicePeriodList():\n        if service.IsActiveOn(date_it_string, date_it):\n          periods_today.append(service)\n      date_service_period_list.append((date_it, periods_today))\n      date_it += one_day\n    return date_service_period_list"}}, "leetcode/leetcode_1854.txt": {"score": 0.8812981843948364, "content": {"text": "def maxAliveYear(logs):\n    \"\"\"You are given a 2D integer array `logs` where each `logs[i] = [birthi, deathi]` indicates the birth and death years of the `ith` person.\n\nThe **population** of some year `x` is the number of people alive during that year. The `ith` person is counted in year `x`'s population if `x` is in the **inclusive** range `[birthi, deathi - 1]`. Note that the person is **not** counted in the year that they die.\n\nReturn _the **earliest** year with the **maximum population**_.\n\n**Example 1:**\n\n**Input:** logs = \\[\\[1993,1999\\],\\[2000,2010\\]\\]\n**Output:** 1993\n**Explanation:** The maximum population is 1, and 1993 is the earliest year with this population.\n\n**Example 2:**\n\n**Input:** logs = \\[\\[1950,1961\\],\\[1960,1971\\],\\[1970,1981\\]\\]\n**Output:** 1960\n**Explanation:** \nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960.\n\n**Constraints:**\n\n*   `1 <= logs.length <= 100`\n*   `1950 <= birthi < deathi <= 2050`\"\"\"\n\n    years = [0] * 101\n    for log in logs:\n        years[log[0] - 1950] += 1\n        years[log[1] - 1950] -= 1\n    max_population = years[0]\n    max_year = 1950\n    for i in range(1, 101):\n        years[i] += years[i - 1]\n        if years[i] > max_population:\n            max_population = years[i]\n            max_year = i + 1950\n    return max_year"}}, "leetcode/csn_python_train_56159.txt": {"score": 0.8800151348114014, "content": {"text": "def windows_intersection(windows):\n    \"\"\"Given a list of (beginning, ending), return another describing where they overlap.\n\n    :rtype: list\n    \"\"\"\n\n    def intersect2(left, right):\n        if left == right:\n            return left\n        elif left is (None, None):\n            return right\n        elif right is (None, None):\n            return left\n        elif left[0] is None:\n            if right[0] is None:\n                return None, min((left[1], right[1]))\n            elif right[1] is None:\n                if left[1] <= right[0]:\n                    return left[1], right[0]\n                else:\n                    return None\n            elif right[0] <= left[1]:\n                return right[0], left[1]\n            else:\n                return None\n        elif left[1] is None:\n            if right[0] is None:\n                return left[0], right[1]\n            else:\n                return right  # assumes left[0] <= right[0]\n        # None not in left\n        elif right[0] is None:\n            return left[0], min((left[1], right[1]))\n        elif right[1] is None:\n            if left[1] >= right[0]:\n                return right[0], left[1]\n            else:\n                return None\n        assert None not in left and None not in right and left[0] < right[1]\n        if left[1] >= right[0]:\n            if right[1] > left[1]:\n                return right[0], left[1]\n            else:\n                return right\n        return None\n\n    if len(windows) == 1:\n        return windows\n    left_none = []\n    right_none = []\n    otherwise = []\n    for window in windows:\n        assert window is not None, None\n        if window[0] is None:\n            left_none.append(window)\n        elif window[1] is None:\n            right_none.append(window)\n        else:\n            otherwise.append(window)\n\n    done = []\n    todo = left_none + sorted(otherwise)\n    for window in todo:\n        if not done:\n            done.append(window)\n            continue\n        res = intersect2(done.pop(), window)\n        if res:\n            done.append(res)\n    return done"}}, "leetcode/leetcode_1904.txt": {"score": 0.8844761252403259, "content": {"text": "def second_largest_digit(s: str) -> int:\n    \"\"\"You are participating in an online chess tournament. There is a chess round that starts every `15` minutes. The first round of the day starts at `00:00`, and after every `15` minutes, a new round starts.\n\n*   For example, the second round starts at `00:15`, the fourth round starts at `00:45`, and the seventh round starts at `01:30`.\n\nYou are given two strings `loginTime` and `logoutTime` where:\n\n*   `loginTime` is the time you will login to the game, and\n*   `logoutTime` is the time you will logout from the game.\n\nIf `logoutTime` is **earlier** than `loginTime`, this means you have played from `loginTime` to midnight and from midnight to `logoutTime`.\n\nReturn _the number of full chess rounds you have played in the tournament_.\n\n**Note:** All the given times follow the 24-hour clock. That means the first round of the day starts at `00:00` and the last round of the day starts at `23:45`.\n\n**Example 1:**\n\n**Input:** loginTime =  \"09:31 \", logoutTime =  \"10:14 \"\n**Output:** 1\n**Explanation:** You played one full round from 09:45 to 10:00.\nYou did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began.\nYou did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended.\n\n**Example 2:**\n\n**Input:** loginTime =  \"21:30 \", logoutTime =  \"03:00 \"\n**Output:** 22\n**Explanation:** You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00.\n10 + 12 = 22.\n\n**Constraints:**\n\n*   `loginTime` and `logoutTime` are in the format `hh:mm`.\n*   `00 <= hh <= 23`\n*   `00 <= mm <= 59`\n*   `loginTime` and `logoutTime` are not equal.\"\"\"\n\n    largest = -1\n    second_largest = -1\n    for c in s:\n        if c.isdigit():\n            digit = int(c)\n            if digit > largest:\n                second_largest = largest\n                largest = digit\n            elif digit != largest and digit > second_largest:\n                second_largest = digit\n    return second_largest"}}, "leetcode/csn_python_train_147455.txt": {"score": 0.8864338397979736, "content": {"text": "def n_weekends(self) -> int:\n        \"\"\"\n        Returns the number of weekends that this interval covers. Includes\n        partial weekends.\n        \"\"\"\n        startdate = self.start.date()\n        enddate = self.end.date()\n        ndays = (enddate - startdate).days + 1\n        in_weekend = False\n        n_weekends = 0\n        for i in range(ndays):\n            date = startdate + datetime.timedelta(days=i)\n            if not in_weekend and is_weekend(date):\n                in_weekend = True\n                n_weekends += 1\n            elif in_weekend and not is_weekend(date):\n                in_weekend = False\n        return n_weekends"}}, "leetcode/leetcode_2409.txt": {"score": 0.99782794713974, "content": {"text": "def days_together(arrive_alice, leave_alice, arrive_bob, leave_bob):\n    \"\"\"Alice and Bob are traveling to Rome for separate business meetings.\n\nYou are given 4 strings `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob`. Alice will be in the city from the dates `arriveAlice` to `leaveAlice` (**inclusive**), while Bob will be in the city from the dates `arriveBob` to `leaveBob` (**inclusive**). Each will be a 5-character string in the format `\"MM-DD \"`, corresponding to the month and day of the date.\n\nReturn _the total number of days that Alice and Bob are in Rome together._\n\nYou can assume that all dates occur in the **same** calendar year, which is **not** a leap year. Note that the number of days per month can be represented as: `[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`.\n\n**Example 1:**\n\n**Input:** arriveAlice =  \"08-15 \", leaveAlice =  \"08-18 \", arriveBob =  \"08-16 \", leaveBob =  \"08-19 \"\n**Output:** 3\n**Explanation:** Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n\n**Example 2:**\n\n**Input:** arriveAlice =  \"10-01 \", leaveAlice =  \"10-31 \", arriveBob =  \"11-01 \", leaveBob =  \"12-31 \"\n**Output:** 0\n**Explanation:** There is no day when Alice and Bob are in Rome together, so we return 0.\n\n**Constraints:**\n\n*   All dates are provided in the format `\"MM-DD \"`.\n*   Alice and Bob's arrival dates are **earlier than or equal to** their leaving dates.\n*   The given dates are valid dates of a **non-leap** year.\"\"\"\n\n    days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def date_to_days(date):\n        month, day = map(int, date.split('-'))\n        return sum(days_in_month[:month]) + day\n\n    arrive_days_alice = date_to_days(arrive_alice)\n    leave_days_alice = date_to_days(leave_alice)\n    arrive_days_bob = date_to_days(arrive_bob)\n    leave_days_bob = date_to_days(leave_bob)\n\n    common_start_date = max(arrive_days_alice, arrive_days_bob)\n    common_end_date = min(leave_days_alice, leave_days_bob)\n\n    return max(0, common_end_date - common_start_date + 1)"}}, "leetcode/csn_python_train_75830.txt": {"score": 0.8823961019515991, "content": {"text": "def _intersect(start1, end1, start2, end2):\n        \"\"\"\n        Returns the intersection of two intervals. Returns (None,None) if the intersection is empty.\n\n        :param int start1: The start date of the first interval.\n        :param int end1: The end date of the first interval.\n        :param int start2: The start date of the second interval.\n        :param int end2: The end date of the second interval.\n\n        :rtype: tuple[int|None,int|None]\n        \"\"\"\n        start = max(start1, start2)\n        end = min(end1, end2)\n\n        if start > end:\n            return None, None\n\n        return start, end"}}, "leetcode/leetcode_2446.txt": {"score": 0.9020346403121948, "content": {"text": "def has_event_conflict(start1: str, end1: str, start2: str, end2: str) -> bool:\n    \"\"\"You are given two arrays of strings that represent two inclusive events that happened **on the same day**, `event1` and `event2`, where:\n\n*   `event1 = [startTime1, endTime1]` and\n*   `event2 = [startTime2, endTime2]`.\n\nEvent times are valid 24 hours format in the form of `HH:MM`.\n\nA **conflict** happens when two events have some non-empty intersection (i.e., some moment is common to both events).\n\nReturn `true` _if there is a conflict between two events. Otherwise, return_ `false`.\n\n**Example 1:**\n\n**Input:** event1 = \\[ \"01:15 \", \"02:00 \"\\], event2 = \\[ \"02:00 \", \"03:00 \"\\]\n**Output:** true\n**Explanation:** The two events intersect at time 2:00.\n\n**Example 2:**\n\n**Input:** event1 = \\[ \"01:00 \", \"02:00 \"\\], event2 = \\[ \"01:20 \", \"03:00 \"\\]\n**Output:** true\n**Explanation:** The two events intersect starting from 01:20 to 02:00.\n\n**Example 3:**\n\n**Input:** event1 = \\[ \"10:00 \", \"11:00 \"\\], event2 = \\[ \"14:00 \", \"15:00 \"\\]\n**Output:** false\n**Explanation:** The two events do not intersect.\n\n**Constraints:**\n\n*   `evnet1.length == event2.length == 2.`\n*   `event1[i].length == event2[i].length == 5`\n*   `startTime1 <= endTime1`\n*   `startTime2 <= endTime2`\n*   All the event times follow the `HH:MM` format.\"\"\"\n\n    start_hour1, start_min1 = map(int, start1.split(\":\"))\n    start_hour2, start_min2 = map(int, start2.split(\":\"))\n    end_hour1, end_min1 = map(int, end1.split(\":\"))\n    end_hour2, end_min2 = map(int, end2.split(\":\"))\n\n    total_min1_start = start_hour1 * 60 + start_min1\n    total_min1_end = end_hour1 * 60 + end_min1\n    total_min2_start = start_hour2 * 60 + start_min2\n    total_min2_end = end_hour2 * 60 + end_min2\n\n    return not (total_min1_end <= total_min2_start or total_min1_start >= total_min2_end)"}}}}, "130": {"gold": {"leetcode/leetcode_1636.txt": 1, "leetcode/leetcode_2545.txt": 1}, "retrieved": {"leetcode/csn_python_train_329822.txt": {"score": 0.8569107055664062, "content": {"text": "def decreasing_probabilities(value):\n    \"\"\"\n    :param value: input string, comma separated or space separated\n    :returns: a list of decreasing probabilities\n\n    >>> decreasing_probabilities('1')\n    Traceback (most recent call last):\n    ...\n    ValueError: Not enough probabilities, found '1'\n    >>> decreasing_probabilities('0.2 0.1')\n    [0.2, 0.1]\n    >>> decreasing_probabilities('0.1 0.2')\n    Traceback (most recent call last):\n    ...\n    ValueError: The probabilities 0.1 0.2 are not in decreasing order\n    \"\"\"\n    probs = probabilities(value)\n    if len(probs) < 2:\n        raise ValueError('Not enough probabilities, found %r' % value)\n    elif sorted(probs, reverse=True) != probs:\n        raise ValueError('The probabilities %s are not in decreasing order'\n                         % value)\n    return probs"}}, "leetcode/csn_python_train_123536.txt": {"score": 0.8574521541595459, "content": {"text": "def multi_sort(remotes, sort):\n    \"\"\"Sort `remotes` in place. Allows sorting by multiple conditions.\n\n    This is needed because Python 3 no longer supports sorting lists of multiple types. Sort keys must all be of the\n    same type.\n\n    Problem: the user expects versions to be sorted latest first and timelogical to be most recent first (when viewing\n    the HTML documentation), yet expects alphabetical sorting to be A before Z.\n    Solution: invert integers (dates and parsed versions).\n\n    :param iter remotes: List of dicts from Versions().remotes.\n    :param iter sort: What to sort by. May be one or more of: alpha, time, semver\n    \"\"\"\n    exploded_alpha = list()\n    exploded_semver = list()\n\n    # Convert name to int if alpha is in sort.\n    if 'alpha' in sort:\n        alpha_max_len = max(len(r['name']) for r in remotes)\n        for name in (r['name'] for r in remotes):\n            exploded_alpha.append([ord(i) for i in name] + [0] * (alpha_max_len - len(name)))\n\n    # Parse versions if semver is in sort.\n    if 'semver' in sort:\n        exploded_semver = semvers(r['name'] for r in remotes)\n\n    # Build sort_mapping dict.\n    sort_mapping = dict()\n    for i, remote in enumerate(remotes):\n        key = list()\n        for sort_by in sort:\n            if sort_by == 'alpha':\n                key.extend(exploded_alpha[i])\n            elif sort_by == 'time':\n                key.append(-remote['date'])\n            elif sort_by == 'semver':\n                key.extend(exploded_semver[i])\n        sort_mapping[id(remote)] = key\n\n    # Sort.\n    remotes.sort(key=lambda k: sort_mapping.get(id(k)))"}}, "leetcode/leetcode_1333.txt": {"score": 0.8599804639816284, "content": {"text": "def sort_based_on_mapping(mapping, nums):\n    \"\"\"Given the array `restaurants` where `restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]`. You have to filter the restaurants using three filters.\n\nThe `veganFriendly` filter will be either _true_ (meaning you should only include restaurants with `veganFriendlyi` set to true) or _false_ (meaning you can include any restaurant). In addition, you have the filters `maxPrice` and `maxDistance` which are the maximum value for price and distance of restaurants you should consider respectively.\n\nReturn the array of restaurant _**IDs**_ after filtering, ordered by **rating** from highest to lowest. For restaurants with the same rating, order them by _**id**_ from highest to lowest. For simplicity `veganFriendlyi` and `veganFriendly` take value _1_ when it is _true_, and _0_ when it is _false_.\n\n**Example 1:**\n\n**Input:** restaurants = \\[\\[1,4,1,40,10\\],\\[2,8,0,50,5\\],\\[3,8,1,30,4\\],\\[4,10,0,10,3\\],\\[5,1,1,15,1\\]\\], veganFriendly = 1, maxPrice = 50, maxDistance = 10\n**Output:** \\[3,1,5\\] \n**Explanation:** \nThe restaurants are:\nRestaurant 1 \\[id=1, rating=4, veganFriendly=1, price=40, distance=10\\]\nRestaurant 2 \\[id=2, rating=8, veganFriendly=0, price=50, distance=5\\]\nRestaurant 3 \\[id=3, rating=8, veganFriendly=1, price=30, distance=4\\]\nRestaurant 4 \\[id=4, rating=10, veganFriendly=0, price=10, distance=3\\]\nRestaurant 5 \\[id=5, rating=1, veganFriendly=1, price=15, distance=1\\] \nAfter filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). \n\n**Example 2:**\n\n**Input:** restaurants = \\[\\[1,4,1,40,10\\],\\[2,8,0,50,5\\],\\[3,8,1,30,4\\],\\[4,10,0,10,3\\],\\[5,1,1,15,1\\]\\], veganFriendly = 0, maxPrice = 50, maxDistance = 10\n**Output:** \\[4,3,2,1,5\\]\n**Explanation:** The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.\n\n**Example 3:**\n\n**Input:** restaurants = \\[\\[1,4,1,40,10\\],\\[2,8,0,50,5\\],\\[3,8,1,30,4\\],\\[4,10,0,10,3\\],\\[5,1,1,15,1\\]\\], veganFriendly = 0, maxPrice = 30, maxDistance = 3\n**Output:** \\[4,5\\]\n\n**Constraints:**\n\n*   `1 <= restaurants.length <= 10^4`\n*   `restaurants[i].length == 5`\n*   `1 <= idi, ratingi, pricei, distancei <= 10^5`\n*   `1 <= maxPrice, maxDistance <= 10^5`\n*   `veganFriendlyi` and `veganFriendly` are 0 or 1.\n*   All `idi` are distinct.\"\"\"\n\n    def mapped_value(num):\n        return int(''.join(str(mapping[int(d)]) for d in str(num)))\n    \n    return sorted(nums, key=mapped_value)"}}, "leetcode/leetcode_2545.txt": {"score": 0.8575908541679382, "content": {"text": "def sort_students(score, k):\n    \"\"\"There is a class with `m` students and `n` exams. You are given a **0-indexed** `m x n` integer matrix `score`, where each row represents one student and `score[i][j]` denotes the score the `ith` student got in the `jth` exam. The matrix `score` contains **distinct** integers only.\n\nYou are also given an integer `k`. Sort the students (i.e., the rows of the matrix) by their scores in the `kth` (**0-indexed**) exam from the highest to the lowest.\n\nReturn _the matrix after sorting it._\n\n**Example 1:**\n\n**Input:** score = \\[\\[10,6,9,1\\],\\[7,5,11,2\\],\\[4,8,3,15\\]\\], k = 2\n**Output:** \\[\\[7,5,11,2\\],\\[10,6,9,1\\],\\[4,8,3,15\\]\\]\n**Explanation:** In the above diagram, S denotes the student, while E denotes the exam.\n- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.\n- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.\n- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.\n\n**Example 2:**\n\n**Input:** score = \\[\\[3,4\\],\\[5,6\\]\\], k = 0\n**Output:** \\[\\[5,6\\],\\[3,4\\]\\]\n**Explanation:** In the above diagram, S denotes the student, while E denotes the exam.\n- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.\n- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.\n\n**Constraints:**\n\n*   `m == score.length`\n*   `n == score[i].length`\n*   `1 <= m, n <= 250`\n*   `1 <= score[i][j] <= 105`\n*   `score` consists of **distinct** integers.\n*   `0 <= k < n`\"\"\"\n\n    score.sort(key=lambda x: x[k], reverse=True)\n    return score"}}, "leetcode/csn_python_train_66244.txt": {"score": 0.8642104268074036, "content": {"text": "def breakRankTies(self, oldsym, newsym):\n        \"\"\"break Ties to form a new list with the same integer ordering\n        from high to low\n\n        Example\n        old = [ 4, 2, 4, 7, 8]  (Two ties, 4 and 4)\n        new = [60, 2 61,90,99]\n        res = [ 4, 0, 3, 1, 2]\n                *     *        This tie is broken in this case\n        \"\"\"\n        stableSort = map(None, oldsym, newsym, range(len(oldsym)))\n        stableSort.sort()\n\n        lastOld, lastNew = None, None\n        x = -1\n        for old, new, index in stableSort:\n            if old != lastOld:\n                x += 1\n                # the last old value was changed, so update both\n                lastOld = old\n                lastNew = new\n            elif new != lastNew:\n                # break the tie based on the new info (update lastNew)\n                x += 1\n                lastNew = new\n            newsym[index] = x"}}, "leetcode/csn_python_train_286597.txt": {"score": 0.8780326843261719, "content": {"text": "def sortedby(item_list, key_list, reverse=False):\n    \"\"\" sorts ``item_list`` using key_list\n\n    Args:\n        list_ (list): list to sort\n        key_list (list): list to sort by\n        reverse (bool): sort order is descending (largest first)\n                        if reverse is True else acscending (smallest first)\n\n    Returns:\n        list : ``list_`` sorted by the values of another ``list``. defaults to\n        ascending order\n\n    SeeAlso:\n        sortedby2\n\n    Examples:\n        >>> # ENABLE_DOCTEST\n        >>> import utool\n        >>> list_    = [1, 2, 3, 4, 5]\n        >>> key_list = [2, 5, 3, 1, 5]\n        >>> result = utool.sortedby(list_, key_list, reverse=True)\n        >>> print(result)\n        [5, 2, 3, 1, 4]\n\n    \"\"\"\n    assert len(item_list) == len(key_list), (\n        'Expected same len. Got: %r != %r' % (len(item_list), len(key_list)))\n    sorted_list = [item for (key, item) in\n                   sorted(list(zip(key_list, item_list)), reverse=reverse)]\n    return sorted_list"}}, "leetcode/leetcode_2418.txt": {"score": 0.9921221137046814, "content": {"text": "def sort_names_by_height(names, heights):\n    \"\"\"You are given an array of strings `names`, and an array `heights` that consists of **distinct** positive integers. Both arrays are of length `n`.\n\nFor each index `i`, `names[i]` and `heights[i]` denote the name and height of the `ith` person.\n\nReturn `names` _sorted in **descending** order by the people's heights_.\n\n**Example 1:**\n\n**Input:** names = \\[ \"Mary \", \"John \", \"Emma \"\\], heights = \\[180,165,170\\]\n**Output:** \\[ \"Mary \", \"Emma \", \"John \"\\]\n**Explanation:** Mary is the tallest, followed by Emma and John.\n\n**Example 2:**\n\n**Input:** names = \\[ \"Alice \", \"Bob \", \"Bob \"\\], heights = \\[155,185,150\\]\n**Output:** \\[ \"Bob \", \"Alice \", \"Bob \"\\]\n**Explanation:** The first Bob is the tallest, followed by Alice and the second Bob.\n\n**Constraints:**\n\n*   `n == names.length == heights.length`\n*   `1 <= n <= 103`\n*   `1 <= names[i].length <= 20`\n*   `1 <= heights[i] <= 105`\n*   `names[i]` consists of lower and upper case English letters.\n*   All the values of `heights` are distinct.\"\"\"\n\n    name_height_pairs = sorted(zip(heights, names), reverse=True)\n    sorted_names = [pair[1] for pair in name_height_pairs]\n    return sorted_names"}}, "leetcode/csn_python_train_286598.txt": {"score": 0.8704334497451782, "content": {"text": "def sortedby2(item_list, *args, **kwargs):\n    \"\"\" sorts ``item_list`` using key_list\n\n    Args:\n        item_list (list): list to sort\n        *args: multiple lists to sort by\n        **kwargs:\n            reverse (bool): sort order is descending if True else acscending\n\n    Returns:\n        list : ``list_`` sorted by the values of another ``list``. defaults to\n        ascending order\n\n    CommandLine:\n        python -m utool.util_list --exec-sortedby2 --show\n\n    Examples:\n        >>> # ENABLE_DOCTEST\n        >>> from utool.util_list import *  # NOQA\n        >>> import utool as ut\n        >>> item_list = [1, 2, 3, 4, 5]\n        >>> key_list1 = [1, 1, 2, 3, 4]\n        >>> key_list2 = [2, 1, 4, 1, 1]\n        >>> args = (key_list1, key_list2)\n        >>> kwargs = dict(reverse=False)\n        >>> result = ut.sortedby2(item_list, *args, **kwargs)\n        >>> print(result)\n        [2, 1, 3, 4, 5]\n\n    Examples:\n        >>> # ENABLE_DOCTEST\n        >>> # Python 3 Compatibility Test\n        >>> import utool as ut\n        >>> item_list = [1, 2, 3, 4, 5]\n        >>> key_list1 = ['a', 'a', 2, 3, 4]\n        >>> key_list2 = ['b', 'a', 4, 1, 1]\n        >>> args = (key_list1, key_list2)\n        >>> kwargs = dict(reverse=False)\n        >>> result = ut.sortedby2(item_list, *args, **kwargs)\n        >>> print(result)\n        [3, 4, 5, 2, 1]\n    \"\"\"\n    assert all([len(item_list) == len_ for len_ in map(len, args)])\n    reverse = kwargs.get('reverse', False)\n    key = operator.itemgetter(*range(1, len(args) + 1))\n    tup_list = list(zip(item_list, *args))\n    #print(tup_list)\n    try:\n        sorted_tups = sorted(tup_list, key=key, reverse=reverse)\n    except TypeError:\n        # Python 3 does not allow sorting mixed types\n        def keyfunc(tup):\n            return tuple(map(str, tup[1:]))\n        sorted_tups = sorted(tup_list, key=keyfunc, reverse=reverse)\n    sorted_list = [tup[0] for tup in sorted_tups]\n    return sorted_list"}}, "leetcode/csn_python_train_196477.txt": {"score": 0.8576720952987671, "content": {"text": "def sort_dict(key_counts, by_key=False):\n    '''Accept a dict of key:values (numerics) returning list of key-value tuples ordered by desc values.\n\n    If by_key=True, sorts by dict key.'''\n    sort_key = lambda x: (-1 * x[1], x[0])\n    if by_key:\n        sort_key = lambda x: x[0]\n    return sorted(key_counts.items(), key=sort_key)"}}, "leetcode/leetcode_1985.txt": {"score": 0.8758828043937683, "content": {"text": "def maxMinProduct(nums):\n    \"\"\"You are given an array of strings `nums` and an integer `k`. Each string in `nums` represents an integer without leading zeros.\n\nReturn _the string that represents the_ `kth` _**largest integer** in_ `nums`.\n\n**Note**: Duplicate numbers should be counted distinctly. For example, if `nums` is `[ \"1 \", \"2 \", \"2 \"]`, `\"2 \"` is the first largest integer, `\"2 \"` is the second-largest integer, and `\"1 \"` is the third-largest integer.\n\n**Example 1:**\n\n**Input:** nums = \\[ \"3 \", \"6 \", \"7 \", \"10 \"\\], k = 4\n**Output:**  \"3 \"\n**Explanation:**\nThe numbers in nums sorted in non-decreasing order are \\[ \"3 \", \"6 \", \"7 \", \"10 \"\\].\nThe 4th largest integer in nums is  \"3 \".\n\n**Example 2:**\n\n**Input:** nums = \\[ \"2 \", \"21 \", \"12 \", \"1 \"\\], k = 3\n**Output:**  \"2 \"\n**Explanation:**\nThe numbers in nums sorted in non-decreasing order are \\[ \"1 \", \"2 \", \"12 \", \"21 \"\\].\nThe 3rd largest integer in nums is  \"2 \".\n\n**Example 3:**\n\n**Input:** nums = \\[ \"0 \", \"0 \"\\], k = 2\n**Output:**  \"0 \"\n**Explanation:**\nThe numbers in nums sorted in non-decreasing order are \\[ \"0 \", \"0 \"\\].\nThe 2nd largest integer in nums is  \"0 \".\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 104`\n*   `1 <= nums[i].length <= 100`\n*   `nums[i]` consists of only digits.\n*   `nums[i]` will not have any leading zeros.\"\"\"\n\n    res, mod = 0, 10**9 + 7\n    n = len(nums)\n    prefix = [0] * (n + 1)\n    stack = []\n\n    for i in range(n):\n        prefix[i + 1] = (prefix[i] + nums[i]) % mod\n\n    for i in range(n + 1):\n        while stack and (i == n or nums[stack[-1]] > nums[i]):\n            j = stack.pop()\n            res = max(res, nums[j] * (prefix[i] - prefix[stack[-1] + 1 if stack else 0]) % mod)\n        stack.append(i)\n\n    return res"}}}}, "131": {"gold": {"leetcode/leetcode_204.txt": 1}, "retrieved": {"leetcode/leetcode_1283.txt": {"score": 0.9268839359283447, "content": {"text": "def format_date(date):\n    \"\"\"Given an array of integers `nums` and an integer `threshold`, we will choose a positive integer `divisor`, divide all the array by it, and sum the division's result. Find the **smallest** `divisor` such that the result mentioned above is less than or equal to `threshold`.\n\nEach result of the division is rounded to the nearest integer greater than or equal to that element. (For example: `7/3 = 3` and `10/2 = 5`).\n\nThe test cases are generated so that there will be an answer.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,5,9\\], threshold = 6\n**Output:** 5\n**Explanation:** We can get a sum to 17 (1+2+5+9) if the divisor is 1. \nIf the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \n\n**Example 2:**\n\n**Input:** nums = \\[44,22,33,11,1\\], threshold = 5\n**Output:** 44\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `1 <= nums[i] <= 106`\n*   `nums.length <= threshold <= 106`\"\"\"\n\n    months = {\n        \"Jan\": \"01\",\n        \"Feb\": \"02\",\n        \"Mar\": \"03\",\n        \"Apr\": \"04\",\n        \"May\": \"05\",\n        \"Jun\": \"06\",\n        \"Jul\": \"07\",\n        \"Aug\": \"08\",\n        \"Sep\": \"09\",\n        \"Oct\": \"10\",\n        \"Nov\": \"11\",\n        \"Dec\": \"12\",\n    }\n\n    day, month, year = date.split()\n    return f\"{year}-{months[month]}-{day}\""}}, "leetcode/leetcode_2470.txt": {"score": 0.931649923324585, "content": {"text": "def count_lcm_subarrays(nums: List[int], k: int) -> int:\n    \"\"\"Given an integer array `nums` and an integer `k`, return _the number of **subarrays** of_ `nums` _where the least common multiple of the subarray's elements is_ `k`.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\nThe **least common multiple of an array** is the smallest positive integer that is divisible by all the array elements.\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,2,7,1\\], k = 6\n**Output:** 4\n**Explanation:** The subarrays of nums where 6 is the least common multiple of all the subarray's elements are:\n- \\[**3**,**6**,2,7,1\\]\n- \\[**3**,**6**,**2**,7,1\\]\n- \\[3,**6**,2,7,1\\]\n- \\[3,**6**,**2**,7,1\\]\n\n**Example 2:**\n\n**Input:** nums = \\[3\\], k = 2\n**Output:** 0\n**Explanation:** There are no subarrays of nums where 2 is the least common multiple of all the subarray's elements.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i], k <= 1000`\"\"\"\n\n    def lcm(a, b):\n        temp = a\n        while temp % b != 0:\n            temp += a\n        return temp\n\n    count = 0\n    for i in range(len(nums)):\n        curr_lcm = nums[i]\n        for j in range(i, len(nums)):\n            curr_lcm = lcm(curr_lcm, nums[j])\n            if curr_lcm == k:\n                count += 1\n\n    return count"}}, "leetcode/csn_python_train_156068.txt": {"score": 0.9274304509162903, "content": {"text": "def _lcm(a, b):\n    \"\"\"\n    Least Common Multiple between 2 integers.\n    \"\"\"\n    if a == 0 or b == 0:\n        return 0\n    else:\n        return abs(a * b) // gcd(a, b)"}}, "leetcode/leetcode_2521.txt": {"score": 0.9358713626861572, "content": {"text": "def count_distinct_prime_factors(nums):\n    \"\"\"Given an array of positive integers `nums`, return _the number of **distinct prime factors** in the product of the elements of_ `nums`.\n\n**Note** that:\n\n*   A number greater than `1` is called **prime** if it is divisible by only `1` and itself.\n*   An integer `val1` is a factor of another integer `val2` if `val2 / val1` is an integer.\n\n**Example 1:**\n\n**Input:** nums = \\[2,4,3,7,10,6\\]\n**Output:** 4\n**Explanation:**\nThe product of all the elements in nums is: 2 \\* 4 \\* 3 \\* 7 \\* 10 \\* 6 = 10080 = 25 \\* 32 \\* 5 \\* 7.\nThere are 4 distinct prime factors so we return 4.\n\n**Example 2:**\n\n**Input:** nums = \\[2,4,8,16\\]\n**Output:** 1\n**Explanation:**\nThe product of all the elements in nums is: 2 \\* 4 \\* 8 \\* 16 = 1024 = 210.\nThere is 1 distinct prime factor so we return 1.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `2 <= nums[i] <= 1000`\"\"\"\n\n    prime_factors = set()\n    for n in nums:\n        for divisor in range(2, int(n**0.5) + 1):\n            if n % divisor == 0:\n                prime_factors.add(divisor)\n                prime_factors.add(n // divisor)\n    return len(prime_factors)"}}, "leetcode/leetcode_2447.txt": {"score": 0.9396124482154846, "content": {"text": "def gcd(a, b):\n    \"\"\"Given an integer array `nums` and an integer `k`, return _the number of **subarrays** of_ `nums` _where the greatest common divisor of the subarray's elements is_ `k`.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\nThe **greatest common divisor of an array** is the largest integer that evenly divides all the array elements.\n\n**Example 1:**\n\n**Input:** nums = \\[9,3,1,2,6,3\\], k = 3\n**Output:** 4\n**Explanation:** The subarrays of nums where 3 is the greatest common divisor of all the subarray's elements are:\n- \\[9,**3**,1,2,6,3\\]\n- \\[9,3,1,2,6,**3**\\]\n- \\[**9,3**,1,2,6,3\\]\n- \\[9,3,1,2,**6,3**\\]\n\n**Example 2:**\n\n**Input:** nums = \\[4\\], k = 7\n**Output:** 0\n**Explanation:** There are no subarrays of nums where 7 is the greatest common divisor of all the subarray's elements.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i], k <= 109`\"\"\"\n\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef count_GCD_subarrays(nums, k):\n    count = 0\n\n    for i in range(len(nums)):\n        gcd_so_far = 0\n        for j in range(i, len(nums)):\n            gcd_so_far = gcd(gcd_so_far, nums[j])\n            if gcd_so_far == k:\n                count += 1\n\n    return count"}}, "leetcode/csn_python_train_70116.txt": {"score": 0.9326523542404175, "content": {"text": "def hcf(num1, num2):\n    \"\"\"\n    Find the highest common factor of 2 numbers\n\n    :type num1: number\n    :param num1: The first number to find the hcf for\n\n    :type num2: number\n    :param num2: The second number to find the hcf for\n    \"\"\"\n\n    if num1 > num2:\n        smaller = num2\n    else:\n        smaller = num1\n    for i in range(1, smaller + 1):\n        if ((num1 % i == 0) and (num2 % i == 0)):\n            return i"}}, "leetcode/csn_python_train_70115.txt": {"score": 0.9296730160713196, "content": {"text": "def lcm(num1, num2):\n    \"\"\"\n    Find the lowest common multiple of 2 numbers\n\n    :type num1: number\n    :param num1: The first number to find the lcm for\n\n    :type num2: number\n    :param num2: The second number to find the lcm for\n    \"\"\"\n\n    if num1 > num2:\n        bigger = num1\n    else:\n        bigger = num2\n    while True:\n        if bigger % num1 == 0 and bigger % num2 == 0:\n            return bigger\n        bigger += 1"}}, "leetcode/leetcode_2427.txt": {"score": 0.9890746474266052, "content": {"text": "def common_factors(a: int, b: int) -> int:\n    \"\"\"Given two positive integers `a` and `b`, return _the number of **common** factors of_ `a` _and_ `b`.\n\nAn integer `x` is a **common factor** of `a` and `b` if `x` divides both `a` and `b`.\n\n**Example 1:**\n\n**Input:** a = 12, b = 6\n**Output:** 4\n**Explanation:** The common factors of 12 and 6 are 1, 2, 3, 6.\n\n**Example 2:**\n\n**Input:** a = 25, b = 30\n**Output:** 2\n**Explanation:** The common factors of 25 and 30 are 1, 5.\n\n**Constraints:**\n\n*   `1 <= a, b <= 1000`\"\"\"\n\n    from math import gcd\n\n    g = gcd(a, b)\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i * i != g:\n                count += 1\n    return count"}}, "leetcode/leetcode_2584.txt": {"score": 0.9360344409942627, "content": {"text": "def find_valid_split(nums):\n    \"\"\"You are given a **0-indexed** integer array `nums` of length `n`.\n\nA **split** at an index `i` where `0 <= i <= n - 2` is called **valid** if the product of the first `i + 1` elements and the product of the remaining elements are coprime.\n\n*   For example, if `nums = [2, 3, 3]`, then a split at the index `i = 0` is valid because `2` and `9` are coprime, while a split at the index `i = 1` is not valid because `6` and `3` are not coprime. A split at the index `i = 2` is not valid because `i == n - 1`.\n\nReturn _the smallest index_ `i` _at which the array can be split validly or_ `-1` _if there is no such split_.\n\nTwo values `val1` and `val2` are coprime if `gcd(val1, val2) == 1` where `gcd(val1, val2)` is the greatest common divisor of `val1` and `val2`.\n\n**Example 1:**\n\n**Input:** nums = \\[4,7,8,15,3,5\\]\n**Output:** 2\n**Explanation:** The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThe only valid split is at index 2.\n\n**Example 2:**\n\n**Input:** nums = \\[4,7,15,8,3,5\\]\n**Output:** -1\n**Explanation:** The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThere is no valid split.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `1 <= nums[i] <= 106`\"\"\"\n\n    n = len(nums)\n    prefix = [0] * n\n    suffix = [0] * n\n\n    prefix[0] = nums[0]\n    suffix[-1] = nums[-1]\n\n    for i in range(1, n):\n        prefix[i] = prefix[i - 1] * nums[i]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] * nums[i]\n\n    for i in range(n - 1):\n        if gcd(prefix[i], suffix[i + 1]) == 1:\n            return i\n\n    return -1\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)"}}, "leetcode/leetcode_1979.txt": {"score": 0.9701349139213562, "content": {"text": "def findGCD(nums):\n    \"\"\"Given an integer array `nums`, return _the **greatest common divisor** of the smallest number and largest number in_ `nums`.\n\nThe **greatest common divisor** of two numbers is the largest positive integer that evenly divides both numbers.\n\n**Example 1:**\n\n**Input:** nums = \\[2,5,6,9,10\\]\n**Output:** 2\n**Explanation:**\nThe smallest number in nums is 2.\nThe largest number in nums is 10.\nThe greatest common divisor of 2 and 10 is 2.\n\n**Example 2:**\n\n**Input:** nums = \\[7,5,6,8,3\\]\n**Output:** 1\n**Explanation:**\nThe smallest number in nums is 3.\nThe largest number in nums is 8.\nThe greatest common divisor of 3 and 8 is 1.\n\n**Example 3:**\n\n**Input:** nums = \\[3,3\\]\n**Output:** 3\n**Explanation:**\nThe smallest number in nums is 3.\nThe largest number in nums is 3.\nThe greatest common divisor of 3 and 3 is 3.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`\"\"\"\n\n    min_val, max_val = min(nums), max(nums)\n    while max_val % min_val != 0:\n        min_val, max_val = max_val % min_val, min_val\n    return min_val"}}}}, "132": {"gold": {"leetcode/leetcode_949.txt": 1, "leetcode/leetcode_1736.txt": 1}, "retrieved": {"leetcode/leetcode_91.txt": {"score": 0.8700583577156067, "content": {"text": "def numDecodings(s: str) -> int:\n    \"\"\"A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** s =  \"12 \"\n**Output:** 2\n**Explanation:**  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n\n**Example 2:**\n\n**Input:** s =  \"226 \"\n**Output:** 3\n**Explanation:**  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n\n**Example 3:**\n\n**Input:** s =  \"06 \"\n**Output:** 0\n**Explanation:**  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \").\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` contains only digits and may contain leading zero(s).\"\"\"\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]"}}, "leetcode/leetcode_1805.txt": {"score": 0.8714483380317688, "content": {"text": "def min_moves(nums, k):\n    \"\"\"You are given a string `word` that consists of digits and lowercase English letters.\n\nYou will replace every non-digit character with a space. For example, `\"a123bc34d8ef34 \"` will become `\" 123 34 8 34 \"`. Notice that you are left with some integers that are separated by at least one space: `\"123 \"`, `\"34 \"`, `\"8 \"`, and `\"34 \"`.\n\nReturn _the number of **different** integers after performing the replacement operations on_ `word`.\n\nTwo integers are considered different if their decimal representations **without any leading zeros** are different.\n\n**Example 1:**\n\n**Input:** word =  \"a123bc34d8ef34 \"\n**Output:** 3\n**Explanation:** The three different integers are  \"123 \",  \"34 \", and  \"8 \". Notice that  \"34 \" is only counted once.\n\n**Example 2:**\n\n**Input:** word =  \"leet1234code234 \"\n**Output:** 2\n\n**Example 3:**\n\n**Input:** word =  \"a1b01c001 \"\n**Output:** 1\n**Explanation:** The three integers  \"1 \",  \"01 \", and  \"001 \" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values.\n\n**Constraints:**\n\n*   `1 <= word.length <= 1000`\n*   `word` consists of digits and lowercase English letters.\"\"\"\n\n    n = len(nums)\n    ones = [i - j for i, j in enumerate(nums) if j == 1]\n    \n    moves = sum(ones[i] - ones[k // 2] for i in range(k))\n    min_moves = moves\n    \n    for i in range(k, len(ones)):\n        moves += ones[i] - ones[i - k] - k\n        min_moves = min(min_moves, moves)\n    \n    return min_moves"}}, "leetcode/leetcode_2222.txt": {"score": 0.8731436729431152, "content": {"text": "def abbreviated_product(left: int, right: int) -> str:\n    \"\"\"You are given a **0-indexed** binary string `s` which represents the types of buildings along a street where:\n\n*   `s[i] = '0'` denotes that the `ith` building is an office and\n*   `s[i] = '1'` denotes that the `ith` building is a restaurant.\n\nAs a city official, you would like to **select** 3 buildings for random inspection. However, to ensure variety, **no two consecutive** buildings out of the **selected** buildings can be of the same type.\n\n*   For example, given `s = \"0**0**1**1**0**1** \"`, we cannot select the `1st`, `3rd`, and `5th` buildings as that would form `\"0**11** \"` which is **not** allowed due to having two consecutive buildings of the same type.\n\nReturn _the **number of valid ways** to select 3 buildings._\n\n**Example 1:**\n\n**Input:** s =  \"001101 \"\n**Output:** 6\n**Explanation:** \nThe following sets of indices selected are valid:\n- \\[0,2,4\\] from  \"**0**0**1**1**0**1 \" forms  \"010 \"\n- \\[0,3,4\\] from  \"**0**01**10**1 \" forms  \"010 \"\n- \\[1,2,4\\] from  \"0**01**1**0**1 \" forms  \"010 \"\n- \\[1,3,4\\] from  \"0**0**1**10**1 \" forms  \"010 \"\n- \\[2,4,5\\] from  \"00**1**1**01** \" forms  \"101 \"\n- \\[3,4,5\\] from  \"001**101** \" forms  \"101 \"\nNo other selection is valid. Thus, there are 6 total ways.\n\n**Example 2:**\n\n**Input:** s =  \"11100 \"\n**Output:** 0\n**Explanation:** It can be shown that there are no valid selections.\n\n**Constraints:**\n\n*   `3 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.\"\"\"\n\n    product = 1\n    for i in range(left, right + 1):\n        product *= i\n    return str(product)"}}, "leetcode/leetcode_639.txt": {"score": 0.883172333240509, "content": {"text": "def num_decodings(s: str) -> int:\n    \"\"\"A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\n**In addition** to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1* \"` may represent any of the encoded messages `\"11 \"`, `\"12 \"`, `\"13 \"`, `\"14 \"`, `\"15 \"`, `\"16 \"`, `\"17 \"`, `\"18 \"`, or `\"19 \"`. Decoding `\"1* \"` is equivalent to decoding **any** of the encoded messages it can represent.\n\nGiven a string `s` consisting of digits and `'*'` characters, return _the **number** of ways to **decode** it_.\n\nSince the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** s =  \"\\* \"\n**Output:** 9\n**Explanation:** The encoded message can represent any of the encoded messages  \"1 \",  \"2 \",  \"3 \",  \"4 \",  \"5 \",  \"6 \",  \"7 \",  \"8 \", or  \"9 \".\nEach of these can be decoded to the strings  \"A \",  \"B \",  \"C \",  \"D \",  \"E \",  \"F \",  \"G \",  \"H \", and  \"I \" respectively.\nHence, there are a total of 9 ways to decode  \"\\* \".\n\n**Example 2:**\n\n**Input:** s =  \"1\\* \"\n**Output:** 18\n**Explanation:** The encoded message can represent any of the encoded messages  \"11 \",  \"12 \",  \"13 \",  \"14 \",  \"15 \",  \"16 \",  \"17 \",  \"18 \", or  \"19 \".\nEach of these encoded messages have 2 ways to be decoded (e.g.  \"11 \" can be decoded to  \"AA \" or  \"K \").\nHence, there are a total of 9 \\* 2 = 18 ways to decode  \"1\\* \".\n\n**Example 3:**\n\n**Input:** s =  \"2\\* \"\n**Output:** 15\n**Explanation:** The encoded message can represent any of the encoded messages  \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \",  \"26 \",  \"27 \",  \"28 \", or  \"29 \".\n \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \", and  \"26 \" have 2 ways of being decoded, but  \"27 \",  \"28 \", and  \"29 \" only have 1 way.\nHence, there are a total of (6 \\* 2) + (3 \\* 1) = 12 + 3 = 15 ways to decode  \"2\\* \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a digit or `'*'`.\"\"\"\n\n    MOD = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 9 if s[0] == '*' else (0 if s[0] == '0' else 1)\n\n    for i in range(2, n + 1):\n        c, prev_c = s[i - 1], s[i - 2]\n        \n        if c == '*':\n            dp[i] = 9 * dp[i - 1]\n            if prev_c == '1': dp[i] += 9 * dp[i - 2]\n            elif prev_c == '2': dp[i] += 6 * dp[i - 2]\n            elif prev_c == '*': dp[i] += 15 * dp[i - 2]\n        else:\n            dp[i] = dp[i - 1] if c != '0' else 0\n            num = int(s[i - 2 : i])\n            if prev_c == '1' or (prev_c == '2' and num <= 26): dp[i] += dp[i - 2]\n            elif prev_c == '*': dp[i] += 2 * dp[i - 2] if 10 <= num <= 26 else dp[i - 2]\n\n        dp[i] %= MOD\n    return dp[n]"}}, "leetcode/leetcode_1736.txt": {"score": 0.8859565854072571, "content": {"text": "def maximumTime(time: str) -> str:\n    \"\"\"You are given a string `time` in the form of `hh:mm`, where some of the digits in the string are hidden (represented by `?`).\n\nThe valid times are those inclusively between `00:00` and `23:59`.\n\nReturn _the latest valid time you can get from_ `time` _by replacing the hidden_ _digits_.\n\n**Example 1:**\n\n**Input:** time =  \"2?:?0 \"\n**Output:**  \"23:50 \"\n**Explanation:** The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.\n\n**Example 2:**\n\n**Input:** time =  \"0?:3? \"\n**Output:**  \"09:39 \"\n\n**Example 3:**\n\n**Input:** time =  \"1?:22 \"\n**Output:**  \"19:22 \"\n\n**Constraints:**\n\n*   `time` is in the format `hh:mm`.\n*   It is guaranteed that you can produce a valid time from the given string.\"\"\"\n\n    time_list = list(time)\n    if time_list[0] == '?':\n        time_list[0] = '2' if time_list[1] <= '3' or time_list[1] == '?' else '1'\n    if time_list[1] == '?':\n        time_list[1] = '3' if time_list[0] == '2' else '9'\n    if time_list[3] == '?':\n        time_list[3] = '5'\n    if time_list[4] == '?':\n        time_list[4] = '9'\n    return \"\".join(time_list)"}}, "leetcode/leetcode_2266.txt": {"score": 0.880994975566864, "content": {"text": "def min_cost(startAt, moveCost, pushCost, targetSeconds):\n    \"\"\"Alice is texting Bob using her phone. The **mapping** of digits to letters is shown in the figure below.\n\nIn order to **add** a letter, Alice has to **press** the key of the corresponding digit `i` times, where `i` is the position of the letter in the key.\n\n*   For example, to add the letter `'s'`, Alice has to press `'7'` four times. Similarly, to add the letter `'k'`, Alice has to press `'5'` twice.\n*   Note that the digits `'0'` and `'1'` do not map to any letters, so Alice **does not** use them.\n\nHowever, due to an error in transmission, Bob did not receive Alice's text message but received a **string of pressed keys** instead.\n\n*   For example, when Alice sent the message `\"bob \"`, Bob received the string `\"2266622 \"`.\n\nGiven a string `pressedKeys` representing the string received by Bob, return _the **total number of possible text messages** Alice could have sent_.\n\nSince the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** pressedKeys =  \"22233 \"\n**Output:** 8\n**Explanation:**\nThe possible text messages Alice could have sent are:\n \"aaadd \",  \"abdd \",  \"badd \",  \"cdd \",  \"aaae \",  \"abe \",  \"bae \", and  \"ce \".\nSince there are 8 possible messages, we return 8.\n\n**Example 2:**\n\n**Input:** pressedKeys =  \"222222222222222222222222222222222222 \"\n**Output:** 82876089\n**Explanation:**\nThere are 2082876103 possible text messages Alice could have sent.\nSince we need to return the answer modulo 109 + 7, we return 2082876103 % (109 + 7) = 82876089.\n\n**Constraints:**\n\n*   `1 <= pressedKeys.length <= 105`\n*   `pressedKeys` only consists of digits from `'2'` - `'9'`.\"\"\"\n\n    min_cost = float('inf')\n\n    for i in range(100):\n        for j in range(100):\n            if i * 60 + j == targetSeconds:\n                minute_move_cost = abs(i - startAt) * moveCost\n                second_move_cost = abs(j - i) * moveCost\n                total_push_cost = (2 if j > 0 else 0) + (1 if j // 10 != 0 else 0) + (1 if i // 10 != 0 else 0)\n                \n                min_cost = min(min_cost, minute_move_cost + second_move_cost + total_push_cost * pushCost)\n\n    return min_cost"}}, "leetcode/leetcode_2094.txt": {"score": 0.8769823312759399, "content": {"text": "def min_stones_remaining(piles, k):\n    \"\"\"You are given an integer array `digits`, where each element is a digit. The array may contain duplicates.\n\nYou need to find **all** the **unique** integers that follow the given requirements:\n\n*   The integer consists of the **concatenation** of **three** elements from `digits` in **any** arbitrary order.\n*   The integer does not have **leading zeros**.\n*   The integer is **even**.\n\nFor example, if the given `digits` were `[1, 2, 3]`, integers `132` and `312` follow the requirements.\n\nReturn _a **sorted** array of the unique integers._\n\n**Example 1:**\n\n**Input:** digits = \\[2,1,3,0\\]\n**Output:** \\[102,120,130,132,210,230,302,310,312,320\\]\n**Explanation:** All the possible integers that follow the requirements are in the output array. \nNotice that there are no **odd** integers or integers with **leading zeros**.\n\n**Example 2:**\n\n**Input:** digits = \\[2,2,8,8,2\\]\n**Output:** \\[222,228,282,288,822,828,882\\]\n**Explanation:** The same digit can be used as many times as it appears in digits. \nIn this example, the digit 8 is used twice each time in 288, 828, and 882. \n\n**Example 3:**\n\n**Input:** digits = \\[3,7,5\\]\n**Output:** \\[\\]\n**Explanation:** No **even** integers can be formed using the given digits.\n\n**Constraints:**\n\n*   `3 <= digits.length <= 100`\n*   `0 <= digits[i] <= 9`\"\"\"\n\n    for _ in range(k):\n        max_pile_index = piles.index(max(piles))\n        piles[max_pile_index] -= piles[max_pile_index] // 2\n\n    return sum(piles)"}}, "leetcode/leetcode_816.txt": {"score": 0.8859192728996277, "content": {"text": "class MyHashSet:\n    \"\"\"We had some 2-dimensional coordinates, like `\"(1, 3) \"` or `\"(2, 0.5) \"`. Then, we removed all commas, decimal points, and spaces and ended up with the string s.\n\n*   For example, `\"(1, 3) \"` becomes `s = \"(13) \"` and `\"(2, 0.5) \"` becomes `s = \"(205) \"`.\n\nReturn _a list of strings representing all possibilities for what our original coordinates could have been_.\n\nOur original representation never had extraneous zeroes, so we never started with numbers like `\"00 \"`, `\"0.0 \"`, `\"0.00 \"`, `\"1.0 \"`, `\"001 \"`, `\"00.01 \"`, or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like `\".1 \"`.\n\nThe final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)\n\n**Example 1:**\n\n**Input:** s =  \"(123) \"\n**Output:** \\[ \"(1, 2.3) \", \"(1, 23) \", \"(1.2, 3) \", \"(12, 3) \"\\]\n\n**Example 2:**\n\n**Input:** s =  \"(0123) \"\n**Output:** \\[ \"(0, 1.23) \", \"(0, 12.3) \", \"(0, 123) \", \"(0.1, 2.3) \", \"(0.1, 23) \", \"(0.12, 3) \"\\]\n**Explanation:** 0.0, 00, 0001 or 00.01 are not allowed.\n\n**Example 3:**\n\n**Input:** s =  \"(00011) \"\n**Output:** \\[ \"(0, 0.011) \", \"(0.001, 1) \"\\]\n\n**Constraints:**\n\n*   `4 <= s.length <= 12`\n*   `s[0] == '('` and `s[s.length - 1] == ')'`.\n*   The rest of `s` are digits.\"\"\"\n\n\n    def __init__(self):\n        self.storage = [False] * 1000001\n\n    def add(self, key: int):\n        self.storage[key] = True\n\n    def remove(self, key: int):\n        self.storage[key] = False\n\n    def contains(self, key: int) -> bool:\n        return self.storage[key]"}}, "leetcode/leetcode_949.txt": {"score": 0.904509961605072, "content": {"text": "from collections import deque\n    \"\"\"Given an array `arr` of 4 digits, find the latest 24-hour time that can be made using each digit **exactly once**.\n\n24-hour times are formatted as `\"HH:MM \"`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.\n\nReturn _the latest 24-hour time in `\"HH:MM \"` format_. If no valid time can be made, return an empty string.\n\n**Example 1:**\n\n**Input:** arr = \\[1,2,3,4\\]\n**Output:**  \"23:41 \"\n**Explanation:** The valid 24-hour times are  \"12:34 \",  \"12:43 \",  \"13:24 \",  \"13:42 \",  \"14:23 \",  \"14:32 \",  \"21:34 \",  \"21:43 \",  \"23:14 \", and  \"23:41 \". Of these times,  \"23:41 \" is the latest.\n\n**Example 2:**\n\n**Input:** arr = \\[5,5,5,5\\]\n**Output:**  \" \"\n**Explanation:** There are no valid 24-hour times as  \"55:55 \" is not valid.\n\n**Constraints:**\n\n*   `arr.length == 4`\n*   `0 <= arr[i] <= 9`\"\"\"\n\n\ndef catMouseGame(graph):\n    n = len(graph)\n    status = [[[0]*3 for _ in range(n)] for _ in range(n)]\n\n    for i in range(1, n):\n        status[i][i][1] = 2\n        status[i][i][2] = 2\n    queue = deque([(i, i, t, 2) for i in range(1, n) for t in (1, 2)])\n\n    while queue:\n        pos_m, pos_c, t_type, t_result = queue.popleft()\n\n        for prev in graph[pos_m if t_type == 1 else pos_c]:\n            if (t_type == 2 and prev == 0) or (t_result == 2 and status[prev][pos_c][3 - t_type]):\n                continue\n            if status[prev][pos_c][3 - t_type]:\n                continue\n            queue.append((pos_c, prev, 3 - t_type, 3 - t_result))\n            status[prev][pos_c][3 - t_type] = 3 - t_result\n\n    return status[1][2][1]"}}, "leetcode/leetcode_2437.txt": {"score": 0.9933812022209167, "content": {"text": "def count_valid_times(time: str) -> int:\n    \"\"\"You are given a string of length `5` called `time`, representing the current time on a digital clock in the format `\"hh:mm \"`. The **earliest** possible time is `\"00:00 \"` and the **latest** possible time is `\"23:59 \"`.\n\nIn the string `time`, the digits represented by the `?` symbol are **unknown**, and must be **replaced** with a digit from `0` to `9`.\n\nReturn _an integer_ `answer`_, the number of valid clock times that can be created by replacing every_ `?` _with a digit from_ `0` _to_ `9`.\n\n**Example 1:**\n\n**Input:** time =  \"?5:00 \"\n**Output:** 2\n**Explanation:** We can replace the ? with either a 0 or 1, producing  \"05:00 \" or  \"15:00 \". Note that we cannot replace it with a 2, since the time  \"25:00 \" is invalid. In total, we have two choices.\n\n**Example 2:**\n\n**Input:** time =  \"0?:0? \"\n**Output:** 100\n**Explanation:** Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.\n\n**Example 3:**\n\n**Input:** time =  \"??:?? \"\n**Output:** 1440\n**Explanation:** There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 \\* 60 = 1440 choices.\n\n**Constraints:**\n\n*   `time` is a valid string of length `5` in the format `\"hh:mm \"`.\n*   `\"00 \" <= hh <= \"23 \"`\n*   `\"00 \" <= mm <= \"59 \"`\n*   Some of the digits might be replaced with `'?'` and need to be replaced with digits from `0` to `9`.\"\"\"\n\n    count = 1\n    if time[0] == '?':\n        count *= 3 if time[1] == '?' or time[1] < '4' else 2\n    if time[1] == '?':\n        count *= 4 if time[0] == '2' else 10\n    if time[3] == '?':\n        count *= 6\n    if time[4] == '?':\n        count *= 10\n    return count"}}}}, "133": {"gold": {"leetcode/leetcode_909.txt": 1}, "retrieved": {"leetcode/leetcode_2440.txt": {"score": 0.9045907855033875, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an undirected tree with `n` nodes labeled from `0` to `n - 1`.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nYou are allowed to **delete** some edges, splitting the tree into multiple connected components. Let the **value** of a component be the sum of **all** `nums[i]` for which node `i` is in the component.\n\nReturn _the **maximum** number of edges you can delete, such that every connected component in the tree has the same value._\n\n**Example 1:**\n\n**Input:** nums = \\[6,2,2,2,6\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\] \n**Output:** 2 \n**Explanation:** The above figure shows how we can delete the edges \\[0,1\\] and \\[3,4\\]. The created components are nodes \\[0\\], \\[1,2,3\\] and \\[4\\]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n\n**Example 2:**\n\n**Input:** nums = \\[2\\], edges = \\[\\]\n**Output:** 0\n**Explanation:** There are no edges to be deleted.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `nums.length == n`\n*   `1 <= nums[i] <= 50`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= edges[i][0], edges[i][1] <= n - 1`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef dfs(node, parent, nums, graph, total, result):\n    total_sum = nums[node]\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            total_sum += dfs(neighbor, node, nums, graph, total, result)\n    if total_sum == total // 2:\n        result.append(1)\n        return 0\n    return total_sum\n\ndef delete_edges_to_balance_tree(nums, edges):\n    n = len(nums)\n    graph = defaultdict(list)\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n\n    total = sum(nums)\n    if total % 2 != 0:\n        return 0  # It is impossible to split the tree fairly.\n\n    result = []\n    dfs(0, -1, nums, graph, total, result)\n    return len(result) - 1"}}, "leetcode/leetcode_1617.txt": {"score": 0.9069312810897827, "content": {"text": "def winnerSquareGame(n: int) -> bool:\n    \"\"\"There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.\"\"\"\n\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]"}}, "leetcode/leetcode_2322.txt": {"score": 0.9100877642631531, "content": {"text": "def dfs(node, parent, xor_values, tree):\n    \"\"\"There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nRemove two **distinct** edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:\n\n1.  Get the XOR of all the values of the nodes for **each** of the three components respectively.\n2.  The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair.\n\n*   For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = **6**`, `1 ^ 9 = **8**`, and `3 ^ 3 ^ 3 = **3**`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn _the **minimum** score of any possible pair of edge removals on the given tree_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,5,4,11\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\]\n**Output:** 9\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[1,3,4\\] with values \\[5,4,11\\]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n- The 2nd component has node \\[0\\] with value \\[1\\]. Its XOR value is 1 = 1.\n- The 3rd component has node \\[2\\] with value \\[5\\]. Its XOR value is 5 = 5.\nThe score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\nIt can be shown that no other pair of removals will obtain a smaller score than 9.\n\n**Example 2:**\n\n**Input:** nums = \\[5,5,2,4,4,2\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[5,2\\],\\[4,3\\],\\[1,3\\]\\]\n**Output:** 0\n**Explanation:** The diagram above shows a way to make a pair of removals.\n- The 1st component has nodes \\[3,4\\] with values \\[4,4\\]. Its XOR value is 4 ^ 4 = 0.\n- The 2nd component has nodes \\[1,0\\] with values \\[5,5\\]. Its XOR value is 5 ^ 5 = 0.\n- The 3rd component has nodes \\[2,5\\] with values \\[2,2\\]. Its XOR value is 2 ^ 2 = 0.\nThe score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\nWe cannot obtain a smaller score than 0.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `3 <= n <= 1000`\n*   `1 <= nums[i] <= 108`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n    xor_value = xor_values[node]\n    for child in tree[node]:\n        if child != parent:\n            xor_value ^= dfs(child, node, xor_values, tree)\n    return xor_value\n\n\ndef minimumScore(nums, edges):\n    n = len(nums)\n    tree = [[] for _ in range(n)]\n    \n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    \n    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]\n    \n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor1 = xor_values[i]\n            xor2 = xor_values[j] ^ nums[i]\n            xor3 = nums[i] ^ nums[j]\n            max_xor = max(xor1, xor2, xor3)\n            min_xor = min(xor1, xor2, xor3)\n            ans = min(ans, max_xor - min_xor)\n    \n    return ans"}}, "leetcode/leetcode_1466.txt": {"score": 0.9081958532333374, "content": {"text": "def maxJumps(arr, d):\n    \"\"\"There are `n` cities numbered from `0` to `n - 1` and `n - 1` roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n\nRoads are represented by `connections` where `connections[i] = [ai, bi]` represents a road from city `ai` to city `bi`.\n\nThis year, there will be a big event in the capital (city `0`), and many people want to travel to this city.\n\nYour task consists of reorienting some roads such that each city can visit the city `0`. Return the **minimum** number of edges changed.\n\nIt's **guaranteed** that each city can reach city `0` after reorder.\n\n**Example 1:**\n\n**Input:** n = 6, connections = \\[\\[0,1\\],\\[1,3\\],\\[2,3\\],\\[4,0\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\n**Example 2:**\n\n**Input:** n = 5, connections = \\[\\[1,0\\],\\[1,2\\],\\[3,2\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\n**Example 3:**\n\n**Input:** n = 3, connections = \\[\\[1,0\\],\\[2,0\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `2 <= n <= 5 * 104`\n*   `connections.length == n - 1`\n*   `connections[i].length == 2`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\"\"\"\n\n    n = len(arr)\n    dp = [1] * n\n\n    def helper(idx):\n        if dp[idx] > 1:\n            return dp[idx]\n        maximum = 1\n        for i in range(1, d + 1):\n            if idx + i < n and arr[idx] <= arr[idx + i]:\n                break\n            if idx + i < n:\n                maximum = max(maximum, 1 + helper(idx + i))\n\n            if idx - i >= 0 and arr[idx] <= arr[idx - i]:\n                break\n            if idx - i >= 0:\n                maximum = max(maximum, 1 + helper(idx - i))\n        \n        dp[idx] = maximum\n        return maximum\n\n    for i in range(n):\n        helper(i)\n\n    return max(dp)"}}, "leetcode/leetcode_1129.txt": {"score": 0.9120498299598694, "content": {"text": "def longestStrChain(words):\n    \"\"\"You are given an integer `n`, the number of nodes in a directed graph where the nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\n\nYou are given two arrays `redEdges` and `blueEdges` where:\n\n*   `redEdges[i] = [ai, bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph, and\n*   `blueEdges[j] = [uj, vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.\n\nReturn an array `answer` of length `n`, where each `answer[x]` is the length of the shortest path from node `0` to node `x` such that the edge colors alternate along the path, or `-1` if such a path does not exist.\n\n**Example 1:**\n\n**Input:** n = 3, redEdges = \\[\\[0,1\\],\\[1,2\\]\\], blueEdges = \\[\\]\n**Output:** \\[0,1,-1\\]\n\n**Example 2:**\n\n**Input:** n = 3, redEdges = \\[\\[0,1\\]\\], blueEdges = \\[\\[2,1\\]\\]\n**Output:** \\[0,1,-1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= redEdges.length, blueEdges.length <= 400`\n*   `redEdges[i].length == blueEdges[j].length == 2`\n*   `0 <= ai, bi, uj, vj < n`\"\"\"\n\n    words.sort(key=lambda x: len(x))\n    dp = {}\n\n    max_len = 0\n    for word in words:\n        for i in range(len(word)):\n            pre = word[:i] + word[i + 1:]\n            dp[word] = max(dp.get(word, 0), dp.get(pre, 0) + 1)\n        max_len = max(max_len, dp[word])\n\n    return max_len"}}, "leetcode/leetcode_2065.txt": {"score": 0.922913670539856, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an **undirected** graph with `n` nodes numbered from `0` to `n - 1` (**inclusive**). You are given a **0-indexed** integer array `values` where `values[i]` is the **value** of the `ith` node. You are also given a **0-indexed** 2D integer array `edges`, where each `edges[j] = [uj, vj, timej]` indicates that there is an undirected edge between the nodes `uj` and `vj`, and it takes `timej` seconds to travel between the two nodes. Finally, you are given an integer `maxTime`.\n\nA **valid** **path** in the graph is any path that starts at node `0`, ends at node `0`, and takes **at most** `maxTime` seconds to complete. You may visit the same node multiple times. The **quality** of a valid path is the **sum** of the values of the **unique nodes** visited in the path (each node's value is added **at most once** to the sum).\n\nReturn _the **maximum** quality of a valid path_.\n\n**Note:** There are **at most four** edges connected to each node.\n\n**Example 1:**\n\n**Input:** values = \\[0,32,10,43\\], edges = \\[\\[0,1,10\\],\\[1,2,15\\],\\[0,3,10\\]\\], maxTime = 49\n**Output:** 75\n**Explanation:**\nOne possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.\n\n**Example 2:**\n\n**Input:** values = \\[5,10,15,20\\], edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[0,3,10\\]\\], maxTime = 30\n**Output:** 25\n**Explanation:**\nOne possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.\nThe nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.\n\n**Example 3:**\n\n**Input:** values = \\[1,2,3,4\\], edges = \\[\\[0,1,10\\],\\[1,2,11\\],\\[2,3,12\\],\\[1,3,13\\]\\], maxTime = 50\n**Output:** 7\n**Explanation:**\nOne possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.\n\n**Constraints:**\n\n*   `n == values.length`\n*   `1 <= n <= 1000`\n*   `0 <= values[i] <= 108`\n*   `0 <= edges.length <= 2000`\n*   `edges[j].length == 3`\n*   `0 <= uj < vj <= n - 1`\n*   `10 <= timej, maxTime <= 100`\n*   All the pairs `[uj, vj]` are **unique**.\n*   There are **at most four** edges connected to each node.\n*   The graph may not be connected.\"\"\"\n\n\ndef maxQuality_dfs(node, time_left, visited, values, neighbors):\n    acc = 0\n    for neighbor, cost in neighbors[node]:\n        if time_left >= cost and not visited[neighbor]:\n            visited[neighbor] = 1\n            acc = max(acc, values[neighbor] + maxQuality_dfs(neighbor, time_left - cost, visited, values, neighbors))\n            visited[neighbor] = 0\n    return acc\n\ndef maxQuality(values, edges, maxTime):\n    neighbors = defaultdict(list)\n    for u, v, cost in edges:\n        neighbors[u].append((v, cost))\n        neighbors[v].append((u, cost))\n    visited = [0] * len(values)\n    return maxQuality_dfs(0, maxTime, visited, values, neighbors)"}}, "leetcode/leetcode_2039.txt": {"score": 0.9120097160339355, "content": {"text": "def sumGame(num: str) -> bool:\n    \"\"\"There is a network of `n` servers, labeled from `0` to `n - 1`. You are given a 2D integer array `edges`, where `edges[i] = [ui, vi]` indicates there is a message channel between servers `ui` and `vi`, and they can pass **any** number of messages to **each other** directly in **one** second. You are also given a **0-indexed** integer array `patience` of length `n`.\n\nAll servers are **connected**, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels.\n\nThe server labeled `0` is the **master** server. The rest are **data** servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers **optimally**, so every message takes the **least amount of time** to arrive at the master server. The master server will process all newly arrived messages **instantly** and send a reply to the originating server via the **reversed path** the message had gone through.\n\nAt the beginning of second `0`, each data server sends its message to be processed. Starting from second `1`, at the **beginning** of **every** second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server:\n\n*   If it has not, it will **resend** the message periodically. The data server `i` will resend the message every `patience[i]` second(s), i.e., the data server `i` will resend the message if `patience[i]` second(s) have **elapsed** since the **last** time the message was sent from this server.\n*   Otherwise, **no more resending** will occur from this server.\n\nThe network becomes **idle** when there are **no** messages passing between servers or arriving at servers.\n\nReturn _the **earliest second** starting from which the network becomes **idle**_.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\]\\], patience = \\[0,2,1\\]\n**Output:** 8\n**Explanation:**\nAt (the beginning of) second 0,\n- Data server 1 sends its message (denoted 1A) to the master server.\n- Data server 2 sends its message (denoted 2A) to the master server.\n\nAt second 1,\n- Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n- Server 1 has not received any reply. 1 second (1 < patience\\[1\\] = 2) elapsed since this server has sent the message, therefore it does not resend the message.\n- Server 2 has not received any reply. 1 second (1 == patience\\[2\\] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B).\n\nAt second 2,\n- The reply 1A arrives at server 1. No more resending will occur from server 1.\n- Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n- Server 2 resends the message (denoted 2C).\n...\nAt second 4,\n- The reply 2A arrives at server 2. No more resending will occur from server 2.\n...\nAt second 7, reply 2D arrives at server 2.\n\nStarting from the beginning of the second 8, there are no messages passing between servers or arriving at servers.\nThis is the time when the network becomes idle.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\],\\[0,2\\],\\[1,2\\]\\], patience = \\[0,10,10\\]\n**Output:** 3\n**Explanation:** Data servers 1 and 2 receive a reply back at the beginning of second 2.\nFrom the beginning of the second 3, the network becomes idle.\n\n**Constraints:**\n\n*   `n == patience.length`\n*   `2 <= n <= 105`\n*   `patience[0] == 0`\n*   `1 <= patience[i] <= 105` for `1 <= i < n`\n*   `1 <= edges.length <= min(105, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `0 <= ui, vi < n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each server can directly or indirectly reach another server.\"\"\"\n\n    n = len(num)\n    sum1, sum2, cnt1, cnt2 = 0, 0, 0, 0\n\n    for i in range(n // 2):\n        if num[i] == '?': cnt1 += 1\n        else: sum1 += int(num[i])\n\n    for i in range(n // 2, n):\n        if num[i] == '?': cnt2 += 1\n        else: sum2 += int(num[i])\n\n    return (sum1 - sum2) != ((cnt2 - cnt1) // 2) * 9"}}, "leetcode/leetcode_2467.txt": {"score": 0.9954337477684021, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted at node `0`. You are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nAt every node `i`, there is a gate. You are also given an array of even integers `amount`, where `amount[i]` represents:\n\n*   the price needed to open the gate at node `i`, if `amount[i]` is negative, or,\n*   the cash reward obtained on opening the gate at node `i`, otherwise.\n\nThe game goes on as follows:\n\n*   Initially, Alice is at node `0` and Bob is at node `bob`.\n*   At every second, Alice and Bob **each** move to an adjacent node. Alice moves towards some **leaf node**, while Bob moves towards node `0`.\n*   For **every** node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:\n    *   If the gate is **already open**, no price will be required, nor will there be any cash reward.\n    *   If Alice and Bob reach the node **simultaneously**, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each.\n*   If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are **independent** of each other.\n\nReturn _the **maximum** net income Alice can have if she travels towards the optimal leaf node._\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\], bob = 3, amount = \\[-2,4,2,-4,6\\]\n**Output:** 6\n**Explanation:** \nThe above diagram represents the given tree. The game goes as follows:\n- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\n  Alice's net income is now -2.\n- Both Alice and Bob move to node 1. \n  Since they reach here simultaneously, they open the gate together and share the reward.\n  Alice's net income becomes -2 + (4 / 2) = 0.\n- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.\n  Bob moves on to node 0, and stops moving.\n- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\]\\], bob = 1, amount = \\[-7280,2350\\]\n**Output:** -7280\n**Explanation:** \nAlice follows the path 0->1 whereas Bob follows the path 1->0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280. \n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\n*   `1 <= bob < n`\n*   `amount.length == n`\n*   `amount[i]` is an **even** integer in the range `[-104, 104]`.\"\"\"\n\n\ndef dfs(node, parent, bob, time, alice_income, res, amount, tree):\n    if time < bob or amount[node] >= 0:\n        alice_income += amount[node]\n    else:\n        alice_income += amount[node] // 2\n    amount[node] = 0\n    is_leaf = True\n    for child in tree[node]:\n        if child != parent:\n            is_leaf = False\n            dfs(child, node, bob, time + 1, alice_income, res, amount, tree)\n    if is_leaf:\n        res[0] = max(res[0], alice_income)\n\ndef maxNetIncome(edges, bob, amount):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    res = [-100000]\n    dfs(0, -1, bob, 0, 0, res, amount, tree)\n    return res[0]"}}, "leetcode/leetcode_2421.txt": {"score": 0.91536545753479, "content": {"text": "from collections import defaultdict\n    \"\"\"There is a tree (i.e. a connected, undirected graph with no cycles) consisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges.\n\nYou are given a **0-indexed** integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting nodes `ai` and `bi`.\n\nA **good path** is a simple path that satisfies the following conditions:\n\n1.  The starting node and the ending node have the **same** value.\n2.  All nodes between the starting node and the ending node have values **less than or equal to** the starting node (i.e. the starting node's value should be the maximum value along the path).\n\nReturn _the number of distinct good paths_.\n\nNote that a path and its reverse are counted as the **same** path. For example, `0 -> 1` is considered to be the same as `1 -> 0`. A single node is also considered as a valid path.\n\n**Example 1:**\n\n**Input:** vals = \\[1,3,2,1,3\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 6\n**Explanation:** There are 5 good paths consisting of a single node.\nThere is 1 additional good path: 1 -> 0 -> 2 -> 4.\n(The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)\nNote that 0 -> 2 -> 3 is not a good path because vals\\[2\\] > vals\\[0\\].\n\n**Example 2:**\n\n**Input:** vals = \\[1,1,2,2,3\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** 7\n**Explanation:** There are 5 good paths consisting of a single node.\nThere are 2 additional good paths: 0 -> 1 and 2 -> 3.\n\n**Example 3:**\n\n**Input:** vals = \\[1\\], edges = \\[\\]\n**Output:** 1\n**Explanation:** The tree consists of only one node, so there is one good path.\n\n**Constraints:**\n\n*   `n == vals.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= vals[i] <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef dfs(node, parent, adj, vals, cur_max, count):\n    if vals[node] >= cur_max:\n        if vals[node] > cur_max:\n            count[0] += 1\n            cur_max = vals[node]\n        for next in adj[node]:\n            if next != parent:\n                dfs(next, node, adj, vals, cur_max, count)\n\ndef number_of_good_paths(vals, edges):\n    n = len(vals)\n    adj = defaultdict(list)\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    count = [0]\n    for i in range(n):\n        dfs(i, -1, adj, vals, -1, count)\n    return count[0]"}}, "leetcode/leetcode_2603.txt": {"score": 0.9208096265792847, "content": {"text": "from collections import defaultdict\n    \"\"\"There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef min_edges_to_collect_coins(coins, edges):\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(adj, coins, 0, -1)[1] // 2\n\ndef dfs(adj, coins, node, parent):\n    sum_coins = coins[node]\n    distance = 0\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            result = dfs(adj, coins, neighbor, node)\n            sum_coins += result[0]\n            distance += 2 * result[0] + result[1]\n    return (sum_coins, distance)"}}}}, "134": {"gold": {"leetcode/leetcode_2413.txt": 1, "leetcode/leetcode_2579.txt": 1}, "retrieved": {"leetcode/leetcode_1444.txt": {"score": 0.8298139572143555, "content": {"text": "def number_of_steps(num):\n    \"\"\"Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.\n\n**Example 1:**\n\n**Input:** pizza = \\[ \"A.. \", \"AAA \", \"... \"\\], k = 3\n**Output:** 3 \n**Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n**Example 2:**\n\n**Input:** pizza = \\[ \"A.. \", \"AA. \", \"... \"\\], k = 3\n**Output:** 1\n\n**Example 3:**\n\n**Input:** pizza = \\[ \"A.. \", \"A.. \", \"... \"\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 50`\n*   `rows == pizza.length`\n*   `cols == pizza[i].length`\n*   `1 <= k <= 10`\n*   `pizza` consists of characters `'A'` and `'.'` only.\"\"\"\n\n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    return steps - 1"}}, "leetcode/leetcode_587.txt": {"score": 0.8387497663497925, "content": {"text": "def cross_product(p, q, r):\n    \"\"\"You are given an array `trees` where `trees[i] = [xi, yi]` represents the location of a tree in the garden.\n\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if **all the trees are enclosed**.\n\nReturn _the coordinates of trees that are exactly located on the fence perimeter_. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** trees = \\[\\[1,1\\],\\[2,2\\],\\[2,0\\],\\[2,4\\],\\[3,3\\],\\[4,2\\]\\]\n**Output:** \\[\\[1,1\\],\\[2,0\\],\\[4,2\\],\\[3,3\\],\\[2,4\\]\\]\n**Explanation:** All the trees will be on the perimeter of the fence except the tree at \\[2, 2\\], which will be inside the fence.\n\n**Example 2:**\n\n**Input:** trees = \\[\\[1,2\\],\\[2,2\\],\\[4,2\\]\\]\n**Output:** \\[\\[4,2\\],\\[2,2\\],\\[1,2\\]\\]\n**Explanation:** The fence forms a line that passes through all the trees.\n\n**Constraints:**\n\n*   `1 <= trees.length <= 3000`\n*   `trees[i].length == 2`\n*   `0 <= xi, yi <= 100`\n*   All the given positions are **unique**.\"\"\"\n\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef fence(trees):\n    trees.sort(key=lambda p: (p[0], p[1]))\n    hull = []\n    for p in trees:\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n\n    for p in reversed(trees):\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n    \n    return hull"}}, "leetcode/leetcode_1453.txt": {"score": 0.8300359845161438, "content": {"text": "def numPoints(darts, r):\n    \"\"\"Alice is throwing `n` darts on a very large wall. You are given an array `darts` where `darts[i] = [xi, yi]` is the position of the `ith` dart that Alice threw on the wall.\n\nBob knows the positions of the `n` darts on the wall. He wants to place a dartboard of radius `r` on the wall so that the maximum number of darts that Alice throws lies on the dartboard.\n\nGiven the integer `r`, return _the maximum number of darts that can lie on the dartboard_.\n\n**Example 1:**\n\n**Input:** darts = \\[\\[-2,0\\],\\[2,0\\],\\[0,2\\],\\[0,-2\\]\\], r = 2\n**Output:** 4\n**Explanation:** Circle dartboard with center in (0,0) and radius = 2 contain all points.\n\n**Example 2:**\n\n**Input:** darts = \\[\\[-3,0\\],\\[3,0\\],\\[2,6\\],\\[5,4\\],\\[0,9\\],\\[7,8\\]\\], r = 5\n**Output:** 5\n**Explanation:** Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n\n**Constraints:**\n\n*   `1 <= darts.length <= 100`\n*   `darts[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `darts` are unique\n*   `1 <= r <= 5000`\"\"\"\n\n    n = len(darts)\n    result = 1\n    \n    for i in range(n):\n        for j in range(n):\n            cnt = 0\n            for k in range(n):\n                dx = darts[i][0] - darts[k][0]\n                dy = darts[i][1] - darts[k][1]\n                if (dx * dx + dy * dy) ** 0.5 <= r:\n                    cnt += 1\n                    \n            if cnt > result:\n                result = cnt\n                \n    return result"}}, "leetcode/leetcode_1547.txt": {"score": 0.840701699256897, "content": {"text": "def destCity(paths):\n    \"\"\"Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows:\n\nGiven an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn _the minimum total cost_ of the cuts.\n\n**Example 1:**\n\n**Input:** n = 7, cuts = \\[1,3,4,5\\]\n**Output:** 16\n**Explanation:** Using cuts order = \\[1, 3, 4, 5\\] as in the input leads to the following scenario:\n \nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be \\[3, 5, 1, 4\\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n**Example 2:**\n\n**Input:** n = 9, cuts = \\[5,6,1,4,2\\]\n**Output:** 22\n**Explanation:** If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order \\[4, 6, 5, 2, 1\\] has total cost = 22 which is the minimum possible.\n\n**Constraints:**\n\n*   `2 <= n <= 106`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   All the integers in `cuts` array are **distinct**.\"\"\"\n\n    starting_cities = set()\n    \n    for path in paths:\n        starting_cities.add(path[0])\n\n    for path in paths:\n        if path[1] not in starting_cities:\n            return path[1]\n\n    return \"\""}}, "leetcode/leetcode_1039.txt": {"score": 0.8607255220413208, "content": {"text": "def find_judge(n, trust):\n    \"\"\"You have a convex `n`\\-sided polygon where each vertex has an integer value. You are given an integer array `values` where `values[i]` is the value of the `ith` vertex (i.e., **clockwise order**).\n\nYou will **triangulate** the polygon into `n - 2` triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all `n - 2` triangles in the triangulation.\n\nReturn _the smallest possible total score that you can achieve with some triangulation of the polygon_.\n\n**Example 1:**\n\n**Input:** values = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The polygon is already triangulated, and the score of the only triangle is 6.\n\n**Example 2:**\n\n**Input:** values = \\[3,7,4,5\\]\n**Output:** 144\n**Explanation:** There are two triangulations, with possible scores: 3\\*7\\*5 + 4\\*5\\*7 = 245, or 3\\*4\\*5 + 3\\*4\\*7 = 144.\nThe minimum score is 144.\n\n**Example 3:**\n\n**Input:** values = \\[1,3,1,4,1,5\\]\n**Output:** 13\n**Explanation:** The minimum score triangulation has score 1\\*1\\*3 + 1\\*1\\*4 + 1\\*1\\*5 + 1\\*1\\*1 = 13.\n\n**Constraints:**\n\n*   `n == values.length`\n*   `3 <= n <= 50`\n*   `1 <= values[i] <= 100`\"\"\"\n\n    trustCounts = [0] * (n + 1)\n    for a, b in trust:\n        trustCounts[a] -= 1\n        trustCounts[b] += 1\n\n    for i in range(1, n + 1):\n        if trustCounts[i] == n - 1:\n            return i\n    return -1"}}, "leetcode/csn_python_train_390584.txt": {"score": 0.8351835012435913, "content": {"text": "def polygon(x, y, radius, sides, rotationDegrees=0, stretchHorizontal=1.0, stretchVertical=1.0, filled=False, thickness=1):\n    \"\"\"\n    Returns a generator that produces the (x, y) points of a regular polygon.\n    `x` and `y` mark the center of the polygon, `radius` indicates the size,\n    `sides` specifies what kind of polygon it is.\n\n    Odd-sided polygons have a pointed corner at the top and flat horizontal\n    side at the bottom. The `rotationDegrees` argument will rotate the polygon\n    counterclockwise.\n\n    The polygon can be stretched by passing `stretchHorizontal` or `stretchVertical`\n    arguments. Passing `2.0` for `stretchHorizontal`, for example, will double with\n    width of the polygon.\n\n    If `filled` is set to `True`, the generator will also produce the interior\n    (x, y) points.\n\n    (Note: The `thickness` parameter is not yet implemented.)\n\n    >>> list(polygon(10, 10, 8, 5))\n    [(9, 3), (8, 4), (7, 5), (6, 6), (5, 6), (4, 7), (3, 8), (3, 9), (4, 10), (4, 11), (4, 12), (5, 13), (5, 14), (6, 15), (6, 16), (7, 16), (8, 16), (9, 16), (10, 16), (11, 16), (12, 16), (13, 16), (14, 16), (14, 15), (15, 14), (15, 13), (16, 12), (16, 11), (16, 10), (17, 9), (17, 8), (16, 7), (15, 6), (14, 5), (13, 4), (12, 4), (11, 3), (10, 2)]\n    >>> drawPoints(polygon(10, 10, 8, 5))\n    ,,,,,,,O,,,,,,,\n    ,,,,,,O,O,,,,,,\n    ,,,,,O,,,OO,,,,\n    ,,,,O,,,,,,O,,,\n    ,,OO,,,,,,,,O,,\n    ,O,,,,,,,,,,,O,\n    O,,,,,,,,,,,,,O\n    O,,,,,,,,,,,,,O\n    ,O,,,,,,,,,,,O,\n    ,O,,,,,,,,,,,O,\n    ,O,,,,,,,,,,,O,\n    ,,O,,,,,,,,,O,,\n    ,,O,,,,,,,,,O,,\n    ,,,O,,,,,,,O,,,\n    ,,,OOOOOOOOO,,,\n    >>> drawPoints(polygon(10, 10, 8, 5, rotationDegrees=20))\n    ,,,,,OO,,,,,,,\n    ,,,,O,,OOO,,,,\n    ,,,,O,,,,,OO,,\n    ,,,O,,,,,,,,OO\n    ,,O,,,,,,,,,,O\n    ,O,,,,,,,,,,,O\n    ,O,,,,,,,,,,,O\n    O,,,,,,,,,,,,O\n    ,O,,,,,,,,,,,O\n    ,O,,,,,,,,,,,O\n    ,,O,,,,,,,,,,O\n    ,,,O,,,,,,,,OO\n    ,,,,O,,,,,OO,,\n    ,,,,O,,OOO,,,,\n    ,,,,,OO,,,,,,,\n    \"\"\"\n    if thickness != 1:\n        raise NotImplementedError('The pybresenham module is under development and the filled, thickness, and endcap parameters are not implemented. You can contribute at https://github.com/asweigart/pybresenham')\n\n    # Validate sides (x, y, radius, and rotationDegrees are validated in polygonVertices())\n    _checkForIntOrFloat(sides)\n    if sides < 3:\n        raise PyBresenhamException('sides argument must be at least 3')\n\n    vertices = list(polygonVertices(x, y, radius, sides, rotationDegrees, stretchHorizontal, stretchVertical))\n\n    if filled:\n        # Run flood fill on the shape, starting from the center.\n        borderPoints = list(lines(vertices, closed=True, thickness=thickness, endcap=None))\n        return iter(floodFill(borderPoints, x, y))\n    else:\n        return lines(vertices, closed=True, thickness=thickness, endcap=None)"}}, "leetcode/leetcode_1395.txt": {"score": 0.8326374292373657, "content": {"text": "def minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    \"\"\"There are `n` soldiers standing in a line. Each soldier is assigned a **unique** `rating` value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\n*   Choose 3 soldiers with index (`i`, `j`, `k`) with rating (`rating[i]`, `rating[j]`, `rating[k]`).\n*   A team is valid if: (`rating[i] < rating[j] < rating[k]`) or (`rating[i] > rating[j] > rating[k]`) where (`0 <= i < j < k < n`).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\n**Example 1:**\n\n**Input:** rating = \\[2,5,3,4,1\\]\n**Output:** 3\n**Explanation:** We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\n**Example 2:**\n\n**Input:** rating = \\[2,1,3\\]\n**Output:** 0\n**Explanation:** We can't form any team given the conditions.\n\n**Example 3:**\n\n**Input:** rating = \\[1,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `n == rating.length`\n*   `3 <= n <= 1000`\n*   `1 <= rating[i] <= 105`\n*   All the integers in `rating` are **unique**.\n\nIn one second, you can either: - Move vertically by one unit, - Move horizontally by one unit, or - Move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in one second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points, but they do not count as visited unless you stop on them.\"\"\"\n\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        time += max(dx, dy)\n    return time"}}, "leetcode/leetcode_1954.txt": {"score": 0.8628301620483398, "content": {"text": "def replace_digits(s: str) -> str:\n    \"\"\"In a garden represented as an infinite 2D grid, there is an apple tree planted at **every** integer coordinate. The apple tree planted at an integer coordinate `(i, j)` has `|i| + |j|` apples growing on it.\n\nYou will buy an axis-aligned **square plot** of land that is centered at `(0, 0)`.\n\nGiven an integer `neededApples`, return _the **minimum perimeter** of a plot such that **at least**_ `neededApples` _apples are **inside or on** the perimeter of that plot_.\n\nThe value of `|x|` is defined as:\n\n*   `x` if `x >= 0`\n*   `-x` if `x < 0`\n\n**Example 1:**\n\n**Input:** neededApples = 1\n**Output:** 8\n**Explanation:** A square plot of side length 1 does not contain any apples.\nHowever, a square plot of side length 2 has 12 apples inside (as depicted in the image above).\nThe perimeter is 2 \\* 4 = 8.\n\n**Example 2:**\n\n**Input:** neededApples = 13\n**Output:** 16\n\n**Example 3:**\n\n**Input:** neededApples = 1000000000\n**Output:** 5040\n\n**Constraints:**\n\n*   `1 <= neededApples <= 1015`\"\"\"\n\n    s = list(s)\n    for i in range(1, len(s), 2):\n        s[i] = chr(ord(s[i - 1]) + int(s[i]))\n    return ''.join(s)"}}, "leetcode/leetcode_2280.txt": {"score": 0.8553126454353333, "content": {"text": "def count_good_triplets(nums1: list, nums2: list) -> int:\n    \"\"\"You are given a 2D integer array `stockPrices` where `stockPrices[i] = [dayi, pricei]` indicates the price of the stock on day `dayi` is `pricei`. A **line chart** is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:\n\nReturn _the **minimum number of lines** needed to represent the line chart_.\n\n**Example 1:**\n\n**Input:** stockPrices = \\[\\[1,7\\],\\[2,6\\],\\[3,5\\],\\[4,4\\],\\[5,4\\],\\[6,3\\],\\[7,2\\],\\[8,1\\]\\]\n**Output:** 3\n**Explanation:**\nThe diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.\nThe following 3 lines can be drawn to represent the line chart:\n- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).\n- Line 2 (in blue) from (4,4) to (5,4).\n- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).\nIt can be shown that it is not possible to represent the line chart using less than 3 lines.\n\n**Example 2:**\n\n**Input:** stockPrices = \\[\\[3,4\\],\\[1,2\\],\\[7,8\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:**\nAs shown in the diagram above, the line chart can be represented with a single line.\n\n**Constraints:**\n\n*   `1 <= stockPrices.length <= 105`\n*   `stockPrices[i].length == 2`\n*   `1 <= dayi, pricei <= 109`\n*   All `dayi` are **distinct**.\"\"\"\n\n    n = len(nums1)\n    pos1 = [0] * n\n    pos2 = [0] * n\n    for i in range(n):\n        pos1[nums1[i]] = i\n        pos2[nums2[i]] = i\n    count = 0\n    for x in range(n):\n        for y in range(x + 1, n):\n            for z in range(y + 1, n):\n                if pos1[x] < pos1[y] < pos1[z] and pos2[x] < pos2[y] < pos2[z]:\n                    count += 1\n    return count"}}, "leetcode/leetcode_2481.txt": {"score": 0.9972308278083801, "content": {"text": "def min_cuts(n):\n    \"\"\"A **valid cut** in a circle can be:\n\n*   A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or\n*   A cut that is represented by a straight line that touches one point on the edge of the circle and its center.\n\nSome valid and invalid cuts are shown in the figures below.\n\nGiven the integer `n`, return _the **minimum** number of cuts needed to divide a circle into_ `n` _equal slices_.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** \nThe above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:**\nAt least 3 cuts are needed to divide the circle into 3 equal slices. \nIt can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.\nAlso note that the first cut will not divide the circle into distinct parts.\n\n**Constraints:**\n\n*   `1 <= n <= 100`\"\"\"\n\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return n"}}}}, "135": {"gold": {"leetcode/leetcode_1697.txt": 1}, "retrieved": {"leetcode/leetcode_1976.txt": {"score": 0.9001783728599548, "content": {"text": "def can_split_string(s: str) -> bool:\n    \"\"\"You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with **bi-directional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the **shortest amount of time**.\n\nReturn _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 7, roads = \\[\\[0,6,7\\],\\[0,1,2\\],\\[1,2,3\\],\\[1,3,3\\],\\[6,3,3\\],\\[3,5,1\\],\\[6,5,1\\],\\[2,5,1\\],\\[0,4,5\\],\\[4,6,2\\]\\]\n**Output:** 4\n**Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u279d 6\n- 0 \u279d 4 \u279d 6\n- 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6\n- 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6\n\n**Example 2:**\n\n**Input:** n = 2, roads = \\[\\[1,0,10\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\n*   `n - 1 <= roads.length <= n * (n - 1) / 2`\n*   `roads[i].length == 3`\n*   `0 <= ui, vi <= n - 1`\n*   `1 <= timei <= 109`\n*   `ui != vi`\n*   There is at most one road connecting any two intersections.\n*   You can reach any intersection from any other intersection.\"\"\"\n\n    count = [0] * 10\n\n    for c in s:\n        count[int(c)] += 1\n\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n\n    return False"}}, "leetcode/leetcode_1697.txt": {"score": 0.9043542146682739, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"An undirected graph of `n` nodes is defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]` denotes an edge between nodes `ui` and `vi` with distance `disi`. Note that there may be **multiple** edges between two nodes.\n\nGiven an array `queries`, where `queries[j] = [pj, qj, limitj]`, your task is to determine for each `queries[j]` whether there is a path between `pj` and `qj` such that each edge on the path has a distance **strictly less than** `limitj` .\n\nReturn _a **boolean array**_ `answer`_, where_ `answer.length == queries.length` _and the_ `jth` _value of_ `answer` _is_ `true` _if there is a path for_ `queries[j]` _is_ `true`_, and_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** n = 3, edgeList = \\[\\[0,1,2\\],\\[1,2,4\\],\\[2,0,8\\],\\[1,0,16\\]\\], queries = \\[\\[0,1,2\\],\\[0,2,5\\]\\]\n**Output:** \\[false,true\\]\n**Explanation:** The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.\nFor the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.\nFor the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.\n\n**Example 2:**\n\n**Input:** n = 5, edgeList = \\[\\[0,1,10\\],\\[1,2,5\\],\\[2,3,9\\],\\[3,4,13\\]\\], queries = \\[\\[0,4,14\\],\\[1,4,13\\]\\]\n**Output:** \\[true,false\\]\n**Exaplanation:** The above figure shows the given graph.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `1 <= edgeList.length, queries.length <= 105`\n*   `edgeList[i].length == 3`\n*   `queries[j].length == 3`\n*   `0 <= ui, vi, pj, qj <= n - 1`\n*   `ui != vi`\n*   `pj != qj`\n*   `1 <= disi, limitj <= 109`\n*   There may be **multiple** edges between two nodes.\"\"\"\n\n\ndef distanceLimitedPathsExist(n, edgeList, queries):\n    graph = defaultdict(list)\n\n    for u, v, dis in edgeList:\n        graph[u].append((v, dis))\n        graph[v].append((u, dis))\n\n    answer = [False] * len(queries)\n    for i, (pj, qj, limitj) in enumerate(queries):\n        q = deque([(pj, 0)])\n        visited = [False] * n\n        visited[pj] = True\n\n        while q:\n            curr_node, curr_dist = q.popleft()\n\n            for next_node, next_dist in graph[curr_node]:\n                if curr_dist + next_dist < limitj:\n                    if next_node == qj:\n                        answer[i] = True\n                        break\n                    if not visited[next_node]:\n                        visited[next_node] = True\n                        q.append((next_node, curr_dist + next_dist))\n            if answer[i]:\n                break\n\n    return answer"}}, "leetcode/leetcode_787.txt": {"score": 0.9171247482299805, "content": {"text": "from collections import deque\n    \"\"\"There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return `-1`.\n\n**Example 1:**\n\n**Input:** n = 4, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[2,0,100\\],\\[1,3,600\\],\\[2,3,200\\]\\], src = 0, dst = 3, k = 1\n**Output:** 700\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities \\[0,1,2,3\\] is cheaper but is invalid because it uses 2 stops.\n\n**Example 2:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 1\n**Output:** 200\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\n**Example 3:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 0\n**Output:** 500\n**Explanation:**\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= flights.length <= (n * (n - 1) / 2)`\n*   `flights[i].length == 3`\n*   `0 <= fromi, toi < n`\n*   `fromi != toi`\n*   `1 <= pricei <= 104`\n*   There will not be any multiple flights between two cities.\n*   `0 <= src, dst, k < n`\n*   `src != dst`\"\"\"\n\n\ndef slidingPuzzle(board):\n    m, n = 2, 3\n    target = \"123450\"\n    start = \"\".join(str(num) for row in board for num in row)\n    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]\n    q = deque([start])\n    res = 0\n    visited = {start}\n    while q:\n        for _ in range(len(q)):\n            cur = q.popleft()\n            if cur == target:\n                return res\n            zero_idx = cur.index(\"0\")\n            for dir in dirs[zero_idx]:\n                neighbor = list(cur)\n                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]\n                neighbor = \"\".join(neighbor)\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        res += 1\n    return -1"}}, "leetcode/leetcode_1514.txt": {"score": 0.907706618309021, "content": {"text": "def min_start_value(nums):\n    \"\"\"You are given an undirected weighted graph of `n` nodes (0-indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes `a` and `b` with a probability of success of traversing that edge `succProb[i]`.\n\nGiven two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability.\n\nIf there is no path from `start` to `end`, **return 0**. Your answer will be accepted if it differs from the correct answer by at most **1e-5**.\n\n**Example 1:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,2\\]\\], succProb = \\[0.5,0.5,0.2\\], start = 0, end = 2\n**Output:** 0.25000\n**Explanation:** There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 \\* 0.5 = 0.25.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\],\\[1,2\\],\\[0,2\\]\\], succProb = \\[0.5,0.5,0.3\\], start = 0, end = 2\n**Output:** 0.30000\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[0,1\\]\\], succProb = \\[0.5\\], start = 0, end = 2\n**Output:** 0.00000\n**Explanation:** There is no path between 0 and 2.\n\n**Constraints:**\n\n*   `2 <= n <= 10^4`\n*   `0 <= start, end < n`\n*   `start != end`\n*   `0 <= a, b < n`\n*   `a != b`\n*   `0 <= succProb.length == edges.length <= 2*10^4`\n*   `0 <= succProb[i] <= 1`\n*   There is at most one edge between every two nodes.\"\"\"\n\n    min_sum, sum = 0, 0\n    for num in nums:\n        sum += num\n        min_sum = min(min_sum, sum)\n    return 1 - min_sum"}}, "leetcode/leetcode_743.txt": {"score": 0.9216910600662231, "content": {"text": "import heapq\n    \"\"\"You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return _the **minimum** time it takes for all the_ `n` _nodes to receive the signal_. If it is impossible for all the `n` nodes to receive the signal, return `-1`.\n\n**Example 1:**\n\n**Input:** times = \\[\\[2,1,1\\],\\[2,3,1\\],\\[3,4,1\\]\\], n = 4, k = 2\n**Output:** 2\n\n**Example 2:**\n\n**Input:** times = \\[\\[1,2,1\\]\\], n = 2, k = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** times = \\[\\[1,2,1\\]\\], n = 2, k = 2\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= k <= n <= 100`\n*   `1 <= times.length <= 6000`\n*   `times[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `0 <= wi <= 100`\n*   All the pairs `(ui, vi)` are **unique**. (i.e., no multiple edges.)\"\"\"\n\n\ndef networkDelayTime(times, n, k):\n    graph = {i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {u: float('inf') for u in range(1, n+1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n\n        for v, weight in graph[u]:\n            new_dist = curr_dist + weight\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n\n    max_time = max(dist.values())\n    return max_time if max_time < float('inf') else -1"}}, "leetcode/leetcode_1928.txt": {"score": 0.9591995477676392, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"There is a country of `n` cities numbered from `0` to `n - 1` where **all the cities are connected** by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is represented as a **0-indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime` **minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or_ `-1` _if you cannot complete it within_ `maxTime` _minutes_.\n\n**Example 1:**\n\n**Input:** maxTime = 30, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 11\n**Explanation:** The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n\n**Example 2:**\n\n**Input:** maxTime = 29, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 48\n**Explanation:** The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n\n**Example 3:**\n\n**Input:** maxTime = 25, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** -1\n**Explanation:** There is no way to reach city 5 from city 0 within 25 minutes.\n\n**Constraints:**\n\n*   `1 <= maxTime <= 1000`\n*   `n == passingFees.length`\n*   `2 <= n <= 1000`\n*   `n - 1 <= edges.length <= 1000`\n*   `0 <= xi, yi <= n - 1`\n*   `1 <= timei <= 1000`\n*   `1 <= passingFees[j] <= 1000`\n*   The graph may contain multiple edges between two nodes.\n*   The graph does not contain self loops.\"\"\"\n\n\ndef getNumberOfBacklogOrders(orders):\n    buy, sell = [], []\n\n    for price, amount, orderType in orders:\n        if orderType == 0:\n            while amount > 0 and sell and -sell[0][0] <= price:\n                executedAmount = min(amount, sell[0][1])\n                amount -= executedAmount\n                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]\n                if sell[0][1] == 0:\n                    heappop(sell)\n            if amount:\n                heappush(buy, [-price, amount])\n        else:\n            while amount > 0 and buy and buy[0][0] >= price:\n                executedAmount = min(amount, buy[0][1])\n                amount -= executedAmount\n                buy[0] = [buy[0][0], buy[0][1] - executedAmount]\n                if buy[0][1] == 0:\n                    heappop(buy)\n            if amount:\n                heappush(sell, [-price, amount])\n\n    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)\n    return res % 1000000007"}}, "leetcode/leetcode_1786.txt": {"score": 0.9190735220909119, "content": {"text": "def count_consistent_strings(allowed, words):\n    \"\"\"There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[1,2,3\\],\\[1,3,3\\],\\[2,3,1\\],\\[1,4,2\\],\\[5,2,2\\],\\[3,5,1\\],\\[5,4,10\\]\\]\n**Output:** 3\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,3,1\\],\\[4,1,2\\],\\[7,3,4\\],\\[2,5,3\\],\\[5,6,1\\],\\[6,7,2\\],\\[7,5,3\\],\\[2,6,4\\]\\]\n**Output:** 1\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The only restricted path is 1 --> 3 --> 7.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `n - 1 <= edges.length <= 4 * 104`\n*   `edges[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= weighti <= 105`\n*   There is at most one edge between any two nodes.\n*   There is at least one path between any two nodes.\"\"\"\n\n    allowed_set = set(allowed)\n    count = 0\n    for word in words:\n        is_valid = True\n        for c in word:\n            if c not in allowed_set:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n    return count"}}, "leetcode/leetcode_2492.txt": {"score": 0.9921083450317383, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are given a positive integer `n` representing `n` cities numbered from `1` to `n`. You are also given a **2D** array `roads` where `roads[i] = [ai, bi, distancei]` indicates that there is a **bidirectional** road between cities `ai` and `bi` with a distance equal to `distancei`. The cities graph is not necessarily connected.\n\nThe **score** of a path between two cities is defined as the **minimum** distance of a road in this path.\n\nReturn _the **minimum** possible score of a path between cities_ `1` _and_ `n`.\n\n**Note**:\n\n*   A path is a sequence of roads between two cities.\n*   It is allowed for a path to contain the same road **multiple** times, and you can visit cities `1` and `n` multiple times along the path.\n*   The test cases are generated such that there is **at least** one path between `1` and `n`.\n\n**Example 1:**\n\n**Input:** n = 4, roads = \\[\\[1,2,9\\],\\[2,3,6\\],\\[2,4,5\\],\\[1,4,7\\]\\]\n**Output:** 5\n**Explanation:** The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n\n**Example 2:**\n\n**Input:** n = 4, roads = \\[\\[1,2,2\\],\\[1,3,4\\],\\[3,4,7\\]\\]\n**Output:** 2\n**Explanation:** The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `1 <= roads.length <= 105`\n*   `roads[i].length == 3`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   `1 <= distancei <= 104`\n*   There are no repeated edges.\n*   There is at least one path between `1` and `n`.\"\"\"\n\nfrom collections import defaultdict\n\ndef minimumScore(n, roads):\n    adj = defaultdict(list)\n    for road in roads:\n        adj[road[0]].append((road[1], road[2]))\n        adj[road[1]].append((road[0], road[2]))\n\n    INF = int(1e9)\n    pq = [(0, 1)]\n\n    minDist = [INF] * (n + 1)\n    while pq:\n        curDist, curCity = heappop(pq)\n\n        if curCity == n:\n            return curDist\n\n        if curDist < minDist[curCity]:\n            minDist[curCity] = curDist\n            for nextCity, nextDist in adj[curCity]:\n                candidate_dist = max(curDist, nextDist)\n                if candidate_dist < minDist[nextCity]:\n                    heappush(pq, (candidate_dist, nextCity))\n\n    return -1"}}, "leetcode/leetcode_2203.txt": {"score": 0.9314150214195251, "content": {"text": "from heapq import heappop, heappush\n    \"\"\"You are given an integer `n` denoting the number of nodes of a **weighted directed** graph. The nodes are numbered from `0` to `n - 1`.\n\nYou are also given a 2D integer array `edges` where `edges[i] = [fromi, toi, weighti]` denotes that there exists a **directed** edge from `fromi` to `toi` with weight `weighti`.\n\nLastly, you are given three **distinct** integers `src1`, `src2`, and `dest` denoting three distinct nodes of the graph.\n\nReturn _the **minimum weight** of a subgraph of the graph such that it is **possible** to reach_ `dest` _from both_ `src1` _and_ `src2` _via a set of edges of this subgraph_. In case such a subgraph does not exist, return `-1`.\n\nA **subgraph** is a graph whose vertices and edges are subsets of the original graph. The **weight** of a subgraph is the sum of weights of its constituent edges.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,2,2\\],\\[0,5,6\\],\\[1,0,3\\],\\[1,4,5\\],\\[2,1,1\\],\\[2,3,3\\],\\[2,3,4\\],\\[3,4,2\\],\\[4,5,1\\]\\], src1 = 0, src2 = 1, dest = 5\n**Output:** 9\n**Explanation:**\nThe above figure represents the input graph.\nThe blue edges represent one of the subgraphs that yield the optimal answer.\nNote that the subgraph \\[\\[1,0,3\\],\\[0,5,6\\]\\] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n\n**Example 2:**\n\n**Input:** n = 3, edges = \\[\\[0,1,1\\],\\[2,1,1\\]\\], src1 = 0, src2 = 1, dest = 2\n**Output:** -1\n**Explanation:**\nThe above figure represents the input graph.\nIt can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.\n\n**Constraints:**\n\n*   `3 <= n <= 105`\n*   `0 <= edges.length <= 105`\n*   `edges[i].length == 3`\n*   `0 <= fromi, toi, src1, src2, dest <= n - 1`\n*   `fromi != toi`\n*   `src1`, `src2`, and `dest` are pairwise distinct.\n*   `1 <= weight[i] <= 105`\"\"\"\n\nfrom sys import maxsize\n\ndef dijkstra(src, adj):\n    dist = [maxsize] * len(adj)\n    dist[src] = 0\n    pq = [(0, src)]\n\n    while pq:\n        d, u = heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in adj[u]:\n            if d + w < dist[v]:\n                dist[v] = d + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\ndef min_weight_subgraph(n, edges, src1, src2, dest):\n    adj = [[] for _ in range(n)]\n    for u, v, w in edges:\n        adj[u].append((v, w))\n\n    dist1 = dijkstra(src1, adj)\n    dist2 = dijkstra(src2, adj)\n\n    res = dist1[dest] + dist2[dest]\n    for u, v, w in edges:\n        res = min(res, dist1[u] + dist2[v] + w)\n        res = min(res, dist1[v] + dist2[u] + w)\n\n    return res if res != maxsize else -1"}}, "leetcode/leetcode_1334.txt": {"score": 0.9399559497833252, "content": {"text": "def findTheCity(n, edges, distanceThreshold):\n    \"\"\"There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[0,1,3\\],\\[1,2,1\\],\\[1,3,4\\],\\[2,3,1\\]\\], distanceThreshold = 4\n**Output:** 3\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> \\[City 1, City 2\\] \nCity 1 -> \\[City 0, City 2, City 3\\] \nCity 2 -> \\[City 0, City 1, City 3\\] \nCity 3 -> \\[City 1, City 2\\] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1,2\\],\\[0,4,8\\],\\[1,2,3\\],\\[1,4,2\\],\\[2,3,1\\],\\[3,4,1\\]\\], distanceThreshold = 2\n**Output:** 0\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> \\[City 1\\] \nCity 1 -> \\[City 0, City 4\\] \nCity 2 -> \\[City 3, City 4\\] \nCity 3 -> \\[City 2, City 4\\]\nCity 4 -> \\[City 1, City 2, City 3\\] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= edges.length <= n * (n - 1) / 2`\n*   `edges[i].length == 3`\n*   `0 <= fromi < toi < n`\n*   `1 <= weighti, distanceThreshold <= 10^4`\n*   All pairs `(fromi, toi)` are distinct.\"\"\"\n\n    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res"}}}}, "136": {"gold": {"leetcode/leetcode_485.txt": 1, "leetcode/leetcode_1004.txt": 1}, "retrieved": {"leetcode/leetcode_1340.txt": {"score": 0.9203662872314453, "content": {"text": "import threading\n    \"\"\"Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:\n\n*   `i + x` where: `i + x < arr.length` and `0 < x <= d`.\n*   `i - x` where: `i - x >= 0` and `0 < x <= d`.\n\nIn addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).\n\nYou can choose any index of the array and start jumping. Return _the maximum number of indices_ you can visit.\n\nNotice that you can not jump outside of the array at any time.\n\n**Example 1:**\n\n**Input:** arr = \\[6,4,14,6,8,13,9,7,10,6,12\\], d = 2\n**Output:** 4\n**Explanation:** You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\nNote that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\nSimilarly You cannot jump from index 3 to index 2 or index 1.\n\n**Example 2:**\n\n**Input:** arr = \\[3,3,3,3,3\\], d = 3\n**Output:** 1\n**Explanation:** You can start at any index. You always cannot jump to any index.\n\n**Example 3:**\n\n**Input:** arr = \\[7,6,5,4,3,2,1\\], d = 1\n**Output:** 7\n**Explanation:** Start at index 0. You can visit all the indicies. \n\n**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 105`\n*   `1 <= d <= arr.length`\"\"\"\n\n\nclass DiningPhilosophers:\n    def __init__(self):\n        self.forks = [threading.Lock() for _ in range(5)]\n        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]\n\n    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:\n        left_fork = philosopher\n        right_fork = (philosopher + 1) % 5\n\n        with self.forks[left_fork]:\n            with self.not_busy[left_fork]:\n                while not self.forks[right_fork].acquire(blocking=False):\n                    self.not_busy[left_fork].wait()\n            pickLeftFork()\n\n            with self.forks[right_fork]:\n                pickRightFork()\n                eat()\n                putRightFork()\n                self.forks[right_fork].release()\n                with self.not_busy[right_fork]:\n                    self.not_busy[right_fork].notify_all()\n\n            putLeftFork()\n            self.not_busy[left_fork].notify_all()"}}, "leetcode/leetcode_2560.txt": {"score": 0.9218659996986389, "content": {"text": "def minimumCapability(nums, k):\n    \"\"\"There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he **refuses to steal from adjacent homes**.\n\nThe **capability** of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\n\nYou are given an integer array `nums` representing how much money is stashed in each house. More formally, the `ith` house from the left has `nums[i]` dollars.\n\nYou are also given an integer `k`, representing the **minimum** number of houses the robber will steal from. It is always possible to steal at least `k` houses.\n\nReturn _the **minimum** capability of the robber out of all the possible ways to steal at least_ `k` _houses_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,5,9\\], k = 2\n**Output:** 5\n**Explanation:** \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums\\[0\\], nums\\[2\\]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums\\[0\\], nums\\[3\\]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums\\[1\\], nums\\[3\\]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\], k = 2\n**Output:** 2\n**Explanation:** There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums\\[0\\], nums\\[4\\]) = 2.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `1 <= k <= (nums.length + 1)/2`\"\"\"\n\n    n, l, r = len(nums), 1, 10**9\n    while l < r:\n        mid = l + (r - l) // 2\n        i, cnt = 0, 0\n        for j in range(n):\n            if nums[j] <= mid:\n                cnt += 1\n                i = j + 2\n                while i + 1 < n and (i == j + 1 or nums[i] > mid):\n                    i += 1\n        if cnt < k:\n            l = mid + 1\n        else:\n            r = mid\n    return l"}}, "leetcode/leetcode_1642.txt": {"score": 0.9214153289794922, "content": {"text": "def maxWaterBottles(numBottles: int, numExchange: int) -> int:\n    \"\"\"You are given an integer array `heights` representing the heights of buildings, some `bricks`, and some `ladders`.\n\nYou start your journey from building `0` and move to the next building by possibly using bricks or ladders.\n\nWhile moving from building `i` to building `i+1` (**0-indexed**),\n\n*   If the current building's height is **greater than or equal** to the next building's height, you do **not** need a ladder or bricks.\n*   If the current building's height is **less than** the next building's height, you can either use **one ladder** or `(h[i+1] - h[i])` **bricks**.\n\n_Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally._\n\n**Example 1:**\n\n**Input:** heights = \\[4,2,7,6,9,14,12\\], bricks = 5, ladders = 1\n**Output:** 4\n**Explanation:** Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 >= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n- Go to building 3 without using ladders nor bricks since 7 >= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n\n**Example 2:**\n\n**Input:** heights = \\[4,12,2,7,3,18,20,3,19\\], bricks = 10, ladders = 2\n**Output:** 7\n\n**Example 3:**\n\n**Input:** heights = \\[14,3,19,3\\], bricks = 17, ladders = 0\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `1 <= heights[i] <= 106`\n*   `0 <= bricks <= 109`\n*   `0 <= ladders <= heights.length`\"\"\"\n\n    total = numBottles\n    while numBottles >= numExchange:\n        newBottles = numBottles // numExchange\n        total += newBottles\n        numBottles = newBottles + numBottles % numExchange\n    return total"}}, "leetcode/leetcode_904.txt": {"score": 0.9238464832305908, "content": {"text": "def leafSimilar(root1, root2):\n    \"\"\"You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the **type** of fruit the `ith` tree produces.\n\nYou want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\n\n*   You only have **two** baskets, and each basket can only hold a **single type** of fruit. There is no limit on the amount of fruit each basket can hold.\n*   Starting from any tree of your choice, you must pick **exactly one fruit** from **every** tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\n*   Once you reach a tree with fruit that cannot fit in your baskets, you must stop.\n\nGiven the integer array `fruits`, return _the **maximum** number of fruits you can pick_.\n\n**Example 1:**\n\n**Input:** fruits = \\[1,2,1\\]\n**Output:** 3\n**Explanation:** We can pick from all 3 trees.\n\n**Example 2:**\n\n**Input:** fruits = \\[0,1,2,2\\]\n**Output:** 3\n**Explanation:** We can pick from trees \\[1,2,2\\].\nIf we had started at the first tree, we would only pick from trees \\[0,1\\].\n\n**Example 3:**\n\n**Input:** fruits = \\[1,2,3,2,2\\]\n**Output:** 4\n**Explanation:** We can pick from trees \\[2,3,2,2\\].\nIf we had started at the first tree, we would only pick from trees \\[1,2\\].\n\n**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `0 <= fruits[i] < fruits.length`\"\"\"\n\n    def getLeaves(node):\n        if not node:\n            return []\n        if not node.left and not node.right:\n            return [node.val]\n        return getLeaves(node.left) + getLeaves(node.right)\n\n    return getLeaves(root1) == getLeaves(root2)"}}, "leetcode/leetcode_1921.txt": {"score": 0.9252766966819763, "content": {"text": "def eliminate_maximum(dist, speed):\n    \"\"\"You are playing a video game where you are defending your city from a group of `n` monsters. You are given a **0-indexed** integer array `dist` of size `n`, where `dist[i]` is the **initial distance** in kilometers of the `ith` monster from the city.\n\nThe monsters walk toward the city at a **constant** speed. The speed of each monster is given to you in an integer array `speed` of size `n`, where `speed[i]` is the speed of the `ith` monster in kilometers per minute.\n\nYou have a weapon that, once fully charged, can eliminate a **single** monster. However, the weapon takes **one minute** to charge.The weapon is fully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a **loss**, and the game ends before you can use your weapon.\n\nReturn _the **maximum** number of monsters that you can eliminate before you lose, or_ `n` _if you can eliminate all the monsters before they reach the city._\n\n**Example 1:**\n\n**Input:** dist = \\[1,3,4\\], speed = \\[1,1,1\\]\n**Output:** 3\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,3,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,2,3\\]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are \\[X,X,2\\]. You eliminate the thrid monster.\nAll 3 monsters can be eliminated.\n\n**Example 2:**\n\n**Input:** dist = \\[1,1,2,3\\], speed = \\[1,1,1,1\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[1,1,2,3\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,1,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Example 3:**\n\n**Input:** dist = \\[3,2,4\\], speed = \\[5,3,2\\]\n**Output:** 1\n**Explanation:**\nIn the beginning, the distances of the monsters are \\[3,2,4\\]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are \\[X,0,2\\], so you lose.\nYou can only eliminate 1 monster.\n\n**Constraints:**\n\n*   `n == dist.length == speed.length`\n*   `1 <= n <= 105`\n*   `1 <= dist[i], speed[i] <= 105`\"\"\"\n\n    n = len(dist)\n    time_to_reach_city = [(dist[i] + speed[i] - 1) // speed[i] for i in range(n)]\n    time_to_reach_city.sort()\n    eliminated = 0\n    for i in range(n):\n        if time_to_reach_city[i] > i:\n            eliminated += 1\n        else:\n            break\n    return eliminated"}}, "leetcode/leetcode_2106.txt": {"score": 0.9264176487922668, "content": {"text": "from math import gcd\n    \"\"\"Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\nReturn _the **maximum total number** of fruits you can harvest_.\n\n**Example 1:**\n\n**Input:** fruits = \\[\\[2,8\\],\\[6,3\\],\\[8,6\\]\\], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n**Example 2:**\n\n**Input:** fruits = \\[\\[0,9\\],\\[4,1\\],\\[5,7\\],\\[6,2\\],\\[7,4\\],\\[10,9\\]\\], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n**Example 3:**\n\n**Input:** fruits = \\[\\[0,3\\],\\[6,4\\],\\[8,5\\]\\], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `fruits[i].length == 2`\n*   `0 <= startPos, positioni <= 2 * 105`\n*   `positioni-1 < positioni` for any `i > 0` (**0-indexed**)\n*   `1 <= amounti <= 104`\n*   `0 <= k <= 2 * 105`\"\"\"\n\n\ndef findGCD(nums):\n    return gcd(min(nums), max(nums))"}}, "leetcode/leetcode_2271.txt": {"score": 0.9232516884803772, "content": {"text": "def rearrange_array(nums):\n    \"\"\"You are given a 2D integer array `tiles` where `tiles[i] = [li, ri]` represents that every tile `j` in the range `li <= j <= ri` is colored white.\n\nYou are also given an integer `carpetLen`, the length of a single carpet that can be placed **anywhere**.\n\nReturn _the **maximum** number of white tiles that can be covered by the carpet_.\n\n**Example 1:**\n\n**Input:** tiles = \\[\\[1,5\\],\\[10,11\\],\\[12,18\\],\\[20,25\\],\\[30,32\\]\\], carpetLen = 10\n**Output:** 9\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles.\n\n**Example 2:**\n\n**Input:** tiles = \\[\\[10,11\\],\\[1,1\\]\\], carpetLen = 2\n**Output:** 2\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2.\n\n**Constraints:**\n\n*   `1 <= tiles.length <= 5 * 104`\n*   `tiles[i].length == 2`\n*   `1 <= li <= ri <= 109`\n*   `1 <= carpetLen <= 109`\n*   The `tiles` are **non-overlapping**.\"\"\"\n\n    nums.sort()\n    half = len(nums) // 2\n    result = [0] * len(nums)\n    j = 0\n    for i in range(half):\n        result[j] = nums[i]\n        result[j + 1] = nums[half + i]\n        j += 2\n    return result"}}, "leetcode/leetcode_1696.txt": {"score": 0.9298856258392334, "content": {"text": "def isPrintable(targetGrid):\n    \"\"\"You are given a **0-indexed** integer array `nums` and an integer `k`.\n\nYou are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n - 1, i + k)]` **inclusive**.\n\nYou want to reach the last index of the array (index `n - 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array.\n\nReturn _the **maximum score** you can get_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,\\-1,-2,4,-7,3\\], k = 2\n**Output:** 7\n**Explanation:** You can choose your jumps forming the subsequence \\[1,-1,4,3\\] (underlined above). The sum is 7.\n\n**Example 2:**\n\n**Input:** nums = \\[10,-5,-2,4,0,3\\], k = 3\n**Output:** 17\n**Explanation:** You can choose your jumps forming the subsequence \\[10,4,3\\] (underlined above). The sum is 17.\n\n**Example 3:**\n\n**Input:** nums = \\[1,-5,-20,4,-1,3,-6,-3\\], k = 2\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length, k <= 105`\n*   `-104 <= nums[i] <= 104`\"\"\"\n\n    m, n = len(targetGrid), len(targetGrid[0])\n    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61\n    vis = [[False]*n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            c = targetGrid[i][j]\n            top[c] = min(top[c], i)\n            bottom[c] = max(bottom[c], i)\n            left[c] = min(left[c], j)\n            right[c] = max(right[c], j)\n\n    def dfs(x):\n        i, j = x // n, x % n\n        if vis[i][j]: return True\n        c = targetGrid[i][j]\n        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False\n        vis[i][j] = True\n        for k in range(1, 61):\n            if k == c: continue\n            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False\n            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False\n        return True\n\n    for color in range(1, 61):\n        for i in range(top[color], bottom[color] + 1):\n            for j in range(left[color], right[color] + 1):\n                if not vis[i][j] and not dfs(i * n + j): return False\n\n    return True"}}, "leetcode/leetcode_849.txt": {"score": 0.9314271211624146, "content": {"text": "def maxDistToClosest(seats):\n    \"\"\"You are given an array representing a row of `seats` where `seats[i] = 1` represents a person sitting in the `ith` seat, and `seats[i] = 0` represents that the `ith` seat is empty **(0-indexed)**.\n\nThere is at least one empty seat, and at least one person sitting.\n\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized.\n\nReturn _that maximum distance to the closest person_.\n\n**Example 1:**\n\n**Input:** seats = \\[1,0,0,0,1,0,1\\]\n**Output:** 2\n**Explanation:** \nIf Alex sits in the second open seat (i.e. seats\\[2\\]), then the closest person has distance 2.\nIf Alex sits in any other open seat, the closest person has distance 1.\nThus, the maximum distance to the closest person is 2.\n\n**Example 2:**\n\n**Input:** seats = \\[1,0,0,0\\]\n**Output:** 3\n**Explanation:** \nIf Alex sits in the last seat (i.e. seats\\[3\\]), the closest person is 3 seats away.\nThis is the maximum distance possible, so the answer is 3.\n\n**Example 3:**\n\n**Input:** seats = \\[0,1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `2 <= seats.length <= 2 * 104`\n*   `seats[i]` is `0` or `1`.\n*   At least one seat is **empty**.\n*   At least one seat is **occupied**.\"\"\"\n\n    n = len(seats)\n    maxDist = 0\n    lastPerson = -1\n\n    for i in range(n):\n        if seats[i] == 1:\n            if lastPerson == -1:\n                maxDist = i\n            else:\n                maxDist = max(maxDist, (i - lastPerson) // 2)\n            lastPerson = i\n\n    maxDist = max(maxDist, n - 1 - lastPerson)\n    return maxDist"}}, "leetcode/leetcode_2511.txt": {"score": 0.99858158826828, "content": {"text": "def max_captured_forts(forts):\n    \"\"\"You are given a **0-indexed** integer array `forts` of length `n` representing the positions of several forts. `forts[i]` can be `-1`, `0`, or `1` where:\n\n*   `-1` represents there is **no fort** at the `ith` position.\n*   `0` indicates there is an **enemy** fort at the `ith` position.\n*   `1` indicates the fort at the `ith` the position is under your command.\n\nNow you have decided to move your army from one of your forts at position `i` to an empty position `j` such that:\n\n*   `0 <= i, j <= n - 1`\n*   The army travels over enemy forts **only**. Formally, for all `k` where `min(i,j) < k < max(i,j)`, `forts[k] == 0.`\n\nWhile moving the army, all the enemy forts that come in the way are **captured**.\n\nReturn _the **maximum** number of enemy forts that can be captured_. In case it is **impossible** to move your army, or you do not have any fort under your command, return `0`_._\n\n**Example 1:**\n\n**Input:** forts = \\[1,0,0,-1,0,0,0,0,1\\]\n**Output:** 4\n**Explanation:**\n- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n- Moving the army from position 8 to position 3 captures 4 enemy forts.\nSince 4 is the maximum number of enemy forts that can be captured, we return 4.\n\n**Example 2:**\n\n**Input:** forts = \\[0,0,1,-1\\]\n**Output:** 0\n**Explanation:** Since no enemy fort can be captured, 0 is returned.\n\n**Constraints:**\n\n*   `1 <= forts.length <= 1000`\n*   `-1 <= forts[i] <= 1`\"\"\"\n\n    n = len(forts)\n    max_capture = 0\n    for i in range(n):\n        if forts[i] == 1:\n            for j in range(i+1, n):\n                if forts[j] != -1:\n                    capture = sum(1 for k in range(i+1, j) if forts[k] == 0)\n                    if forts[j] == 1:\n                        max_capture = max(max_capture, capture)\n    return max_capture"}}}}, "137": {"gold": {"leetcode/leetcode_2332.txt": 1, "leetcode/leetcode_2462.txt": 1}, "retrieved": {"leetcode/leetcode_851.txt": {"score": 0.9088241457939148, "content": {"text": "def to_goat_latin(sentence: str) -> str:\n    \"\"\"There is a group of `n` people labeled from `0` to `n - 1` where each person has a different amount of money and a different level of quietness.\n\nYou are given an array `richer` where `richer[i] = [ai, bi]` indicates that `ai` has more money than `bi` and an integer array `quiet` where `quiet[i]` is the quietness of the `ith` person. All the given data in richer are **logically correct** (i.e., the data will not lead you to a situation where `x` is richer than `y` and `y` is richer than `x` at the same time).\n\nReturn _an integer array_ `answer` _where_ `answer[x] = y` _if_ `y` _is the least quiet person (that is, the person_ `y` _with the smallest value of_ `quiet[y]`_) among all people who definitely have equal to or more money than the person_ `x`.\n\n**Example 1:**\n\n**Input:** richer = \\[\\[1,0\\],\\[2,1\\],\\[3,1\\],\\[3,7\\],\\[4,3\\],\\[5,3\\],\\[6,3\\]\\], quiet = \\[3,2,5,4,6,1,7,0\\]\n**Output:** \\[5,5,2,5,4,5,6,7\\]\n**Explanation:** \nanswer\\[0\\] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet\\[x\\]) is person 7, but it is not clear if they have more money than person 0.\nanswer\\[7\\] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet\\[x\\]) is person 7.\nThe other answers can be filled out with similar reasoning.\n\n**Example 2:**\n\n**Input:** richer = \\[\\], quiet = \\[0\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   `n == quiet.length`\n*   `1 <= n <= 500`\n*   `0 <= quiet[i] < n`\n*   All the values of `quiet` are **unique**.\n*   `0 <= richer.length <= n * (n - 1) / 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs of `richer` are **unique**.\n*   The observations in `richer` are all logically consistent.\"\"\"\n\n    words = sentence.split()\n    vowels = set(\"AEIOUaeiou\")\n    result = []\n\n    for i, word in enumerate(words):\n        if word[0] not in vowels:\n            word = word[1:] + word[0]\n        result.append(word + \"ma\" + \"a\" * (i + 1))\n\n    return ' '.join(result)"}}, "leetcode/leetcode_881.txt": {"score": 0.9113270044326782, "content": {"text": "from collections import defaultdict\n    \"\"\"You are given an array `people` where `people[i]` is the weight of the `ith` person, and an **infinite number of boats** where each boat can carry a maximum weight of `limit`. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most `limit`.\n\nReturn _the minimum number of boats to carry every given person_.\n\n**Example 1:**\n\n**Input:** people = \\[1,2\\], limit = 3\n**Output:** 1\n**Explanation:** 1 boat (1, 2)\n\n**Example 2:**\n\n**Input:** people = \\[3,2,2,1\\], limit = 3\n**Output:** 3\n**Explanation:** 3 boats (1, 2), (2) and (3)\n\n**Example 3:**\n\n**Input:** people = \\[3,5,3,4\\], limit = 5\n**Output:** 4\n**Explanation:** 4 boats (3), (3), (4), (5)\n\n**Constraints:**\n\n*   `1 <= people.length <= 5 * 104`\n*   `1 <= people[i] <= limit <= 3 * 104`\"\"\"\n\n\ndef loudAndRich(richer, quiet):\n    n = len(quiet)\n    graph = defaultdict(list)\n    for r in richer:\n        graph[r[1]].append(r[0])\n\n    answer = [-1] * n\n\n    def dfs(x):\n        if answer[x] != -1:\n            return answer[x]\n        answer[x] = x\n        for y in graph[x]:\n            cand = dfs(y)\n            if quiet[cand] < quiet[answer[x]]:\n                answer[x] = cand\n        return answer[x]\n\n    for i in range(n):\n        dfs(i)\n\n    return answer"}}, "leetcode/leetcode_1687.txt": {"score": 0.9164009094238281, "content": {"text": "def min_trips(boxes, portsCount, maxBoxes, maxWeight):\n    \"\"\"You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a **limit** on the **number of boxes** and the **total weight** that it can carry.\n\nYou are given an array `boxes`, where `boxes[i] = [ports\u200b\u200bi\u200b, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.\n\n*   `ports\u200b\u200bi` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.\n*   `portsCount` is the number of ports.\n*   `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered **in the order they are given**. The ship will follow these steps:\n\n*   The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.\n*   For each loaded box **in order**, the ship will make a **trip** to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no **trip** is needed, and the box can immediately be delivered.\n*   The ship then makes a return **trip** to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\n\nReturn _the **minimum** number of **trips** the ship needs to make to deliver all boxes to their respective ports._\n\n**Example 1:**\n\n**Input:** boxes = \\[\\[1,1\\],\\[2,1\\],\\[1,1\\]\\], portsCount = 2, maxBoxes = 3, maxWeight = 3\n**Output:** 4\n**Explanation:** The optimal strategy is as follows: \n- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\nSo the total number of trips is 4.\nNote that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n\n**Example 2:**\n\n**Input:** boxes = \\[\\[1,2\\],\\[3,3\\],\\[3,1\\],\\[3,1\\],\\[2,4\\]\\], portsCount = 3, maxBoxes = 3, maxWeight = 6\n**Output:** 6\n**Explanation:** The optimal strategy is as follows: \n- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n**Example 3:**\n\n**Input:** boxes = \\[\\[1,4\\],\\[1,2\\],\\[2,1\\],\\[2,1\\],\\[3,2\\],\\[3,4\\]\\], portsCount = 3, maxBoxes = 6, maxWeight = 7\n**Output:** 6\n**Explanation:** The optimal strategy is as follows:\n- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n**Constraints:**\n\n*   `1 <= boxes.length <= 105`\n*   `1 <= portsCount, maxBoxes, maxWeight <= 105`\n*   `1 <= ports\u200b\u200bi <= portsCount`\n*   `1 <= weightsi <= maxWeight`\"\"\"\n\n    trips = 0\n    idx = 0\n    n = len(boxes)\n    while idx < n:\n        curr_limit = maxWeight\n        prev_port = 0\n        count = 0\n        while count < maxBoxes and idx < n:\n            if boxes[idx][1] <= curr_limit:\n                if prev_port != boxes[idx][0]:\n                    prev_port = boxes[idx][0]\n                    trips += 1\n                curr_limit -= boxes[idx][1]\n                count += 1\n                idx += 1\n            else:\n                break\n        trips += 1\n    return trips"}}, "leetcode/leetcode_1962.txt": {"score": 0.9149863719940186, "content": {"text": "from queue import PriorityQueue\n    \"\"\"You are given a **0-indexed** integer array `piles`, where `piles[i]` represents the number of stones in the `ith` pile, and an integer `k`. You should apply the following operation **exactly** `k` times:\n\n*   Choose any `piles[i]` and **remove** `floor(piles[i] / 2)` stones from it.\n\n**Notice** that you can apply the operation on the **same** pile more than once.\n\nReturn _the **minimum** possible total number of stones remaining after applying the_ `k` _operations_.\n\n`floor(x)` is the **greatest** integer that is **smaller** than or **equal** to `x` (i.e., rounds `x` down).\n\n**Example 1:**\n\n**Input:** piles = \\[5,4,9\\], k = 2\n**Output:** 12\n**Explanation:** Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are \\[5,4,5\\].\n- Apply the operation on pile 0. The resulting piles are \\[3,4,5\\].\nThe total number of stones in \\[3,4,5\\] is 12.\n\n**Example 2:**\n\n**Input:** piles = \\[4,3,6,7\\], k = 3\n**Output:** 12\n**Explanation:** Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are \\[4,3,3,7\\].\n- Apply the operation on pile 3. The resulting piles are \\[4,3,3,4\\].\n- Apply the operation on pile 0. The resulting piles are \\[2,3,3,4\\].\nThe total number of stones in \\[2,3,3,4\\] is 12.\n\n**Constraints:**\n\n*   `1 <= piles.length <= 105`\n*   `1 <= piles[i] <= 104`\n*   `1 <= k <= 105`\"\"\"\n\n\ndef getOrder(tasks):\n    task_indices = sorted(range(len(tasks)), key=lambda i: tasks[i][0])\n    min_heap = PriorityQueue()\n    time = 0\n    task_idx = 0\n    result = []\n\n    while task_indices:\n        while task_idx < len(task_indices) and tasks[task_indices[task_idx]][0] <= time:\n            idx = task_indices[task_idx]\n            min_heap.put((tasks[idx][1], idx))\n            task_idx += 1\n\n        if not min_heap.empty():\n            processing_time, index = min_heap.get()\n            time += processing_time\n            result.append(index)\n            task_indices.remove(index)\n        elif task_idx < len(task_indices):\n            time = max(time, tasks[task_indices[task_idx]][0])\n\n    return result"}}, "leetcode/leetcode_2136.txt": {"score": 0.9130259156227112, "content": {"text": "def earliestBlooms(plantTime, growTime):\n    \"\"\"You have `n` flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two **0-indexed** integer arrays `plantTime` and `growTime`, of length `n` each:\n\n*   `plantTime[i]` is the number of **full days** it takes you to **plant** the `ith` seed. Every day, you can work on planting exactly one seed. You **do not** have to work on planting the same seed on consecutive days, but the planting of a seed is not complete **until** you have worked `plantTime[i]` days on planting it in total.\n*   `growTime[i]` is the number of **full days** it takes the `ith` seed to grow after being completely planted. **After** the last day of its growth, the flower **blooms** and stays bloomed forever.\n\nFrom the beginning of day `0`, you can plant the seeds in **any** order.\n\nReturn _the **earliest** possible day where **all** seeds are blooming_.\n\n**Example 1:**\n\n**Input:** plantTime = \\[1,4,3\\], growTime = \\[2,3,1\\]\n**Output:** 9\n**Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n**Example 2:**\n\n**Input:** plantTime = \\[1,2,3,2\\], growTime = \\[2,1,2,1\\]\n**Output:** 9\n**Explanation:** The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n\n**Example 3:**\n\n**Input:** plantTime = \\[1\\], growTime = \\[1\\]\n**Output:** 2\n**Explanation:** On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming.\n\n**Constraints:**\n\n*   `n == plantTime.length == growTime.length`\n*   `1 <= n <= 105`\n*   `1 <= plantTime[i], growTime[i] <= 104`\"\"\"\n\n    n = len(plantTime)\n    processTime = list(zip(plantTime, growTime))\n    processTime.sort()\n\n    day = 0\n    blooms = 0\n    for p in processTime:\n        day += p[0]\n        blooms = max(blooms, day + p[1])\n    return blooms"}}, "leetcode/leetcode_1834.txt": {"score": 0.9346888065338135, "content": {"text": "def minimum_teachings(n, languages, friendships):\n    \"\"\"You are given `n`\u200b\u200b\u200b\u200b\u200b\u200b tasks labeled from `0` to `n - 1` represented by a 2D integer array `tasks`, where `tasks[i] = [enqueueTimei, processingTimei]` means that the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b task will be available to process at `enqueueTimei` and will take `processingTimei` to finish processing.\n\nYou have a single-threaded CPU that can process **at most one** task at a time and will act in the following way:\n\n*   If the CPU is idle and there are no available tasks to process, the CPU remains idle.\n*   If the CPU is idle and there are available tasks, the CPU will choose the one with the **shortest processing time**. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.\n*   Once a task is started, the CPU will **process the entire task** without stopping.\n*   The CPU can finish a task then start a new one instantly.\n\nReturn _the order in which the CPU will process the tasks._\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[3,2\\],\\[4,1\\]\\]\n**Output:** \\[0,2,3,1\\]\n**Explanation:** The events go as follows: \n- At time = 1, task 0 is available to process. Available tasks = {0}.\n- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n- At time = 2, task 1 is available to process. Available tasks = {1}.\n- At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n- At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n- At time = 10, the CPU finishes task 1 and becomes idle.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[7,10\\],\\[7,12\\],\\[7,5\\],\\[7,4\\],\\[7,2\\]\\]\n**Output:** \\[4,3,2,0,1\\]\n**Explanation****:** The events go as follows:\n- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n- At time = 40, the CPU finishes task 1 and becomes idle.\n\n**Constraints:**\n\n*   `tasks.length == n`\n*   `1 <= n <= 105`\n*   `1 <= enqueueTimei, processingTimei <= 109`\"\"\"\n\n    language_users = {}\n    unconnected_users = set()\n\n    for u, v in friendships:\n        can_communicate = any(lang in languages[v-1] for lang in languages[u-1])\n        if not can_communicate:\n            unconnected_users.add(u)\n            unconnected_users.add(v)\n\n    res = len(unconnected_users)\n    for i in range(1, n+1):\n        cnt = sum(i not in languages[user-1] for user in unconnected_users)\n        res = min(res, cnt)\n\n    return res"}}, "leetcode/leetcode_2402.txt": {"score": 0.9220671057701111, "content": {"text": "import heapq\n    \"\"\"You are given an integer `n`. There are `n` rooms numbered from `0` to `n - 1`.\n\nYou are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the **half-closed** time interval `[starti, endi)`. All the values of `starti` are **unique**.\n\nMeetings are allocated to rooms in the following manner:\n\n1.  Each meeting will take place in the unused room with the **lowest** number.\n2.  If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the **same** duration as the original meeting.\n3.  When a room becomes unused, meetings that have an earlier original **start** time should be given the room.\n\nReturn _the **number** of the room that held the most meetings._ If there are multiple rooms, return _the room with the **lowest** number._\n\nA **half-closed interval** `[a, b)` is the interval between `a` and `b` **including** `a` and **not including** `b`.\n\n**Example 1:**\n\n**Input:** n = 2, meetings = \\[\\[0,10\\],\\[1,5\\],\\[2,7\\],\\[3,4\\]\\]\n**Output:** 0\n**Explanation:**\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period \\[5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period \\[10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\n**Example 2:**\n\n**Input:** n = 3, meetings = \\[\\[1,20\\],\\[2,10\\],\\[3,5\\],\\[4,9\\],\\[6,8\\]\\]\n**Output:** 1\n**Explanation:**\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period \\[5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period \\[10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `1 <= meetings.length <= 105`\n*   `meetings[i].length == 2`\n*   `0 <= starti < endi <= 5 * 105`\n*   All the values of `starti` are **unique**.\"\"\"\n\n\ndef most_visited_room(n, meetings):\n    meetings.sort()\n    pq = []\n    rooms = [0] * n\n    \n    for start, end in meetings:\n        while pq and pq[0][0] <= start:\n            _, room = heapq.heappop(pq)\n            rooms[room] += 1\n        heapq.heappush(pq, (end, len(pq) % n))\n    \n    return rooms.index(max(rooms))"}}, "leetcode/leetcode_2532.txt": {"score": 0.9760962128639221, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"There are `k` workers who want to move `n` boxes from an old warehouse to a new one. You are given the two integers `n` and `k`, and a 2D integer array `time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]`.\n\nThe warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all `k` workers are waiting on the left side of the bridge. To move the boxes, the `ith` worker (**0-indexed**) can :\n\n*   Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.\n*   Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.\n*   Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.\n*   Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.\n\nA worker `i` is **less efficient** than a worker `j` if either condition is met:\n\n*   `leftToRighti + rightToLefti > leftToRightj + rightToLeftj`\n*   `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j`\n\nThe following rules regulate the movement of the workers through the bridge :\n\n*   If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.\n*   If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with **the lowest efficiency** crosses first.\n*   If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with **the lowest efficiency** crosses first.\n\nReturn _the instance of time at which the last worker **reaches the left bank** of the river after all n boxes have been put in the new warehouse_.\n\n**Example 1:**\n\n**Input:** n = 1, k = 3, time = \\[\\[1,1,2,1\\],\\[1,1,3,1\\],\\[1,1,4,1\\]\\]\n**Output:** 6\n**Explanation:** \nFrom 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\nFrom 1 to 2: worker 2 picks up a box from the old warehouse.\nFrom 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\nFrom 6 to 7: worker 2 puts a box at the new warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n**Example 2:**\n\n**Input:** n = 3, k = 2, time = \\[\\[1,9,1,8\\],\\[10,10,10,10\\]\\]\n**Output:** 50\n**Explanation:** \nFrom 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.\nFrom 10 to 20: worker 1 picks up a box from the old warehouse.\nFrom 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 11 to 20: worker 0 picks up a box from the old warehouse.\nFrom 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\nFrom 30 to 40: worker 1 puts a box at the new warehouse.\nFrom 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 31 to 39: worker 0 puts a box at the new warehouse.\nFrom 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 40 to 49: worker 0 picks up a box from the old warehouse.\nFrom 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 50 to 58: worker 0 puts a box at the new warehouse.\nThe whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n**Constraints:**\n\n*   `1 <= n, k <= 104`\n*   `time.length == k`\n*   `time[i].length == 4`\n*   `1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000`\"\"\"\n\n\ndef getLastMoment(n, k, time):\n    left = [(time[j][0] + time[j][2], j) for j in range(k)]\n    right = []\n\n    while n:\n        while right and right[0][0] <= left[0][0]:\n            right_top = heappop(right)\n            heappush(left, (right_top[0] + time[right_top[1]][0] + time[right_top[1]][2], right_top[1]))\n        left_top = heappop(left)\n        time[left_top[1]][2] += time[left_top[1]][3] + time[left_top[1]][0] + time[left_top[1]][1]\n        heappush(right, (left_top[0] + time[left_top[1]][1], left_top[1]))\n        n -= 1\n\n    lastMoment = -1\n    while right:\n        right_top = heappop(right)\n        lastMoment = max(lastMoment, time[right_top[1]][2])\n    return lastMoment"}}, "leetcode/leetcode_2391.txt": {"score": 0.9258982539176941, "content": {"text": "def min_minutes(garbage: list[str], travel: list[int]) -> int:\n    \"\"\"You are given a **0-indexed** array of strings `garbage` where `garbage[i]` represents the assortment of garbage at the `ith` house. `garbage[i]` consists only of the characters `'M'`, `'P'` and `'G'` representing one unit of metal, paper and glass garbage respectively. Picking up **one** unit of any type of garbage takes `1` minute.\n\nYou are also given a **0-indexed** integer array `travel` where `travel[i]` is the number of minutes needed to go from house `i` to house `i + 1`.\n\nThere are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house `0` and must visit each house **in order**; however, they do **not** need to visit every house.\n\nOnly **one** garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks **cannot** do anything.\n\nReturn _the **minimum** number of minutes needed to pick up all the garbage._\n\n**Example 1:**\n\n**Input:** garbage = \\[ \"G \", \"P \", \"GP \", \"GG \"\\], travel = \\[2,4,3\\]\n**Output:** 21\n**Explanation:**\nThe paper garbage truck:\n1. Travels from house 0 to house 1\n2. Collects the paper garbage at house 1\n3. Travels from house 1 to house 2\n4. Collects the paper garbage at house 2\nAltogether, it takes 8 minutes to pick up all the paper garbage.\nThe glass garbage truck:\n1. Collects the glass garbage at house 0\n2. Travels from house 0 to house 1\n3. Travels from house 1 to house 2\n4. Collects the glass garbage at house 2\n5. Travels from house 2 to house 3\n6. Collects the glass garbage at house 3\nAltogether, it takes 13 minutes to pick up all the glass garbage.\nSince there is no metal garbage, we do not need to consider the metal garbage truck.\nTherefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.\n\n**Example 2:**\n\n**Input:** garbage = \\[ \"MMM \", \"PGM \", \"GP \"\\], travel = \\[3,10\\]\n**Output:** 37\n**Explanation:**\nThe metal garbage truck takes 7 minutes to pick up all the metal garbage.\nThe paper garbage truck takes 15 minutes to pick up all the paper garbage.\nThe glass garbage truck takes 15 minutes to pick up all the glass garbage.\nIt takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.\n\n**Constraints:**\n\n*   `2 <= garbage.length <= 105`\n*   `garbage[i]` consists of only the letters `'M'`, `'P'`, and `'G'`.\n*   `1 <= garbage[i].length <= 10`\n*   `travel.length == garbage.length - 1`\n*   `1 <= travel[i] <= 100`\"\"\"\n\n    time_garbage = [0, 0, 0]\n    time_travel = [0, 0, 0]\n\n    for i, g in enumerate(garbage):\n        m, p, g = g.count('M'), g.count('P'), g.count('G')\n        time_garbage[0] += m\n        time_garbage[1] += p\n        time_garbage[2] += g\n        if i < len(garbage) - 1:\n            time_travel[0] += travel[i]\n            time_travel[1] += travel[i]\n            time_travel[2] += travel[i]\n    \n    return sum(time_garbage) + sum(time_travel)"}}, "leetcode/leetcode_1882.txt": {"score": 0.9273818731307983, "content": {"text": "import heapq\n    \"\"\"You are given two **0-indexed** integer arrays `servers` and `tasks` of lengths `n`\u200b\u200b\u200b\u200b\u200b\u200b and `m`\u200b\u200b\u200b\u200b\u200b\u200b respectively. `servers[i]` is the **weight** of the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b server, and `tasks[j]` is the **time needed** to process the `j\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b task **in seconds**.\n\nTasks are assigned to the servers using a **task queue**. Initially, all servers are free, and the queue is **empty**.\n\nAt second `j`, the `jth` task is **inserted** into the queue (starting with the `0th` task being inserted at second `0`). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the **smallest weight**, and in case of a tie, it is assigned to a free server with the **smallest index**.\n\nIf there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned **in order of insertion** following the weight and index priorities above.\n\nA server that is assigned task `j` at second `t` will be free again at second `t + tasks[j]`.\n\nBuild an array `ans`\u200b\u200b\u200b\u200b of length `m`, where `ans[j]` is the **index** of the server the `j\u200b\u200b\u200b\u200b\u200b\u200bth` task will be assigned to.\n\nReturn _the array_ `ans`\u200b\u200b\u200b\u200b.\n\n**Example 1:**\n\n**Input:** servers = \\[3,3,2\\], tasks = \\[1,2,3,2,1,2\\]\n**Output:** \\[2,2,0,2,1,2\\]\n**Explanation:** Events in chronological order go as follows:\n- At second 0, task 0 is added and processed using server 2 until second 1.\n- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.\n- At second 2, task 2 is added and processed using server 0 until second 5.\n- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.\n- At second 4, task 4 is added and processed using server 1 until second 5.\n- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.\n\n**Example 2:**\n\n**Input:** servers = \\[5,1,4,3,2\\], tasks = \\[2,1,2,4,5,2,1\\]\n**Output:** \\[1,4,1,4,1,3,2\\]\n**Explanation:** Events in chronological order go as follows: \n- At second 0, task 0 is added and processed using server 1 until second 2.\n- At second 1, task 1 is added and processed using server 4 until second 2.\n- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. \n- At second 3, task 3 is added and processed using server 4 until second 7.\n- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. \n- At second 5, task 5 is added and processed using server 3 until second 7.\n- At second 6, task 6 is added and processed using server 2 until second 7.\n\n**Constraints:**\n\n*   `servers.length == n`\n*   `tasks.length == m`\n*   `1 <= n, m <= 2 * 105`\n*   `1 <= servers[i], tasks[j] <= 2 * 105`\"\"\"\n\nfrom typing import List\n\ndef assignTasks(servers: List[int], tasks: List[int]) -> List[int]:\n    free_servers = [(servers[i], i) for i in range(len(servers))]\n    heapq.heapify(free_servers)\n    busy_servers = []\n    result = [0] * len(tasks)\n\n    for time in range(len(tasks)):\n        while busy_servers and busy_servers[0][0] <= time:\n            _, server_elem = heapq.heappop(busy_servers)\n            heapq.heappush(free_servers, server_elem)\n        \n        if free_servers:\n            server_elem = heapq.heappop(free_servers)\n            result[time] = server_elem[1]\n            heapq.heappush(busy_servers, (time + tasks[time], server_elem))\n\n    return result"}}}}, "138": {"gold": {"leetcode/leetcode_50.txt": 1}, "retrieved": {"leetcode/leetcode_1610.txt": {"score": 0.8785647749900818, "content": {"text": "def xor_operation(n, start):\n    \"\"\"You are given an array `points`, an integer `angle`, and your `location`, where `location = [posx, posy]` and `points[i] = [xi, yi]` both denote **integral coordinates** on the X-Y plane.\n\nInitially, you are facing directly east from your position. You **cannot move** from your position, but you can **rotate**. In other words, `posx` and `posy` cannot be changed. Your field of view in **degrees** is represented by `angle`, determining how wide you can see from any given view direction. Let `d` be the amount in degrees that you rotate counterclockwise. Then, your field of view is the **inclusive** range of angles `[d - angle/2, d + angle/2]`.\n\nYour browser does not support the video tag or this video format.\n\nYou can **see** some set of points if, for each point, the **angle** formed by the point, your position, and the immediate east direction from your position is **in your field of view**.\n\nThere can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.\n\nReturn _the maximum number of points you can see_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[2,1\\],\\[2,2\\],\\[3,3\\]\\], angle = 90, location = \\[1,1\\]\n**Output:** 3\n**Explanation:** The shaded region represents your field of view. All points can be made visible in your field of view, including \\[3,3\\] even though \\[2,2\\] is in front and in the same line of sight.\n\n**Example 2:**\n\n**Input:** points = \\[\\[2,1\\],\\[2,2\\],\\[3,4\\],\\[1,1\\]\\], angle = 90, location = \\[1,1\\]\n**Output:** 4\n**Explanation:** All points can be made visible in your field of view, including the one at your location.\n\n**Example 3:**\n\n**Input:** points = \\[\\[1,0\\],\\[2,1\\]\\], angle = 13, location = \\[1,1\\]\n**Output:** 1\n**Explanation:** You can only see one of the two points, as shown above.\n\n**Constraints:**\n\n*   `1 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `location.length == 2`\n*   `0 <= angle < 360`\n*   `0 <= posx, posy, xi, yi <= 100`\"\"\"\n\n    xor_result = 0\n    for i in range(n):\n        xor_result ^= (start + 2 * i)\n    return xor_result"}}, "leetcode/leetcode_1560.txt": {"score": 0.8875207304954529, "content": {"text": "def busy_student(start_time, end_time, query_time):\n    \"\"\"Given an integer `n` and an integer array `rounds`. We have a circular track which consists of `n` sectors labeled from `1` to `n`. A marathon will be held on this track, the marathon consists of `m` rounds. The `ith` round starts at sector `rounds[i - 1]` and ends at sector `rounds[i]`. For example, round 1 starts at sector `rounds[0]` and ends at sector `rounds[1]`\n\nReturn _an array of the most visited sectors_ sorted in **ascending** order.\n\nNotice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).\n\n**Example 1:**\n\n**Input:** n = 4, rounds = \\[1,3,1,2\\]\n**Output:** \\[1,2\\]\n**Explanation:** The marathon starts at sector 1. The order of the visited sectors is as follows:\n1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\nWe can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.\n\n**Example 2:**\n\n**Input:** n = 2, rounds = \\[2,1,2,1,2,1,2,1,2\\]\n**Output:** \\[2\\]\n\n**Example 3:**\n\n**Input:** n = 7, rounds = \\[1,3,5,7\\]\n**Output:** \\[1,2,3,4,5,6,7\\]\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= m <= 100`\n*   `rounds.length == m + 1`\n*   `1 <= rounds[i] <= n`\n*   `rounds[i] != rounds[i + 1]` for `0 <= i < m`\"\"\"\n\n    count = 0\n    for i in range(len(start_time)):\n        if start_time[i] <= query_time <= end_time[i]:\n            count += 1\n    return count"}}, "leetcode/leetcode_1411.txt": {"score": 0.8813980221748352, "content": {"text": "class ListNode:\n    \"\"\"You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow,** or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\n\nGiven `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 12\n**Explanation:** There are 12 possible way to paint the grid as shown.\n\n**Example 2:**\n\n**Input:** n = 5000\n**Output:** 30228214\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `1 <= n <= 5000`\"\"\"\n\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head: ListNode) -> int:\n    num = 0\n    while head:\n        num = (num << 1) | head.val\n        head = head.next\n    return num"}}, "leetcode/leetcode_1386.txt": {"score": 0.8925387859344482, "content": {"text": "def shiftGrid(grid, k):\n    \"\"\"A cinema has `n` rows of seats, numbered from 1 to `n` and there are ten seats in each row, labelled from 1 to 10 as shown in the figure above.\n\nGiven the array `reservedSeats` containing the numbers of seats already reserved, for example, `reservedSeats[i] = [3,8]` means the seat located in row **3** and labelled with **8** is already reserved.\n\n_Return the maximum number of four-person groups you can assign on the cinema seats._ A four-person group occupies four adjacent seats **in one single row**. Seats across an aisle (such as \\[3,3\\] and \\[3,4\\]) are not considered to be adjacent, but there is an exceptional case on which an aisle split a four-person group, in that case, the aisle split a four-person group in the middle, which means to have two people on each side.\n\n**Example 1:**\n\n**Input:** n = 3, reservedSeats = \\[\\[1,2\\],\\[1,3\\],\\[1,8\\],\\[2,6\\],\\[3,1\\],\\[3,10\\]\\]\n**Output:** 4\n**Explanation:** The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.\n\n**Example 2:**\n\n**Input:** n = 2, reservedSeats = \\[\\[2,1\\],\\[1,8\\],\\[2,6\\]\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** n = 4, reservedSeats = \\[\\[4,3\\],\\[1,4\\],\\[4,6\\],\\[1,7\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= n <= 10^9`\n*   `1 <= reservedSeats.length <= min(10*n, 10^4)`\n*   `reservedSeats[i].length == 2`\n*   `1 <= reservedSeats[i][0] <= n`\n*   `1 <= reservedSeats[i][1] <= 10`\n*   All `reservedSeats[i]` are distinct.\"\"\"\n\n    m, n = len(grid), len(grid[0])\n    k %= (m * n)\n    res = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            idx = (i * n + j + k) % (m * n)\n            res[idx // n][idx % n] = grid[i][j]\n    return res"}}, "leetcode/leetcode_2211.txt": {"score": 0.8993812799453735, "content": {"text": "def k_radius_average(nums, k):\n    \"\"\"There are `n` cars on an infinitely long road. The cars are numbered from `0` to `n - 1` from left to right and each car is present at a **unique** point.\n\nYou are given a **0-indexed** string `directions` of length `n`. `directions[i]` can be either `'L'`, `'R'`, or `'S'` denoting whether the `ith` car is moving towards the **left**, towards the **right**, or **staying** at its current point respectively. Each moving car has the **same speed**.\n\nThe number of collisions can be calculated as follows:\n\n*   When two cars moving in **opposite** directions collide with each other, the number of collisions increases by `2`.\n*   When a moving car collides with a stationary car, the number of collisions increases by `1`.\n\nAfter a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\n\nReturn _the **total number of collisions** that will happen on the road_.\n\n**Example 1:**\n\n**Input:** directions =  \"RLRSLL \"\n**Output:** 5\n**Explanation:**\nThe collisions that will happen on the road are:\n- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\nThus, the total number of collisions that will happen on the road is 5. \n\n**Example 2:**\n\n**Input:** directions =  \"LLRR \"\n**Output:** 0\n**Explanation:**\nNo cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.\n\n**Constraints:**\n\n*   `1 <= directions.length <= 105`\n*   `directions[i]` is either `'L'`, `'R'`, or `'S'`.\"\"\"\n\n    n = len(nums)\n    avgs = [-1] * n\n    for i in range(k, n - k):\n        sum = 0\n        for j in range(i - k, i + k + 1):\n            sum += nums[j]\n        avgs[i] = sum // (2 * k + 1)\n    return avgs"}}, "leetcode/leetcode_1997.txt": {"score": 0.905390202999115, "content": {"text": "def firstDayBeenInAllRooms(nextVisit):\n    \"\"\"There are `n` rooms you need to visit, labeled from `0` to `n - 1`. Each day is labeled, starting from `0`. You will go in and visit one room a day.\n\nInitially on day `0`, you visit room `0`. The **order** you visit the rooms for the coming days is determined by the following **rules** and a given **0-indexed** array `nextVisit` of length `n`:\n\n*   Assuming that on a day, you visit room `i`,\n*   if you have been in room `i` an **odd** number of times (**including** the current visit), on the **next** day you will visit a room with a **lower or equal room number** specified by `nextVisit[i]` where `0 <= nextVisit[i] <= i`;\n*   if you have been in room `i` an **even** number of times (**including** the current visit), on the **next** day you will visit room `(i + 1) mod n`.\n\nReturn _the label of the **first** day where you have been in **all** the rooms_. It can be shown that such a day exists. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** nextVisit = \\[0,0\\]\n**Output:** 2\n**Explanation:**\n- On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n  On the next day you will visit room nextVisit\\[0\\] = 0\n- On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n  On the next day you will visit room (0 + 1) mod 2 = 1\n- On day 2, you visit room 1. This is the first day where you have been in all the rooms.\n\n**Example 2:**\n\n**Input:** nextVisit = \\[0,0,2\\]\n**Output:** 6\n**Explanation:**\nYour room visiting order for each day is: \\[0,0,1,0,0,1,2,...\\].\nDay 6 is the first day where you have been in all the rooms.\n\n**Example 3:**\n\n**Input:** nextVisit = \\[0,1,2,0\\]\n**Output:** 6\n**Explanation:**\nYour room visiting order for each day is: \\[0,0,1,1,2,2,3,...\\].\nDay 6 is the first day where you have been in all the rooms.\n\n**Constraints:**\n\n*   `n == nextVisit.length`\n*   `2 <= n <= 105`\n*   `0 <= nextVisit[i] <= i`\"\"\"\n\n    n = len(nextVisit)\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[n - 1]"}}, "leetcode/leetcode_1227.txt": {"score": 0.8858781456947327, "content": {"text": "from collections import defaultdict\n    \"\"\"`n` passengers board an airplane with exactly `n` seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:\n\n*   Take their own seat if it is still available, and\n*   Pick other seats randomly when they find their seat occupied\n\nReturn _the probability that the_ `nth` _person gets his own seat_.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** 1.00000\n**Explanation:** The first person can only get the first seat.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 0.50000\n**Explanation:** The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).\n\n**Constraints:**\n\n*   `1 <= n <= 105`\"\"\"\n\n\ndef num_equiv_domino_pairs(dominoes):\n    freq = defaultdict(int)\n    result = 0\n    for domino in dominoes:\n        key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n        result += freq[key]\n        freq[key] += 1\n    return result"}}, "leetcode/leetcode_2127.txt": {"score": 0.9227654337882996, "content": {"text": "def max_invited(favorite):\n    \"\"\"A company is organizing a meeting and has a list of `n` employees, waiting to be invited. They have arranged for a large **circular** table, capable of seating **any number** of employees.\n\nThe employees are numbered from `0` to `n - 1`. Each employee has a **favorite** person and they will attend the meeting **only if** they can sit next to their favorite person at the table. The favorite person of an employee is **not** themself.\n\nGiven a **0-indexed** integer array `favorite`, where `favorite[i]` denotes the favorite person of the `ith` employee, return _the **maximum number of employees** that can be invited to the meeting_.\n\n**Example 1:**\n\n**Input:** favorite = \\[2,2,1,2\\]\n**Output:** 3\n**Explanation:**\nThe above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.\nAll employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.\nNote that the company can also invite employees 1, 2, and 3, and give them their desired seats.\nThe maximum number of employees that can be invited to the meeting is 3. \n\n**Example 2:**\n\n**Input:** favorite = \\[1,2,0\\]\n**Output:** 3\n**Explanation:** \nEach employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.\nThe seating arrangement will be the same as that in the figure given in example 1:\n- Employee 0 will sit between employees 2 and 1.\n- Employee 1 will sit between employees 0 and 2.\n- Employee 2 will sit between employees 1 and 0.\nThe maximum number of employees that can be invited to the meeting is 3.\n\n**Example 3:**\n\n**Input:** favorite = \\[3,0,1,4,1\\]\n**Output:** 4\n**Explanation:**\nThe above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.\nEmployee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\nSo the company leaves them out of the meeting.\nThe maximum number of employees that can be invited to the meeting is 4.\n\n**Constraints:**\n\n*   `n == favorite.length`\n*   `2 <= n <= 105`\n*   `0 <= favorite[i] <= n - 1`\n*   `favorite[i] != i`\"\"\"\n\n    in_degree = [0] * len(favorite)\n    for fav in favorite:\n        in_degree[fav] += 1\n    result = 0\n    for degree in in_degree:\n        result += max(degree - 1, 0)\n    return min(result + 2, len(favorite))"}}, "leetcode/leetcode_1823.txt": {"score": 0.8928102850914001, "content": {"text": "def halves_are_alike(s: str) -> bool:\n    \"\"\"There are `n` friends that are playing a game. The friends are sitting in a circle and are numbered from `1` to `n` in **clockwise order**. More formally, moving clockwise from the `ith` friend brings you to the `(i+1)th` friend for `1 <= i < n`, and moving clockwise from the `nth` friend brings you to the `1st` friend.\n\nThe rules of the game are as follows:\n\n1.  **Start** at the `1st` friend.\n2.  Count the next `k` friends in the clockwise direction **including** the friend you started at. The counting wraps around the circle and may count some friends more than once.\n3.  The last friend you counted leaves the circle and loses the game.\n4.  If there is still more than one friend in the circle, go back to step `2` **starting** from the friend **immediately clockwise** of the friend who just lost and repeat.\n5.  Else, the last friend in the circle wins the game.\n\nGiven the number of friends, `n`, and an integer `k`, return _the winner of the game_.\n\n**Example 1:**\n\n**Input:** n = 5, k = 2\n**Output:** 3\n**Explanation:** Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.\n\n**Example 2:**\n\n**Input:** n = 6, k = 5\n**Output:** 1\n**Explanation:** The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.\n\n**Constraints:**\n\n*   `1 <= k <= n <= 500`\n\n**Follow up:**\n\nCould you solve this problem in linear time with constant space?\"\"\"\n\n    half_length = len(s) // 2\n    count_a, count_b = 0, 0\n\n    for i in range(half_length):\n        if s[i] in \"aeiouAEIOU\": count_a += 1\n\n    for i in range(half_length, len(s)):\n        if s[i] in \"aeiouAEIOU\": count_b += 1\n\n    return count_a == count_b"}}, "leetcode/leetcode_2550.txt": {"score": 0.9969888925552368, "content": {"text": "def ways_to_collide(n):\n    \"\"\"There is a regular convex polygon with `n` vertices. The vertices are labeled from `0` to `n - 1` in a clockwise direction, and each vertex has **exactly one monkey**. The following figure shows a convex polygon of `6` vertices.\n\nEach monkey moves simultaneously to a neighboring vertex. A neighboring vertex for a vertex `i` can be:\n\n*   the vertex `(i + 1) % n` in the clockwise direction, or\n*   the vertex `(i - 1 + n) % n` in the counter-clockwise direction.\n\nA **collision** happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge.\n\nReturn _the number of ways the monkeys can move so that at least **one collision**_ _happens_. Since the answer may be very large, return it modulo `109 + 7`.\n\n**Note** that each monkey can only move once.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 6\n**Explanation:** There are 8 total possible movements.\nTwo ways such that they collide at some point are:\n- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.\n- Monkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.\nIt can be shown 6 total movements result in a collision.\n\n**Example 2:**\n\n**Input:** n = 4\n**Output:** 14\n**Explanation:** It can be shown that there are 14 ways for the monkeys to collide.\n\n**Constraints:**\n\n*   `3 <= n <= 109`\"\"\"\n\n    MOD = 10**9 + 7\n    return (pow(2, n, MOD) - n - 1 + MOD) % MOD"}}}}, "139": {"gold": {"leetcode/leetcode_123.txt": 1, "leetcode/leetcode_2054.txt": 1}, "retrieved": {"leetcode/leetcode_2542.txt": {"score": 0.923902153968811, "content": {"text": "def maxScore(nums1, nums2, k):\n    \"\"\"You are given two **0-indexed** integer arrays `nums1` and `nums2` of equal length `n` and a positive integer `k`. You must choose a **subsequence** of indices from `nums1` of length `k`.\n\nFor chosen indices `i0`, `i1`, ..., `ik - 1`, your **score** is defined as:\n\n*   The sum of the selected elements from `nums1` multiplied with the **minimum** of the selected elements from `nums2`.\n*   It can defined simply as: `(nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])`.\n\nReturn _the **maximum** possible score._\n\nA **subsequence** of indices of an array is a set that can be derived from the set `{0, 1, ..., n-1}` by deleting some or no elements.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,3,3,2\\], nums2 = \\[2,1,3,4\\], k = 3\n**Output:** 12\n**Explanation:** \nThe four possible subsequence scores are:\n- We choose the indices 0, 1, and 2 with score = (1+3+3) \\* min(2,1,3) = 7.\n- We choose the indices 0, 1, and 3 with score = (1+3+2) \\* min(2,1,4) = 6. \n- We choose the indices 0, 2, and 3 with score = (1+3+2) \\* min(2,3,4) = 12. \n- We choose the indices 1, 2, and 3 with score = (3+3+2) \\* min(1,3,4) = 8.\nTherefore, we return the max score, which is 12.\n\n**Example 2:**\n\n**Input:** nums1 = \\[4,2,3,1,1\\], nums2 = \\[7,5,10,9,6\\], k = 1\n**Output:** 30\n**Explanation:** \nChoosing index 2 is optimal: nums1\\[2\\] \\* nums2\\[2\\] = 3 \\* 10 = 30 is the maximum possible score.\n\n**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `0 <= nums1[i], nums2[j] <= 105`\n*   `1 <= k <= n`\"\"\"\n\n    n = len(nums1)\n    res = 0\n    sum_n1 = 0\n    min_n2 = nums2[0]\n    i, j = 0, 0\n    while j < n:\n        sum_n1 += nums1[j]\n        min_n2 = min(min_n2, nums2[j])\n        if j - i + 1 > k:\n            sum_n1 -= nums1[i]\n            i += 1\n        if j + 1 >= k:\n            res = max(res, sum_n1 * min_n2)\n        j += 1\n    return res"}}, "leetcode/leetcode_1035.txt": {"score": 0.9252181649208069, "content": {"text": "class TreeNode:\n    \"\"\"You are given two integer arrays `nums1` and `nums2`. We write the integers of `nums1` and `nums2` (in the order they are given) on two separate horizontal lines.\n\nWe may draw connecting lines: a straight line connecting two numbers `nums1[i]` and `nums2[j]` such that:\n\n*   `nums1[i] == nums2[j]`, and\n*   the line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n\nReturn _the maximum number of connecting lines we can draw in this way_.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,4,2\\], nums2 = \\[1,2,4\\]\n**Output:** 2\n**Explanation:** We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from nums1\\[1\\] = 4 to nums2\\[2\\] = 4 will intersect the line from nums1\\[2\\]=2 to nums2\\[1\\]=2.\n\n**Example 2:**\n\n**Input:** nums1 = \\[2,5,1,2,5\\], nums2 = \\[10,5,2,1,5,2\\]\n**Output:** 3\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,3,7,1,7,5\\], nums2 = \\[1,9,2,5,1\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 500`\n*   `1 <= nums1[i], nums2[j] <= 2000`\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isCousins(self, root, x, y):\n        def findDepth(node, search_val, depth):\n            if not node:\n                return -1\n            if node.val == search_val:\n                return depth\n            left_depth = findDepth(node.left, search_val, depth + 1)\n            if left_depth != -1:\n                return left_depth\n            return findDepth(node.right, search_val, depth + 1)\n\n        def findParent(node, search_val):\n            if not node or not (node.left or node.right):\n                return None\n            if (node.left and node.left.val == search_val) or (node.right and node.right.val == search_val):\n                return node\n            left_parent = findParent(node.left, search_val)\n            if left_parent:\n                return left_parent\n            return findParent(node.right, search_val)\n\n        x_depth = findDepth(root, x, 0)\n        y_depth = findDepth(root, y, 0)\n        x_parent = findParent(root, x)\n        y_parent = findParent(root, y)\n        return (x_depth == y_depth) and (x_parent != y_parent)"}}, "leetcode/leetcode_1024.txt": {"score": 0.9283167123794556, "content": {"text": "def count_and_triples(nums):\n    \"\"\"You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n*   For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** clips = \\[\\[0,2\\],\\[4,6\\],\\[8,10\\],\\[1,9\\],\\[1,5\\],\\[5,9\\]\\], time = 10\n**Output:** 3\n**Explanation:** We take the clips \\[0,2\\], \\[8,10\\], \\[1,9\\]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut \\[1,9\\] into segments \\[1,2\\] + \\[2,8\\] + \\[8,9\\].\nNow we have segments \\[0,2\\] + \\[2,8\\] + \\[8,10\\] which cover the sporting event \\[0, 10\\].\n\n**Example 2:**\n\n**Input:** clips = \\[\\[0,1\\],\\[1,2\\]\\], time = 5\n**Output:** -1\n**Explanation:** We cannot cover \\[0,5\\] with only \\[0,1\\] and \\[1,2\\].\n\n**Example 3:**\n\n**Input:** clips = \\[\\[0,1\\],\\[6,8\\],\\[0,2\\],\\[5,6\\],\\[0,4\\],\\[0,3\\],\\[6,7\\],\\[1,3\\],\\[4,7\\],\\[1,4\\],\\[2,5\\],\\[2,6\\],\\[3,4\\],\\[4,5\\],\\[5,7\\],\\[6,9\\]\\], time = 9\n**Output:** 3\n**Explanation:** We can take clips \\[0,4\\], \\[4,7\\], and \\[6,9\\].\n\n**Constraints:**\n\n*   `1 <= clips.length <= 100`\n*   `0 <= starti <= endi <= 100`\n*   `1 <= time <= 100`\n\n0 <= i < j < k < nums.length, and nums\\[i\\] & nums\\[j\\] & nums\\[k\\] != 0. (\\`&\\` represents the bitwise AND operation.)\"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count"}}, "leetcode/leetcode_2551.txt": {"score": 0.9338254928588867, "content": {"text": "def maximize_score(weights, k):\n    \"\"\"You have `k` bags. You are given a **0-indexed** integer array `weights` where `weights[i]` is the weight of the `ith` marble. You are also given the integer `k.`\n\nDivide the marbles into the `k` bags according to the following rules:\n\n*   No bag is empty.\n*   If the `ith` marble and `jth` marble are in a bag, then all marbles with an index between the `ith` and `jth` indices should also be in that same bag.\n*   If a bag consists of all the marbles with an index from `i` to `j` inclusively, then the cost of the bag is `weights[i] + weights[j]`.\n\nThe **score** after distributing the marbles is the sum of the costs of all the `k` bags.\n\nReturn _the **difference** between the **maximum** and **minimum** scores among marble distributions_.\n\n**Example 1:**\n\n**Input:** weights = \\[1,3,5,1\\], k = 2\n**Output:** 4\n**Explanation:** \nThe distribution \\[1\\],\\[3,5,1\\] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution \\[1,3\\],\\[5,1\\], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n\n**Example 2:**\n\n**Input:** weights = \\[1, 3\\], k = 2\n**Output:** 0\n**Explanation:** The only distribution possible is \\[1\\],\\[3\\]. \nSince both the maximal and minimal score are the same, we return 0.\n\n**Constraints:**\n\n*   `1 <= k <= weights.length <= 105`\n*   `1 <= weights[i] <= 109`\"\"\"\n\n    n = len(weights)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n    dp = [[-1000000000] * (k + 1) for _ in range(n)]\n\n    for i in range(n):\n        dp[i][1] = prefix_sum[i + 1]\n        if i > 0:\n            dp[i][i + 1] = prefix_sum[i + 1] - prefix_sum[1]\n        for j in range(2, min(i + 1, k) + 1):\n            for q in range(1, i - j + 3):\n                dp[i][j] = max(dp[i][j], dp[i - q][j - 1] + weights[i] + weights[i - q])\n\n    return dp[n - 1][k] - dp[n - 1][1]"}}, "leetcode/leetcode_2611.txt": {"score": 0.9298790097236633, "content": {"text": "def maxPoints(reward1, reward2, k):\n    \"\"\"There are two mice and `n` different types of cheese, each type of cheese should be eaten by exactly one mouse.\n\nA point of the cheese with index `i` (**0-indexed**) is:\n\n*   `reward1[i]` if the first mouse eats it.\n*   `reward2[i]` if the second mouse eats it.\n\nYou are given a positive integer array `reward1`, a positive integer array `reward2`, and a non-negative integer `k`.\n\nReturn _**the maximum** points the mice can achieve if the first mouse eats exactly_ `k` _types of cheese._\n\n**Example 1:**\n\n**Input:** reward1 = \\[1,1,3,4\\], reward2 = \\[4,4,1,1\\], k = 2\n**Output:** 15\n**Explanation:** In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\n**Example 2:**\n\n**Input:** reward1 = \\[1,1\\], reward2 = \\[1,1\\], k = 2\n**Output:** 2\n**Explanation:** In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n**Constraints:**\n\n*   `1 <= n == reward1.length == reward2.length <= 105`\n*   `1 <= reward1[i], reward2[i] <= 1000`\n*   `0 <= k <= n`\"\"\"\n\n    gap = sorted([(reward2[i] - reward1[i], i) for i in range(len(reward1))], reverse=True)\n    firstMousePoints = sum(reward1[gap[i][1]] for i in range(k))\n    secondMousePoints = sum(reward2[gap[i][1]] for i in range(k, len(reward1)))\n    return firstMousePoints + secondMousePoints"}}, "leetcode/leetcode_2054.txt": {"score": 0.93035489320755, "content": {"text": "def find_chair(times, target_friend):\n    \"\"\"You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose **at most** **two** **non-overlapping** events to attend such that the sum of their values is **maximized**.\n\nReturn _this **maximum** sum._\n\nNote that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[2,4,3\\]\\]\n**Output:** 4\n**Explanation:** Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[1,5,5\\]\\]\n**Output:** 5\n**Explanation:** Choose event 2 for a sum of 5.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,5,3\\],\\[1,5,1\\],\\[6,6,5\\]\\]\n**Output:** 8\n**Explanation:** Choose events 0 and 2 for a sum of 3 + 5 = 8.\n\n**Constraints:**\n\n*   `2 <= events.length <= 105`\n*   `events[i].length == 3`\n*   `1 <= startTimei <= endTimei <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    n = len(times)\n    events = []\n    for i, (arrival, leaving) in enumerate(times):\n        events.append((arrival, i))\n        events.append((leaving, ~i))\n    events.sort()\n    chairs = [-1] * n\n    available_chairs = sorted(range(n))\n    for time, friend_id in events:\n        if friend_id >= 0:\n            chairs[friend_id] = available_chairs.pop(0)\n            if friend_id == target_friend:\n                return chairs[friend_id]\n        else:\n            available_chairs.append(chairs[~friend_id])\n            available_chairs.sort()\n    return -1"}}, "leetcode/leetcode_1499.txt": {"score": 0.9329286813735962, "content": {"text": "import heapq\n    \"\"\"You are given an array `points` containing the coordinates of points on a 2D plane, sorted by the x-values, where `points[i] = [xi, yi]` such that `xi < xj` for all `1 <= i < j <= points.length`. You are also given an integer `k`.\n\nReturn _the maximum value of the equation_ `yi + yj + |xi - xj|` where `|xi - xj| <= k` and `1 <= i < j <= points.length`.\n\nIt is guaranteed that there exists at least one pair of points that satisfy the constraint `|xi - xj| <= k`.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,3\\],\\[2,0\\],\\[5,10\\],\\[6,-10\\]\\], k = 1\n**Output:** 4\n**Explanation:** The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\nNo other pairs satisfy the condition, so we return the max of 4 and 1.\n\n**Example 2:**\n\n**Input:** points = \\[\\[0,0\\],\\[3,0\\],\\[9,2\\]\\], k = 3\n**Output:** 3\n**Explanation:** Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.\n\n**Constraints:**\n\n*   `2 <= points.length <= 105`\n*   `points[i].length == 2`\n*   `-108 <= xi, yi <= 108`\n*   `0 <= k <= 2 * 108`\n*   `xi < xj` for all `1 <= i < j <= points.length`\n*   `xi` form a strictly increasing sequence.\"\"\"\n\n\ndef max_performance(n, k, speed, efficiency):\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n\n    result = 0\n    sum_speed = 0\n    min_heap = []\n    for e, s in engineers:\n        if len(min_heap) >= k:\n            sum_speed -= heapq.heappop(min_heap)\n\n        heapq.heappush(min_heap, s)\n        sum_speed += s\n        result = max(result, e * sum_speed)\n\n    return result % (10**9 + 7)"}}, "leetcode/leetcode_2555.txt": {"score": 0.9931557774543762, "content": {"text": "from bisect import bisect_left, bisect_right\n    \"\"\"There are some prizes on the **X-axis**. You are given an integer array `prizePositions` that is **sorted in non-decreasing order**, where `prizePositions[i]` is the position of the `ith` prize. There could be different prizes at the same position on the line. You are also given an integer `k`.\n\nYou are allowed to select two segments with integer endpoints. The length of each segment must be `k`. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n\n*   For example if `k = 2`, you can choose segments `[1, 3]` and `[2, 4]`, and you will win any prize i that satisfies `1 <= prizePositions[i] <= 3` or `2 <= prizePositions[i] <= 4`.\n\nReturn _the **maximum** number of prizes you can win if you choose the two segments optimally_.\n\n**Example 1:**\n\n**Input:** prizePositions = \\[1,1,2,2,3,3,5\\], k = 2\n**Output:** 7\n**Explanation:** In this example, you can win all 7 prizes by selecting two segments \\[1, 3\\] and \\[3, 5\\].\n\n**Example 2:**\n\n**Input:** prizePositions = \\[1,2,3,4\\], k = 0\n**Output:** 2\n**Explanation:** For this example, **one choice** for the segments is `[3, 3]` and `[4, 4],` and you will be able to get `2` prizes. \n\n**Constraints:**\n\n*   `1 <= prizePositions.length <= 105`\n*   `1 <= prizePositions[i] <= 109`\n*   `0 <= k <= 109`\n*   `prizePositions` is sorted in non-decreasing order.\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}\"\"\"\n\n\ndef max_prizes(prize_positions, k):\n    n = len(prize_positions)\n    ans = 0\n    for i in range(n):\n        left_segment_end = prize_positions[i] + k\n        right_segment_start = bisect_right(prize_positions, left_segment_end)\n        right_segment_end = prize_positions[right_segment_start] + k\n        ans = max(ans, bisect_right(prize_positions, right_segment_end) - bisect_left(prize_positions, prize_positions[i]))\n    return ans"}}, "leetcode/leetcode_1235.txt": {"score": 0.9382649660110474, "content": {"text": "from bisect import bisect_left\n    \"\"\"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.\n\nYou're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\nIf you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.\n\n**Example 1:**\n\n**Input:** startTime = \\[1,2,3,3\\], endTime = \\[3,4,5,6\\], profit = \\[50,10,40,70\\]\n**Output:** 120\n**Explanation:** The subset chosen is the first and fourth job. \nTime range \\[1-3\\]+\\[3-6\\] , we get profit of 120 = 50 + 70.\n\n**Example 2:**\n\n**Input:** startTime = \\[1,2,3,4,6\\], endTime = \\[3,5,10,6,9\\], profit = \\[20,20,100,70,60\\]\n**Output:** 150\n**Explanation:** The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n**Example 3:**\n\n**Input:** startTime = \\[1,1,1\\], endTime = \\[2,3,4\\], profit = \\[5,6,4\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`\n*   `1 <= startTime[i] < endTime[i] <= 109`\n*   `1 <= profit[i] <= 104`\"\"\"\n\n\ndef jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(endTime, startTime, profit))\n    dp = [jobs[0][2]]\n    \n    def latestNonConflict(index):\n        startTimeToFind = jobs[index][1]\n        index = bisect_left([job[0] for job in jobs], startTimeToFind)\n        if index:\n            return index - 1\n        return -1\n\n    for i in range(1, len(jobs)):\n        L = latestNonConflict(i)\n        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))\n\n    return dp[-1]"}}, "leetcode/leetcode_2271.txt": {"score": 0.9561347365379333, "content": {"text": "def rearrange_array(nums):\n    \"\"\"You are given a 2D integer array `tiles` where `tiles[i] = [li, ri]` represents that every tile `j` in the range `li <= j <= ri` is colored white.\n\nYou are also given an integer `carpetLen`, the length of a single carpet that can be placed **anywhere**.\n\nReturn _the **maximum** number of white tiles that can be covered by the carpet_.\n\n**Example 1:**\n\n**Input:** tiles = \\[\\[1,5\\],\\[10,11\\],\\[12,18\\],\\[20,25\\],\\[30,32\\]\\], carpetLen = 10\n**Output:** 9\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles.\n\n**Example 2:**\n\n**Input:** tiles = \\[\\[10,11\\],\\[1,1\\]\\], carpetLen = 2\n**Output:** 2\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2.\n\n**Constraints:**\n\n*   `1 <= tiles.length <= 5 * 104`\n*   `tiles[i].length == 2`\n*   `1 <= li <= ri <= 109`\n*   `1 <= carpetLen <= 109`\n*   The `tiles` are **non-overlapping**.\"\"\"\n\n    nums.sort()\n    half = len(nums) // 2\n    result = [0] * len(nums)\n    j = 0\n    for i in range(half):\n        result[j] = nums[i]\n        result[j + 1] = nums[half + i]\n        j += 2\n    return result"}}}}, "140": {"gold": {"leetcode/leetcode_310.txt": 1, "leetcode/leetcode_834.txt": 1}, "retrieved": {"leetcode/leetcode_675.txt": {"score": 0.9182256460189819, "content": {"text": "from heapq import heappush, heappop\n    \"\"\"You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:\n\n*   `0` means the cell cannot be walked through.\n*   `1` represents an empty cell that can be walked through.\n*   A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).\n\nStarting from the point `(0, 0)`, return _the minimum steps you need to walk to cut off all the trees_. If you cannot cut off all the trees, return `-1`.\n\n**Note:** The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n**Example 1:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,4\\],\\[7,6,5\\]\\]\n**Output:** 6\n**Explanation:** Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n**Example 2:**\n\n**Input:** forest = \\[\\[1,2,3\\],\\[0,0,0\\],\\[7,6,5\\]\\]\n**Output:** -1\n**Explanation:** The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n**Example 3:**\n\n**Input:** forest = \\[\\[2,3,4\\],\\[0,0,5\\],\\[8,7,6\\]\\]\n**Output:** 6\n**Explanation:** You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n\n**Constraints:**\n\n*   `m == forest.length`\n*   `n == forest[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= forest[i][j] <= 109`\n*   Heights of all trees are **distinct**.\"\"\"\n\nfrom collections import deque\n\ndef cutOffTree(forest: List[List[int]]) -> int:\n    if not forest or not forest[0]: return 0\n    m, n = len(forest), len(forest[0])\n    trees = []\n    \n    for i in range(m):\n        for j in range(n):\n            if forest[i][j] > 1:\n                heappush(trees, (forest[i][j], i, j))\n    \n    startX, startY = 0, 0\n    totalSteps = 0\n    while trees:\n        tree, endX, endY = heappop(trees)\n        steps = bfs(forest, startX, startY, endX, endY)\n        if steps == -1:\n            return -1\n        totalSteps += steps\n        startX, startY = endX, endY\n    \n    return totalSteps\n\ndef bfs(forest, startX, startY, endX, endY):\n    if startX == endX and startY == endY:\n        return 0\n        \n    m, n = len(forest), len(forest[0])\n    visited = [[False] * n for _ in range(m)]\n    q = deque([(startX, startY, 0)])\n    visited[startX][startY] = True\n    dirs = [-1, 0, 1, 0, -1]\n    \n    while q:\n        x, y, steps = q.popleft()\n        for k in range(4):\n            newX, newY = x + dirs[k], y + dirs[k+1]\n            if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY] and forest[newX][newY] != 0:\n                if newX == endX and newY == endY:\n                    return steps + 1\n                q.append((newX, newY, steps + 1))\n                visited[newX][newY] = True\n    \n    return -1"}}, "leetcode/leetcode_310.txt": {"score": 0.9222013354301453, "content": {"text": "from collections import deque\n    \"\"\"A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\n\nReturn _a list of all **MHTs'** root labels_. You can return the answer in **any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[1\\]\n**Explanation:** As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n**Example 2:**\n\n**Input:** n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]\n**Output:** \\[3,4\\]\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs `(ai, bi)` are distinct.\n*   The given input is **guaranteed** to be a tree and there will be **no repeated** edges.\"\"\"\n\nfrom typing import List\n\ndef find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1:\n        return [0]\n\n    adj_list = [set() for _ in range(n)]\n    for a, b in edges:\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)\n\n    while n > 2:\n        leaves_size = len(leaves)\n        n -= leaves_size\n        for _ in range(leaves_size):\n            leaf = leaves.popleft()\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)"}}, "leetcode/leetcode_2467.txt": {"score": 0.9246912598609924, "content": {"text": "from collections import defaultdict\n    \"\"\"There is an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted at node `0`. You are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nAt every node `i`, there is a gate. You are also given an array of even integers `amount`, where `amount[i]` represents:\n\n*   the price needed to open the gate at node `i`, if `amount[i]` is negative, or,\n*   the cash reward obtained on opening the gate at node `i`, otherwise.\n\nThe game goes on as follows:\n\n*   Initially, Alice is at node `0` and Bob is at node `bob`.\n*   At every second, Alice and Bob **each** move to an adjacent node. Alice moves towards some **leaf node**, while Bob moves towards node `0`.\n*   For **every** node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:\n    *   If the gate is **already open**, no price will be required, nor will there be any cash reward.\n    *   If Alice and Bob reach the node **simultaneously**, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each.\n*   If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are **independent** of each other.\n\nReturn _the **maximum** net income Alice can have if she travels towards the optimal leaf node._\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\], bob = 3, amount = \\[-2,4,2,-4,6\\]\n**Output:** 6\n**Explanation:** \nThe above diagram represents the given tree. The game goes as follows:\n- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\n  Alice's net income is now -2.\n- Both Alice and Bob move to node 1. \n  Since they reach here simultaneously, they open the gate together and share the reward.\n  Alice's net income becomes -2 + (4 / 2) = 0.\n- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.\n  Bob moves on to node 0, and stops moving.\n- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\]\\], bob = 1, amount = \\[-7280,2350\\]\n**Output:** -7280\n**Explanation:** \nAlice follows the path 0->1 whereas Bob follows the path 1->0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280. \n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\n*   `1 <= bob < n`\n*   `amount.length == n`\n*   `amount[i]` is an **even** integer in the range `[-104, 104]`.\"\"\"\n\n\ndef dfs(node, parent, bob, time, alice_income, res, amount, tree):\n    if time < bob or amount[node] >= 0:\n        alice_income += amount[node]\n    else:\n        alice_income += amount[node] // 2\n    amount[node] = 0\n    is_leaf = True\n    for child in tree[node]:\n        if child != parent:\n            is_leaf = False\n            dfs(child, node, bob, time + 1, alice_income, res, amount, tree)\n    if is_leaf:\n        res[0] = max(res[0], alice_income)\n\ndef maxNetIncome(edges, bob, amount):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[0]].append(edge[1])\n        tree[edge[1]].append(edge[0])\n    res = [-100000]\n    dfs(0, -1, bob, 0, 0, res, amount, tree)\n    return res[0]"}}, "leetcode/leetcode_834.txt": {"score": 0.9234694242477417, "content": {"text": "def ambiguousCoordinates(s):\n    \"\"\"There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[8,12,6,10,10,10\\]\n**Explanation:** The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on.\n\n**Example 2:**\n\n**Input:** n = 1, edges = \\[\\]\n**Output:** \\[0\\]\n\n**Example 3:**\n\n**Input:** n = 2, edges = \\[\\[1,0\\]\\]\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 3 * 104`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   The given input represents a valid tree.\"\"\"\n\n    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n    \n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n        \n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n    \n    return res"}}, "leetcode/leetcode_2045.txt": {"score": 0.9461610317230225, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"A city is represented as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from **green** to **red** and vice versa every `change` minutes. All signals change **at the same time**. You can enter a vertex at **any time**, but can leave a vertex **only when the signal is green**. You **cannot wait** at a vertex if the signal is **green**.\n\nThe **second minimum value** is defined as the smallest value **strictly larger** than the minimum value.\n\n*   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return _the **second minimum time** it will take to go from vertex_ `1` _to vertex_ `n`.\n\n**Notes:**\n\n*   You can go through any vertex **any** number of times, **including** `1` and `n`.\n*   You can assume that when the journey **starts**, all signals have just turned **green**.\n\n**Example 1:**\n\n\u2003 \u2003 \u2003 \u2003\n\n**Input:** n = 5, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[3,4\\],\\[4,5\\]\\], time = 3, change = 5\n**Output:** 13\n**Explanation:**\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\], time = 3, change = 2\n**Output:** 11\n**Explanation:**\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n**Constraints:**\n\n*   `2 <= n <= 104`\n*   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each vertex can be reached directly or indirectly from every other vertex.\n*   `1 <= time, change <= 103`\"\"\"\n\n\ndef secondMinimum(n, edges, time, change):\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dist = [float('inf')] * (n + 1)\n    dist2 = [float('inf')] * (n + 1)\n    dist[1] = 0\n\n    q = deque([1])\n\n    while q:\n        cur = q.popleft()\n\n        nextDist = dist[cur] + time\n        waitTime = change if (nextDist // change) % 2 == 1 else 0\n        nextDist += waitTime\n\n        for next in graph[cur]:\n            if nextDist < dist[next]:\n                nextDist, dist[next] = dist[next], nextDist\n                q.append(next)\n            if nextDist < dist2[next]:\n                nextDist, dist2[next] = dist2[next], nextDist\n                q.append(next)\n\n    return dist2[n]"}}, "leetcode/leetcode_2477.txt": {"score": 0.9599249958992004, "content": {"text": "from collections import defaultdict, deque\n    \"\"\"There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of `n` cities numbered from `0` to `n - 1` and exactly `n - 1` roads. The capital city is city `0`. You are given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a **bidirectional road** connecting cities `ai` and `bi`.\n\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\n\nThere is a car in each city. You are given an integer `seats` that indicates the number of seats in each car.\n\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\n\nReturn _the minimum number of liters of fuel to reach the capital city_.\n\n**Example 1:**\n\n**Input:** roads = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\]\\], seats = 5\n**Output:** 3\n**Explanation:** \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\n**Example 2:**\n\n**Input:** roads = \\[\\[3,1\\],\\[3,2\\],\\[1,0\\],\\[0,4\\],\\[0,5\\],\\[4,6\\]\\], seats = 2\n**Output:** 7\n**Explanation:** \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\n**Example 3:**\n\n**Input:** roads = \\[\\], seats = 1\n**Output:** 0\n**Explanation:** No representatives need to travel to the capital city.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `roads.length == n - 1`\n*   `roads[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `roads` represents a valid tree.\n*   `1 <= seats <= 105`\"\"\"\n\n\n\ndef min_fuel(roads, seats):\n    n = len(roads) + 1\n    graph = defaultdict(list)\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n\n    distance = [-1] * n\n    q = deque([0])\n    distance[0] = 0\n\n    while q:\n        city = q.popleft()\n        for neighbor in graph[city]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[city] + 1\n                q.append(neighbor)\n\n    total_fuel = 0\n    for city in range(1, n):\n        total_fuel += (distance[city] - 1) // (seats - 1) + 1\n    return total_fuel"}}, "leetcode/leetcode_1494.txt": {"score": 0.9383518099784851, "content": {"text": "from collections import deque\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`.\n\nIn one semester, you can take **at most** `k` courses as long as you have taken all the prerequisites in the **previous** semesters for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course.\n\n**Example 1:**\n\n**Input:** n = 4, relations = \\[\\[2,1\\],\\[3,1\\],\\[1,4\\]\\], k = 2\n**Output:** 3\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[2,1\\],\\[3,1\\],\\[4,1\\],\\[1,5\\]\\], k = 2\n**Output:** 4\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5.\n\n**Constraints:**\n\n*   `1 <= n <= 15`\n*   `1 <= k <= n`\n*   `0 <= relations.length <= n * (n-1) / 2`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.\n*   The given graph is a directed acyclic graph.\"\"\"\n\n\ndef minNumberOfSemesters(n, relations, k):\n    indegree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev_course, next_course in relations:\n        graph[prev_course].append(next_course)\n        indegree[next_course] += 1\n\n    semesters = 0\n    while n > 0:\n        zero_indegree = deque()\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                zero_indegree.append(i)\n                indegree[i] = -1\n\n        courses = 0\n        while zero_indegree and courses < k:\n            curr_course = zero_indegree.popleft()\n            n -= 1\n\n            for next_course in graph[curr_course]:\n                indegree[next_course] -= 1\n            courses += 1\n        semesters += 1\n    return semesters"}}, "leetcode/leetcode_2603.txt": {"score": 0.9990739226341248, "content": {"text": "from collections import defaultdict\n    \"\"\"There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\"\"\"\n\n\ndef min_edges_to_collect_coins(coins, edges):\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    return dfs(adj, coins, 0, -1)[1] // 2\n\ndef dfs(adj, coins, node, parent):\n    sum_coins = coins[node]\n    distance = 0\n    for neighbor in adj[node]:\n        if neighbor != parent:\n            result = dfs(adj, coins, neighbor, node)\n            sum_coins += result[0]\n            distance += 2 * result[0] + result[1]\n    return (sum_coins, distance)"}}, "leetcode/leetcode_2050.txt": {"score": 0.9386190176010132, "content": {"text": "def count_good_digit_strings(n):\n    \"\"\"You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.\"\"\"\n\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total"}}, "leetcode/leetcode_847.txt": {"score": 0.9520929455757141, "content": {"text": "from collections import deque\n    \"\"\"You have an undirected, connected graph of `n` nodes labeled from `0` to `n - 1`. You are given an array `graph` where `graph[i]` is a list of all the nodes connected with node `i` by an edge.\n\nReturn _the length of the shortest path that visits every node_. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[1,2,3\\],\\[0\\],\\[0\\],\\[0\\]\\]\n**Output:** 4\n**Explanation:** One possible path is \\[1,0,2,0,3\\]\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1\\],\\[0,2,4\\],\\[1,3,4\\],\\[2\\],\\[1,2\\]\\]\n**Output:** 4\n**Explanation:** One possible path is \\[0,1,4,2,3\\]\n\n**Constraints:**\n\n*   `n == graph.length`\n*   `1 <= n <= 12`\n*   `0 <= graph[i].length < n`\n*   `graph[i]` does not contain `i`.\n*   If `graph[a]` contains `b`, then `graph[b]` contains `a`.\n*   The input graph is always connected.\"\"\"\n\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    queue = deque([(i, 1 << i, 0) for i in range(n)])\n    visited = [[False] * (1 << n) for _ in range(n)]\n\n    for i in range(n):\n        visited[i][1 << i] = True\n\n    while queue:\n        node, bitmask, length = queue.popleft()\n\n        if bitmask == (1 << n) - 1:\n            return length\n\n        for nei in graph[node]:\n            next_bitmask = bitmask | (1 << nei)\n            if not visited[nei][next_bitmask]:\n                visited[nei][next_bitmask] = True\n                queue.append((nei, next_bitmask, length + 1))\n\n    return 0"}}}}, "141": {"gold": {"leetcode/leetcode_198.txt": 1}, "retrieved": {"leetcode/leetcode_2279.txt": {"score": 0.9418467879295349, "content": {"text": "def max_unique_even_sum(final_sum):\n    \"\"\"You have `n` bags numbered from `0` to `n - 1`. You are given two **0-indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in **any** of the bags.\n\nReturn _the **maximum** number of bags that could have full capacity after placing the additional rocks in some bags._\n\n**Example 1:**\n\n**Input:** capacity = \\[2,3,4,5\\], rocks = \\[1,2,4,4\\], additionalRocks = 2\n**Output:** 3\n**Explanation:**\nPlace 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now \\[2,3,4,4\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3.\n\n**Example 2:**\n\n**Input:** capacity = \\[10,2,2\\], rocks = \\[2,2,0\\], additionalRocks = 100\n**Output:** 3\n**Explanation:**\nPlace 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now \\[10,2,2\\].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks.\n\n**Constraints:**\n\n*   `n == capacity.length == rocks.length`\n*   `1 <= n <= 5 * 104`\n*   `1 <= capacity[i] <= 109`\n*   `0 <= rocks[i] <= capacity[i]`\n*   `1 <= additionalRocks <= 109`\"\"\"\n\n    result = []\n    current = 2\n    while final_sum > 0:\n        if final_sum >= current:\n            result.append(current)\n            final_sum -= current\n            current += 2\n        else:\n            break\n    return result"}}, "leetcode/leetcode_2212.txt": {"score": 0.9432414770126343, "content": {"text": "def min_deletions(nums):\n    \"\"\"Alice and Bob are opponents in an archery competition. The competition has set the following rules:\n\n1.  Alice first shoots `numArrows` arrows and then Bob shoots `numArrows` arrows.\n2.  The points are then calculated as follows:\n    1.  The target has integer scoring sections ranging from `0` to `11` **inclusive**.\n    2.  For **each** section of the target with score `k` (in between `0` to `11`), say Alice and Bob have shot `ak` and `bk` arrows on that section respectively. If `ak >= bk`, then Alice takes `k` points. If `ak < bk`, then Bob takes `k` points.\n    3.  However, if `ak == bk == 0`, then **nobody** takes `k` points.\n\n*   For example, if Alice and Bob both shot `2` arrows on the section with score `11`, then Alice takes `11` points. On the other hand, if Alice shot `0` arrows on the section with score `11` and Bob shot `2` arrows on that same section, then Bob takes `11` points.\n    \n\nYou are given the integer `numArrows` and an integer array `aliceArrows` of size `12`, which represents the number of arrows Alice shot on each scoring section from `0` to `11`. Now, Bob wants to **maximize** the total number of points he can obtain.\n\nReturn _the array_ `bobArrows` _which represents the number of arrows Bob shot on **each** scoring section from_ `0` _to_ `11`. The sum of the values in `bobArrows` should equal `numArrows`.\n\nIf there are multiple ways for Bob to earn the maximum total points, return **any** one of them.\n\n**Example 1:**\n\n**Input:** numArrows = 9, aliceArrows = \\[1,1,0,1,0,0,2,1,0,1,2,0\\]\n**Output:** \\[0,0,0,0,1,1,0,0,1,2,3,1\\]\n**Explanation:** The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points.\n\n**Example 2:**\n\n**Input:** numArrows = 3, aliceArrows = \\[0,0,1,0,0,0,0,0,0,0,0,2\\]\n**Output:** \\[0,0,0,0,0,0,0,0,1,1,1,0\\]\n**Explanation:** The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points.\n\n**Constraints:**\n\n*   `1 <= numArrows <= 105`\n*   `aliceArrows.length == bobArrows.length == 12`\n*   `0 <= aliceArrows[i], bobArrows[i] <= numArrows`\n*   `sum(aliceArrows[i]) == numArrows`\"\"\"\n\n    n = len(nums)\n    if n <= 2:\n        return 0\n        \n    min_idx, max_idx = 0, 0\n\n    for i in range(1, n):\n        if nums[i] < nums[min_idx]:\n            min_idx = i\n        if nums[i] > nums[max_idx]:\n            max_idx = i\n\n    return min(max(min_idx, max_idx), n - min(min_idx, max_idx) - 1, min_idx + n - max_idx - 1)"}}, "leetcode/leetcode_826.txt": {"score": 0.9444226026535034, "content": {"text": "def maxProfitAssignment(difficulty, profit, worker):\n    \"\"\"You have `n` jobs and `m` workers. You are given three arrays: `difficulty`, `profit`, and `worker` where:\n\n*   `difficulty[i]` and `profit[i]` are the difficulty and the profit of the `ith` job, and\n*   `worker[j]` is the ability of `jth` worker (i.e., the `jth` worker can only complete a job with difficulty at most `worker[j]`).\n\nEvery worker can be assigned **at most one job**, but one job can be **completed multiple times**.\n\n*   For example, if three workers attempt the same job that pays `$1`, then the total profit will be `$3`. If a worker cannot complete any job, their profit is `$0`.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n\n**Example 1:**\n\n**Input:** difficulty = \\[2,4,6,8,10\\], profit = \\[10,20,30,40,50\\], worker = \\[4,5,6,7\\]\n**Output:** 100\n**Explanation:** Workers are assigned jobs of difficulty \\[4,4,6,6\\] and they get a profit of \\[20,20,30,30\\] separately.\n\n**Example 2:**\n\n**Input:** difficulty = \\[85,47,57\\], profit = \\[24,66,99\\], worker = \\[40,25,25\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == difficulty.length`\n*   `n == profit.length`\n*   `m == worker.length`\n*   `1 <= n, m <= 104`\n*   `1 <= difficulty[i], profit[i], worker[i] <= 105`\"\"\"\n\n    n = len(difficulty)\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    max_profit = 0\n    total_profit = 0\n    job_idx = 0\n\n    for w in worker:\n        while job_idx < n and w >= jobs[job_idx][0]:\n            max_profit = max(max_profit, jobs[job_idx][1])\n            job_idx += 1\n        total_profit += max_profit\n\n    return total_profit"}}, "leetcode/leetcode_1723.txt": {"score": 0.9445974230766296, "content": {"text": "def max_achievable_requests(n, requests, idx=0, counts=None):\n    \"\"\"You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`\"\"\"\n\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)"}}, "leetcode/leetcode_2054.txt": {"score": 0.9495589733123779, "content": {"text": "def find_chair(times, target_friend):\n    \"\"\"You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose **at most** **two** **non-overlapping** events to attend such that the sum of their values is **maximized**.\n\nReturn _this **maximum** sum._\n\nNote that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[2,4,3\\]\\]\n**Output:** 4\n**Explanation:** Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[1,5,5\\]\\]\n**Output:** 5\n**Explanation:** Choose event 2 for a sum of 5.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,5,3\\],\\[1,5,1\\],\\[6,6,5\\]\\]\n**Output:** 8\n**Explanation:** Choose events 0 and 2 for a sum of 3 + 5 = 8.\n\n**Constraints:**\n\n*   `2 <= events.length <= 105`\n*   `events[i].length == 3`\n*   `1 <= startTimei <= endTimei <= 109`\n*   `1 <= valuei <= 106`\"\"\"\n\n    n = len(times)\n    events = []\n    for i, (arrival, leaving) in enumerate(times):\n        events.append((arrival, i))\n        events.append((leaving, ~i))\n    events.sort()\n    chairs = [-1] * n\n    available_chairs = sorted(range(n))\n    for time, friend_id in events:\n        if friend_id >= 0:\n            chairs[friend_id] = available_chairs.pop(0)\n            if friend_id == target_friend:\n                return chairs[friend_id]\n        else:\n            available_chairs.append(chairs[~friend_id])\n            available_chairs.sort()\n    return -1"}}, "leetcode/leetcode_1537.txt": {"score": 0.9498533010482788, "content": {"text": "def maxScore(s):\n    \"\"\"You are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid path** is defined as follows:\n\n*   Choose array `nums1` or `nums2` to traverse (from index-0).\n*   Traverse the current array from left to right.\n*   If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[2,4,5,8,10\\], nums2 = \\[4,6,8,9\\]\n**Output:** 30\n**Explanation:** Valid paths:\n\\[2,4,5,8,10\\], \\[2,4,5,8,9\\], \\[2,4,6,8,9\\], \\[2,4,6,8,10\\],  (starting from nums1)\n\\[4,6,8,9\\], \\[4,5,8,10\\], \\[4,5,8,9\\], \\[4,6,8,10\\]    (starting from nums2)\nThe maximum is obtained with the path in green **\\[2,4,6,8,10\\]**.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,3,5,7,9\\], nums2 = \\[3,5,100\\]\n**Output:** 109\n**Explanation:** Maximum sum is obtained with the path **\\[1,3,5,100\\]**.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[6,7,8,9,10\\]\n**Output:** 40\n**Explanation:** There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path \\[6,7,8,9,10\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 107`\n*   `nums1` and `nums2` are strictly increasing.\"\"\"\n\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score"}}, "leetcode/leetcode_455.txt": {"score": 0.9513494372367859, "content": {"text": "def find_content_children(g, s):\n    \"\"\"Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n**Example 1:**\n\n**Input:** g = \\[1,2,3\\], s = \\[1,1\\]\n**Output:** 1\n**Explanation:** You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n**Example 2:**\n\n**Input:** g = \\[1,2\\], s = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n\n**Constraints:**\n\n*   `1 <= g.length <= 3 * 104`\n*   `0 <= s.length <= 3 * 104`\n*   `1 <= g[i], s[j] <= 231 - 1`\"\"\"\n\n    g.sort()\n    s.sort()\n    i = j = 0\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n\n        j += 1\n\n    return i"}}, "leetcode/leetcode_2410.txt": {"score": 0.952295184135437, "content": {"text": "def max_matchings(players, trainers):\n    \"\"\"You are given a **0-indexed** integer array `players`, where `players[i]` represents the **ability** of the `ith` player. You are also given a **0-indexed** integer array `trainers`, where `trainers[j]` represents the **training capacity** of the `jth` trainer.\n\nThe `ith` player can **match** with the `jth` trainer if the player's ability is **less than or equal to** the trainer's training capacity. Additionally, the `ith` player can be matched with at most one trainer, and the `jth` trainer can be matched with at most one player.\n\nReturn _the **maximum** number of matchings between_ `players` _and_ `trainers` _that satisfy these conditions._\n\n**Example 1:**\n\n**Input:** players = \\[4,7,9\\], trainers = \\[8,2,5,8\\]\n**Output:** 2\n**Explanation:**\nOne of the ways we can form two matchings is as follows:\n- players\\[0\\] can be matched with trainers\\[0\\] since 4 <= 8.\n- players\\[1\\] can be matched with trainers\\[3\\] since 7 <= 8.\nIt can be proven that 2 is the maximum number of matchings that can be formed.\n\n**Example 2:**\n\n**Input:** players = \\[1,1,1\\], trainers = \\[10\\]\n**Output:** 1\n**Explanation:**\nThe trainer can be matched with any of the 3 players.\nEach player can only be matched with one trainer, so the maximum answer is 1.\n\n**Constraints:**\n\n*   `1 <= players.length, trainers.length <= 105`\n*   `1 <= players[i], trainers[j] <= 109`\"\"\"\n\n    players.sort()\n    trainers.sort()\n\n    player_index, trainer_index, match_count = 0, 0, 0\n    while (player_index < len(players)) and (trainer_index < len(trainers)):\n        if players[player_index] <= trainers[trainer_index]:\n            match_count += 1\n            player_index += 1\n            trainer_index += 1\n        else:\n            trainer_index += 1\n\n    return match_count"}}, "leetcode/leetcode_2542.txt": {"score": 0.9530975818634033, "content": {"text": "def maxScore(nums1, nums2, k):\n    \"\"\"You are given two **0-indexed** integer arrays `nums1` and `nums2` of equal length `n` and a positive integer `k`. You must choose a **subsequence** of indices from `nums1` of length `k`.\n\nFor chosen indices `i0`, `i1`, ..., `ik - 1`, your **score** is defined as:\n\n*   The sum of the selected elements from `nums1` multiplied with the **minimum** of the selected elements from `nums2`.\n*   It can defined simply as: `(nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])`.\n\nReturn _the **maximum** possible score._\n\nA **subsequence** of indices of an array is a set that can be derived from the set `{0, 1, ..., n-1}` by deleting some or no elements.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,3,3,2\\], nums2 = \\[2,1,3,4\\], k = 3\n**Output:** 12\n**Explanation:** \nThe four possible subsequence scores are:\n- We choose the indices 0, 1, and 2 with score = (1+3+3) \\* min(2,1,3) = 7.\n- We choose the indices 0, 1, and 3 with score = (1+3+2) \\* min(2,1,4) = 6. \n- We choose the indices 0, 2, and 3 with score = (1+3+2) \\* min(2,3,4) = 12. \n- We choose the indices 1, 2, and 3 with score = (3+3+2) \\* min(1,3,4) = 8.\nTherefore, we return the max score, which is 12.\n\n**Example 2:**\n\n**Input:** nums1 = \\[4,2,3,1,1\\], nums2 = \\[7,5,10,9,6\\], k = 1\n**Output:** 30\n**Explanation:** \nChoosing index 2 is optimal: nums1\\[2\\] \\* nums2\\[2\\] = 3 \\* 10 = 30 is the maximum possible score.\n\n**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 105`\n*   `0 <= nums1[i], nums2[j] <= 105`\n*   `1 <= k <= n`\"\"\"\n\n    n = len(nums1)\n    res = 0\n    sum_n1 = 0\n    min_n2 = nums2[0]\n    i, j = 0, 0\n    while j < n:\n        sum_n1 += nums1[j]\n        min_n2 = min(min_n2, nums2[j])\n        if j - i + 1 > k:\n            sum_n1 -= nums1[i]\n            i += 1\n        if j + 1 >= k:\n            res = max(res, sum_n1 * min_n2)\n        j += 1\n    return res"}}, "leetcode/leetcode_2611.txt": {"score": 0.993905782699585, "content": {"text": "def maxPoints(reward1, reward2, k):\n    \"\"\"There are two mice and `n` different types of cheese, each type of cheese should be eaten by exactly one mouse.\n\nA point of the cheese with index `i` (**0-indexed**) is:\n\n*   `reward1[i]` if the first mouse eats it.\n*   `reward2[i]` if the second mouse eats it.\n\nYou are given a positive integer array `reward1`, a positive integer array `reward2`, and a non-negative integer `k`.\n\nReturn _**the maximum** points the mice can achieve if the first mouse eats exactly_ `k` _types of cheese._\n\n**Example 1:**\n\n**Input:** reward1 = \\[1,1,3,4\\], reward2 = \\[4,4,1,1\\], k = 2\n**Output:** 15\n**Explanation:** In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\n**Example 2:**\n\n**Input:** reward1 = \\[1,1\\], reward2 = \\[1,1\\], k = 2\n**Output:** 2\n**Explanation:** In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n**Constraints:**\n\n*   `1 <= n == reward1.length == reward2.length <= 105`\n*   `1 <= reward1[i], reward2[i] <= 1000`\n*   `0 <= k <= n`\"\"\"\n\n    gap = sorted([(reward2[i] - reward1[i], i) for i in range(len(reward1))], reverse=True)\n    firstMousePoints = sum(reward1[gap[i][1]] for i in range(k))\n    secondMousePoints = sum(reward2[gap[i][1]] for i in range(k, len(reward1)))\n    return firstMousePoints + secondMousePoints"}}}}}